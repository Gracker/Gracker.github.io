<!DOCTYPE html>
<html lang="zh,en">
    <!-- title -->
<!-- keywords -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Gracker">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Gracker">
        <meta name="keywords" content="Android,Performance,AndroidPerformance,性能,优化,性能优化,Perf,Flutter,Linux,LinuxPerformance,AndroidFramework,Framework,Android Performance,Flutter,Kotlin,Memory,内存,流畅性,卡顿,响应速度,Jank,Smooth,Android Framework,ANR,Crash,Dalvik,ART,Jetpack,Compose">
    <meta name="description" content="Focus On Android Performance">
    <meta name="description" content="本文介绍了 App 开发者不经常接触到但是在 Android Framework 渲染链路中非常重要的一个类 Choreographer。包括 Choreographer 的引入背景、Choreographer 的简介、部分源码解析、Choreographer 与 MessageQueue、Choreographer 和 APM，以及手机厂商基于 Choreographer 的一些优化思路 Cho">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 基于 Choreographer 的渲染机制详解">
<meta property="og:url" content="https://androidperformance.com/2019/10/22/Android-Choreographer/index.html">
<meta property="og:site_name" content="Android Performance">
<meta property="og:description" content="本文介绍了 App 开发者不经常接触到但是在 Android Framework 渲染链路中非常重要的一个类 Choreographer。包括 Choreographer 的引入背景、Choreographer 的简介、部分源码解析、Choreographer 与 MessageQueue、Choreographer 和 APM，以及手机厂商基于 Choreographer 的一些优化思路 Cho">
<meta property="og:locale">
<meta property="og:image" content="https://androidperformance.com/images/15717420275540.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717420373518.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717420453069.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717420572997.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15722752299458.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717420793673.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717420863795.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717420948412.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717421215251.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717421364722.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717421441350.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717421837064.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717421963577.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717422041938.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717422180571.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15724225347501.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717422327935.jpg">
<meta property="og:image" content="https://androidperformance.com/images/15717422623134.jpg">
<meta property="og:image" content="https://androidperformance.com/images/WechatIMG581.png">
<meta property="article:published_time" content="2019-10-22T10:55:11.000Z">
<meta property="article:modified_time" content="2024-11-11T16:43:00.140Z">
<meta property="article:author" content="Gracker">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Framework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://androidperformance.com/images/15717420275540.jpg">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    <title>Android 基于 Choreographer 的渲染机制详解 · Android Performance</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .footer-fixed-btn,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(
            -45deg,
            #444 0,
            #444 80px,
            #333 80px,
            #333 160px
        );
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link id="stylesheet-fancybox" rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link id="stylesheet-base" rel="preload" href="/css/style.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link id="stylesheet-mobile" rel="preload" href="/css/mobile.css" as="style" onload="this.onload=null;this.rel='stylesheet';this.media='screen and (max-width: 960px)'">
    <link id="stylesheet-theme-dark" rel="preload" href="/css/dark.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    <!-- 百度统计  -->
    <!-- 谷歌统计  -->
        <script>
            var cnzz_s_tag = document.createElement('script');
            cnzz_s_tag.type = 'text/javascript';
            cnzz_s_tag.async = true;
            cnzz_s_tag.charset = 'utf-8';
            cnzz_s_tag.src = 'https://w.cnzz.com/c.php?id=&async=1';
            var root_s = document.getElementsByTagName('script')[0];
            root_s.parentNode.insertBefore(cnzz_s_tag, root_s);
        </script>
    <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-50993302-2"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'UA-50993302-2');
        </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Android Performance" type="application/atom+xml">
</head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
        <body class="post-body">
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        <div class="header-sidebar-menu">
            <div style="padding-left: 1px;">&#xe775;</div>
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href="/">Android Performance</a>
        </span>
    </div>
    <!-- toggle banner -->
    <div class="banner">
        <div class="blog-title header-element">
            <a href="/">Android Performance</a>
        </div>
        <div class="post-title header-element">
            <a href="#" class="post-name">Android 基于 Choreographer 的渲染机制详解</a>
        </div>
    </div>
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- donate button -->

    <!-- back to top button -->
    <div class="footer-fixed-btn footer-fixed-btn--hidden back-top">
        <div>&#xe639;</div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="    height:50vh;
">
    <!-- 主页  -->
    <!-- 404页  -->
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
                Android 基于 Choreographer 的渲染机制详解
            <!-- 404 -->
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            <!-- 404 -->
        </p>
        <!-- 文章页 meta -->
            <div class="post-intros">
                <!-- 文章页标签  -->
                    <div class="post-intro-tags" >
        <a class="post-tag" href="javascript:void(0);" data-tags="Android">Android</a>
        <a class="post-tag" href="javascript:void(0);" data-tags="Framework">Framework</a>
</div>

                <!-- 文章字数统计 -->
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">7.3k</span>Reading time: <span class="post-count reading-time">31 min</span></span>
                    </div>
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2019/10/22</span>
                    <!-- busuanzi -->
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" alt="loading">
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <p>本文介绍了 App 开发者不经常接触到但是在 Android Framework 渲染链路中非常重要的一个类 Choreographer。包括 Choreographer 的引入背景、Choreographer 的简介、部分源码解析、Choreographer 与 MessageQueue、Choreographer 和 APM，以及手机厂商基于 Choreographer 的一些优化思路</p>
<p>Choreographer 的引入，主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对  Vsync 信号周期的调整，来控制每一帧绘制操作的时机. 目前大部分手机都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每个 16.6 ms ， Vsync 信号唤醒 Choreographer 来做 App 的绘制操作 ，这就是引入 Choreographer 的主要作用. 了解 Choreographer 还可以帮助 App 开发者知道程序每一帧运行的基本原理，也可以加深对 Message、Handler、Looper、MessageQueue、Measure、Layout、Draw 的理解</p>
<span id="more"></span>

<p>本文是 Systrace 系列文章的第八篇，主要是对 Systrace 中的 Choreographer 进行简单介绍</p>
<p>本系列的<strong>目的</strong>是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p>
<h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/">Systrace 简介</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/">Systrace 基础知识 - Systrace 预备知识</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/05/27/why-60-fps/">Systrace 基础知识 - Why 60 fps ？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/">Systrace 基础知识 - SystemServer 解读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/">Systrace 基础知识 - SurfaceFlinger 解读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/">Systrace 基础知识 - Input 解读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/">Systrace 基础知识 - Vsync 解读</a></li>
<li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer">Systrace 基础知识 - Triple Buffer 解读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU">Systrace 基础知识 - CPU Info 解读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/">Systrace 流畅性实战 1 ：了解卡顿原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2021/09/13/android-systrace-Responsiveness-in-action-1/">Systrace 响应速度实战 1 ：了解响应速度原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2021/09/13/android-systrace-Responsiveness-in-action-2/">Systrace 响应速度实战 2 ：响应速度实战分析-以启动速度为例</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2021/09/13/android-systrace-Responsiveness-in-action-3/">Systrace 响应速度实战 3 ：响应速度延伸知识</a>   </li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2022/01/21/android-systrace-cpu-state-runnable/">Systrace 线程 CPU 运行状态分析技巧 - Runnable 篇</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2022/03/13/android-systrace-cpu-state-running/">Systrace 线程 CPU 运行状态分析技巧 - Running 篇</a></li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2022/03/13/android-systrace-cpu-state-sleep/">Systrace 线程 CPU 运行状态分析技巧 - Sleep 和 Uninterruptible Sleep 篇</a></li>
</ol>
<h1 id="主线程运行机制的本质"><a href="#主线程运行机制的本质" class="headerlink" title="主线程运行机制的本质"></a>主线程运行机制的本质</h1><p>在讲 Choreographer 之前，我们先理一下 Android 主线程运行的本质，其实就是 Message 的处理过程，我们的各种操作，包括每一帧的渲染操作 ，都是通过 Message 的形式发给主线程的 MessageQueue ，MessageQueue 处理完消息继续等下一个消息，如下图所示</p>
<p><strong>MethodTrace 图示</strong></p>
<p><img src="/images/15717420275540.jpg"></p>
<p><strong>Systrace 图示</strong></p>
<p><img src="/images/15717420373518.jpg"></p>
<h2 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h2><p>引入 Vsync 之前的 Android 版本，渲染一帧相关的 Message ，中间是没有间隔的，上一帧绘制完，下一帧的 Message 紧接着就开始被处理。这样的问题就是，帧率不稳定，可能高也可能低，不稳定，如下图</p>
<p><strong>MethodTrace 图示</strong></p>
<p><img src="/images/15717420453069.jpg"></p>
<p><strong>Systrace 图示</strong></p>
<p><img src="/images/15717420572997.jpg"></p>
<p>可以看到这时候的瓶颈是在 dequeueBuffer, 因为屏幕是有刷新周期的, FB 消耗 Front Buffer 的速度是一定的, 所以 SF 消耗 App Buffer 的速度也是一定的, 所以 App 会卡在 dequeueBuffer 这里,这就会导致 App Buffer 获取不稳定, 很容易就会出现卡顿掉帧的情况.</p>
<p>对于用户来说，稳定的帧率才是好的体验，比如你玩王者荣耀，相比 fps 在 60 和 40 之间频繁变化，用户感觉更好的是稳定在 50 fps 的情况.</p>
<p>所以 Android 的演进中，引入了 <strong>Vsync + TripleBuffer + Choreographer</strong> 的机制，其主要目的就是提供一个稳定的帧率输出机制，让软件层和硬件层可以以共同的频率一起工作。</p>
<h2 id="引入-Choreographer"><a href="#引入-Choreographer" class="headerlink" title="引入 Choreographer"></a>引入 Choreographer</h2><p>Choreographer 的引入，主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对  Vsync 信号周期的调整，来控制每一帧绘制操作的时机. 至于为什么 Vsync 周期选择是 16.6ms (60 fps) ，是因为目前大部分手机的屏幕都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每隔 16.6 ms ，Vsync 信号到来唤醒 Choreographer 来做 App 的绘制操作 ，如果每个 Vsync 周期应用都能渲染完成，那么应用的 fps 就是 60 ，给用户的感觉就是非常流畅，这就是引入 Choreographer 的主要作用</p>
<p><img src="/images/15722752299458.jpg"></p>
<p>当然目前使用 90Hz 刷新率屏幕的手机越来越多，Vsync 周期从 16.6ms 到了 11.1ms，上图中的操作要在更短的时间内完成，对性能的要求也越来越高，具体可以看<a target="_blank" rel="noopener" href="https://www.androidperformance.com/2019/05/15/90hz-on-android/">新的流畅体验，90Hz 漫谈</a> 这篇文章</p>
<h1 id="Choreographer-简介"><a href="#Choreographer-简介" class="headerlink" title="Choreographer 简介"></a>Choreographer 简介</h1><p>Choreographer 扮演 Android 渲染链路中承上启下的角色</p>
<ol>
<li><strong>承上</strong>：负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等</li>
<li><strong>启下</strong>：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync)</li>
</ol>
<p>从上面可以看出来， Choreographer 担任的是一个工具人的角色，他之所以重要，是因为通过 <strong>Choreographer + SurfaceFlinger + Vsync + TripleBuffer</strong> 这一套从上到下的机制，保证了 Android App 可以以一个稳定的帧率运行(20fps、90fps 或者 60fps)，减少帧率波动带来的不适感。</p>
<p>了解 Choreographer 还可以帮助 App 开发者知道程序每一帧运行的基本原理，也可以加深对 <strong>Message、Handler、Looper、MessageQueue、Input、Animation、Measure、Layout、Draw</strong> 的理解 , 很多 <strong>APM</strong> 工具也用到了 <strong>Choreographer( 利用 FrameCallback + FrameInfo )</strong> + <strong>MessageQueue ( 利用 IdleHandler )</strong> + <strong>Looper ( 设置自定义 MessageLogging)</strong> 这些组合拳，深入了解了这些之后，再去做优化，脑子里的思路会更清晰。</p>
<p>另外虽然画图是一个比较好的解释流程的好路子，但是我个人不是很喜欢画图，因为平时 Systrace 和 MethodTrace 用的比较多，Systrace 是按从左到右展示整个系统的运行情况的一个工具(包括 cpu、SurfaceFlinger、SystemServer、App 等关键进程)，使用 <strong>Systrace</strong> 和 <strong>MethodTrace</strong> 也可以很方便地展示关键流程。当你对系统代码比较熟悉的时候，看 Systrace 就可以和手机运行的实际情况对应起来。所以下面的文章除了一些网图之外，其他的我会多以 Systrace 来展示。</p>
<h2 id="从-Systrace-的角度来看-Choreogrepher-的工作流程"><a href="#从-Systrace-的角度来看-Choreogrepher-的工作流程" class="headerlink" title="从 Systrace 的角度来看 Choreogrepher 的工作流程"></a>从 Systrace 的角度来看 Choreogrepher 的工作流程</h2><p>下图以滑动桌面为例子，我们先看一下从左到右滑动桌面的一个完整的预览图（App 进程），可以看到 Systrace 中从左到右，每一个绿色的帧都表示一帧，表示最终我们可以手机上看到的画面</p>
<ol>
<li>图中每一个灰色的条和白色的条宽度是一个 Vsync 的时间，也就是 16.6ms</li>
<li>每一帧处理的流程：接收到 Vsync 信号回调-&gt; UI Thread –&gt; RenderThread –&gt; SurfaceFlinger(图中未显示)</li>
<li>UI Thread 和 RenderThread 就可以完成 App 一帧的渲染，渲染完的 Buffer 抛给 SurfaceFlinger 去合成，然后我们就可以在屏幕上看到这一帧了</li>
<li>可以看到桌面滑动的每一帧耗时都很短（Ui Thread 耗时 + RenderThread 耗时），但是由于 Vsync 的存在，每一帧都会等到 Vsync 才会去做处理</li>
</ol>
<p><img src="/images/15717420793673.jpg"></p>
<p>有了上面这个整体的概念，我们将 UI Thread 的每一帧放大来看，看看 Choreogrepher 的位置以及 Choreogrepher 是怎么组织每一帧的</p>
<p><img src="/images/15717420863795.jpg"></p>
<h2 id="Choreographer-的工作流程"><a href="#Choreographer-的工作流程" class="headerlink" title="Choreographer 的工作流程"></a>Choreographer 的工作流程</h2><ol>
<li>Choreographer 初始化</li>
<li>初始化 FrameHandler ，绑定 Looper</li>
<li>初始化 FrameDisplayEventReceiver ，与 SurfaceFlinger 建立通信用于接收和请求 Vsync</li>
<li>初始化 CallBackQueues</li>
<li>SurfaceFlinger 的 appEventThread 唤醒发送 Vsync ，Choreographer 回调 FrameDisplayEventReceiver.onVsync , 进入 Choreographer 的主处理函数  doFrame</li>
<li>Choreographer.doFrame 计算掉帧逻辑</li>
<li>Choreographer.doFrame 处理 Choreographer 的第一个 callback ： input </li>
<li>Choreographer.doFrame 处理 Choreographer 的第二个 callback ： animation </li>
<li>Choreographer.doFrame 处理 Choreographer 的第三个 callback ： insets animation </li>
<li>Choreographer.doFrame 处理 Choreographer 的第四个 callback ： traversal </li>
<li>traversal-draw 中 UIThread 与 RenderThread 同步数据</li>
<li>Choreographer.doFrame 处理 Choreographer 的第五个 callback ： commit ?</li>
<li>RenderThread 处理绘制命令，将处理好的绘制命令发给 GPU 处理</li>
<li>调用 swapBuffer 提交给 SurfaceFlinger 进行合成（此时 Buffer 并没有真正完成，需要等 CPU 完成后 SurfaceFlinger 才能真正使用，新版本的 Systrace 中有 gpu 的 fence 来标识这个时间）</li>
</ol>
<p><strong>第一步初始化完成后，后续就会在步骤 2-9 之间循环</strong></p>
<p>同时也附上这一帧所对应的 MethodTrace（这里预览一下即可，下面会有详细的大图）</p>
<p><img src="/images/15717420948412.jpg"></p>
<p>下面我们就从源码的角度，来看一下具体的实现</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>下面从源码的角度来简单看一下，源码只摘抄了部分重要的逻辑，其他的逻辑则被剔除，另外 Native 部分与 SurfaceFlinger 交互的部分也没有列入，不是本文的重点，有兴趣的可以自己去跟一下。</p>
<h2 id="Choreographer-的初始化"><a href="#Choreographer-的初始化" class="headerlink" title="Choreographer 的初始化"></a>Choreographer 的初始化</h2><h3 id="Choreographer-的单例初始化"><a href="#Choreographer-的单例初始化" class="headerlink" title="Choreographer 的单例初始化"></a>Choreographer 的单例初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread local storage for the choreographer.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Choreographer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的 Looper</span></span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 构造 Choreographer 对象</span></span><br><span class="line">        <span class="type">Choreographer</span> <span class="variable">choreographer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">            mMainInstance = choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> choreographer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Choreographer-的构造函数"><a href="#Choreographer-的构造函数" class="headerlink" title="Choreographer 的构造函数"></a>Choreographer 的构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    <span class="comment">// 1. 初始化 FrameHandler</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">    <span class="comment">// 2. 初始化 DisplayEventReceiver</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line">    <span class="comment">//3. 初始化 CallbacksQueues</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FrameHandler"><a href="#FrameHandler" class="headerlink" title="FrameHandler"></a>FrameHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME:<span class="comment">//开始渲染下一帧的操作</span></span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:<span class="comment">//请求 Vsync </span></span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:<span class="comment">//处理 Callback</span></span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Choreographer-初始化链"><a href="#Choreographer-初始化链" class="headerlink" title="Choreographer 初始化链"></a>Choreographer 初始化链</h3><p>在 Activity 启动过程，执行完 onResume 后，会调用 Activity.makeVisible()，然后再调用到 addView()， 层层调用会进入如下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.handleResumeActivity(IBinder, <span class="type">boolean</span>, <span class="type">boolean</span>, String) (android.app) </span><br><span class="line">--&gt;WindowManagerImpl.addView(View, LayoutParams) (android.view) </span><br><span class="line">  --&gt;WindowManagerGlobal.addView(View, LayoutParams, Display, Window) (android.view) </span><br><span class="line">    --&gt;ViewRootImpl.ViewRootImpl(Context, Display) (android.view) </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="FrameDisplayEventReceiver-简介"><a href="#FrameDisplayEventReceiver-简介" class="headerlink" title="FrameDisplayEventReceiver 简介"></a>FrameDisplayEventReceiver 简介</h2><p>Vsync 的注册、申请、接收都是通过 FrameDisplayEventReceiver 这个类，所以可以先简单介绍一下。 FrameDisplayEventReceiver 继承 DisplayEventReceiver ， 有三个比较重要的方法</p>
<ol>
<li>onVsync – Vsync 信号回调</li>
<li>run – 执行 doFrame</li>
<li>scheduleVsync  – 请求 Vsync 信号</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">DisplayEventReceiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleVsync</span><span class="params">()</span> &#123;</span><br><span class="line">        ......  </span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Choreographer-中-Vsync-的注册"><a href="#Choreographer-中-Vsync-的注册" class="headerlink" title="Choreographer 中 Vsync 的注册"></a>Choreographer 中 Vsync 的注册</h2><p>从下面的函数调用栈可以看到，Choreographer 的内部类 FrameDisplayEventReceiver.onVsync 负责接收 Vsync 回调，通知 UIThread 进行数据处理。</p>
<p>那么 FrameDisplayEventReceiver 是通过什么方式在 Vsync 信号到来的时候回调 onVsync 呢？答案是 FrameDisplayEventReceiver 的初始化的时候，最终通过监听文件句柄的形式，其对应的初始化流程如下</p>
<p>android&#x2F;view&#x2F;Choreographer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android&#x2F;view&#x2F;Choreographer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(looper, vsyncSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android&#x2F;view&#x2F;DisplayEventReceiver.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nativeInit 后续的代码可以自己跟一下，可以对照这篇文章和源码，由于篇幅比较多，这里就不细写了(<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/304f56f5d486">https://www.jianshu.com/p/304f56f5d486</a>) ， 后续梳理好这一块的逻辑后，会在另外的文章更新。</p>
<p>简单来说，FrameDisplayEventReceiver 的初始化过程中，通过 BitTube(本质是一个 socket pair)，来传递和请求 Vsync 事件，当 SurfaceFlinger 收到 Vsync 事件之后，通过 appEventThread 将这个事件通过 BitTube 传给 DisplayEventDispatcher ，DisplayEventDispatcher 通过 BitTube 的接收端监听到 Vsync 事件之后，回调 Choreographer.FrameDisplayEventReceiver.onVsync ，触发开始一帧的绘制，如下图</p>
<p><img src="/images/15717421215251.jpg"></p>
<h2 id="Choreographer-处理一帧的逻辑"><a href="#Choreographer-处理一帧的逻辑" class="headerlink" title="Choreographer 处理一帧的逻辑"></a>Choreographer 处理一帧的逻辑</h2><p>Choreographer 处理绘制的逻辑核心在 Choreographer.doFrame 函数中，从下图可以看到，FrameDisplayEventReceiver.onVsync post 了自己，其 run 方法直接调用了 doFrame 开始一帧的逻辑处理</p>
<p>android&#x2F;view&#x2F;Choreographer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doFrame 函数主要做下面几件事</p>
<ol>
<li>计算掉帧逻辑</li>
<li>记录帧绘制信息</li>
<li>执行 CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_INSETS_ANIMATION、CALLBACK_TRAVERSAL、CALLBACK_COMMIT</li>
</ol>
<h3 id="计算掉帧逻辑"><a href="#计算掉帧逻辑" class="headerlink" title="计算掉帧逻辑"></a>计算掉帧逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">long</span> <span class="variable">intendedFrameTimeNanos</span> <span class="operator">=</span> frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> startNanos - frameTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                        + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Choreographer.doFrame 的掉帧检测比较简单，从下图可以看到，Vsync 信号到来的时候会标记一个 start_time ，执行 doFrame 的时候标记一个 end_time ，这两个时间差就是 Vsync 处理时延，也就是掉帧</p>
<p><img src="/images/15717421364722.jpg"></p>
<p>我们以 Systrace 的掉帧的实际情况来看掉帧的计算逻辑</p>
<p><img src="/images/15717421441350.jpg"></p>
<p>这里需要注意的是，这种方法计算的掉帧，是前一帧的掉帧情况，而不是这一帧的掉帧情况，这个计算方法是有缺陷的，会导致有的掉帧没有被计算到</p>
<h3 id="记录帧绘制信息"><a href="#记录帧绘制信息" class="headerlink" title="记录帧绘制信息"></a>记录帧绘制信息</h3><p>Choreographer 中 FrameInfo 来负责记录帧的绘制信息，doFrame 执行的时候，会把每一个关键节点的绘制时间记录下来，我们使用 dumpsys gfxinfo 就可以看到。当然 Choreographer 只是记录了一部分，剩余的部分在 hwui 那边来记录。</p>
<p>从 FrameInfo 这些标志就可以看出记录的内容，后面我们看 dumpsys gfxinfo 的时候数据就是按照这个来排列的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Various flags set to provide extra metadata about the current frame</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FLAGS</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is this the first-draw following a window layout?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">FLAG_WINDOW_LAYOUT_CHANGED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A renderer associated with just a Surface, not with a ViewRootImpl instance.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">FLAG_SURFACE_CANVAS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LongDef(flag = true, value = &#123;</span></span><br><span class="line"><span class="meta">        FLAG_WINDOW_LAYOUT_CHANGED, FLAG_SURFACE_CANVAS &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FrameInfoFlags &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The intended vsync time, unadjusted by jitter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTENDED_VSYNC</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jitter-adjusted vsync time, this is what was used as input into the</span></span><br><span class="line"><span class="comment">// animation &amp; drawing system</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VSYNC</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The time of the oldest input event</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OLDEST_INPUT_EVENT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The time of the newest input event</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEWEST_INPUT_EVENT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When input event handling started</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HANDLE_INPUT_START</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When animation evaluations started</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ANIMATION_START</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When ViewRootImpl#performTraversals() started</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PERFORM_TRAVERSALS_START</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When View:draw() started</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DRAW_START</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>doFrame 函数记录从 Vsync time 到 markPerformTraversalsStart 的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_INPUT Callbacks </span></span><br><span class="line">    mFrameInfo.markInputHandlingStart();</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_ANIMATION Callbacks</span></span><br><span class="line">    mFrameInfo.markAnimationsStart();</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_INSETS_ANIMATION Callbacks</span></span><br><span class="line">    <span class="comment">// 处理 CALLBACK_TRAVERSAL Callbacks</span></span><br><span class="line">    mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_COMMIT Callbacks</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行-Callbacks"><a href="#执行-Callbacks" class="headerlink" title="执行 Callbacks"></a>执行 Callbacks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_INPUT Callbacks </span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_ANIMATION Callbacks</span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_INSETS_ANIMATION Callbacks</span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_TRAVERSAL Callbacks</span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_COMMIT Callbacks</span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Input 回调调用栈</strong></p>
<p><strong>input callback</strong> 一般是执行 ViewRootImpl.ConsumeBatchedInputRunnable</p>
<p>android&#x2F;view&#x2F;ViewRootImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConsumeBatchedInputRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doConsumeBatchedInput(mChoreographer.getFrameTimeNanos());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doConsumeBatchedInput</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mConsumeBatchedInputScheduled) &#123;</span><br><span class="line">        mConsumeBatchedInputScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mInputEventReceiver != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInputEventReceiver.consumeBatchedInputEvents(frameTimeNanos)</span><br><span class="line">                    &amp;&amp; frameTimeNanos != -<span class="number">1</span>) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doProcessInputEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Input 时间经过处理，最终会传给 DecorView 的 dispatchTouchEvent，这就到了我们熟悉的 Input 事件分发</p>
<p><img src="/images/15717421837064.jpg"></p>
<p><strong>Animation 回调调用栈</strong></p>
<p>一般我们接触的多的是调用 View.postOnAnimation 的时候，会使用到 CALLBACK_ANIMATION </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOnAnimation</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AttachInfo</span> <span class="variable">attachInfo</span> <span class="operator">=</span> mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_ANIMATION, action, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Postpone the runnable until we know</span></span><br><span class="line">        <span class="comment">// on which thread it needs to run.</span></span><br><span class="line">        getRunQueue().post(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么一般是什么时候回调用到 View.postOnAnimation 呢，我截取了一张图，大家可以自己去看一下，接触最多的应该是 startScroll，Fling 这种操作</p>
<p><img src="/images/15717421963577.jpg"></p>
<p>其调用栈根据其 post 的内容，下面是桌面滑动松手之后的 fling 动画。</p>
<p><img src="/images/15717422041938.jpg"></p>
<p>另外我们的 Choreographer 的 FrameCallback 也是用的 CALLBACK_ANIMATION </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postFrameCallbackDelayed</span><span class="params">(FrameCallback callback, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;callback must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class="line">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Traversal 调用栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//为了提高优先级，先 postSyncBarrier</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 真正开始执行 measure、layout、draw</span></span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里把 SyncBarrier remove</span></span><br><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="comment">// 真正开始</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// measure 操作</span></span><br><span class="line">      <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123;</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// layout 操作</span></span><br><span class="line">      <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">          performLayout(lp, mWidth, mHeight);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// draw 操作</span></span><br><span class="line">      <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">          performDraw();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>doTraversal 的 TraceView 示例</strong></p>
<p><img src="/images/15717422180571.jpg"></p>
<h2 id="下一帧的-Vsync-请求"><a href="#下一帧的-Vsync-请求" class="headerlink" title="下一帧的 Vsync 请求"></a>下一帧的 Vsync 请求</h2><p>由于动画、滑动、Fling 这些操作的存在，我们需要一个连续的、稳定的帧率输出机制。这就涉及到了 Vsync 的请求逻辑，在连续的操作，比如动画、滑动、Fling 这些情况下，每一帧的 doFrame 的时候，都会根据情况触发下一个 Vsync 的申请，这样我们就可以获得连续的 Vsync 信号。</p>
<p>看下面的 scheduleTraversals 调用栈(scheduleTraversals 中会触发 Vsync 请求)<br><img src="/images/15724225347501.jpg"><br>我们比较熟悉的 invalidate 和 requestLayout 都会触发 Vsync 信号请求</p>
<p>我们下面以 Animation 为例，看看 Animation 是如何驱动下一个 Vsync ，来持续更新画面的</p>
<h3 id="ObjectAnimator-动画驱动逻辑"><a href="#ObjectAnimator-动画驱动逻辑" class="headerlink" title="ObjectAnimator 动画驱动逻辑"></a>ObjectAnimator 动画驱动逻辑</h3><p>android&#x2F;animation&#x2F;ObjectAnimator.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android&#x2F;animation&#x2F;ValueAnimator.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">boolean</span> playBackwards)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    addAnimationCallback(<span class="number">0</span>); <span class="comment">// 动画 start 的时候添加 Animation Callback </span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addAnimationCallback</span><span class="params">(<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    getAnimationHandler().addAnimationFrameCallback(<span class="built_in">this</span>, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android&#x2F;animation&#x2F;AnimationHandler.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAnimationFrameCallback</span><span class="params">(<span class="keyword">final</span> AnimationFrameCallback callback, <span class="type">long</span> delay)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// post FrameCallback</span></span><br><span class="line">        getProvider().postFrameCallback(mFrameCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 mFrameCallback 回调 doFrame，里面 post了自己</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.<span class="type">FrameCallback</span> <span class="variable">mFrameCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>.FrameCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">        doAnimationFrame(getProvider().getFrameTime());</span><br><span class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// post 自己</span></span><br><span class="line">            getProvider().postFrameCallback(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用 postFrameCallback 会走到 mChoreographer.postFrameCallback ，这里就会触发 Choreographer 的 Vsync 请求逻辑</p>
<p>android&#x2F;animation&#x2F;AnimationHandler.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postFrameCallback</span><span class="params">(Choreographer.FrameCallback callback)</span> &#123;</span><br><span class="line">    mChoreographer.postFrameCallback(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android&#x2F;view&#x2F;Choreographer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">        Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">// 请求 Vsync scheduleFrameLocked -&gt;scheduleVsyncLocked-&gt; mDisplayEventReceiver.scheduleVsync -&gt;nativeScheduleVsync</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的 Animation.start 设置，利用了 Choreographer.FrameCallback 接口，每一帧都去请求下一个 Vsync<br><strong>动画过程中一帧的 TraceView 示例</strong></p>
<p><img src="/images/15717422327935.jpg"></p>
<h2 id="源码小结"><a href="#源码小结" class="headerlink" title="源码小结"></a>源码小结</h2><ol>
<li><p><strong>Choreographer</strong> 是线程单例的，而且必须要和一个 Looper 绑定，因为其内部有一个 Handler 需要和 Looper 绑定，一般是 App 主线程的 Looper 绑定</p>
</li>
<li><p><strong>DisplayEventReceiver</strong> 是一个 abstract class，其 JNI 的代码部分会创建一个IDisplayEventConnection 的 Vsync 监听者对象。这样，来自 AppEventThread 的 VSYNC 中断信号就可以传递给 Choreographer 对象了。当 Vsync 信号到来时，DisplayEventReceiver 的 onVsync 函数将被调用。</p>
</li>
<li><p><strong>DisplayEventReceiver</strong> 还有一个 scheduleVsync 函数。当应用需要绘制UI时，将首先申请一次 Vsync 中断，然后再在中断处理的 onVsync 函数去进行绘制。</p>
</li>
<li><p><strong>Choreographer</strong> 定义了一个 <strong>FrameCallback</strong> <strong>interface</strong>，每当 Vsync 到来时，其 doFrame 函数将被调用。这个接口对 Android Animation 的实现起了很大的帮助作用。以前都是自己控制时间，现在终于有了固定的时间中断。</p>
</li>
<li><p><strong>Choreographer</strong> 的主要功能是，当收到 Vsync 信号时，去调用使用者通过 postCallback 设置的回调函数。目前一共定义了五种类型的回调，它们分别是：</p>
<ol>
<li><strong>CALLBACK_INPUT</strong>  : 处理输入事件处理有关</li>
<li><strong>CALLBACK_ANIMATION</strong> ： 处理 Animation 的处理有关</li>
<li><strong>CALLBACK_INSETS_ANIMATION</strong> ： 处理 Insets Animation 的相关回调</li>
<li><strong>CALLBACK_TRAVERSAL</strong>  : 处理和 UI 等控件绘制有关</li>
<li><strong>CALLBACK_COMMIT</strong> ： 处理 Commit 相关回调，主要是是用于执行组件 Application&#x2F;Activity&#x2F;Service 的 onTrimMemory，在 ApplicationThread 的 scheduleTrimMemory 方法中向 Choreographer 插入的；另外这个 Callback 也提供了一个监测一帧耗时的时机</li>
</ol>
</li>
<li><p><strong>ListView</strong> 的 Item 初始化(obtain\setup) 会在 input 里面也会在 animation 里面，这取决于</p>
</li>
<li><p><strong>CALLBACK_INPUT</strong> 、<strong>CALLBACK_ANIMATION</strong> 会修改 view 的属性，所以要先与 CALLBACK_TRAVERSAL 执行</p>
</li>
</ol>
<h1 id="APM-与-Choreographer"><a href="#APM-与-Choreographer" class="headerlink" title="APM 与 Choreographer"></a>APM 与 Choreographer</h1><p>由于 Choreographer 的位置，许多性能监控的手段都是利用 Choreographer 来做的，除了自带的掉帧计算，Choreographer 提供的 FrameCallback 和 FrameInfo 都给 App 暴露了接口，让 App 开发者可以通过这些方法监控自身 App 的性能，其中常用的方法如下：</p>
<ol>
<li>利用 FrameCallback 的 doFrame 回调</li>
<li>利用 FrameInfo 进行监控</li>
<li>使用 ：adb shell dumpsys gfxinfo <packagename> framestats</li>
<li>示例 ：adb shell dumpsys gfxinfo com.meizu.flyme.launcher framestats</li>
<li>利用 SurfaceFlinger 进行监控</li>
<li>使用 ：adb shell dumpsys SurfaceFlinger –latency</li>
<li>示例 ：adb shell dumpsys SurfaceFlinger –latency com.meizu.flyme.launcher&#x2F;com.meizu.flyme.launcher.Launcher#0</li>
<li>利用 SurfaceFlinger PageFlip 机制进行监控</li>
<li>使用 ： adb service call SurfaceFlinger 1013</li>
<li>备注：需要系统权限</li>
<li>Choreographer 自身的掉帧计算逻辑</li>
<li>BlockCanary 基于 Looper 的性能监控</li>
</ol>
<h2 id="利用-FrameCallback-的-doFrame-回调"><a href="#利用-FrameCallback-的-doFrame-回调" class="headerlink" title="利用 FrameCallback 的 doFrame 回调"></a>利用 FrameCallback 的 doFrame 回调</h2><h3 id="FrameCallback-接口"><a href="#FrameCallback-接口" class="headerlink" title="FrameCallback 接口"></a>FrameCallback 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FrameCallback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Choreographer.getInstance().postFrameCallback(youOwnFrameCallback );</span><br></pre></td></tr></table></figure>
<h3 id="接口处理"><a href="#接口处理" class="headerlink" title="接口处理"></a>接口处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postFrameCallbackDelayed</span><span class="params">(FrameCallback callback, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class="line">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>TinyDancer 就是使用了这个方法来计算 FPS (<a target="_blank" rel="noopener" href="https://github.com/friendlyrobotnyc/TinyDancer">https://github.com/friendlyrobotnyc/TinyDancer</a>)</p>
<h2 id="利用-FrameInfo-进行监控"><a href="#利用-FrameInfo-进行监控" class="headerlink" title="利用 FrameInfo 进行监控"></a>利用 FrameInfo 进行监控</h2><p>adb shell dumpsys gfxinfo <packagename> framestats</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Window: StatusBar</span><br><span class="line">Stats since: 17990256398ns</span><br><span class="line">Total frames rendered: 1562</span><br><span class="line">Janky frames: 361 (23.11%)</span><br><span class="line">50th percentile: 6ms</span><br><span class="line">90th percentile: 23ms</span><br><span class="line">95th percentile: 36ms</span><br><span class="line">99th percentile: 101ms</span><br><span class="line">Number Missed Vsync: 33</span><br><span class="line">Number High input latency: 683</span><br><span class="line">Number Slow UI thread: 273</span><br><span class="line">Number Slow bitmap uploads: 8</span><br><span class="line">Number Slow issue draw commands: 18</span><br><span class="line">Number Frame deadline missed: 287</span><br><span class="line">HISTOGRAM: 5ms=670 6ms=128 7ms=84 8ms=63 9ms=38 10ms=23 11ms=21 12ms=20 13ms=25 14ms=39 15ms=65 16ms=36 17ms=51 18ms=37 19ms=41 20ms=20 21ms=19 22ms=18 23ms=15 24ms=14 25ms=8 26ms=4 27ms=6 28ms=3 29ms=4 30ms=2 31ms=2 32ms=6 34ms=12 36ms=10 38ms=9 40ms=3 42ms=4 44ms=5 46ms=8 48ms=6 53ms=6 57ms=4 61ms=1 65ms=0 69ms=2 73ms=2 77ms=3 81ms=4 85ms=1 89ms=2 93ms=0 97ms=2 101ms=1 105ms=1 109ms=1 113ms=1 117ms=1 121ms=2 125ms=1 129ms=0 133ms=1 150ms=2 200ms=3 250ms=0 300ms=1 350ms=1 400ms=0 450ms=0 500ms=0 550ms=0 600ms=0 650ms=0 </span><br><span class="line"></span><br><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,</span><br><span class="line">0,10158314881426,10158314881426,9223372036854775807,0,10158315693363,10158315760759,10158315769821,10158316032165,10158316627842,10158316838988,10158318055915,10158320387269,10158321770654,428000,773000,</span><br><span class="line">0,10158332036261,10158332036261,9223372036854775807,0,10158332799196,10158332868519,10158332877269,10158333137738,10158333780654,10158333993206,10158335078467,10158337689561,10158339307061,474000,885000,</span><br><span class="line">0,10158348665353,10158348665353,9223372036854775807,0,10158349710238,10158349773102,10158349780863,10158350405863,10158351135967,10158351360446,10158352300863,10158354305654,10158355814509,471000,836000,</span><br><span class="line">0,10158365296729,10158365296729,9223372036854775807,0,10158365782373,10158365821019,10158365825238,10158365975290,10158366547946,10158366687217,10158367240706,10158368429248,10158369291852,269000,476000,</span><br></pre></td></tr></table></figure>
<h2 id="利用-SurfaceFlinger-进行监控"><a href="#利用-SurfaceFlinger-进行监控" class="headerlink" title="利用 SurfaceFlinger 进行监控"></a>利用 SurfaceFlinger 进行监控</h2><p>命令解释：</p>
<ol>
<li>数据的单位是纳秒，时间是以开机时间为起始点</li>
<li>每一次的命令都会得到128行的帧相关的数据</li>
</ol>
<p>数据：</p>
<ol>
<li>第一行数据，表示刷新的时间间隔refresh_period</li>
<li>第1列：这一部分的数据表示应用程序绘制图像的时间点</li>
<li>第2列：在SF(软件)将帧提交给H&#x2F;W(硬件)绘制之前的垂直同步时间，也就是每帧绘制完提交到硬件的时间戳，该列就是垂直同步的时间戳</li>
<li>第3列：在SF将帧提交给H&#x2F;W的时间点，算是H&#x2F;W接受完SF发来数据的时间点，绘制完成的时间点。</li>
</ol>
<p><strong>掉帧 jank 计算</strong></p>
<p>每一行都可以通过下面的公式得到一个值，该值是一个标准，我们称为jankflag，如果当前行的jankflag与上一行的jankflag发生改变，那么就叫掉帧</p>
<p>ceil((C - A) &#x2F; refresh-period)</p>
<h2 id="利用-SurfaceFlinger-PageFlip-机制进行监控"><a href="#利用-SurfaceFlinger-PageFlip-机制进行监控" class="headerlink" title="利用 SurfaceFlinger PageFlip 机制进行监控"></a>利用 SurfaceFlinger PageFlip 机制进行监控</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line"><span class="type">Parcel</span> <span class="variable">reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">                data.writeInterfaceToken(<span class="string">&quot;android.ui.ISurfaceComposer&quot;</span>);</span><br><span class="line">mFlinger.transact(<span class="number">1013</span>, data, reply, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">pageFlipCount</span> <span class="operator">=</span> reply.readInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">frames</span> <span class="operator">=</span> pageFlipCount - mLastPageFlipCount;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> now - mLastUpdateTime;</span><br><span class="line">mFps = (<span class="type">float</span>) (frames * <span class="number">1e9</span> / duration);</span><br><span class="line">mLastPageFlipCount = pageFlipCount;</span><br><span class="line">mLastUpdateTime = now;</span><br><span class="line">reply.recycle();</span><br><span class="line">data.recycle();</span><br></pre></td></tr></table></figure>
<h2 id="Choreographer-自身的掉帧计算逻辑"><a href="#Choreographer-自身的掉帧计算逻辑" class="headerlink" title="Choreographer 自身的掉帧计算逻辑"></a>Choreographer 自身的掉帧计算逻辑</h2><p>SKIPPED_FRAME_WARNING_LIMIT 默认为30 , 由 debug.choreographer.skipwarning 这个属性控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class="line">    <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BlockCanary"><a href="#BlockCanary" class="headerlink" title="BlockCanary"></a>BlockCanary</h2><p>Blockcanary 做性能监控使用的是 Looper 的消息机制，通过对 MessageQueue 中每一个 Message 的前后进行记录，打到监控性能的目的</p>
<p>android&#x2F;os&#x2F;Looper.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MessageQueue-与-Choreographer"><a href="#MessageQueue-与-Choreographer" class="headerlink" title="MessageQueue 与 Choreographer"></a>MessageQueue 与 Choreographer</h1><p>所谓的异步消息其实就是这样的，我们可以通过 enqueueBarrier 往消息队列中插入一个 Barrier，那么队列中执行时间在这个 Barrier 以后的同步消息都会被这个 Barrier 拦截住无法执行，直到我们调用 removeBarrier 移除了这个 Barrier，而异步消息则没有影响，消息默认就是同步消息，除非我们调用了 Message 的 setAsynchronous，这个方法是隐藏的。只有在初始化 Handler 时通过参数指定往这个 Handler 发送的消息都是异步的，这样在 Handler 的 enqueueMessage 中就会调用 Message 的 setAsynchronous 设置消息是异步的，从上面 Handler.enqueueMessage 的代码中可以看到。</p>
<p>所谓异步消息，其实只有一个作用，就是在设置 Barrier 时仍可以不受 Barrier 的影响被正常处理，如果没有设置 Barrier，异步消息就与同步消息没有区别，可以通过 removeSyncBarrier 移除 Barrier</p>
<h2 id="SyncBarrier-在-Choreographer-中使用的一个示例"><a href="#SyncBarrier-在-Choreographer-中使用的一个示例" class="headerlink" title="SyncBarrier 在 Choreographer 中使用的一个示例"></a>SyncBarrier 在 Choreographer 中使用的一个示例</h2><p>scheduleTraversals 的时候 postSyncBarrier</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//为了提高优先级，先 postSyncBarrier</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doTraversal 的时候 removeSyncBarrier</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里把 SyncBarrier remove</span></span><br><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="comment">// 真正开始</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Choreographer post Message 的时候，会把这些消息设为 Asynchronous ，这样 Choreographer 中的这些 Message 的优先级就会比较高，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">msg.arg1 = callbackType;</span><br><span class="line">msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">mHandler.sendMessageAtTime(msg, dueTime);</span><br></pre></td></tr></table></figure>
<h1 id="厂商优化"><a href="#厂商优化" class="headerlink" title="厂商优化"></a>厂商优化</h1><p>系统厂商由于可以直接修改源码，也利用这方面的便利，做一些功能和优化，不过由于保密的问题，代码就不直接放上来了，我可以大概说一下思路，感兴趣的可以私下讨论</p>
<h2 id="移动事件优化"><a href="#移动事件优化" class="headerlink" title="移动事件优化"></a>移动事件优化</h2><p>Choreographer 本身是没有 input 消息的， 不过修改源码之后，input 消息可以直接给到 Choreographer 这里， 有了这些 Input 消息，Choreographer 就可以做一些事情，比如说提前响应，不去等 Vsync</p>
<h2 id="后台动画优化"><a href="#后台动画优化" class="headerlink" title="后台动画优化"></a>后台动画优化</h2><p>当一个 Android App 退到后台之后，只要他没有被杀死，那么他做什么事情大家都不要奇怪，因为这就是 Android。有的 App 退到后台之后还在持续调用 Choreographer 中的 Animation Callback，而这个 Callback 的执行完全是无意义的，而且用户还不知道，但是对 cpu 的占用是比较高的。</p>
<p>所以在 Choreographer 中会针对这种情况做优化，禁止不符合条件的 App 在后台继续无用的操作</p>
<p><img src="/images/15717422623134.jpg"></p>
<h2 id="帧绘制优化"><a href="#帧绘制优化" class="headerlink" title="帧绘制优化"></a>帧绘制优化</h2><p>和移动事件优化一样，由于有了 Input 事件的信息，在某些场景下我们可以通知 SurfaceFlinger 不用去等待 Vsync 直接做合成操作</p>
<h2 id="应用启动优化"><a href="#应用启动优化" class="headerlink" title="应用启动优化"></a>应用启动优化</h2><p>我们前面说，主线程的所有操作都是给予 Message 的 ，如果某个操作，非重要的 Message 被排列到了队列后面，那么对这个操作产生影响；而通过重新排列 MessageQueue，在应用启动的时候，把启动相关的重要的启动 Message 放到队列前面，来起到加快启动速度的作用</p>
<h2 id="高帧率优化"><a href="#高帧率优化" class="headerlink" title="高帧率优化"></a>高帧率优化</h2><p>90&#x2F;120 fps 的手机上 ， Vsync 间隔从 16.6ms 变成了 11.1ms&#x2F;8.8ms ，这带来了巨大的性能和功耗挑战，如何在一帧内完成渲染的必要操作，是手机厂商必须要思考和优化的地方：</p>
<ol>
<li>超级 App 的性能表现以及优化</li>
<li>游戏高帧率合作</li>
<li>120fps、90 fps 和 60 fps 相互切换的逻辑</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/304f56f5d486">https://www.jianshu.com/p/304f56f5d486</a></li>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2017/02/25/choreographer/">http://gityuan.com/2017/02/25/choreographer/</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/view/Choreographer">https://developer.android.com/reference/android/view/Choreographer</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jishuwen.com/d/2Vcc">https://www.jishuwen.com/d/2Vcc</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5c8772eee51d456cda2e8099">https://juejin.im/entry/5c8772eee51d456cda2e8099</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/142">Android 开发高手课</a></li>
</ol>
<h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87954949">知乎 - Android 基于 Choreographer 的渲染机制详解</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5daedc65e51d457834735c65">掘金 - Android 基于 Choreographer 的渲染机制详解</a></p>
<h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><p>下面是个人的介绍和相关的链接，期望与同行的各位多多交流，三人行，则必有我师!</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/about/">博主个人介绍</a> ：里面有个人的微信和微信群链接。</li>
<li><a href="https://androidperformance.com/2019/12/01/BlogMap/">本博客内容导航</a> ：个人博客内容的一个导航。</li>
<li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">个人整理和搜集的优秀博客文章 - Android 性能优化必知必会</a> ：欢迎大家自荐和推荐 （微信私聊即可）</li>
<li><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2023/12/30/the-performance/">Android性能优化知识星球</a> ： 欢迎加入，多谢支持～</li>
</ol>
<blockquote>
<p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p>
</blockquote>
<p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>

    </article>
    <!-- license -->
        <div class="license-wrapper">
            <p>Author：<a href="https://androidperformance.com">Gracker</a>
            <p>Link：<a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">https://androidperformance.com/2019/10/22/Android-Choreographer/</a>
            <p>Publish date：<a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">October 22nd 2019, 6:55:11 pm</a>
            <p>Update date：<a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">November 12th 2024, 12:43:00 am</a>
            <p>License：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
                <div class="nextSlogan">Next Post</div>
                <a href="/2019/10/24/Android-Background-Animation/" title="Android 中的“后台无效动画“行为分析">
                    <div class="nextTitle">Android 中的“后台无效动画“行为分析</div>
                </a>
        </li>
        <li class="previous">
                <div class="prevSlogan">Previous Post</div>
                <a href="/2019/09/18/Android-Jank-Due-To-Low-Memory/" title="Android 中的卡顿丢帧原因概述 - 低内存篇">
                    <div class="prevTitle">Android 中的卡顿丢帧原因概述 - 低内存篇</div>
                </a>
        </li>
    </ul>
    <!-- comment -->
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->

            
            
            
            <!-- utteranc评论 -->

            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->

            
            
            
        </div>
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    <!-- Mathjax -->
</main>

                <!-- profile -->
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
        <div class="social">
                            <a href="mailto:Dreamtale.jg@gmail.com" class="iconfont-archer email" title="email" ></a>
                <a href="https://github.com/gracker" class="iconfont-archer github" target="_blank" title="github"></a>
                <span class="iconfont-archer wechat" title="wechat">
                    <img class="profile-qr" src="/assets/Wechat.jpeg" />
                </span>
                <span class="iconfont-archer qq" title="qq">
                    <img class="profile-qr" src="/553000664" />
                </span>
                <a href="https://weibo.com/gracker520" class="iconfont-archer weibo" target="_blank" title="weibo"></a>
                <a href="https://www.zhihu.com/people/gracker" class="iconfont-archer zhihu" target="_blank" title="zhihu"></a>
                <a href="https://twitter.com/Gracker_Gao" class="iconfont-archer twitter" target="_blank" title="twitter"></a>
                <a href="https://juejin.im/user/557b0590e4b052e031453d76" class="iconfont-archer juejin" target="_blank" title="juejin"></a>
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title="rss"></a>

        </div>
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
        <div class="website-approve">
                <span id="icp-approve" class="icp-approve">
                    <a href="https://beian.miit.gov.cn/" target="_blank">蜀 ICP 备 20016190 号</a>
                </span>
        </div>
    <!-- 不蒜子  -->
        <div class="busuanzi-container">
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
        </div>
</footer>

        </div>
        <!-- toc -->
            <div class="toc-wrapper toc-wrapper-loding" style=    top:50vh;
>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">系列文章目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.</span> <span class="toc-text">主线程运行机制的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E8%BF%9B"><span class="toc-number">2.1.</span> <span class="toc-text">演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-Choreographer"><span class="toc-number">2.2.</span> <span class="toc-text">引入 Choreographer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Choreographer-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">Choreographer 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-Systrace-%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B-Choreogrepher-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">从 Systrace 的角度来看 Choreogrepher 的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Choreographer-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Choreographer 的工作流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Choreographer-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">Choreographer 的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Choreographer-%E7%9A%84%E5%8D%95%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.1.</span> <span class="toc-text">Choreographer 的单例初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Choreographer-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">Choreographer 的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FrameHandler"><span class="toc-number">4.1.3.</span> <span class="toc-text">FrameHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Choreographer-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE"><span class="toc-number">4.1.4.</span> <span class="toc-text">Choreographer 初始化链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FrameDisplayEventReceiver-%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.</span> <span class="toc-text">FrameDisplayEventReceiver 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Choreographer-%E4%B8%AD-Vsync-%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-number">4.3.</span> <span class="toc-text">Choreographer 中 Vsync 的注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Choreographer-%E5%A4%84%E7%90%86%E4%B8%80%E5%B8%A7%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">4.4.</span> <span class="toc-text">Choreographer 处理一帧的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%8E%89%E5%B8%A7%E9%80%BB%E8%BE%91"><span class="toc-number">4.4.1.</span> <span class="toc-text">计算掉帧逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%B8%A7%E7%BB%98%E5%88%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">4.4.2.</span> <span class="toc-text">记录帧绘制信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-Callbacks"><span class="toc-number">4.4.3.</span> <span class="toc-text">执行 Callbacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E5%B8%A7%E7%9A%84-Vsync-%E8%AF%B7%E6%B1%82"><span class="toc-number">4.5.</span> <span class="toc-text">下一帧的 Vsync 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectAnimator-%E5%8A%A8%E7%94%BB%E9%A9%B1%E5%8A%A8%E9%80%BB%E8%BE%91"><span class="toc-number">4.5.1.</span> <span class="toc-text">ObjectAnimator 动画驱动逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%B0%8F%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text">源码小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APM-%E4%B8%8E-Choreographer"><span class="toc-number">5.</span> <span class="toc-text">APM 与 Choreographer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-FrameCallback-%E7%9A%84-doFrame-%E5%9B%9E%E8%B0%83"><span class="toc-number">5.1.</span> <span class="toc-text">利用 FrameCallback 的 doFrame 回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FrameCallback-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.1.</span> <span class="toc-text">FrameCallback 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">接口使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%A4%84%E7%90%86"><span class="toc-number">5.1.3.</span> <span class="toc-text">接口处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-FrameInfo-%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7"><span class="toc-number">5.2.</span> <span class="toc-text">利用 FrameInfo 进行监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-SurfaceFlinger-%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7"><span class="toc-number">5.3.</span> <span class="toc-text">利用 SurfaceFlinger 进行监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-SurfaceFlinger-PageFlip-%E6%9C%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7"><span class="toc-number">5.4.</span> <span class="toc-text">利用 SurfaceFlinger PageFlip 机制进行监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Choreographer-%E8%87%AA%E8%BA%AB%E7%9A%84%E6%8E%89%E5%B8%A7%E8%AE%A1%E7%AE%97%E9%80%BB%E8%BE%91"><span class="toc-number">5.5.</span> <span class="toc-text">Choreographer 自身的掉帧计算逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockCanary"><span class="toc-number">5.6.</span> <span class="toc-text">BlockCanary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MessageQueue-%E4%B8%8E-Choreographer"><span class="toc-number">6.</span> <span class="toc-text">MessageQueue 与 Choreographer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SyncBarrier-%E5%9C%A8-Choreographer-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.1.</span> <span class="toc-text">SyncBarrier 在 Choreographer 中使用的一个示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%82%E5%95%86%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">厂商优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E4%BA%8B%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">移动事件优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">后台动画优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A7%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">帧绘制优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.</span> <span class="toc-text">应用启动优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B8%A7%E7%8E%87%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">高帧率优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">8.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E7%9F%A5%E4%B9%8E%E5%9C%B0%E5%9D%80"><span class="toc-number">9.</span> <span class="toc-text">本文知乎地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%88%91-amp-amp-%E5%8D%9A%E5%AE%A2"><span class="toc-number">10.</span> <span class="toc-text">关于我 &amp;&amp; 博客</span></a></li></ol>
            </div>
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    <div class="total-and-search">
        <div class="total-archive">
        Total : 113
        </div>
        <!-- search  -->
    </div>
    <div class="post-archive">
            <div class="archive-year"> 2025 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">01/27</span>
            <a class="archive-post-title" href="/2025/01/27/Android-Weekly-2025-04/">Android Weekly 2025-04 期</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/19</span>
            <a class="archive-post-title" href="/2025/01/19/Android-Weekly-2025-03/">Android Weekly 2025-03 期</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/12</span>
            <a class="archive-post-title" href="/2025/01/12/Android-Weekly-2025-02/">Android Weekly 2025-02 期</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/06</span>
            <a class="archive-post-title" href="/2025/01/06/Android-Weekly-2025-01/">Android Weekly 2025-01 期</a>
        </li>
                </ul>
            <div class="archive-year"> 2024 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span>
            <a class="archive-post-title" href="/2024/05/21/Android-Perfetto-03-how-to-analysis-perfetto/">Android Perfetto 系列 3：熟悉 Perfetto View</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span>
            <a class="archive-post-title" href="/2024/05/21/Android-Perfetto-02-how-to-get-perfetto/">Android Perfetto 系列 2：Perfetto Trace 抓取</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span>
            <a class="archive-post-title" href="/2024/05/21/Android-Perfetto-01-What-is-perfetto/">Android Perfetto 系列 1：Perfetto 工具简介</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span>
            <a class="archive-post-title" href="/2024/03/27/Android-Perfetto-101/">Android Perfetto 系列目录</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span>
            <a class="archive-post-title" href="/2024/01/01/2023-review/">2023 年的方方面面</a>
        </li>
                </ul>
            <div class="archive-year"> 2023 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">12/30</span>
            <a class="archive-post-title" href="/2023/12/30/the-performance/">关于 The Android Performance 知识星球介绍</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/15</span>
            <a class="archive-post-title" href="/2023/10/15/the-performance-design-of-os-en/">The Performance Design Of OS</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span>
            <a class="archive-post-title" href="/2023/08/21/the-performance-design-of-os/">OS 设计之性能设计</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/14</span>
            <a class="archive-post-title" href="/2023/05/14/bad-android-app-with-system-permissions/">当 App 有了系统权限，真的可以为所欲为？</a>
        </li>
                </ul>
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span>
            <a class="archive-post-title" href="/2022/03/27/the-performance-tea-part-01/">The Performance 星球茶话会 - 第一期</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/13</span>
            <a class="archive-post-title" href="/2022/03/13/android-systrace-cpu-state-sleep/">Systrace 线程 CPU 运行状态分析技巧 - Sleep 和 Uninterruptible Sleep 篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/13</span>
            <a class="archive-post-title" href="/2022/03/13/android-systrace-cpu-state-running/">Systrace 线程 CPU 运行状态分析技巧 - Running 篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span>
            <a class="archive-post-title" href="/2022/01/21/android-systrace-cpu-state-runnable/">Systrace 线程 CPU 运行状态分析技巧 - Runnable 篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/07</span>
            <a class="archive-post-title" href="/2022/01/07/Techniques-Philosophy-and-Tools-for-Android-Performance-Optimization/">Techniques, Philosophy, and Tools for Android Performance Optimization</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/07</span>
            <a class="archive-post-title" href="/2022/01/07/The-Performace-1-Performance-Tools/">Android 性能优化的术、道、器</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/03</span>
            <a class="archive-post-title" href="/2022/01/03/2021-Review/">回顾 2021</a>
        </li>
                </ul>
            <div class="archive-year"> 2021 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span>
            <a class="archive-post-title" href="/2021/10/27/if-i-write-a-book-about-performance/">一本讲 Android 流畅性的书，应该有什么内容？</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span>
            <a class="archive-post-title" href="/2021/10/26/build-android-12/">Android 系统开发系列（1）：Android 12 源代码下载、编译和刷机</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span>
            <a class="archive-post-title" href="/2021/09/13/android-systrace-Responsiveness-in-action-3/">Android Systrace 响应速度实战 3 ：响应速度延伸知识</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span>
            <a class="archive-post-title" href="/2021/09/13/android-systrace-Responsiveness-in-action-2/">Android Systrace 响应速度实战 2 ：响应速度实战分析-以启动速度为例</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span>
            <a class="archive-post-title" href="/2021/09/13/android-systrace-Responsiveness-in-action-1/">Android Systrace 响应速度实战 1 ：了解响应速度原理</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span>
            <a class="archive-post-title" href="/2021/04/24/android-systrace-smooth-in-action-3/">Android Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span>
            <a class="archive-post-title" href="/2021/04/24/android-systrace-smooth-in-action-2/">Android Systrace 流畅性实战 2 ：案例分析 - MIUI 桌面滑动卡顿分析</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span>
            <a class="archive-post-title" href="/2021/04/24/android-systrace-smooth-in-action-1/">Android Systrace 流畅性实战 1 ：了解卡顿原理</a>
        </li>
                </ul>
            <div class="archive-year"> 2020 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span>
            <a class="archive-post-title" href="/2020/08/20/weibo-imageload-opt-on-huawei/">华为手机刷微博体验更好？技术角度的一些分析和思考</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/26</span>
            <a class="archive-post-title" href="/2020/05/26/samsung_crash/">一个「闰」字引发的事故 - 三星系统重启分析</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/07</span>
            <a class="archive-post-title" href="/2020/05/07/Android-App-Chain-Wakeup/">Android App 链式唤醒分析</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">02/14</span>
            <a class="archive-post-title" href="/2020/02/14/Android-Systrace-SurfaceFlinger/">Android Systrace 基础知识 - SurfaceFlinger 解读</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2020/02/03/android-development-learning-path-2020-edition/">Android 开发者学习路线(2020 版本)</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/28</span>
            <a class="archive-post-title" href="/2020/01/28/2020-read/">我的 2020 年读书单</a>
        </li>
                </ul>
            <div class="archive-year"> 2019 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span>
            <a class="archive-post-title" href="/2019/12/21/Android-Systrace-CPU/">Android Systrace 基础知识 - CPU Info 解读</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/15</span>
            <a class="archive-post-title" href="/2019/12/15/Android-Systrace-Triple-Buffer/">Android Systrace 基础知识 - Triple Buffer 解读</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span>
            <a class="archive-post-title" href="/2019/12/06/Android-Systrace-Binder/">Android Systrace 基础知识 - Binder 和锁竞争解读</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/01</span>
            <a class="archive-post-title" href="/2019/12/01/BlogMap/">「置顶」博客文章目录</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/01</span>
            <a class="archive-post-title" href="/2019/12/01/Android-Systrace-Vsync/">Android Systrace 基础知识 - Vsync 解读</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/18</span>
            <a class="archive-post-title" href="/2019/11/18/Android-App-Lunch-Optimize/">Android App 启动优化全记录</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/06</span>
            <a class="archive-post-title" href="/2019/11/06/Android-Systrace-MainThread-And-RenderThread/">Android Systrace 基础知识 - MainThread 和 RenderThread 解读</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span>
            <a class="archive-post-title" href="/2019/11/04/Android-Systrace-Input/">Android Systrace 基础知识 - Input 解读</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span>
            <a class="archive-post-title" href="/2019/10/24/Android-Background-Animation/">Android 中的“后台无效动画“行为分析</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span>
            <a class="archive-post-title" href="/2019/10/22/Android-Choreographer/">Android 基于 Choreographer 的渲染机制详解</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span>
            <a class="archive-post-title" href="/2019/09/18/Android-Jank-Due-To-Low-Memory/">Android 中的卡顿丢帧原因概述 - 低内存篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/17</span>
            <a class="archive-post-title" href="/2019/09/17/Android-Kill-Background-App-Debug/">Android 桌面被杀问题分析案例</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span>
            <a class="archive-post-title" href="/2019/09/05/Android-Jank-Due-To-App/">Android 中的卡顿丢帧原因概述 - 应用篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span>
            <a class="archive-post-title" href="/2019/09/05/Android-Jank-Due-To-System/">Android 中的卡顿丢帧原因概述 - 系统篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span>
            <a class="archive-post-title" href="/2019/09/05/Android-Jank-Debug/">Android 中的卡顿丢帧原因概述 - 方法论</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/01</span>
            <a class="archive-post-title" href="/2019/09/01/Android-Activity-Lunch-Mode/">Android 中的 Activity Launch Mode 详解</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/27</span>
            <a class="archive-post-title" href="/2019/07/27/Android-Hardware-Layer/">Android 中的 Hardware Layer 详解</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span>
            <a class="archive-post-title" href="/2019/07/23/Android-Systrace-Pre/">Android Systrace 基础知识 -- 分析 Systrace 预备知识</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/29</span>
            <a class="archive-post-title" href="/2019/06/29/Android-Systrace-SystemServer/">Android Systrace 基础知识 - SystemServer 解读</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span>
            <a class="archive-post-title" href="/2019/05/28/Android-Systrace-About/">Android Systrace 基础知识 -- Systrace 简介</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span>
            <a class="archive-post-title" href="/2019/05/27/why-60-fps/">Android Systrace 基础知识 -- Why 60 fps ？</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/26</span>
            <a class="archive-post-title" href="/2019/05/26/Android_Systrace_0/">Android Systrace -- 系列文章目录</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/15</span>
            <a class="archive-post-title" href="/2019/05/15/90hz-on-android/">Android 新的流畅体验，90Hz 漫谈</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span>
            <a class="archive-post-title" href="/2019/04/07/liqi/">利器 - 高效工具推荐</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span>
            <a class="archive-post-title" href="/2019/01/21/android-performance-case-jank-accessbility/">Android 无障碍服务导致的整机卡顿案例分析</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/12</span>
            <a class="archive-post-title" href="/2019/01/12/recommend-of-2018/">2018 年度好物推荐 - 给辛勤工作的自己一点奖励</a>
        </li>
                </ul>
            <div class="archive-year"> 2018 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span>
            <a class="archive-post-title" href="/2018/11/01/android-system-develop-0/">Android 系统开发源码环境搭建</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/25</span>
            <a class="archive-post-title" href="/2018/10/25/How-do-engineers-count-well/">陆奇：除了好代码，工程师怎样才算优秀？</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/01</span>
            <a class="archive-post-title" href="/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/">程序员的修炼-08-阅读之美</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/30</span>
            <a class="archive-post-title" href="/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/">程序员的修炼-07-游戏与编程</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/29</span>
            <a class="archive-post-title" href="/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/">程序员的修炼-06-互联网那些事</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span>
            <a class="archive-post-title" href="/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/">程序员的修炼-05-了解你的用户</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span>
            <a class="archive-post-title" href="/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/">程序员的修炼-04-关于测试的一些思考</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span>
            <a class="archive-post-title" href="/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/">程序员的修炼-03-Web 设计原则</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span>
            <a class="archive-post-title" href="/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/">程序员的修炼-02-编程之道</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/19</span>
            <a class="archive-post-title" href="/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/">程序员的修炼-01-绝地反击之术</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span>
            <a class="archive-post-title" href="/2018/09/13/android-memory/">Android 系统不释放内存吗？</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span>
            <a class="archive-post-title" href="/2018/08/13/Some-Thoughts-on-the-Fluency-of-Android/">关于 Android 系统流畅性的一些思考</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/20</span>
            <a class="archive-post-title" href="/2018/05/20/zhihu-startingwindow/">知乎 救救你的 StartingWindow</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/07</span>
            <a class="archive-post-title" href="/2018/05/07/Android-performance-optimization-skills-and-tools/">「置顶」Android 性能优化必知必会</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/06</span>
            <a class="archive-post-title" href="/2018/01/06/2017%E5%B9%B4%E5%BA%A6%E6%9C%80%E6%8E%A8%E8%8D%90/">2017 年度好物推荐 - 给辛勤工作的自己一点奖励</a>
        </li>
                </ul>
            <div class="archive-year"> 2017 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">04/23</span>
            <a class="archive-post-title" href="/2017/04/23/About-work/">2017</a>
        </li>
                </ul>
            <div class="archive-year"> 2016 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">04/05</span>
            <a class="archive-post-title" href="/2016/04/05/android-bottom-bar-2/">Android Bottom navigation 规范二：样式、行为与规格</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/05</span>
            <a class="archive-post-title" href="/2016/04/05/android-bottom-bar-1/">Android Bottom Navigation 规范一：使用方法</a>
        </li>
                </ul>
            <div class="archive-year"> 2015 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">12/31</span>
            <a class="archive-post-title" href="/2015/12/31/How-to-calculation-android-app-lunch-time/">Android 中如何计算 App 的启动时间？</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/29</span>
            <a class="archive-post-title" href="/2015/12/29/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E4%B8%80%E7%A7%8DDelayLoad%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86-%E4%B8%8B%E7%AF%87/">Android 应用启动优化:一种 DelayLoad 的实现和原理(下篇)</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/18</span>
            <a class="archive-post-title" href="/2015/11/18/Android-app-lunch-optimize-delay-load/">Android 应用启动优化 - 一种 DelayLoad 的实现和原理(上篇)</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">08/12</span>
            <a class="archive-post-title" href="/2015/08/12/AndroidL-hwui-RenderThread-workflow/">Android hwui 中 RenderThread 工作流程</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span>
            <a class="archive-post-title" href="/2015/08/05/HashMap/">Java7 HashMap 源码分析</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/20</span>
            <a class="archive-post-title" href="/2015/07/20/Android-Performance-Memory-onTrimMemory/">Android 代码内存优化建议 - OnTrimMemory 优化</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/20</span>
            <a class="archive-post-title" href="/2015/07/20/Android-Performance-Memory-AndroidResource/">Android 代码内存优化建议 - Android 资源篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/20</span>
            <a class="archive-post-title" href="/2015/07/20/Android-Performance-Memory-Google/">Android 代码内存优化建议 - Android 官方篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/20</span>
            <a class="archive-post-title" href="/2015/07/20/Android-Performance-Memory-Java/">Android 代码内存优化建议 - Java 官方篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/29</span>
            <a class="archive-post-title" href="/2015/05/29/Nexus6-with-Android-M/">Nexus6 with Android M 开启多窗口模式</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/06</span>
            <a class="archive-post-title" href="/2015/05/06/Java-Singleton/">细说 Java 单例模式</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span>
            <a class="archive-post-title" href="/2015/04/19/Android-Performance-Patterns-4/">Android 性能优化典范 - Profile GPU Rendering</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span>
            <a class="archive-post-title" href="/2015/04/19/Android-Performance-Patterns-3/">Android 性能优化典范 - Understanding VSYNC</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span>
            <a class="archive-post-title" href="/2015/04/19/Android-Performance-Patterns-2/">Android 性能优化典范之 Understanding Overdraw</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span>
            <a class="archive-post-title" href="/2015/04/19/Android-Performance-Patterns-1/">Android 性能优化典范 - Render Performance</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span>
            <a class="archive-post-title" href="/2015/04/19/Android-Performance-Patterns/">Android 性能优化典范综述</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span>
            <a class="archive-post-title" href="/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/">Android 内存优化之三 - 打开 MAT 中的 Bitmap 原图</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span>
            <a class="archive-post-title" href="/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/">Android 内存优化之二 - MAT使用进阶</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span>
            <a class="archive-post-title" href="/2015/04/11/AndroidMemory-Usage-Of-MAT/">Android 内存优化(1) - MAT 使用入门</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/31</span>
            <a class="archive-post-title" href="/2015/03/31/android-performance-case-study-follow-up/">Android性能优化后续</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span>
            <a class="archive-post-title" href="/2015/03/15/android-tips-round-up-5/">Android 小技巧 - 5</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span>
            <a class="archive-post-title" href="/2015/03/15/android-tips-round-up-4/">Android 小技巧 - 4</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span>
            <a class="archive-post-title" href="/2015/03/15/android-tips-round-up-3/">Android 小技巧 -3</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span>
            <a class="archive-post-title" href="/2015/02/04/build-rom-for-nexus5/">为 Nexus5 编译 AndroidL 固件</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/30</span>
            <a class="archive-post-title" href="/2015/01/30/android-performance-tools-systrace-1/">Android 性能优化之 Systrace 工具介绍(一)</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span>
            <a class="archive-post-title" href="/2015/01/16/view-android-source-code-with-androidstudio/">使用 Android Studio 查看 Android Lollipop 源码</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span>
            <a class="archive-post-title" href="/2015/01/13/android-performance-optimization-overdraw-2/">Android 性能优化之过渡绘制 - 实战篇</a>
        </li>
                </ul>
            <div class="archive-year"> 2014 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">10/20</span>
            <a class="archive-post-title" href="/2014/10/20/android-performance-optimization-overdraw-1/">Android 性能优化之过渡绘制 - 理论篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/03</span>
            <a class="archive-post-title" href="/2014/06/03/android-edittext-do-not-auto-get-focus/">Android 小技巧 - 如何让EditText不自动获取焦点</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/31</span>
            <a class="archive-post-title" href="/2014/05/31/android-tips-round-up-2/">Android 小技巧 -2</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span>
            <a class="archive-post-title" href="/2014/05/28/android-tips-round-up-1/">Android 小技巧 - 1</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/02</span>
            <a class="archive-post-title" href="/2014/05/02/android_log_to_file/">Android Tools - Log2File</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span>
            <a class="archive-post-title" href="/2014/04/01/android-service-build-your-own-notification-servers-app/">Android Service：开发自己的通知中心(2):辅助性服务实战</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/25</span>
            <a class="archive-post-title" href="/2014/03/25/ubuntu-adb-can-not-find-devices/">Android:Ubuntu 下执行 Adb 命令找不到设备</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span>
            <a class="archive-post-title" href="/2014/03/17/android-build-your-own-android-notification-service-app/">Android Service：开发自己的通知中心(1):辅助性服务介绍</a>
        </li>
            </ul>
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
            <span class="sidebar-tag-name" data-tags="年终总结">
                <span class="iconfont-archer">&#xe606;</span>
                年终总结
            </span>
            <span class="sidebar-tag-name" data-tags="知识星球">
                <span class="iconfont-archer">&#xe606;</span>
                知识星球
            </span>
            <span class="sidebar-tag-name" data-tags="流畅度">
                <span class="iconfont-archer">&#xe606;</span>
                流畅度
            </span>
            <span class="sidebar-tag-name" data-tags="年度推荐">
                <span class="iconfont-archer">&#xe606;</span>
                年度推荐
            </span>
            <span class="sidebar-tag-name" data-tags="随笔">
                <span class="iconfont-archer">&#xe606;</span>
                随笔
            </span>
            <span class="sidebar-tag-name" data-tags="Android">
                <span class="iconfont-archer">&#xe606;</span>
                Android
            </span>
            <span class="sidebar-tag-name" data-tags="Framework">
                <span class="iconfont-archer">&#xe606;</span>
                Framework
            </span>
            <span class="sidebar-tag-name" data-tags="Performance">
                <span class="iconfont-archer">&#xe606;</span>
                Performance
            </span>
            <span class="sidebar-tag-name" data-tags="Tools">
                <span class="iconfont-archer">&#xe606;</span>
                Tools
            </span>
            <span class="sidebar-tag-name" data-tags="Systrace">
                <span class="iconfont-archer">&#xe606;</span>
                Systrace
            </span>
            <span class="sidebar-tag-name" data-tags="Perfetto">
                <span class="iconfont-archer">&#xe606;</span>
                Perfetto
            </span>
            <span class="sidebar-tag-name" data-tags="MethodTrace">
                <span class="iconfont-archer">&#xe606;</span>
                MethodTrace
            </span>
            <span class="sidebar-tag-name" data-tags="MAT">
                <span class="iconfont-archer">&#xe606;</span>
                MAT
            </span>
            <span class="sidebar-tag-name" data-tags="Memory">
                <span class="iconfont-archer">&#xe606;</span>
                Memory
            </span>
            <span class="sidebar-tag-name" data-tags="启动优化">
                <span class="iconfont-archer">&#xe606;</span>
                启动优化
            </span>
            <span class="sidebar-tag-name" data-tags="DelayLoad">
                <span class="iconfont-archer">&#xe606;</span>
                DelayLoad
            </span>
            <span class="sidebar-tag-name" data-tags="程序员">
                <span class="iconfont-archer">&#xe606;</span>
                程序员
            </span>
            <span class="sidebar-tag-name" data-tags="Java">
                <span class="iconfont-archer">&#xe606;</span>
                Java
            </span>
            <span class="sidebar-tag-name" data-tags="Singleton">
                <span class="iconfont-archer">&#xe606;</span>
                Singleton
            </span>
            <span class="sidebar-tag-name" data-tags="Nexus">
                <span class="iconfont-archer">&#xe606;</span>
                Nexus
            </span>
            <span class="sidebar-tag-name" data-tags="设计规范">
                <span class="iconfont-archer">&#xe606;</span>
                设计规范
            </span>
            <span class="sidebar-tag-name" data-tags="Process">
                <span class="iconfont-archer">&#xe606;</span>
                Process
            </span>
            <span class="sidebar-tag-name" data-tags="卡顿">
                <span class="iconfont-archer">&#xe606;</span>
                卡顿
            </span>
            <span class="sidebar-tag-name" data-tags="Ubuntu">
                <span class="iconfont-archer">&#xe606;</span>
                Ubuntu
            </span>
            <span class="sidebar-tag-name" data-tags="流畅性">
                <span class="iconfont-archer">&#xe606;</span>
                流畅性
            </span>
            <span class="sidebar-tag-name" data-tags="体验优化">
                <span class="iconfont-archer">&#xe606;</span>
                体验优化
            </span>
            <span class="sidebar-tag-name" data-tags="读书笔记">
                <span class="iconfont-archer">&#xe606;</span>
                读书笔记
            </span>
            <span class="sidebar-tag-name" data-tags="程序员的修炼">
                <span class="iconfont-archer">&#xe606;</span>
                程序员的修炼
            </span>
            <span class="sidebar-tag-name" data-tags="了解你的用户">
                <span class="iconfont-archer">&#xe606;</span>
                了解你的用户
            </span>
            <span class="sidebar-tag-name" data-tags="游戏与编程">
                <span class="iconfont-archer">&#xe606;</span>
                游戏与编程
            </span>
            <span class="sidebar-tag-name" data-tags="设计原则">
                <span class="iconfont-archer">&#xe606;</span>
                设计原则
            </span>
            <span class="sidebar-tag-name" data-tags="测试">
                <span class="iconfont-archer">&#xe606;</span>
                测试
            </span>
            <span class="sidebar-tag-name" data-tags="阅读之美">
                <span class="iconfont-archer">&#xe606;</span>
                阅读之美
            </span>
            <span class="sidebar-tag-name" data-tags="互联网那些事">
                <span class="iconfont-archer">&#xe606;</span>
                互联网那些事
            </span>
            <span class="sidebar-tag-name" data-tags="利器">
                <span class="iconfont-archer">&#xe606;</span>
                利器
            </span>
            <span class="sidebar-tag-name" data-tags="用户体验">
                <span class="iconfont-archer">&#xe606;</span>
                用户体验
            </span>
            <span class="sidebar-tag-name" data-tags="知乎">
                <span class="iconfont-archer">&#xe606;</span>
                知乎
            </span>
            <span class="sidebar-tag-name" data-tags="StartingWindow">
                <span class="iconfont-archer">&#xe606;</span>
                StartingWindow
            </span>
            <span class="sidebar-tag-name" data-tags="Lunch">
                <span class="iconfont-archer">&#xe606;</span>
                Lunch
            </span>
            <span class="sidebar-tag-name" data-tags="hwui">
                <span class="iconfont-archer">&#xe606;</span>
                hwui
            </span>
            <span class="sidebar-tag-name" data-tags="RenderThread">
                <span class="iconfont-archer">&#xe606;</span>
                RenderThread
            </span>
            <span class="sidebar-tag-name" data-tags="Menory">
                <span class="iconfont-archer">&#xe606;</span>
                Menory
            </span>
            <span class="sidebar-tag-name" data-tags="HashMap">
                <span class="iconfont-archer">&#xe606;</span>
                HashMap
            </span>
            <span class="sidebar-tag-name" data-tags="个人感悟">
                <span class="iconfont-archer">&#xe606;</span>
                个人感悟
            </span>
            <span class="sidebar-tag-name" data-tags="响应速度">
                <span class="iconfont-archer">&#xe606;</span>
                响应速度
            </span>
            <span class="sidebar-tag-name" data-tags="Design">
                <span class="iconfont-archer">&#xe606;</span>
                Design
            </span>
            <span class="sidebar-tag-name" data-tags="Operation System">
                <span class="iconfont-archer">&#xe606;</span>
                Operation System
            </span>
            <span class="sidebar-tag-name" data-tags="iOS">
                <span class="iconfont-archer">&#xe606;</span>
                iOS
            </span>
            <span class="sidebar-tag-name" data-tags="Android Weekly">
                <span class="iconfont-archer">&#xe606;</span>
                Android Weekly
            </span>
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
        <span class="sidebar-category-name" data-categories="年终总结">
            <span class="iconfont-archer">&#xe60a;</span>
            年终总结
        </span>
        <span class="sidebar-category-name" data-categories="随笔">
            <span class="iconfont-archer">&#xe60a;</span>
            随笔
        </span>
        <span class="sidebar-category-name" data-categories="Android">
            <span class="iconfont-archer">&#xe60a;</span>
            Android
        </span>
        <span class="sidebar-category-name" data-categories="Memory">
            <span class="iconfont-archer">&#xe60a;</span>
            Memory
        </span>
        <span class="sidebar-category-name" data-categories="Memory">
            <span class="iconfont-archer">&#xe60a;</span>
            Memory
        </span>
        <span class="sidebar-category-name" data-categories="Android">
            <span class="iconfont-archer">&#xe60a;</span>
            Android
        </span>
        <span class="sidebar-category-name" data-categories="Performance">
            <span class="iconfont-archer">&#xe60a;</span>
            Performance
        </span>
        <span class="sidebar-category-name" data-categories="Android">
            <span class="iconfont-archer">&#xe60a;</span>
            Android
        </span>
        <span class="sidebar-category-name" data-categories="Java">
            <span class="iconfont-archer">&#xe60a;</span>
            Java
        </span>
        <span class="sidebar-category-name" data-categories="Framework">
            <span class="iconfont-archer">&#xe60a;</span>
            Framework
        </span>
        <span class="sidebar-category-name" data-categories="Tools">
            <span class="iconfont-archer">&#xe60a;</span>
            Tools
        </span>
        <span class="sidebar-category-name" data-categories="Android">
            <span class="iconfont-archer">&#xe60a;</span>
            Android
        </span>
        <span class="sidebar-category-name" data-categories="读书笔记">
            <span class="iconfont-archer">&#xe60a;</span>
            读书笔记
        </span>
        <span class="sidebar-category-name" data-categories="知识星球">
            <span class="iconfont-archer">&#xe60a;</span>
            知识星球
        </span>
        <span class="sidebar-category-name" data-categories="iOS">
            <span class="iconfont-archer">&#xe60a;</span>
            iOS
        </span>
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "https://androidperformance.com",
        root: siteMetaRoot,
        author: "Gracker"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->

        <!-- main func -->
        <script src="/scripts/main.js"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.js" onload="window.Fancybox.bind('[data-fancybox]')" defer></script>
        <!-- algolia -->
        <!-- busuanzi -->
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        <!-- async load share.js -->
            <script src="/scripts/share.js" async></script>
        <!-- mermaid -->
    </body>
</html>
