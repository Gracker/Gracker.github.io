<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</title>
      <link href="/2021/04/24/android-systrace-smooth-in-action-3/"/>
      <url>/2021/04/24/android-systrace-smooth-in-action-3/</url>
      
        <content type="html"><![CDATA[<p>当我们说 <strong>流畅度</strong> 的时候，我们说的是什么？不同的人对流畅性(卡顿掉帧)有不同的理解，对卡顿阈值也有不同的感知，所以有必要在开始这个系列文章之前，先把涉及到的内容说清楚，防止出现不同的理解，也方便大家带着问题去看这几篇问题，下面是一些基本的说明</p><ol><li>对手机用户来说，卡顿包含了很多场景，比如在 <strong>滑动列表的时候掉帧</strong>、<strong>应用启动白屏过长</strong>、<strong>点击电源键亮屏慢</strong>、<strong>界面操作没有反应然后闪退</strong>、<strong>点击图标没有响应</strong>、<strong>窗口动画不连贯、滑动不跟手、重启手机进入桌面卡顿</strong> 等场景，这些场景跟我们开发人员所理解的卡顿还有点不一样，开发人员会更加细分去分析这些问题，这是开发人员和用户之间的一个认知差异，这一点在处理用户(或者测试人员)的问题反馈的时候尤其需要注意</li><li>对开发人员来说，上面的场景包括了 <strong>流畅度</strong>（滑动列表的时候掉帧、窗口动画不连贯、重启手机进入桌面卡顿）、<strong>响应速度</strong>（应用启动白屏过长、点击电源键亮屏慢、滑动不跟手）、<strong>稳定性</strong>（界面操作没有反应然后闪退、点击图标没有响应）这三个大的分类。之所以这么分类，是因为每一种分类都有不太一样的分析方法和步骤，快速分辨问题是属于哪一类很重要</li><li>在技术上来说，<strong>流畅度、响应速度、稳定性</strong>（ANR）这三类之所以用户感知都是卡顿，是因为这三类问题产生的原理是一致的，都是由于主线程的 Message 在执行任务的时候超时，根据不同的超时阈值来进行划分而已，所以要理解这些问题，需要对系统的一些基本的运行机制有一定的了解，本文会介绍一些基本的运行机制</li><li>流畅性这个系列主要是分析流畅度相关的问题，响应速度和稳定性会有专门的文章介绍，在理解了流畅性相关的内容之后，再去分析响应速度和稳定性问题会事半功倍</li><li>流畅性这个系列主要是讲如何使用 Systrace (Perfetto) 工具去分析，之所以 Systrace 为切入点，是因为影响流畅度的因素很多，有 App 自身的原因、也有系统的原因。而  (Perfetto)  工具可以从一个整机运行的角度来展示问题发生的过程，方便我们去初步定位问题<a id="more"></a></li></ol><p>Systrace 流畅性实战目前包括下面三篇</p><ol><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><p>Systrace (Perfetto) 工具的基本使用如果还不是很熟悉，那么需要优先去补一下 <a href="https://www.androidperformance.com/2019/05/26/Android_Systrace_0/" target="_blank" rel="noopener">Systrace 基础知识系列</a></p><h1 id="Systrace-的-Frame-颜色是什么意思？"><a href="#Systrace-的-Frame-颜色是什么意思？" class="headerlink" title="Systrace 的 Frame 颜色是什么意思？"></a>Systrace 的 Frame 颜色是什么意思？</h1><p>这里的 Frame 标记指的是应用主线程上面那个圈，共有三个颜色，每一帧的耗时不同，则标识的颜色不同</p><p>点击这个小圆圈就可以看到这一帧所对应的主线程+渲染线程（会以高亮显示，其他的则变灰显示）</p><h2 id="绿帧"><a href="#绿帧" class="headerlink" title="绿帧"></a>绿帧</h2><p>绿帧是最常见的帧，表示这一帧在一个 Vsync 周期里面完成</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2022.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2022.png"></p><h2 id="黄帧"><a href="#黄帧" class="headerlink" title="黄帧"></a>黄帧</h2><p>黄帧表示这一帧耗时超过1个 Vsync 周期，但是小于 2 个 Vsync 周期。黄帧的出现表示这一帧可能存在性能问题，可能会导致卡顿情况出现</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2023.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2023.png"></p><h2 id="红帧"><a href="#红帧" class="headerlink" title="红帧"></a>红帧</h2><p>红帧表示这一帧耗时超过 2 个 Vsync 周期，红帧的出现表示这一帧可能存在性能问题，大概率会导致卡顿情况出现</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2024.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2024.png"></p><h1 id="没有红帧就没有掉帧？"><a href="#没有红帧就没有掉帧？" class="headerlink" title="没有红帧就没有掉帧？"></a>没有红帧就没有掉帧？</h1><p>不一定，判断是否掉帧要看 SurfaceFlinger，而不是看 App ，这部分需要有 <a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/" target="_blank" rel="noopener">https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/</a> 这篇文章的基础</p><h2 id="出现黄帧但是不掉帧的情况"><a href="#出现黄帧但是不掉帧的情况" class="headerlink" title="出现黄帧但是不掉帧的情况"></a>出现黄帧但是不掉帧的情况</h2><p>如上所述，红帧和黄帧都表示这一帧存在性能问题，黄帧表示这一帧耗时超过一个 Vsync 周期，但是由于 Android Triple Buffer（现在的高帧率手机会配置更多的 Buffer）的存在，就算 App 主线程这一帧超过一个 Vsync 周期，也会由于多 Buffer 的缓冲，使得这一帧并不会出现掉帧</p><h2 id="出现黄帧且掉帧的情况"><a href="#出现黄帧且掉帧的情况" class="headerlink" title="出现黄帧且掉帧的情况"></a>出现黄帧且掉帧的情况</h2><p>这次分析的 Systrace（见附件），就是没有红帧只有黄帧，连续出现两个黄帧，第一个黄帧导致了卡顿，而第二个黄帧则没有</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2025.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2025.png"></p><h1 id="主线程为何要等待渲染线程？"><a href="#主线程为何要等待渲染线程？" class="headerlink" title="主线程为何要等待渲染线程？"></a>主线程为何要等待渲染线程？</h1><p>还是这个 Systrace（附件） 中的情况，第一个疑点处两个黄帧，可以看到第二个黄帧的主线程耗时很久，这时候不能单纯以为是主线程的问题（因为是 Sleep 状态）</p><p>如下图所示，是因为前一帧的渲染线程超时，导致这一帧的渲染线程任务在排队等待，如（<a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/</a>）这篇文章里面的流程，主线程是需要等待渲染线程执行完 syncFrameState 之后 unblockMainThread，然后才能继续。</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2026.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2026.png"></p><h1 id="为什么一直滑动不松手，就不会卡？"><a href="#为什么一直滑动不松手，就不会卡？" class="headerlink" title="为什么一直滑动不松手，就不会卡？"></a>为什么一直滑动不松手，就不会卡？</h1><p>还是这个场景（桌面左右滑动），卡顿是发生在松手之后的，如果一直不松手，那么就不会出现卡顿，这是为什么？</p><p>如下图，可以看到，如果不松手，cpu 这里会有一个持续的 Boost，且此时 RenderThread 的任务都跑在 4-6 这三个大核上面，没有跑到小核，自然也不会出现卡顿情况</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2027.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2027.png"></p><p>这一段 Boost 的 Timeout 是 120 ms，具体的配置每个机型都不一样，熟悉 PerfLock 的应该知道，这里就不多说了</p><h1 id="如果不卡，怎么衡量性能好坏？"><a href="#如果不卡，怎么衡量性能好坏？" class="headerlink" title="如果不卡，怎么衡量性能好坏？"></a>如果不卡，怎么衡量性能好坏？</h1><p>如果这个场景不卡，那么我们怎么衡量两台不同的机器在这个场景下的性能呢？</p><p>可以使用 <code>adb shell dumpsys gfxinfo</code> ，使用方法如下</p><ol><li>首先确定要测试的包名，到 App 界面准备好操作</li><li>执行2-3次 <code>adb shell dumpsys gfxinfo com.miui.home framestats reset</code> ，这一步的目的是清除历数据</li><li>开始操作（比如使用命令行左右滑动，或者自己用手指滑动）</li><li>操作结束后，执行 <code>adb shell dumpsys gfxinfo com.miui.home framestats</code> 这时候会有一堆数据输出，我们只需要关注其中的一部分数据即可</li><li>重点关注<ol><li><strong>Janky frames</strong> ：超过 Vsync 周期的 Frame，不一定出现卡顿</li><li><strong>95th percentile</strong> ：95% 的值</li><li><strong>HISTOGRAM</strong> ： 原始数值</li><li><strong>PROFILEDATA</strong> ：每一帧的详细原始数据</li></ol></li></ol><p>我们拿这个场景，跟 Oppo Reno 5 来做对比，只取我们关注的一部分数据</p><h2 id="小米-90-fps"><a href="#小米-90-fps" class="headerlink" title="小米 - 90 fps"></a>小米 - 90 fps</h2><p><img src="/images/16192690407230.jpg" alt="xiaomi"></p><h2 id="Oppo-90-fps"><a href="#Oppo-90-fps" class="headerlink" title="Oppo - 90 fps"></a>Oppo - 90 fps</h2><p><img src="/images/16192690109378.jpg" alt="oppo"></p><p>下面是一些对比，可以看到小米在桌面滑动这个场景，性能是要弱于 Oppo 的</p><ol><li>Janky frames<ol><li>小米：27 (35.53%)</li><li>Oppo：1 (1.11%)</li></ol></li><li>95th percentile<ol><li>小米：18ms</li><li>Oppo：5ms</li></ol></li></ol><p>另外 GPU 的数据也比较有趣，小米的高通 865 配的 GPU 要比 Reno 5 Pro 配的 GPU 要强很多，所以 GPU 的数据小米要比 Reno 5 Pro 要好，也可以推断出这个场景的瓶颈在 CPU 而不是在 GPU</p><h1 id="为什么录屏看不出来卡顿？"><a href="#为什么录屏看不出来卡顿？" class="headerlink" title="为什么录屏看不出来卡顿？"></a>为什么录屏看不出来卡顿？</h1><p>可能有下面几种情况</p><ol><li>如果使用的手机是大于 60 fps 的，比如小米这个是 90 fps，而录屏的时候选择 60 fps 的录屏，则录屏文件会看不出来卡顿 （使用其他手机录像也会有这个问题）</li><li>如果录屏是以高帧率（90fps）录制的，但是播放的时候是使用低帧率（60fps）的设备观看的（小米就是这个情况），也不会看出来卡顿，比如用 90 fps 的规格录制视频，但是在手机上播放的时候，系统会自动切换到 60 fps, 导致看不出来卡顿</li></ol><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附件已经上传到了 Github 上，可以自行下载：<a href="https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_Smooth_In_Action" target="_blank" rel="noopener">https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_Smooth_In_Action</a></p><ol><li>xiaomi_launcher.zip : 桌面滑动卡顿的 Systrace 文件，这次案例主要是分析这个 Systrace 文件</li><li>xiaomi_launcher_scroll_all_the_time.zip : 桌面一直按着滑动的 Systrace 文件</li><li>oppo_launcher_scroll.zip ：对比文件</li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 流畅性 </tag>
            
            <tag> 体验优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Systrace 流畅性实战 2 ：案例分析 - MIUI 桌面滑动卡顿分析</title>
      <link href="/2021/04/24/android-systrace-smooth-in-action-2/"/>
      <url>/2021/04/24/android-systrace-smooth-in-action-2/</url>
      
        <content type="html"><![CDATA[<p>当我们说 <strong>流畅度</strong> 的时候，我们说的是什么？不同的人对流畅性(卡顿掉帧)有不同的理解，对卡顿阈值也有不同的感知，所以有必要在开始这个系列文章之前，先把涉及到的内容说清楚，防止出现不同的理解，也方便大家带着问题去看这几篇问题，下面是一些基本的说明</p><ol><li>对手机用户来说，卡顿包含了很多场景，比如在 <strong>滑动列表的时候掉帧</strong>、<strong>应用启动白屏过长</strong>、<strong>点击电源键亮屏慢</strong>、<strong>界面操作没有反应然后闪退</strong>、<strong>点击图标没有响应</strong>、<strong>窗口动画不连贯、滑动不跟手、重启手机进入桌面卡顿</strong> 等场景，这些场景跟我们开发人员所理解的卡顿还有点不一样，开发人员会更加细分去分析这些问题，这是开发人员和用户之间的一个认知差异，这一点在处理用户(或者测试人员)的问题反馈的时候尤其需要注意</li><li>对开发人员来说，上面的场景包括了 <strong>流畅度</strong>（滑动列表的时候掉帧、窗口动画不连贯、重启手机进入桌面卡顿）、<strong>响应速度</strong>（应用启动白屏过长、点击电源键亮屏慢、滑动不跟手）、<strong>稳定性</strong>（界面操作没有反应然后闪退、点击图标没有响应）这三个大的分类。之所以这么分类，是因为每一种分类都有不太一样的分析方法和步骤，快速分辨问题是属于哪一类很重要</li><li>在技术上来说，<strong>流畅度、响应速度、稳定性</strong>（ANR）这三类之所以用户感知都是卡顿，是因为这三类问题产生的原理是一致的，都是由于主线程的 Message 在执行任务的时候超时，根据不同的超时阈值来进行划分而已，所以要理解这些问题，需要对系统的一些基本的运行机制有一定的了解，本文会介绍一些基本的运行机制</li><li>流畅性这个系列主要是分析流畅度相关的问题，响应速度和稳定性会有专门的文章介绍，在理解了流畅性相关的内容之后，再去分析响应速度和稳定性问题会事半功倍</li><li>流畅性这个系列主要是讲如何使用 Systrace (Perfetto) 工具去分析，之所以 Systrace 为切入点，是因为影响流畅度的因素很多，有 App 自身的原因、也有系统的原因。而  (Perfetto)  工具可以从一个整机运行的角度来展示问题发生的过程，方便我们去初步定位问题<a id="more"></a></li></ol><p>Systrace 流畅性实战目前包括下面三篇</p><ol><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><p>Systrace (Perfetto) 工具的基本使用如果还不是很熟悉，那么需要优先去补一下 <a href="https://www.androidperformance.com/2019/05/26/Android_Systrace_0/" target="_blank" rel="noopener">Systrace 基础知识系列</a></p><p>Systrace 作为分析卡顿问题的第一手工具，给开发者提供了一个从手机全局角度去看问题的方式，通过 Systrace 工具进行分析，我们可以大致确定卡顿问题的原因：是系统导致的还是应用自身的问题</p><p>当然 Systrace 作为一个工具，再进行深入的分析的时候就会有点力不从心，需要配合 TraceView + 源码来进一步定位和解决问题，最后再使用 Systrace 进行验证</p><p>所以本文更多地是讲如何发现和分析卡顿问题，至于如何解决，就需要后续自己寻找合适的解决方案了，比如对比竞品的 Systrace 表现、优化代码逻辑、优化系统调度、优化布局等</p><h1 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h1><p>个人在使用小米 10 Pro 的时候，在桌面滑动这个最常用的场景里面，总会有一种卡顿的感觉，10 Pro 是 90Hz 的屏幕，FPS 也是 90，所以一旦出现卡顿，就会有很明显的感觉(个人对这个也比较敏感)。之前没怎么关注，在升级 12.5 之后，这个问题还是没有解决，所以我想看看到底是怎么回事</p><p>抓了 Systrace 之后分析发现，这个卡顿场景是一个非常好的案例，所以把这个例子拿出来作为流畅度的一个实战分享</p><p>建议大家下载附件中的 Systrace，对照文章食用最佳</p><blockquote><ol><li>鉴于卡顿问题的影响因素比较多，所以在开始之前，我把本次分析所涉及的硬件、软件版本沟通清楚，如果后续此场景有优化，此文章也不会进行修改，以文章附件中的 Systrace 为准</li><li>硬件：小米10 Pro</li><li>软件：MIUI 12.5.3 稳定版</li><li>小米桌面版本：RELEASE-4.21.11.2922-03151646</li></ol></blockquote><h1 id="Systrace-分析"><a href="#Systrace-分析" class="headerlink" title="Systrace 分析"></a>Systrace 分析</h1><p>分析卡顿问题，我们一般的流程如下</p><ol><li>抓取 Systrace，可以用 shell 或者手机自带的工具来抓取</li><li>在 Chrome 中打开 Systrace 文件（html 结尾）,如果不能直接打开，可以在 Chrome 中输入 chrome://tracing/，然后把 Systrace 文件拖到里面就可以打开</li><li>定位 App 进程在 Systrace 中的位置</li><li>定位问题发生点 - 一般以输入事件，比如 input 事件</li><li>分析 App 进程的主线程和渲染线程</li><li>分析 SurfaceFlinger 进程的主线程和 Binder 线程</li><li>分析 SystemServer 进程的 Binder （不涉及可以不用看）</li></ol><p>按照这个流程分析之后，需要再反过来看各个进程，把各个线索联系起来，推断最有可能的原因</p><h2 id="从-Input-事件开始"><a href="#从-Input-事件开始" class="headerlink" title="从 Input 事件开始"></a>从 Input 事件开始</h2><p>这次抓的 Systrace 我只滑动了一次，所以比较好定位，滑动的 input 事件由一个 Input Down 事件 + 若干个 Input Move 事件 + 一个 Input Up 事件组成</p><p>在 Systrace 中，SystemServer 中的 InputDispatcher 和 InputReader 线程都有体现，我们这里主要看在 App 主线程中的体现</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%208.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%208.png"></p><p>如上图，App 主线程上的 deliverInputEvent 标识了应用处理 input 事件的过程，input up 之后，就进入了 Fling 阶段，这部分的基础知识可以查看下面这两篇文章</p><ol><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/</a></li><li><a href="https://www.androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/" target="_blank" rel="noopener">https://www.androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/</a></li></ol><h2 id="分析主线程"><a href="#分析主线程" class="headerlink" title="分析主线程"></a>分析主线程</h2><p>由于这次卡顿主要是松手之后才出现的，所以我们主要看 Input Up 之后的这段</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%209.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%209.png"></p><p>主线程上面的 Frame 有颜色进行标注，一般有绿、黄、红三种颜色，上面的 Systrace 里面，没有红色的帧，只有绿色和黄色。那么黄色就一定是卡顿么？红色就一定是卡顿么？其实不一定，单单通过主线程，我们并不能确定是否卡顿，这个在下面会讲</p><p>从主线程我们没法确定是否发生了卡顿，我们找出了三个可疑的点，接下来我们看一下 RenderThread</p><h2 id="分析渲染线程"><a href="#分析渲染线程" class="headerlink" title="分析渲染线程"></a>分析渲染线程</h2><p>放大第一个可疑点，可以看到，这一帧总耗时在 19ms， RenderThread 耗时16ms，且 RenderThread 的 cpu 状态都是 running（绿色），那么这一帧这么耗时的原因大概率是下面两个原因导致的：</p><ol><li>RenderThread 本身耗时，任务比较繁忙</li><li>RenderThread 的任务受 CPU 影响（可能是频率低了、或者是跑到小核了）</li></ol><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2010.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2010.png"></p><p>由于只是可疑点，所以我们先不去看 cpu 相关的，先查看 SurfaceFlinger 进程，确定这里有卡顿发生</p><h2 id="分析-SurfaceFlinger"><a href="#分析-SurfaceFlinger" class="headerlink" title="分析 SurfaceFlinger"></a>分析 SurfaceFlinger</h2><p>对于 Systrace 中 SurfaceFlinger 部分解读不熟悉的可以先预习一下这篇文章 <a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/</a></p><p>这里我们主要看两个点</p><ol><li>App 对应的 BufferQueue 的 Buffer 情况。通过这个我们可以知道在 SurfaceFlinger 端，App 是否有可用的 Buffer 提供给 SurfaceFlinger 进行合成</li><li>SurfaceFlinger 主线程的合成情况。通过查看 SurfaceFlinger 在 sf-vsync 到来的时候是否进行了合成工作，就可以判断这一帧是否出现了卡顿。</li></ol><p><strong>判断是否卡顿的标准如下</strong></p><ol><li><p>如果 SurfaceFlinger 主线程没有合成任务，而且 App 在这一个 Vsync 周期(vsync-app)进行了正常的工作，<strong>但是对应的 App 的 BufferQueue 里面没有可用的 Buffer，那么说明这一帧卡了 — 卡顿出现</strong><br>这种情况如下图所示（也是上图中第一个疑点所在的位置）</p><p> <img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2011.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2011.png"></p></li><li><p>如果 SurfaceFlinger 进行了合成，而且 App 在这一个 Vsync 周期(vsync-app)进行了正常的工作，<strong>但是对应的 App 的 BufferQueue 里面没有可用的 Buffer，那么这一帧也是卡了</strong>，之所以 SurfaceFlinger 会正常合成，是因为有其他的 App 提供了可用来合成的 Buffer <strong>— 卡顿出现</strong><br>这种情况如下图所示（也在附件的 Systrace 里面）<br><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2012.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2012.png"></p></li><li><p>如果 SurfaceFlinger 进行了合成，而且 App 在这一个 Vsync 周期(vsync-app)进行了正常的工作，而且对应的 App 的 BufferQueue 里面有可用的 Buffer，那么这一帧就会正常合成，此时没有卡顿出现 <strong>— 正常情况</strong><br>正常情况如下，作为对比还是贴上来方便大家对比<br><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2013.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2013.png"></p></li></ol><p>回到本例的第一个疑点的地方，我们通过 SurfaceFlinger 端的分析，发现这一帧确实是掉了，原因是 App 没有准备好可用的 Buffer 供 SurfaceFlinger 来合成，那么接下来就需要看为什么这一帧 App 没有可用的 Buffer 给到 SurfaceFlinger</p><h2 id="回到渲染线程"><a href="#回到渲染线程" class="headerlink" title="回到渲染线程"></a>回到渲染线程</h2><p>上面我们分析这一帧所对应的 MainThread + RenderThread 耗时在 19ms，且 RenderThread 耗时就在 16ms，那么我们来看 RenderThread 的情况</p><p>出现这种情况主要是有下面两个原因</p><ol><li>RenderThread 本身耗时，任务比较繁忙</li><li>RenderThread 的任务受 CPU 影响（可能是频率低了、或者是跑到小核了）</li></ol><p>但是桌面滑动这个场景，负载并不高，且松手之后并没有多余的操作，View 更新之类的，本身耗时比前一帧多了将近 3 倍，可以推断不是自身负载加重导致的耗时</p><p>那么就需要看此时的 RenderThread 的 cpu 情况：</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2014.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2014.png"></p><p>既然在 Running 情况，我们就去 CPU Info 区域查看这一段时间这个任务的调度情况</p><h2 id="分析-CPU-区域的信息"><a href="#分析-CPU-区域的信息" class="headerlink" title="分析 CPU 区域的信息"></a>分析 CPU 区域的信息</h2><p>查看 CPU （Kernel 区域，这部分的基础知识可以查看 <a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Android Systrace 基础知识 - CPU Info 解读</a> 和 <a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Android Systrace 基础知识 – 分析 Systrace 预备知识</a>）这两篇文章</p><p>回到这个案例，我们可以看到 App 对应的 RenderThread 大部分跑在 cpu 2 和 cpu 0 上，也就是小核上（这个机型是高通骁龙 865，有四个小核+3个大核+1个超大核）</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2015.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2015.png"></p><p>其此时对应的频率也已经达到了小核的最高频率（1.8Ghz）</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2016.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2016.png"></p><p>且此时没有 cpu boost 介入</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2017.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2017.png"></p><p>那么这里我们猜想，之所以这一帧 RenderThread 如此耗时，是因为小核就算跑满了，也没法在这么短的时间内完成任务</p><p>那么接下来要验证我们的猜想，需要进行下面两个步骤</p><ol><li>对比其他正常的帧，是否有跑在小核的。如果有且没有出现掉帧，那么说明我们的猜想是错误的</li><li>对比其他几个异常的帧，看看掉帧的原因是否也是因为 RenderThread 任务跑到了小核导致的。如果不是，那么就需要做其他的假设猜想</li></ol><p>在用同样的流程分析了后面几个掉帧之后，我们发现</p><ol><li>对比其他正常的帧，没有在小核跑的，包括掉帧后的下一帧，调度器马上把 RenderThread 摆到了大核，没有出现连续掉帧的情况</li><li>对比其他几个异常的帧，<strong>都是由于 RenderThread 跑到了小核，但是小核的性能不足导致 RenderThread 执行耗时，最终引起卡顿</strong></li></ol><p>至此，这一次的卡顿分析我们就找到了原因：<strong>RenderThread 掉到了小核</strong></p><p>至于 RenderThread 的任务为啥跑着跑着就掉到了小核，这个跟调度器是有关系的，大小核直接的调度跟任务的负载有关系，任务从大核掉到小核、或者从小核迁移到大核，调度器这边都是有参数和算法来控制的，所以后续的优化可能需要从这方面去入手</p><ol><li>调整大小核迁移的阈值参数或者修改调度器算法</li><li>参考竞品表现，看看竞品在这个场景的性能指标，调度情况等，分析竞品可能使用的策略</li></ol><h1 id="Triple-Buffer-在这个场景发挥了什么作用？"><a href="#Triple-Buffer-在这个场景发挥了什么作用？" class="headerlink" title="Triple Buffer 在这个场景发挥了什么作用？"></a>Triple Buffer 在这个场景发挥了什么作用？</h1><p>在 <a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/#Triple-Buffer-%E7%9A%84%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">Triple-Buffer-的作用</a> 这篇文章，讲到了 Triple Buffer 几个作用</p><ol><li>缓解掉帧</li><li>减少主线程和渲染线程等待时间</li><li>降低 GPU 和 SurfaceFlinger 瓶颈</li></ol><p>那么在桌面滑动卡顿这个案例里面，Triple Buffer 发挥了什么作用呢？结论是：有的场景没有发挥作用，反而有副作用，导致卡顿现象更明显，下面是分析流程</p><p>可以看文章中 Triple Buffer <strong>缓解掉帧</strong> 的原理：</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2018.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2018.png"></p><p>在分析小米桌面滑动卡顿这个案例的时候，我发现在有一个问题，小米桌面对应的 App 的 BufferQueue，有时候会出现可用 Buffer 从 2 →0 ，这相当于直接把一个 Buffer 给抛弃掉了，如下图所示</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2019.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2019.png"></p><p>这样的话，如果在后续的桌面 Fling 过程中，又出现了一次 RenderThread 耗时，那么就会以卡顿的形式直接体现出来，这样也就失去了 Triple Buffer 的<strong>缓解掉帧</strong>的作用了</p><p>下图可以看到，由于丢弃了一个 Buffer，导致再一次出现 RenderThread 耗时的时候，表现依然是无 Buffer 可用，出现掉帧</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2020.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2020.png"></p><p>仔细看前面这段丢弃 Buffer 的逻辑，也很容易想到，这里本身就已经丢了一帧了，还把这个耗时帧所对应的 Buffer 给丢弃了（也可能丢弃的是第二帧），不管是哪种情况，滑动时候的每一帧的内容都是计算好的（参考 List Fling 的计算过程），如果把其中一帧丢了，再加上本身 SurfaceFlinger 卡的那一下，卡顿感会非常明显</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2021.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%2021.png"></p><p>举个例子,以滑动为例，offset 指的是离屏幕一个左边的距离</p><ol><li>正常情况下，滑动的时候，offset 是：<code>2→4→6→8→10→12</code> </li><li>掉了一帧的情况下，滑动的 Offset 是：<code>2→4→6→6→8→10→12</code> （假设 计算 8 的这一帧超时了，就会看到两个 6 ，这是掉了一帧的情况）</li><li>像上图里面，如果直接扔掉了那个耗时的帧，就会出现下面这种 Offset：<code>2→4→6→6→10→12</code> ，直接从 6 跳到了 10，相当于卡了1次，步子扯大了一次，感官上会觉得<strong>卡+跳跃</strong></li></ol><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附件已经上传到了 Github 上，可以自行下载：<a href="https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_Smooth_In_Action" target="_blank" rel="noopener">https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_Smooth_In_Action</a></p><ol><li>xiaomi_launcher.zip : 桌面滑动卡顿的 Systrace 文件，这次案例主要是分析这个 Systrace 文件</li><li>xiaomi_launcher_scroll_all_the_time.zip : 桌面一直按着滑动的 Systrace 文件</li><li>oppo_launcher_scroll.zip ：对比文件</li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 流畅性 </tag>
            
            <tag> 体验优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Systrace 流畅性实战 1 ：了解卡顿原理</title>
      <link href="/2021/04/24/android-systrace-smooth-in-action-1/"/>
      <url>/2021/04/24/android-systrace-smooth-in-action-1/</url>
      
        <content type="html"><![CDATA[<p>当我们说 <strong>流畅度</strong> 的时候，我们说的是什么？不同的人对流畅性(卡顿掉帧)有不同的理解，对卡顿阈值也有不同的感知，所以有必要在开始这个系列文章之前，先把涉及到的内容说清楚，防止出现不同的理解，也方便大家带着问题去看这几篇问题，下面是一些基本的说明</p><ol><li>对手机用户来说，卡顿包含了很多场景，比如在 <strong>滑动列表的时候掉帧</strong>、<strong>应用启动白屏过长</strong>、<strong>点击电源键亮屏慢</strong>、<strong>界面操作没有反应然后闪退</strong>、<strong>点击图标没有响应</strong>、<strong>窗口动画不连贯、滑动不跟手、重启手机进入桌面卡顿</strong> 等场景，这些场景跟我们开发人员所理解的卡顿还有点不一样，开发人员会更加细分去分析这些问题，这是开发人员和用户之间的一个认知差异，这一点在处理用户(或者测试人员)的问题反馈的时候尤其需要注意</li><li>对开发人员来说，上面的场景包括了 <strong>流畅度</strong>（滑动列表的时候掉帧、窗口动画不连贯、重启手机进入桌面卡顿）、<strong>响应速度</strong>（应用启动白屏过长、点击电源键亮屏慢、滑动不跟手）、<strong>稳定性</strong>（界面操作没有反应然后闪退、点击图标没有响应）这三个大的分类。之所以这么分类，是因为每一种分类都有不太一样的分析方法和步骤，快速分辨问题是属于哪一类很重要</li><li>在技术上来说，<strong>流畅度、响应速度、稳定性</strong>（ANR）这三类之所以用户感知都是卡顿，是因为这三类问题产生的原理是一致的，都是由于主线程的 Message 在执行任务的时候超时，根据不同的超时阈值来进行划分而已，所以要理解这些问题，需要对系统的一些基本的运行机制有一定的了解，本文会介绍一些基本的运行机制</li><li>流畅性这个系列主要是分析流畅度相关的问题，响应速度和稳定性会有专门的文章介绍，在理解了流畅性相关的内容之后，再去分析响应速度和稳定性问题会事半功倍</li><li>流畅性这个系列主要是讲如何使用 Systrace (Perfetto) 工具去分析，之所以 Systrace 为切入点，是因为影响流畅度的因素很多，有 App 自身的原因、也有系统的原因。而  (Perfetto)  工具可以从一个整机运行的角度来展示问题发生的过程，方便我们去初步定位问题<a id="more"></a></li></ol><p>Systrace 流畅性实战目前包括下面三篇</p><ol><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><p>Systrace (Perfetto) 工具的基本使用如果还不是很熟悉，那么需要优先去补一下 <a href="https://www.androidperformance.com/2019/05/26/Android_Systrace_0/" target="_blank" rel="noopener">Systrace 基础知识系列</a></p><h1 id="了解卡顿原理"><a href="#了解卡顿原理" class="headerlink" title="了解卡顿原理"></a>了解卡顿原理</h1><h2 id="卡顿现象及影响"><a href="#卡顿现象及影响" class="headerlink" title="卡顿现象及影响"></a>卡顿现象及影响</h2><p>如文章开头所述，本文主要是分析流畅度相关的问题。流畅度是一个定义，我们评价一个场景的流畅度的时候，往往会使用 fps 来表示。比如 60 fps，意思是每秒画面更新 60 次；120  fps，意思是每秒画面更新 120 次。如果 120 fps 的情况下，每秒画面只更新了 110 次(连续动画的过程)，这种情况我们就称之为<strong>掉帧</strong>，其表现就是<strong>卡顿</strong>，fps 对应的也从 120 降低到了 110 ，这些都可以被精确地监控到</p><p>同时掉帧帧的原因非常多，有 APP 本身的问题，有系统原因导致卡顿的，也有硬件层的、整机卡的，这个可以参考下面四篇文章</p><ol><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 方法论</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 应用篇</a></li><li><a href="https://www.androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 低内存篇</a></li></ol><p>用户在使用手机的过程中，卡顿是最容易被感受到的</p><ol><li>偶尔出现的小卡顿会降低用户的使用体验，比如刷微博的时候卡了一下，比如返回桌面动画卡顿这种</li><li>整机出现卡顿的则会让手机无法使用</li><li>现在的高帧率时代，如果用户习惯了 120 fps ，在用户比较容易感知的场景下突然切换到 60 fps，用户也会有明显的感知，并觉得出现了卡顿</li></ol><p>所以不管是应用还是系统，都应该尽量避免出现卡顿，发现的卡顿问题最好优先进行解决</p><h2 id="卡顿定义"><a href="#卡顿定义" class="headerlink" title="卡顿定义"></a>卡顿定义</h2><h3 id="应用一帧渲染的整体流程"><a href="#应用一帧渲染的整体流程" class="headerlink" title="应用一帧渲染的整体流程"></a>应用一帧渲染的整体流程</h3><p>为了知道卡顿是如何发生的，我们需要知道应用主线程的一帧是如何工作的</p><h3 id="从执行顺序的角度来看"><a href="#从执行顺序的角度来看" class="headerlink" title="从执行顺序的角度来看"></a>从执行顺序的角度来看</h3><p>从 Choreographer 收到 Vsync 开始，到 SurfaceFlinger/HWC 合成一帧结束（后面还包含屏幕显示部分，不过是硬件相关，这里就不列出来了）</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled.png"></p><h3 id="从-Systrace-的角度来看"><a href="#从-Systrace-的角度来看" class="headerlink" title="从 Systrace 的角度来看"></a>从 Systrace 的角度来看</h3><p>上面的流程图从 Systrace （Perfetto）的角度来看会更加直观</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%201.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%201.png"></p><p>具体的流程参考上面两个图以及代码就会很清楚了，上述整体流程中，任何一个步骤超时都有可能导致卡顿，所以分析卡顿问题，需要从多个层面来进行分析，比如应用主线程、渲染线程、SystemServer 进程、SurfaceFlinger 进程、Linux 区域等</p><h2 id="卡顿定义-1"><a href="#卡顿定义-1" class="headerlink" title="卡顿定义"></a>卡顿定义</h2><p>我对卡顿的定义是：<strong>稳定帧率输出的画面出现几帧没有绘制 。</strong>对应的应用单词是 <strong>Smooth</strong> VS <strong>Jank</strong></p><p>比如下图中，App 主线程有在正常绘制的时候（通常是做动画或者列表滑动），有一帧没有绘制，那么我们认为这一帧有可能会导致卡顿（这里说的是有可能，由于 Triple Buffer 的存在，这里也有可能不掉帧）</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%202.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%202.png"></p><p>下面从三个方面定义卡顿</p><ol><li><strong>从现象上来说，在 App 连续的动画播放或者手指滑动列表时（关键是连续），如果连续 2 帧或者 2 帧以上，应用的画面都没有变化，那么我们认为这里发生了卡顿</strong></li><li><strong>从 SurfaceFlinger 的角度来说，在 App 连续的动画播放或者手指滑动列表时（关键是连续），如果有一个 Vsync 到来的时候 ，App 没有可以用来合成的 Buffer，那么这个 Vsync 周期 SurfaceFlinger 就不会走合成的逻辑（或者是去合成其他的 Layer），那么这一帧就会显示 App 的上一帧的画面，我们认为这里发生了卡顿</strong></li><li><strong>从 App 的角度来看，如果渲染线程在一个 Vsync 周期内没有 queueBuffer 到 SurfaceFlinger 中 App 对应的 BufferQueue 中，那么我们认为这里发生了卡顿</strong></li></ol><p>这里没有提到应用主线程，是因为主线程耗时长一般会间接导致渲染线程出现延迟，加大渲染线程执行超时的风险，从而引起卡顿；而且应用导致的卡顿原因里面，大部分都是主线程耗时过长导致的</p><p>卡顿还要区分是不是<strong>逻辑卡顿</strong>，<strong>逻辑卡顿</strong>指的是一帧的渲染流程都是没有问题的，也有对应的 Buffer 给到 SurfaceFlinger 去合成，但是这个 App Buffer 的内容和上一帧 App Buffer 相同（或者基本相同，肉眼无法分辨），那么用户看来就是连续两帧显示了相同的内容。这里一般来说我们也认为是发生了卡顿（不过还要区分具体的情况）；<strong>逻辑卡顿主要是应用自身的代码逻辑造成的</strong></p><h1 id="系统运行机制简介"><a href="#系统运行机制简介" class="headerlink" title="系统运行机制简介"></a>系统运行机制简介</h1><p>由于卡顿的原因比较多，如果要分析卡顿问题，首先得对 Android 系统运行的机制有一定的了解，下面简单介绍一下分析卡顿问题需要了解的系统运行机制：</p><ol><li>App 主线程运行原理</li><li>Message、Handler、MessageQueue、Looper 机制</li><li>屏幕刷新机制和 Vsync</li><li>Choreogrepher 机制</li><li>Buffer 流程和 TripleBuffer</li><li>Input 流程</li></ol><h2 id="系统机制-App-主线程运行原理"><a href="#系统机制-App-主线程运行原理" class="headerlink" title="系统机制 - App 主线程运行原理"></a>系统机制 - App 主线程运行原理</h2><p>App 进程在创建的时候，Fork 完成后会调用 ActivityThread 的 main 方法，进行主线程的初始化工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ......</span><br><span class="line">     <span class="comment">// 创建 Looper、Handler、MessageQueue</span></span><br><span class="line">       Looper.prepareMainLooper();</span><br><span class="line">       ......</span><br><span class="line">       ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">       thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           sMainThreadHandler = thread.getHandler();</span><br><span class="line">      &#125;</span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">// 开始准备接收消息</span></span><br><span class="line">       Looper.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备主线程的 Looper</span></span><br><span class="line">frameworks/base/core/java/android/os/Looper.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prepare 方法中会创建一个 Looper 对象</span></span><br><span class="line">frameworks/base/core/java/android/os/Looper.java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Looper 对象创建的时候，同时创建一个 MessageQueue</span></span><br><span class="line">frameworks/base/core/java/android/os/Looper.java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程初始化完成后，主线程就有了完整的 Looper、MessageQueue、Handler，此时 ActivityThread 的 Handler 就可以开始处理 Message，包括 Application、Activity、ContentProvider、Service、Broadcast 等组件的生命周期函数，都会以 Message 的形式，在主线程按照顺序处理，这就是 App 主线程的初始化和运行原理，部分处理的 Message 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_APPLICATION        = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_APPLICATION        = <span class="number">111</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVER                = <span class="number">113</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATE_SERVICE          = <span class="number">114</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_ARGS            = <span class="number">115</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP_SERVICE            = <span class="number">116</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"bindApplication"</span>);</span><br><span class="line">                AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                handleBindApplication(data);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统机制-Message-机制"><a href="#系统机制-Message-机制" class="headerlink" title="系统机制 - Message 机制"></a>系统机制 - Message 机制</h2><p>上一节应用的主线程初始化完成后，主线程就进入阻塞状态，等待 Message，一旦有 Message 发过来，主线程就会被唤醒，处理 Message，处理完成之后，如果没有其他的 Message 需要处理，那么主线程就会进入休眠阻塞状态继续等待</p><p>从下图可以看到 ，Android Message 机制的核心就是四个：<strong>Handler</strong>、<strong>Looper</strong>、<strong>MessageQueue</strong>、<strong>Message</strong></p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%203.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%203.png"></p><p>网上有很多关于 Message 机制代码细节的分析，所以这里只是简单介绍 Message 机制的四个核心组件的作用</p><ol><li><strong>Handler</strong> : Handler 主要是用来处理 Message，应用可以在任何线程创建 Handler，只要在创建的时候指定对应的 Looper 即可，如果不指定，默认是在当前 Thread 对应的 Looper</li><li><strong>Looper :</strong> Looper 可以看成是一个循环器，其 loop 方法开启后，不断地从 MessageQueue 中获取 Message，对 Message 进行 Delivery 和 Dispatch，最终发给对应的 Handler 去处理。由于 Looper 中应用可以在 Message 处理前后插入自己的 printer，所以很多 APM 工具都会使用这个作为性能监控的一个切入点，具体可以参考 Tencent-Matrix 和 BlockCanary</li><li><strong>MessageQueue</strong>：MessageQueue 入上图所示，就是一个 Message 管理器，队列中是 Message，在没有 Message 的时候，MessageQueue 借助 Linux 的 nativePoll 机制，阻塞等待，直到有 Message 进入队列</li><li><strong>Message</strong>：Message 是传递消息的对象，其内部包含了要传递的内容，最常用的包括 what、arg、callback 等</li></ol><p>从第一节 App 主线程运行原理可知，ActivityThread 的就是利用 Message 机制，处理 App 各个生命周期和组件各个生命周期的函数</p><h2 id="系统机制-屏幕刷新机制-和-Vsync"><a href="#系统机制-屏幕刷新机制-和-Vsync" class="headerlink" title="系统机制 - 屏幕刷新机制 和 Vsync"></a>系统机制 - 屏幕刷新机制 和 Vsync</h2><p>首先我们需要知道什么是<strong>屏幕刷新率</strong>，简单来说，屏幕刷新率是一个硬件的概念，是说屏幕这个硬件刷新画面的频率：举例来说，60Hz 刷新率意思是：这个屏幕在 1 秒内，会刷新显示内容 60 次；那么对应的，90Hz 是说在 1 秒内刷新显示内容 90 次</p><p>与屏幕刷新率对应的，<strong>FPS</strong> 是一个软件的概念，与屏幕刷新率这个硬件概念要区分开，FPS 是由软件系统决定的 ：FPS 是 Frame Per Second 的缩写，意思是每秒产生画面的个数。举例来说，60FPS 指的是每秒产生 60 个画面；90FPS 指的是每秒产生 90 个画面</p><p>VSync 是垂直同期( Vertical Synchronization )的简称。基本的思路是将你的 FPS 和显示器的刷新率同期起来。其目的是避免一种称之为”撕裂”的现象.</p><ol><li>60 fps 的系统 , 1s 内需要生成 60 个可供显示的 Frame , 也就是说绘制一帧需要 16.67ms ( 1/60 ) , 才会不掉帧 ( FrameMiss ).</li><li>90 fps 的系统 , 1s 内生成 90 个可供显示的 Frame , 也就是说绘制一帧需要 11.11ms ( 1/90 ) , 才不会掉帧 ( FrameMiss ).</li></ol><p>一般来说，屏幕刷新率是由屏幕控制的，FPS 则是由 Vsync 来控制的，在实际的使用场景里面，屏幕刷新率和 FPS 一般都是一一对应的，具体可以参考下面两篇文章：</p><ol><li><a href="https://androidperformance.com/2019/05/15/90hz-on-android/">Android 新的流畅体验，90Hz 漫谈</a></li><li><a href="https://androidperformance.com/2019/12/01/Android-Systrace-Vsync/">Android Systrace 基础知识 - Vsync 解读</a></li></ol><h2 id="系统机制-Choreographer"><a href="#系统机制-Choreographer" class="headerlink" title="系统机制 - Choreographer"></a>系统机制 - Choreographer</h2><p>上一节讲到 Vsync 控制 FPS，其实 Vsync 是通过 Choreographer 来控制应用刷新的频率的</p><p>Choreographer 的引入，主要是配合 Vsync，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对 Vsync 信号周期的调整，来控制每一帧绘制操作的时机. 至于为什么 Vsync 周期选择是 16.6ms (60 fps) ，是因为目前大部分手机的屏幕都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每隔 16.6 ms，Vsync 信号到来唤醒 Choreographer 来做 App 的绘制操作 ，如果每个 Vsync 周期应用都能渲染完成，那么应用的 fps 就是 60，给用户的感觉就是非常流畅，这就是引入 Choreographer 的主要作用</p><p>Choreographer 扮演 Android 渲染链路中承上启下的角色</p><ol><li>承上：负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等</li><li>启下：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync) .</li></ol><p>下图就是 Vsync 信号到来的时候，Choreographer 借助 Message 机制开始一帧的绘制工作流程图</p><p>这部分详细的流程可以看 <a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Android 基于 Choreographer 的渲染机制详解</a> 这篇文章</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%204.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%204.png"></p><h2 id="系统机制-Buffer-流程和-TripleBuffer"><a href="#系统机制-Buffer-流程和-TripleBuffer" class="headerlink" title="系统机制 - Buffer 流程和 TripleBuffer"></a>系统机制 - Buffer 流程和 TripleBuffer</h2><p>BufferQueue 是一个生产者(Producer)-消费者(Consumer)模型中的数据结构，一般来说，消费者(Consumer) 创建 BufferQueue，而生产者(Producer) 一般不和 BufferQueue 在同一个进程里面</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%205.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%205.png"></p><p>在 Android App 的渲染流程里面，App 就是个生产者(Producer) ，而 SurfaceFlinger 是一个消费者(Consumer)，所以上面的流程就可以翻译为</p><ol><li>当 App 需要 Buffer 时，它通过调用 dequeueBuffer（）并指定 Buffer 的宽度，高度，像素格式和使用标志，从 BufferQueue 请求释放 Buffer</li><li>App 可以用 cpu 进行渲染也可以调用用 gpu 来进行渲染，渲染完成后，通过调用 queueBuffer（）将缓冲区返回到 App 对应的 BufferQueue(如果是 gpu 渲染的话，这里还有个 gpu 处理的过程，所以这个 Buffer 不会马上可用，需要等 GPU 渲染完成)</li><li>SurfaceFlinger 在收到 Vsync 信号之后，开始准备合成，使用 acquireBuffer（）获取 App 对应的 BufferQueue 中的 Buffer 并进行合成操作</li><li>合成结束后，SurfaceFlinger 将通过调用 releaseBuffer（）将 Buffer 返回到 App 对应的 BufferQueue</li></ol><p>知道了 Buffer 流转的过程，下面需要说明的是，在目前的大部分系统上，每个应用都有三个 Buffer 轮转使用，来减少由于 Buffer 在某个流程耗时过长导致应用无 Buffer 可用而出现卡顿情况</p><p>下图是双 Buffer 和 三 Buffer 的一个对比图</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%206.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%206.png"></p><p>三 Buffer 的好处如下</p><ol><li><strong>缓解掉帧</strong> :从上图 Double Buffer 和 Triple Buffer 的对比图可以看到，在这种情况下（出现连续主线程超时），三个 Buffer 的轮转有助于缓解掉帧出现的次数（从掉帧两次 -&gt; 只掉帧一次）。，App 主线程超时不一定会导致掉帧，由于 Triple Buffer 的存在，部分 App 端的掉帧(主要是由于 GPU 导致)，到 SurfaceFlinger 这里未必是掉帧，这是看 Systrace 的时候需要注意的一个点</li><li><strong>减少主线程和渲染线程等待时间</strong> ：双 Buffer 的轮转，App 主线程有时候必须要等待 SurfaceFlinger(消费者)释放 Buffer 后，才能获取 Buffer 进行生产，这时候就有个问题，现在大部分手机 SurfaceFlinger 和 App 同时收到 Vsync 信号，如果出现 App 主线程等待 SurfaceFlinger(消费者)释放 Buffer，那么势必会让 App 主线程的执行时间延后</li><li><strong>降低 GPU 和 SurfaceFlinger 瓶颈</strong> ：这个比较好理解，双 Buffer 的时候，App 生产的 Buffer 必须要及时拿去让 GPU 进行渲染，然后 SurfaceFlinger 才能进行合成，一旦 GPU 超时，就很容易出现 SurfaceFlinger 无法及时合成而导致掉帧；在三个 Buffer 轮转的时候，App 生产的 Buffer 可以及早进入 BufferQueue，让 GPU 去进行渲染（因为不需要等待，就算这里积累了 2 个 Buffer，下下一帧才去合成，这里也会提早进行，而不是在真正使用之前去匆忙让 GPU 去渲染），另外 SurfaceFlinger 本身的负载如果比较大，三个 Buffer 轮转也会有效降低 dequeueBuffer 的等待时间</li></ol><p>坏处就是 Buffer 多了会占用内存</p><p>这部分详细的流程可以看 <a href="https://androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/">Android Systrace 基础知识 - Triple Buffer 解读</a> 这篇文章</p><h2 id="系统机制-Input-流程"><a href="#系统机制-Input-流程" class="headerlink" title="系统机制 - Input 流程"></a>系统机制 - Input 流程</h2><p>Android 系统是由事件驱动的，而 input 是最常见的事件之一，用户的点击、滑动、长按等操作，都属于 input 事件驱动，其中的核心就是 InputReader 和 InputDispatcher。InputReader 和 InputDispatcher 是跑在 SystemServer 里面的两个 Native 线程，负责读取和分发 Input 事件，我们分析 Systrace 的 Input 事件流，首先是找到这里。</p><ol><li>InputReader 负责从 EventHub 里面把 Input 事件读取出来，然后交给 InputDispatcher 进行事件分发</li><li>InputDispatcher 在拿到 InputReader 获取的事件之后，对事件进行包装和分发 (也就是发给对应的)</li><li>OutboundQueue 里面放的是即将要被派发给对应 AppConnection 的事件</li><li>WaitQueue 里面记录的是已经派发给 AppConnection 但是 App 还在处理没有返回处理成功的事件</li><li>PendingInputEventQueue 里面记录的是 App 需要处理的 Input 事件，这里可以看到已经到了应用进程</li><li>deliverInputEvent 标识 App UI Thread 被 Input 事件唤醒</li><li>InputResponse 标识 Input 事件区域，这里可以看到一个 Input_Down 事件 + 若干个 Input_Move 事件 + 一个 Input_Up 事件的处理阶段都被算到了这里</li><li>App 响应 Input 事件 ： 这里是滑动然后松手，也就是我们熟悉的桌面滑动的操作，桌面随着手指的滑动更新画面，松手后触发 Fling 继续滑动，从 Systrace 就可以看到整个事件的流程</li></ol><p>上面流程对应的 Systrace 如下</p><p><img src="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%207.png" alt="/images/Systrace-Smooth%20e5d284a979a447ad8b45ff021d6e41cf/Untitled%207.png"></p><p>这部分详细的流程可以看 <a href="https://androidperformance.com/2019/11/04/Android-Systrace-Input/">Android Systrace 基础知识 - Input 解读</a> 这篇文章</p><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附件已经上传到了 Github 上，可以自行下载：<a href="https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_Smooth_In_Action" target="_blank" rel="noopener">https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_Smooth_In_Action</a></p><ol><li>xiaomi_launcher.zip : 桌面滑动卡顿的 Systrace 文件，这次案例主要是分析这个 Systrace 文件</li><li>xiaomi_launcher_scroll_all_the_time.zip : 桌面一直按着滑动的 Systrace 文件</li><li>oppo_launcher_scroll.zip ：对比文件</li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 流畅性 </tag>
            
            <tag> 体验优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为手机刷微博体验更好？技术角度的一些分析和思考</title>
      <link href="/2020/08/20/weibo-imageload-opt-on-huawei/"/>
      <url>/2020/08/20/weibo-imageload-opt-on-huawei/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>技术群里的小伙伴发了一条微博， <a href="https://weibo.com/1808884742/IApbpEVQr" target="_blank" rel="noopener">https://weibo.com/1808884742/IApbpEVQr</a>， 博主 @王波粒 发现， Mate 30 Pro 有个很特别的现象（建议先去看一下视频） </p><p><img src="/images/15979019506115.jpg" alt=""></p><p>这个视频描述和底下的猜测都不对，我这边总结一下这个现象： <strong>微博这个 App 在华为的手机上，在主页列表上下滑动的情况下依然可以流畅加载图片，而同一个版本的微博客户端，安装到其他手机上，在主页列表上下滑动的情况下，则必须要等到滑动停止之后才会加载图片</strong> </p><p><strong>这个现象有什么特别呢 ？</strong> </p><ol><li>从技术上讲，滑动列表停止后再加载图片是目前列表滑动优化中一个比较常见的优化项，很多主流 App 也都是这么做的 ，做这种处理主要是因为 <strong>如果在列表滑动的时候，碰到图片视频就加载，那么会加载很多无用的图片&amp;&amp;视频，浪费资源不说，还可能会影响真正用户看到的图片的加载速度</strong> （加载一般都有并行上限和队列，队列里面无效的图片太多，后来的图片就得排队等待）。 这里比较 <strong>特别的就是同一个版本的微博 APK，在华为的机型上与在其他机型上表现不一致，作为一个系统优化工程师，这个还是值得去搞清楚的（大胆猜测是微博针对华为的机型做了优化），那么这个优化的内容是什么？</strong> </li><li>从用户体验的角度来讲，列表滑动的同时加载图片，用户可以更早地看到图片，减少图片占位白图的显示时间，可以提升滑动的体验 </li><li>第三个现象就得认真体验才会感觉到： <strong>华为手机上的微博在松手后的滑动曲线和其他手机上的微博在松手后的滑动曲线是不一样的，华为的微博列表松手后的滑动曲线速度更慢，更柔和，结束的时候也不会太突兀，与系统默认的列表滑动曲线明显不一样</strong> </li></ol><p>上面三个是从现象上来说的，下面就从技术上来验证，从最后的结果来看，华为和微博的合作毫无疑问是很成功的，可以作为一个案例推广到其他头部 App，同时作为 Android 开发者，对华为这种非常细致的体验优化真的是非常敬佩 </p><h2 id="背景备注"><a href="#背景备注" class="headerlink" title="背景备注"></a>背景备注</h2><ol><li><strong>由于 “列表滑动的同时加载图片” 这个功能由微博官方服务器控制，可以随时开启或者关闭，所以文章中所说的 “同一个版本的微博客户端，安装到其他手机上，在主页列表上下滑动的情况下，则必须要等到滑动停止之后才会加载图片” 这个现象在 “列表滑动的同时加载图片” 这个功能开启后，现象就会变成 “主页列表上下滑动的时候就会加载图片”</strong> </li><li><strong>在 2020-6 月左右分析这个问题的时候，“列表滑动的同时加载图片” 这个功能还是关闭的，只有华为手机做了优化才有效果，其他手机是 “滑动停止之后才会加载图片”</strong> </li><li><strong>在 2020-8 月再看这个问题的时候，“列表滑动的同时加载图片” 这个功能在其他手机上已经开启</strong> </li><li><strong>华为的 PerfSDK 还有效果么？答案是有，具体分析可以看下文，因为有了这个 SDK，不仅对微博有好处(减少图片加载个数)，对华为也有好处(提升微博主页列表在华为手机上的滑动体验，即 Fling 曲线优化) ；而粗暴开启 “列表滑动的同时加载图片” 的其他手机，如果性能不足，开启后反而会增加卡顿出现的概率(微博官方应该有性能监控数据可以看到)</strong> </li><li><strong>反编译的微博版本：10.8.1</strong> </li></ol><h2 id="结论先行"><a href="#结论先行" class="headerlink" title="结论先行"></a>结论先行</h2><p><strong>‘’微博这个 App 在华为的手机上，在主页列表上下滑动的情况下依然可以流畅加载图片 ‘’这个现象是因为华为和微博做了联合优化，主要是为了优化微博列表滑动时候的用户体验，其优化点如下</strong> </p><ol><li>华为提供了一个简单的接口打包成 SDK 提供给微博，这个接口可以让微博的列表监听到列表的当前速度（Velocity），在速度高于阈值或者低于阈值的时候，都会及时通知 App </li><li>微博拿到这个速度回调之后，就可以根据列表的滑动速度来决定是否要在滑动过程中加载图片，一旦列表的滑动速度低于设定的阈值，就开启图片加载；一旦列表的滑动速度高于设定的阈值，就关闭图片加载 </li><li>华为检测到这个应用使用了 SDK，就可以将优化过后的滑动曲线应用在这个 App 的列表 Fling 阶段，提升用户体验 </li></ol><p>对细节感兴趣的同学可以继续阅读，有能力的同学看完后可以修改 Framework 相关代码，编译一个 SDK，然后自己写个 Demo 接入 SDK，就可以打通我下面所说的所有内容了，我自己在 AOSP 的代码上实现了一遍，Demo 也可以正常运行，有兴趣可以跟我私下交流 </p><h1 id="微博-华为是怎么优化？"><a href="#微博-华为是怎么优化？" class="headerlink" title="微博+华为是怎么优化？"></a>微博+华为是怎么优化？</h1><h2 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h2><p>我们在滑动微博列表的时候，一个滑动操作主要由下面三部分组成 </p><ol><li>手指接触屏幕，上下滑动微博主页列表，但是手指 <strong>没有离开屏幕</strong> ，这个阶段我们称之为阶段一，技术术语为 SCROLL_STATE_TOUCH_SCROLL </li><li>手指上下滑动的时候 <strong>离开屏幕</strong> (必须有一个上滑或者下滑的速度)，微博列表有了一个惯性，根据惯性的方向继续滑动，这个阶段我们称之为阶段二，技术术语为 SCROLL_STATE_FLING </li><li>列表惯性滑动后停止，这 个 阶段我们称之为阶段三 ， 技术术语为  SCROLL_STATE_I DLE </li></ol><p>而华为和微博的优化主要在阶段一和阶段二 </p><h3 id="阶段一优化"><a href="#阶段一优化" class="headerlink" title="阶段一优化"></a>阶段一优化</h3><ol><li>优化前：只要手指不离开屏幕，图片加载功能关闭 </li><li>优化后：只要手指不离开屏幕，列表就不会滑动太快，这时候图片加载功能开启 </li></ol><h3 id="阶段二优化"><a href="#阶段二优化" class="headerlink" title="阶段二优化"></a>阶段二优化</h3><ol><li><strong>滑动图片加载优化</strong> <ol><li>优化前：只要列表滑动不停止，图片加载功能关闭 </li><li>优化后：图片加载功能是否开启取决于当前列表滑动的速度 <ol><li>列表滑动速度太快，这时候图片加载功能关闭 </li><li>列表滑动速度掉落到一个阈值，图片加载功能开启 </li></ol></li></ol></li><li><strong>列表 Fling 曲线优化</strong> <ol><li>优化前：列表滑动的曲线是默认值，滑动时间比较短，停止的时候比较突兀，不柔和 </li><li>优化后：列表滑动的曲线是华为经过优化的，滑动时间比较长，停止的时候比较柔，不突兀，比较接近 iPhone 的列表滑动曲线 </li></ol></li></ol><h2 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h2><p>技术分析的代码主要来源于微博 apk 的反编译，微博版本 10.8.1，通过反编译的代码可以看到， <strong>微博主页在初始化的时候，会接入华为提供的 PerfSDK，从而获得监听列表滑动速度的能力</strong> </p><h3 id="阶段一优化的技术分析"><a href="#阶段一优化的技术分析" class="headerlink" title="阶段一优化的技术分析"></a>阶段一优化的技术分析</h3><p>列表的 ScrollStateChange 是标识列表状态的一个回调，微博在 ScrollStateChange 这个回调中会根据当前的状态来决定是否加载图片， 从下面的代码逻辑来看 </p><ol><li>当 <strong>滑动图片加载优化生效</strong> 的时候，如果 State != 2，那么就允许 ImageLoader 加载图片，State 为 2 也就是 SCROLL_STATE_FLING，熟悉列表滑动的同学应该知道，SCROLL_STATE_FLING  就是 <strong>滑动列表的时候手指松手后列表继续滑动的那一段</strong> ，叫 fling，毕竟只有 fling 的时候才有 Velocity，松手后会根据这个值的大小计算滑动曲线和滑动时长 </li><li>当 <strong>滑动图片加载优化不生效</strong> 的时候，就到了常规的列表滑动优化：即列表停止之后才开始加载图片 ：State !=0，0 即 SCROLL_STATE_IDLE </li></ol><p><img src="/images/15979019763546.jpg" alt=""></p><h3 id="阶段二优化的技术分析"><a href="#阶段二优化的技术分析" class="headerlink" title="阶段二优化的技术分析"></a>阶段二优化的技术分析</h3><p>微博的主页在初始化的时候，会给首页的 ListView 注册一个 HwPerfVelocityCallback，从名字可以看出来，这个回调是监听 Velocity 的，也就是滑动的速度，两个回调： </p><ol><li>HwPerfonVelocityDownToThreshold : 当速度降低到阈值之后，打开 ImageLoader 的图片加载功能 </li><li>HwPerfonVelocityUpToThreshold： 当速度升高到阈值之后，关闭 ImageLoader 的图片加载功能 </li></ol><p>下图为反编译后的源码 </p><p><img src="/images/15979019932037.jpg" alt=""></p><p>至于滑动曲线，则需要查看华为的 Framework 的代码，由于代码量比较大，这里只贴一下 OverScroller.java 中的 update 方法，具体感兴趣的可以自己去翻一番华为的 Framework 代码<br><img src="/images/15979020033894.jpg" alt=""></p><p>计算 Distance 的代码 </p><p><img src="/images/15979020127885.jpg" alt=""></p><p>计算 Velocity 的代码 </p><p><img src="/images/15979020218054.jpg" alt=""></p><p>关于滑动曲线的解释，大家可以看这一篇知乎回答，其中对比了 iOS 和 Android 的滑动曲线的不同 ：<a href="https://www.zhihu.com/question/291779390/answer/484881732" target="_blank" rel="noopener">为什么 iOS 的过渡动画看起来很舒服？</a></p><h2 id="其他厂商处理"><a href="#其他厂商处理" class="headerlink" title="其他厂商处理"></a>其他厂商处理</h2><p>上面图中代码最后一段还有一个判断开关， 如果 boolean a = HwPerfUtil.m14290a 这个返回的是 false，这就是说有可能华为这个优化关闭了，有可能是非华为机器，那么会 <strong>判断 Android 版本号和全局 Feature 开关</strong> </p><p><img src="/images/15979020689139.jpg" alt=""></p><p>对应的 FeedAbManager 就是一个 Feature 管理器，可以在线开关某些 Feature<br><img src="/images/15979020809489.jpg" alt=""></p><p>而 m52580k 的实现如下 </p><p><img src="/images/15979020905125.jpg" alt=""></p><p>可以看到这里还受到一个全局的 Feature 配置：feed_scroll_loadimage_enable，这个 Feature 是服务端可以配置的<br><img src="/images/15979021040883.jpg" alt=""></p><p>这里就是处理其他厂商的逻辑 </p><h1 id="最后一个问题：滑动点击"><a href="#最后一个问题：滑动点击" class="headerlink" title="最后一个问题：滑动点击"></a>最后一个问题：滑动点击</h1><p>滑动点击是个什么问题呢？列表在滑动的过程中，如果用户点击列表的某一个 Item，那么根据 Android 的事件分发机制，这时候列表的 Item 并不会被点击到，而是整个列表先收到点击事件，然后 <strong>触发列表滑动停止；列表停止的时候点击 Item 才会触发 Item 的点击</strong> </p><p>上面阶段二的优化中，在优化了滑动曲线之后，列表处于 Fling 状态的时间变长，如果用户想点击去某一个 Item 查看详情，那么需要先点击一下让列表停止，然后再点击一下才能进去，这就是这一节想说的 ：滑动点击问题 </p><p>滑动(Fling 状态)和点击其实是需要一个平衡的，这个平衡需要开发者自己去把控： </p><p>滑动(Fling 状态)的时间越短，列表越容易停下，用户点击列表越容易触发 Item 的点击，但是容易停止带来的问题就是不够柔和。想象你在粗糙的水泥地上滑出去一块石头，这石头没有滑动多久就会停止，不管是扔石头的你还是旁边看你扔石头的我，都不会觉得这有什么美感，但是没得选。这个的 <strong>代表其实就是 Android 原生的 Fling 曲线</strong> </p><p>滑动(Fling 状态)的时间越长，滑动(Fling 状态)的时间越长，列表越不容易停下，用户点击列表越不容易触发 Item 的点击，如果曲线优化的好，给人的感觉就是很柔和，符合物理规律，想象你在光滑的冰面上滑出去一块冰，冰面越滑，冰块滑动的时间就越长，越不容易停下。这其中的极端代表就是 iOS 的 Fling 曲线。说 iOS 极端是因为，iOS 的滑动曲线调的太磨叽了，时间长不说，停的异常慢，很多时候你都需要点击一下列表让他先停止，然后再进行下一步的点击动作。而小米的 MIUI12 对这个也进行了调整，效果要比 iOS 好一些，如果再和三方进行类似华为和微博的合作，体验会更上一层楼 </p><p>滑动点击问题其实也可以通过厂商和 App 合作来解决，比如，当滑动到整个滑动距离的 98%(或者 95%) 之后，用户点击列表不再是让列表停止，而是列表内的 item 响应这个点击。这个思想来源于 Launcher 的代码，Launcher 的每一页在左右滑动的时候，如果滑动还没有停止但是用户比较手速快点击了某个 icon 想启动，那么这时候不会触发 Page 停止，而是直接响应 icon 的点击启动应用操作 </p><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><h2 id="列表滑动图片加载的性能考虑"><a href="#列表滑动图片加载的性能考虑" class="headerlink" title="列表滑动图片加载的性能考虑"></a>列表滑动图片加载的性能考虑</h2><p>前文有提到这个问题，滑动的时候进行图片加载主要有两个问题： </p><ol><li>如果用户滑动非常快，比如是想找昨天发的某个微博，那么今天发的所有的带图片的微博在用户滑动的时候是没必要加载的，因为用户的目标不是这些图片，而 App 去加载这些图片，而程序员是不会为用户提前加载你未看到的数据，因为加载过多的数据不仅容易发生数据复用、缓存过多、内存溢出等错误，还会对服务器造成不必要的资源请求。 </li><li>如果用户滑动非常快，那么图片加载队列势必有许多无效的资源(对这一刻的用户来说)，而用户真正想看的图片反而排在了加载队列后面，造成加载速度变慢，也会影响用户的体验 </li></ol><p>滑动中加载图片最大的风险其实就是造成卡顿，因为图片加载本身就是一个比较重的操作，而高帧率的手机上，一帧的时间被压缩到很短，任何小的不确定性都有可能造成卡顿 </p><p>所以厂商+应用的这个优化： <strong>快速滑动不加载图片，慢速的时候再加载，然后优化滑动曲线</strong> ，其实对厂商和应用都是非常有益处的 </p><h2 id="列表滑动监听背景知识"><a href="#列表滑动监听背景知识" class="headerlink" title="列表滑动监听背景知识"></a>列表滑动监听背景知识</h2><p>下面的 AbsListView 的 OnScrollListener 里面标注了列表滑动的三个状态 </p><ol><li>滑动停止：SCROLL_STATE_IDLE </li><li>手指在屏幕上滑动：SCROLL_STATE_TOUCH_SCROLL </li><li>手指离开屏幕，列表靠惯性继续滑动：SCROLL_STATE_FLING </li></ol><p>两个回调 </p><ol><li>列表状态变化时的回调 ：onScrollStateChanged </li><li>列表滑动时候的回调：onScroll </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnScrollListener</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The view is not scrolling. Note navigating the list using the trackball counts as being in the idle state since these transitions are not animated. </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> SCROLL_STATE_IDLE = <span class="number">0</span>;      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//The user is scrolling using touch, and their finger is still on the screen </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> SCROLL_STATE_TOUCH_SCROLL = <span class="number">1</span>;      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//The user had previously been scrolling using touch and had performed a fling. The animation is now coasting to a stop </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> SCROLL_STATE_FLING = <span class="number">2</span>;      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Callback method to be invoked while the list view or grid view is being scrolled. If the view is being scrolled, this method will be called before the next frame of the scroll is rendered. In particular, it will be called before any calls to </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span></span>;      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Callback method to be invoked when the list or grid has been scrolled. This will be called after the scroll has completed </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem, <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表滑动状态的变化"><a href="#列表滑动状态的变化" class="headerlink" title="列表滑动状态的变化"></a>列表滑动状态的变化</h2><p>TOUCH_SCROLL、FLING、IDLE 三个状态对应的列表滑动操作如下 </p><ol><li>TOUCH_SCROLL： 手指滑动 List 阶段，但是手指没有离开屏幕，这时候上下滑动都是 TOUCH_SCROLL </li><li>FLING： 手指滑动 List 后抬手到 List 停止的阶段（必须有一个上滑或者下滑的速度，否则不会进入 Fling） </li><li>IDLE：List 停止阶段 </li></ol><p>这三个状态的变化情况如下 </p><ol><li>手指滑动列表，停止后松手：IDLE  -&gt; TOUCH_SCROLL -&gt; IDLE </li><li>手指滑动列表，松手后列表继续滑动，然后停止：IDLE  -&gt; TOUCH_SCROLL -&gt; FLING -&gt; IDLE </li></ol><h2 id="列表的-Fling-曲线计算"><a href="#列表的-Fling-曲线计算" class="headerlink" title="列表的 Fling 曲线计算"></a>列表的 Fling 曲线计算</h2><p>Fling 触发之后，每一帧都会调用 update 函数来更新 distance  和 mCurrVelocity，所以我们只需要监听 mCurrVelocity  的值，超过一定的阈值，就可以回调给 App </p><p>frameworks/base/core/java/android/widget/OverScroller.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">update</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> time = AnimationUtils.currentAnimationTimeMillis(); </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = time - mStartTime; </span><br><span class="line">    <span class="keyword">double</span> distance = <span class="number">0.0</span>; </span><br><span class="line">    <span class="keyword">switch</span> (mState) &#123; </span><br><span class="line">        <span class="keyword">case</span> SPLINE: &#123; <span class="comment">// Fling  状态 </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) currentTime / mSplineDuration; </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t); </span><br><span class="line">            <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f; </span><br><span class="line">            <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f; </span><br><span class="line">            <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123; </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES; </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES; </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index]; </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>]; </span><br><span class="line">                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf); </span><br><span class="line">                distanceCoef = d_inf + (t - t_inf) * velocityCoef; </span><br><span class="line">            &#125; </span><br><span class="line">            distance = distanceCoef * mSplineDistance; </span><br><span class="line">            mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * <span class="number">1000.0f</span>; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">case</span> BALLISTIC: &#123; <span class="comment">// 列表滑到 底 之后的 拉伸阶段 </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t = currentTime / <span class="number">1000.0f</span>; </span><br><span class="line">            mCurrVelocity = mVelocity + mDeceleration * t; </span><br><span class="line">            distance = mVelocity * t + mDeceleration * t * t / <span class="number">2.0f</span>; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">case</span> CUBIC: &#123; <span class="comment">// 列表滑到底拉伸 之后的 回弹阶段 </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) (currentTime) / mDuration; </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t2 = t * t; </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> sign = Math.signum(mVelocity); </span><br><span class="line">            distance = sign * mOver * (<span class="number">3.0f</span> * t2 - <span class="number">2.0f</span> * t * t2);  </span><br><span class="line">            mCurrVelocity = sign * mOver * <span class="number">6.0f</span> * (- t + t2);  </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    mCurrentPosition = mStart + (<span class="keyword">int</span>) Math.round(distance); </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="厂商应用联合优化"><a href="#厂商应用联合优化" class="headerlink" title="厂商应用联合优化"></a>厂商应用联合优化</h1><p>微博这个优化就是厂商和应用之间联合优化的一个案例，应用对用户体验的极致追求，让这种合作在未来会变得更加频繁，像微信、快手、抖音这些… </p><p>下面这个招聘是拼多多的一个 JD，看职位描述是专门对接厂商的优化，也可以看出应用对厂商的合作越来越重视。之前厂商和应用是魔高一尺道高一丈的关系，互相攻防导致最终体验受损的还是用户；而现在这种厂商和应用合作的关系，不仅提升了双方的体验，也会带动 Android 生态圈向好的方面去发展 </p><p><img src="/images/15979021330055.jpg" alt=""></p><h1 id="本文其他地址"><a href="#本文其他地址" class="headerlink" title="本文其他地址"></a>本文其他地址</h1><p>微信公众号 - <a href="https://mp.weixin.qq.com/s/wJKOvU7CqP3vM0TG7rO66g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wJKOvU7CqP3vM0TG7rO66g</a><br>知乎专栏（求个赞） - <a href="https://zhuanlan.zhihu.com/p/191460094" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/191460094</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 流畅性 </tag>
            
            <tag> 体验优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个「闰」字引发的事故 - 三星系统重启分析</title>
      <link href="/2020/05/26/samsung_crash/"/>
      <url>/2020/05/26/samsung_crash/</url>
      
        <content type="html"><![CDATA[<p>2020 年 5 月 23 号凌晨 1 点 30 左右, 大量三星手机用户的手机出现死机, 无限重启、进 Recovery 等问题, 并且操作不当会导致数据丢失, 并且上了知乎的热点, 售后点更是人满为患</p><p>知乎的部分回答中, 大家更是对三星的家属送上了亲切的问候, 甚至有的人已经将这次事故与 Note7 事件、充电门、绿屏门事件相提并论, 甚至预言三星因此会退出国内市场 ; 有的人因为这个丢了 Offer , 有的人准备了很久的资源丢失, 有的人甚至直接把手机砸了…</p><p>作为一个 Android 开发者, 我并不想对三星落井下石 , 我只想搞清楚到底是什么原因导致了这场事故 , 以及我们能从里面学到什么 . 我认为既然是 Android 系统出了问题, 我们有必要从技术的角度来分析为什么会出现这样的问题</p><a id="more"></a><p><img src="/images/15904500356668.jpg" alt="知乎热点"></p><p>甚至商场里的机器都变砖了</p><p><img src="/images/15904500558308.jpg" alt="商场"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>结论先行, 对于不喜欢看长文的吃瓜群众来说, 直接看结论即可：</p><p><strong>这次事故表现是一部分三星用户的手机系统中关键系统服务重复 Crash 并强制进入 Recovery 界面. 关键系统服务指的是三星的 SystemUI 进程 , SystemUI 进程在初始化 AOD 插件的时候 AOD 插件初始化出错导致 SystemUI Crash, 由于是系统服务, SystemUI Crash 到一定的次数之后, 就会强制进入 Recovery 界面, 所以 大部分用户看到的都是 Recovery 界面(下面有图)</strong></p><p><strong>AOD 全称 Always On Display, 中文翻译是息屏显示, 就是你按电源键锁屏后, 在屏幕上显示时间、天气、图案等的服务, 这个只有部分高端机型才有这个功能.</strong></p><p><strong>AOD Crash 的原因是 2020 年 5 月 23 是闰四月, AOD 显示阴历的时候, 需要显示闰四月, 所以在代码中会走到显示闰四月这个一般很难走进的分支条件, 走进这个条件之后, 需要获取 common_data_leap_month 这个字段, 但是由于代码编译出现了 Bug, 导致无法找到这个字段, 所以该进程直接报了 FATAL EXCEPETION, 进程重启, 重启之后还是要获取这个字段, 再重启, 如此反复 , 最终触发系统的自救措施, 进入 Recovery 界面</strong></p><p><strong>这也是为什么只有中国用户才会出现这个问题, 就是因为 AOD 在 5 月 23 号需要显示”闰”四月 , 但是没找到 “闰” 这个字, 所以就挂了 . 所以并不是千年虫 , 也不是服务器被黑, 更不是三星故意恶心人, 这种编译导致的 Bug , 再碰上几年一遇的闰月 , 遇到了就认了吧 , 老老实实道歉, 不丢人.</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>吃瓜群众可以折返了, 感兴趣的 Android 开发者可以继续往下看,  内容虽然简单, 但是个人觉得还是可以看一下的</p><p>对于三星的开发人员来说, 分析这个 Crash 非常简单, 直接在监控里面捞 Log 就可以了, 从后面的分析来看, 这个问题也很快被发现, 并进行了修复(持续了半年左右)；但是对这个问题感兴趣的其他开发者来说, 需要借助其他的工具</p><p>不过分析的过程也非常简单, 这里会把自己分析的思路和用到的工具记录下来, 方便大家使用</p><h2 id="从现象入手"><a href="#从现象入手" class="headerlink" title="从现象入手"></a>从现象入手</h2><p>上面结论有说, Persist 进程频繁 Crash 会导致系统触发自救, 进入 Recovery 界面, 所以用户很多反馈截图大家看到都是 Recovery 界面 , 如下<br><img src="/images/15904500815732.jpg" alt="Recovery 界面"></p><p>不过也有用户的界面直接显示了报错信息（我猜测是三星这边自己加的功能吧, 知道的麻烦告知一下）, 这个界面对我们分析代码来说很重要</p><p><img src="/images/15904500993262.jpg" alt="报错信息界面"></p><p>开发者对于这个堆栈是最熟悉不过了, 这是在一帧的渲染流程中, AOD 的 LocalDataView 在初始化的时候, 调用 getLunarCalendarInChina 方法出错了, LunarCalendar 是阴历的意思, 报错主要是因为找不到 common_data_leap_month 这个 string 值. </p><p>那么问题就很清楚了, 我们只需要查下面两个点</p><ol><li><strong>common_data_leap_month 这个 string 字段出现的代码逻辑</strong></li><li><strong>common_data_leap_month 这个 string 字段没有找到导致运行报错的原因</strong></li></ol><h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>首先看 common_data_leap_month 字段出现的代码逻辑, 既然上面已经列出了函数堆栈, 那么我们需要直接查看代码来分析这个问题产生的逻辑, 如何拿到代码？自然是需要反编译, 推荐的反编译工具： <a href="https://github.com/tp7309/TTDeDroid" target="_blank" rel="noopener">TTDeDroid</a></p><p>反编译需要三星 AOD 的代码, 可以在 ApkMirror 里面搜 Always-On-Display,  就可以找到对应的文件, 可以看到三星的 AOD 更新的频率还是很频繁的, 通过用户反馈可以知道, 并非所有的用户都有这个问题, 且更新到新版本就没有问题了, 那么我们推测问题是出在老版本上的( 从堆栈来猜测应该是 V4.0 的版本 )</p><h3 id="正常版本-V5-2-05"><a href="#正常版本-V5-2-05" class="headerlink" title="正常版本_V5.2.05"></a>正常版本_V5.2.05</h3><p>最新版本是正常的, 没有 Crash 的情况</p><p>首先我们先看一下最新版本这一段代码的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String month = shouldShowLeapMonth(locale) ? context.getResources().getString(R.string.common_date_leap_month) + months[convertMonth] : months[convertMonth]</span><br></pre></td></tr></table></figure><p>这个就是说如果需要显示闰月, 那就取  common_date_leap_month 的值, 全局搜索 common_date_leap_month 发现最新版本里面是有定义这个值的 .</p><p>这里就可以看到 common_data_leap_month 字段出现的代码逻辑 : <strong>只有需要显示闰月的时候, 才会去获取 common_date_leap_month 这个字段的值, 其他 99.9% 的时候都不会触发这个值的获取</strong> .</p><p><img src="/images/15904501249419.jpg" alt="代码逻辑"></p><p>R.java 文件里面存在的 common_date_leap_month,  说明是存在的, 查看对应的 string.xml 中也有这个字段的定义</p><p><img src="/images/15904501422407.jpg" alt="R 文件"></p><p><img src="/images/15904501665686.jpg" alt="xml 文件"></p><h3 id="出问题版本-V4-1-70"><a href="#出问题版本-V4-1-70" class="headerlink" title="出问题版本_V4.1.70"></a>出问题版本_V4.1.70</h3><p>既然新版本没有问题, 且我们也知道了 common_date_leap_month 这个字段的代码逻辑 , 那么我们从老版本来看 common_date_leap_month 这个字段没有找到的原因.</p><p>这里找的这个老版本是有问题的, 使用这个版本(这几个版本) 的用户到了 23 号会出现频繁 Crash 的现象. 之所以我认为他是有问题的 , 是因为全局搜索 common_date_leap_month 字段,  发现 R 文件里面没有对应的字段, 对应的 string.xml  里面也没有这个字段和他对应的值, 也就是说 , 这里代码只使用, 没有定义和赋值( 那怎么编译过的呢 ？？？)</p><p><img src="/images/15904501980864.jpg" alt="只有使用,没有声明和赋值"></p><p>上面对应的代码逻辑如下,  可以看到函数名和行数和报错是一致的, InChina….</p><p><img src="/images/15904502144641.jpg" alt="对应的代码和行数"></p><p>具体对应的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getLunarCalendarInChina</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sSolarLunarConverter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sSolarLunarConverter = SECCalendarFeatures.getInstance().getSolarLunarConverter();</span><br><span class="line">        <span class="keyword">if</span> (sSolarLunarConverter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Time time = <span class="keyword">new</span> Time();</span><br><span class="line">    time.set(Calendar.getInstance().getTimeInMillis());</span><br><span class="line">    sSolarLunarConverter.convertSolarToLunar(time.getYear(), time.getMonth(), time.getMonthDay());</span><br><span class="line">    String[] months = context.getResources().getStringArray(R.array.common_LunarMonth);</span><br><span class="line">    String[] days = context.getResources().getStringArray(R.array.common_LunarDay);</span><br><span class="line">    <span class="keyword">int</span> convertMonth = sSolarLunarConverter.getMonth();</span><br><span class="line">    <span class="keyword">int</span> convertDay = sSolarLunarConverter.getDay() - <span class="number">1</span>;</span><br><span class="line">    ACLog.d(TAG, <span class="string">"Lunar month and day : "</span> + convertMonth + <span class="string">", "</span> + convertDay);</span><br><span class="line">    <span class="keyword">if</span> (convertMonth &lt; <span class="number">0</span> || convertMonth &gt;= months.length || convertDay &lt; <span class="number">0</span> || convertDay &gt;= days.length) &#123;</span><br><span class="line">        ACLog.e(TAG, <span class="string">"getLunarCalendarInChina, array out of bound month = "</span> + months.length + <span class="string">", days = "</span> + days.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String chinaLunar = (sSolarLunarConverter.isLeapMonth() ? context.getResources().getString(R.string.common_date_leap_month) + months[convertMonth] : months[convertMonth]) + days[convertDay];</span><br><span class="line">    String str = chinaLunar;</span><br><span class="line">    <span class="keyword">return</span> chinaLunar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题出现的时间"><a href="#问题出现的时间" class="headerlink" title="问题出现的时间"></a>问题出现的时间</h3><p>根据我这边的调查, 发现这个问题其实在 AOD 这个应用从 v3.3.18 升级到 v4.0.57 的时候就出现了, 但是中间一直都没有出问题, 没有闰四月, 用户也就不会有问题, 测试也没有测出来, 直到 2019 年 6 月 24 号发布的 v4.2.44 版本才修复了这个问题</p><p><img src="/images/15904502326041.jpg" alt="4.3.44 版本修复"></p><p>v3.3.18 版本我们可以看到, common_date_leap_month  这个字段还是存在的</p><p><img src="/images/15904502473489.jpg" alt="v3.3.18"></p><p>升级到 v4.0.57(第一个出问题的版本) 之后 , 这个字段就没有了( 那怎么编译过的呢 ？？？)</p><p><img src="/images/15904515064964.jpg" alt=""></p><p><strong>理一下</strong>：</p><ol><li>AOD 从 v3.3.18 升级到 v4.0.57 的引入了这个问题(2018 年 10 月 24 号引入)</li><li>AOD 从 v4.2.24 升级到 v4.2.44 <strong>解决</strong>了这个问题(2019 年 6 月 24 号 修复)</li></ol><p>这期间所有 AOD 版本在 v4.0.57 - v4.2.44 却从来没有升级的机型, 都会在 2020-5-23 号这一天进入 Recovery 模式.</p><h2 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h2><p>上面一个很重要的点就是编译问题, Android 开发者都知道, 如果我在代码中写 getString(R.string.common_date_leap_month) ,  那我得在 strings.xml 里面定义这个 common_date_leap_month,  然后给他赋值, 比如 “闰” , 这样才能在 R 文件中看到这个字段, 我们才能使用 getString(R.string.common_date_leap_month)  这样的语法去调用 ; 否则在编译阶段就会出现问题 , 编译提示 R.string.common_date_leap_month 不存在</p><p><img src="/images/15904515163672.jpg" alt="罪魁祸首"></p><p>但是通过上面的分析我们发现, 频繁 Crash 的版本就是因为找不到 common_date_leap_month  这个字段才 Crash 的, 既然找不到那也应该编译不过才对, 但是既然我们拿到了 apk,  那说明编译也是没问题的.</p><p>这种情况出现的话, 一般有下面两种情况</p><ol><li>项目中有同一个 jar 包的不同版本, 因此编译和运行时使用了不同的 jar 包</li><li>编译使用的是 Maven, 项目中的依赖由于使用了不同版本的包, 最后打包的时候使用的不是你需要的版本</li></ol><p>猜测三星这次出问题的是因为第二种情况, 主项目和子 modules 使用了不同版本的包, 导致可以编译通过, 但是最终打包进项目的并不是编译时候的包, 就出现了运行时的 FATAL EXCEPTION : NoSuchFieldError ( 如果有知道具体原因的可以留言讨论一波 )</p><p><strong>开个玩笑, 这个问题对三星来说绝对是一个大的事故, 不过也贡献了一个经典的案例, 估计以后其他 App 或者手机厂商都会把这个纳入到功能测试中. 至于三星, 国内市场本身就不行了, S20 系列刚有些回暖, 又出现这档子事, 还是那句话 : 这是命, 得认, 道歉 , 不丢人</strong></p><p>想必三星对这一天也会铭心刻骨</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的分析过程虽然比较简单, 但是有一些比较繁琐的工作, 比如找版本, 反编译 , 看代码逻辑等. 最终也算是找到了问题的根本原因 : 编译导致的问题碰上十几年才遇到一次的闰四月. 那么从这件事我们学到了什么呢?</p><ol><li>功能测试 : 闰月是日历中的一个功能 , 不算是常用功能 , 但是相对来说比较专业 , 像这种涉及到专业的地方, 一定要谨慎 , 列出所有可能出现的情况去做测试, 必要的情况下, 交给专业的人来评估测试用例</li><li>涉及到多方依赖编译的项目, 在编译的时候要确保引用的版本和本地的版本一致 , 对于多方依赖的模块, 每次发版本之前最好跟对应的依赖的模块确认</li><li>SystemUI (锁屏\状态栏\手势\多任务\ AOD 等) 模块和桌面模块是用户直接能感受到的模块, 这些模块对稳定性的要求要非常高, 因为一旦这些模块发生 FATAL , 带来的影响是非常巨大的, 就像三星这次, 所以这几个模块的开发人员也是最辛苦的, 既要承接一些亮点功能的实现, 又要保证稳定性, 同时也位于系统开发和应用开发中间, 两边都有很大的耦合, 着实不容易 (媳妇做这一块 6 年多了, 晚上加个鸡腿…)</li><li>厂商提供的系统更新和厂商自己的应用更新(尤其是系统应用) , 一定要及时更新, 每次系统和系统应用更新一般都会修复很多 Bug , 增强稳定性和性能. 系统和系统应用没有盈利的压力, 所以更新都是以提升质量为主, 可以放心更新.</li><li>开发者对这种事情要保持好奇和敬畏 : 好奇可以帮助我学到很多东西, 透过现象看本质 ; 敬畏可以让我知道自己知识的欠缺, 在庞大的 Android 体系中, 自己知道的不过沧海一粟..</li><li>这个问题对三星来说绝对是一个大的事故, 不过也贡献了一个经典的案例, 估计以后其他 App 或者手机厂商都会把这个纳入到功能测试中. 至于三星, 国内市场本身就不行了, S20 系列刚有些回暖, 又出现这档子事, 还是那句话 : 这是命, 得认, 道歉 , 不丢人」</li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android App 链式唤醒分析</title>
      <link href="/2020/05/07/Android-App-Chain-Wakeup/"/>
      <url>/2020/05/07/Android-App-Chain-Wakeup/</url>
      
        <content type="html"><![CDATA[<p>MIUI 12 的发布, 将之前一直是应用开发者和 Rom 开发者斗争最激烈的部分展示给了普通消费者, 让普通消费者也知道了这场斗争的细节, 正所谓 “魔高一尺道高一丈” , Rom 开发者由于有更高的代码修改权限, 始终占据着上风 ; App 开发者当然也不甘示弱, 各种保活拉起黑科技层出不穷,甚至 Google 都参与到了这部分斗争中, 居中调和, 制定各种规则来规范双方. 当然斗争对双方来说都算是好事, 毕竟任何一方完全的胜利都会导致 “狡兔死走狗烹,飞鸟尽良弓藏”</p><p>不过双方斗争的受害者无疑还是使用手机的消费者 , App 如果斗争成功, 那么手机上各种后台进程乱跑, 杀不掉, 占用 CPU 和内存 , 这不是消费者想看到的 ; 如果 Rom 开发者斗争成功 , App 的体验必定会大打折扣 , 各位 App 开发者应该深有体会. </p><p>从文章最后一段可以看到, 其实各个手机厂商对付这一套都有自己的策略, 基本上都可以搞定自启动和关联启动. 至于隐私 , 李彦宏曾经说过 “<strong>中国人对隐私问题的态度更加开放，也相对来说没那么敏感。如果他们可以用隐私换取便利、安全或者效率。在很多情况下，他们就愿意这么做</strong>“ . 大家想想在微信里面复制一段话打开到淘宝就可以自动跳转到这个物品, 方不方便? 好不好用? 还想不想用? 剪贴板再借我看一看?</p><a id="more"></a><p>希望大家在隐私问题上不要打哈哈, 技术是把双刃剑, 如果隐私落到别有用心的人手上, 后果是很严重的, 就算不是为了自己, 为了下一代. 欧盟为什么要搞《通用数据保护条例》（General Data Protection Regulation，简称 GDPR）, 就是为了隐私. 举个例子 , 国内很多厂商的产品现在要区分是否在欧盟买, 如果是在欧盟卖的话, 就得把里面那些收集用户数据的功能都关掉 , 否则抓住了就能罚你罚到吐血 . 至于中国和印度, 随便收集.</p><p>本篇文章不涉及到隐私部分, 我是对隐私保护无条件支持的 . 这里只从技术的角度 , 来讲一下 MIUI 12 爆出来的应用自启动和关联唤醒的问题.</p><p>PS: <strong>大家在自己的手机上可能看不到我列的一些例子, 是因为我是用的 Android 10 的 AOSP 代码, 大部分的国产 Rom 都已经阻断了应用的这些行为.</strong></p><h1 id="技术名词解释"><a href="#技术名词解释" class="headerlink" title="技术名词解释"></a>技术名词解释</h1><p>首先解释几个技术名词, 方便大家对号入座</p><h2 id="进程启动"><a href="#进程启动" class="headerlink" title="进程启动"></a>进程启动</h2><p>在 Android 中 , 一个 App 包含六部分, 进程(必选) + Activity (可选) + BroadcastReceiver (可选)+Service (可选)+ContentProvider (可选) + 子进程(可选)</p><p>一个必选项加五个可选项, 组成了一个 App , 其中 Activity(可选) + BroadcastReceiver(可选)+Service(可选)+ContentProvider(可选) 这四个又称为 Android 的四大组件, 之所以这四兄弟这么特殊, 是因为这四个组件都可以单独启动,</p><p>但是这四兄弟启动之前, 系统都会检查对应的进程是否存在, 如果进程不存在 , 那么就需要先启动进程, 再启动这个组件. 我们在桌面上点击一个应用图标, 其实启动的就是他的 Activity , 系统会先创建进程, 然后再启动 Activity , 我们才可以看到对应的界面</p><p>一般自启动和关联启动, 一般不会直接启动 Activity , 因为 Activity 是用户可感知的 , 你在后台莫名其妙起了一个界面到前台, 用户分分钟卸了你 . 所以一般自启动和关联启动都是在 BroadcastReceiver (可选) + Service (可选) + ContentProvider (可选) 三个上面做文章. </p><h2 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h2><p>自启动指的是不借助其他的应用, 通过监听系统的一些事件, 或者文件变化, 通过系统的机制, 把自己的进程拉起来处理事情.</p><h2 id="关联启动"><a href="#关联启动" class="headerlink" title="关联启动"></a>关联启动</h2><p>关联启动指的是借助其他应用来启动自己, 比如大家列出来的起点读书启动作家助手\电信营业厅\百词斩这种.</p><h2 id="启动阻断"><a href="#启动阻断" class="headerlink" title="启动阻断"></a>启动阻断</h2><p>启动阻断也叫切断唤醒, Rom 开发人员在四大组件启动的地方加入逻辑判断, 符合条件的组件才能拉起自己的进程 , 不符合条件的组件直接返回 , 这样就达到了启动阻断的目的.</p><p>当然这里面还有很多工作要做, 比如工作状态判断, 拉起合理性判断 , 一旦错误的阻断必然会引起用户的使用逻辑的断裂, 比如用户在一个 App 里面要拉起支付宝进行支付 , 结果启动支付宝的支付组件的时候被你给阻断了, 可以想象用户的愤怒</p><p>有了上面几个简单的概念, 下面我们就简单说一下自启动和关联启动的技术分析 .</p><h1 id="分析手段"><a href="#分析手段" class="headerlink" title="分析手段"></a>分析手段</h1><h2 id="Monkey"><a href="#Monkey" class="headerlink" title="Monkey"></a>Monkey</h2><p>要分析应用启动，首先需要安装大量应用，然后执行 Monkey，让大部分进程都跑起来。我使用的 Monkey 命令如下，跑完就自己去睡觉了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey --kill-process-after-error --ignore-security-exceptions --ignore-crashes --pct-appswitch 90 --pct-touch 10 --throttle 10000 --ignore-timeouts --ignore-native-crashes 100000000</span><br></pre></td></tr></table></figure><h2 id="EventLog"><a href="#EventLog" class="headerlink" title="EventLog"></a>EventLog</h2><p>首先可以用 EventLog 来查看进程的启动信息，EventLog 会如实记录每个进程的启动、死亡信息。我使用下面的命令来进行进程启动和死亡的过滤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -b events | egrep "am_proc_died|am_proc_start"</span><br></pre></td></tr></table></figure><h2 id="Dumpsys"><a href="#Dumpsys" class="headerlink" title="Dumpsys"></a>Dumpsys</h2><p>这里主要是使用了 Dumpsys activity ，主要是用来分析进程的各个组件的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity</span><br></pre></td></tr></table></figure><h1 id="自启动的技术分析"><a href="#自启动的技术分析" class="headerlink" title="自启动的技术分析"></a>自启动的技术分析</h1><p>自启动指的是不借助其他的应用, 通过监听系统的一些事件, 或者文件变化, 通过系统的机制, 把自己的进程拉起来处理事情. 这些系统的事件就包括开机广播 / 网络变化 / 媒体库扫描等(这里只列了一部分) .</p><h2 id="开机广播"><a href="#开机广播" class="headerlink" title="开机广播"></a>开机广播</h2><p>用户重启手机后, 系统会向注册了开机广播的应用发广播, 收到广播的应用就可以把自己拉起来, 开始处理对应的逻辑(拉起更多的进程) , 对应的广播如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">android</span><span class="selector-class">.intent</span><span class="selector-class">.action</span><span class="selector-class">.BOOT_COMPLETED</span></span><br></pre></td></tr></table></figure><p>应用可以监听这个广播, 在用户重启手机后, 将自己唤醒, 处理自己的逻辑 , 比如说继续图片备份/  继续同步联系人 / 检查是否有固件更新 / 推送最新的新闻等操作</p><p><strong>当然监听这个广播也是应用自启动的一个手段</strong></p><h3 id="案例-腾讯新闻监听开机广播拉起后台进程"><a href="#案例-腾讯新闻监听开机广播拉起后台进程" class="headerlink" title="案例: 腾讯新闻监听开机广播拉起后台进程"></a>案例: 腾讯新闻监听开机广播拉起后台进程</h3><p>典型的广播接受处理记录 : com.tencent.news 的 com.tencent.news.system.BootBroadcastReceiver 组件接收了 android.intent.action.BOOT_COMPLETED 广播 ,处理了 7s ,至于怎么处理, 当然是先把 com.tencent.news 这个进程拉起来, 然后执行 BootBroadcastReceiver  的 onReceive 方法 . 这是一个典型的自启动的例子</p><p><img src="/images/15888647034327.jpg" alt=""></p><h2 id="网络变化"><a href="#网络变化" class="headerlink" title="网络变化"></a>网络变化</h2><p>网络变化包括网络连接 / 断开 / wifi 移动网络切换等操作 , 一旦发生这些事件, 系统会向对应注册了这个事件的应用发送广播 . 对应的广播如下: </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">android</span><span class="selector-class">.net</span><span class="selector-class">.conn</span><span class="selector-class">.CONNECTIVITY_CHANGE</span></span><br></pre></td></tr></table></figure><p>应用就可以监听这个广播来执行对应的逻辑 , 比如你在看直播 ,突然 wifi 断了切换成了 4G 网络, 应用就可以提醒用户是否使用移动网络继续观看, 毕竟网络直播还是很耗流量的.</p><p><strong>当然监听这个广播也是应用自启动的一个手段</strong></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>下图可以看到五个监听了网络变大的广播接收器 (只显示了五个 , 其实有 200 多个) , 监听到网络变化后拉起自身</p><ol><li>包名: com.alibaba.android.rimet(钉钉)<ol><li>接收器 : com.xiaomi.push.service.receivers.NetworkStatusReceiver</li></ol></li><li>包名: cn.xuexi.android<ol><li>接收器: com.xiaomi.push.service.receivers.NetworkStatusReceiver</li></ol></li><li>包名: com.sina.weibo<ol><li>接收器: com.xiaomi.push.service.receivers.NetworkStatusReceiver</li></ol></li><li>包名: com.sdu.didi.psnger<ol><li>接收器 : com.didi.sdk.push.PushNetReceiver</li></ol></li><li>包名: com.meelive.ingkee<ol><li>接收器 : com.network_optimization.NetWorkStateReceiver</li></ol></li></ol><p>图中 packageName 就是对于的应用的包名, name 是启动的组件</p><p><img src="/images/15888647135669.jpg" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">android</span><span class="selector-class">.net</span><span class="selector-class">.wifi</span><span class="selector-class">.STATE_CHANGE</span></span><br></pre></td></tr></table></figure><p><img src="/images/15888647201101.jpg" alt=""></p><h2 id="媒体库扫描"><a href="#媒体库扫描" class="headerlink" title="媒体库扫描"></a>媒体库扫描</h2><p>系统监听到文件变化或者存储盘变化也会发通知给各个应用 , 比如说增加了一个图片或者文档 , 其对于的广播如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">android</span><span class="selector-class">.intent</span><span class="selector-class">.action</span><span class="selector-class">.MEDIA_SCANNER_STARTED</span></span><br><span class="line"><span class="selector-tag">android</span><span class="selector-class">.intent</span><span class="selector-class">.action</span><span class="selector-class">.MEDIA_SCANNER_FINISHED</span></span><br><span class="line"><span class="selector-tag">android</span><span class="selector-class">.intent</span><span class="selector-class">.action</span><span class="selector-class">.MEDIA_EJECT</span></span><br></pre></td></tr></table></figure><p><strong>当然监听这个广播也是应用自启动的一个手段</strong></p><h3 id="案例-jd-监听-MEDIA-SCANNER-STARTED-广播自启"><a href="#案例-jd-监听-MEDIA-SCANNER-STARTED-广播自启" class="headerlink" title="案例: jd 监听 MEDIA_SCANNER_STARTED 广播自启"></a>案例: jd 监听 MEDIA_SCANNER_STARTED 广播自启</h3><p>下面是一个典型的监听媒体库扫描广播进行自启动的案例:</p><p>com.jd.jrapp 的广播接收器 com.jd.jrapp.library.longconnection.receiver.BootReceiver 监听到 android.intent.action.MEDIA_SCANNER_STARTED 广播后, 启动自己进程开始处理</p><p><img src="/images/15888647284822.jpg" alt=""></p><h2 id="三方-SDK-个推"><a href="#三方-SDK-个推" class="headerlink" title="三方 SDK - 个推"></a>三方 SDK - 个推</h2><p>个推是各个应用接入的一个三方 SDK , 用于消息推送 , 但其实个推也集成了上面说的哪几种自启动的方式 , 包括 BOOT_COMPLETED,CONNECTIVITY_CHANGE,USER_PRESENT 这些</p><p>关于个推,由于可定制型比较强, 比如 在项目源码中添加一个继承自 com.igexin.sdk.PushService 的自定义 Service 就可以 , 所以从 EventLog 和 Dumpsys 没法直接看出来哪个用了个推来保活或者相互唤醒, 不过其对于的子进程得设置为 :pushservice , 可以根据这个做判断(有可能不准)</p><p>所以我们直接看个推的配置文档</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.igexin.sdk.PushService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"android.permission.BIND_JOB_SERVICE"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"NotificationCenter"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":pushservice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">"com.igexin.sdk.PushReceiver"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.USER_PRESENT"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 以下三项为可选的 action 声明，有助于提高 service 存活率 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MEDIA_MOUNTED"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.ACTION_POWER_CONNECTED"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.ACTION_POWER_DISCONNECTED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.igexin.sdk.PushActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:excludeFromRecents</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":pushservice"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.igexin.sdk.PushActivityTask"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent.NoTitleBar"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:name</span>=<span class="string">"com.igexin.sdk.GActivity"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:excludeFromRecents</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:process</span>=<span class="string">":pushservice"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:taskAffinity</span>=<span class="string">"com.igexin.sdk.PushActivityTask"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent.NoTitleBar"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>像最前面同提到的 BootComplete , com.ss.android.ugc.aweme:pushservice 可能就是接入了个推</p><p><img src="/images/15888647377742.jpg" alt=""></p><h1 id="关联启动的技术分析"><a href="#关联启动的技术分析" class="headerlink" title="关联启动的技术分析"></a>关联启动的技术分析</h1><p>关联启动指的是借助其他应用来启动自己 , 比如说很多 App 接入了同一个 SDK , 那么一旦你启动了接入这个 SDK 的应用 ,那么这个 SDK 就可以启动同样接入了这个 SDK 的其他应用, 达到关联唤醒的目的</p><p>这个 SDK 可以是 BAT 集团内部自研的通用 SDK , 也可以是三方提供的 SDK , 根据我自己的调试来看 , 大家提到的 xxx 启动了 xxx , 大部分都是通过三方 SDK 来实现的 , 大部分是用了极光推送.</p><p>下面就以一个案例来看极光推送是怎么利用一个已经启动的 App 来启动另外一个没有启动的 App 的.</p><p>首先我们看 EventLog 可以看到进程的启动信息 , 包括进程名, 进程 pid , 启动的组件, 启动的组件类型.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">19428</span>,<span class="number">10195</span>,com<span class="selector-class">.qq</span><span class="selector-class">.reader</span>,service,&#123;com<span class="selector-class">.qq</span>.reader/cn<span class="selector-class">.jpush</span><span class="selector-class">.android</span><span class="selector-class">.service</span>.DaemonService&#125;]</span><br></pre></td></tr></table></figure><p>上面这条 Log 解释一下就是 </p><ol><li>启动进程 : com.qq.reader(QQ 阅读) </li><li>启动 pid :19428 </li><li>启动组件: cn.jpush.android.service.DaemonService </li><li>组件类型: service</li></ol><h3 id="案例-起点-App-通过极光推送拉起-QQ-阅读"><a href="#案例-起点-App-通过极光推送拉起-QQ-阅读" class="headerlink" title="案例:起点 App 通过极光推送拉起 QQ 阅读"></a>案例:起点 App 通过极光推送拉起 QQ 阅读</h3><p>执行 adb shell am force-stop com.qq.reader  , 强制杀掉 QQ 阅读 , 观察 EventLog, 从下面的可以看到 , QQ 阅读的进程被拉起, 拉起的是 Service 这个组件, 其具体的内容是 com.qq.reader/cn.jpush.android.service.DaemonService</p><p><img src="/images/15888647497735.jpg" alt=""></p><p>当然从 Event Log 里面我们看不出来是谁拉起了这个 Service ,这时候就需要 dumpsys activity 的帮助了, 由于是 Service 组件被拉起, 那么我们可以看 com.qq.reader 的 ServiceRecord , 其内容如下, 可以看到其 Connections 一栏, 是被 com.qidian.QDReader:pushcore 这个进程拉起的</p><p><img src="/images/15888647596688.jpg" alt=""></p><p>那么对应的 , 在小米的 MIUI 12 关联启动界面就会显示 : 起点读书 在 8:48 分拉起了 QQ 阅读(由于没有小米手机, 所以没法截图, 大家自己看高票答案 <a href="https://www.zhihu.com/question/391494145" target="_blank" rel="noopener">https://www.zhihu.com/question/391494145</a> 自己脑补一下就可以了)</p><p>极光推送的官方文档其实也说的很清楚, 提供了被拉起和拉起别人的功能, 看你自己怎么用.</p><h3 id="极光官方文档唤醒配置"><a href="#极光官方文档唤醒配置" class="headerlink" title="极光官方文档唤醒配置"></a>极光官方文档唤醒配置</h3><p><img src="/images/15888647676816.jpg" alt=""></p><h3 id="极光关联启动文档"><a href="#极光关联启动文档" class="headerlink" title="极光关联启动文档"></a>极光关联启动文档</h3><p><img src="/images/15888647754201.jpg" alt=""></p><p><img src="/images/15888647806293.jpg" alt=""></p><h1 id="手机厂商应对"><a href="#手机厂商应对" class="headerlink" title="手机厂商应对"></a>手机厂商应对</h1><p>最前面的有说到, 进程管理是应用开发者和 Rom 开发者斗争最激烈的部分 , MIUI 选择了将斗争的过程展示给了普通消费者, 让普通消费者也知道了这场斗争的细节 . 其他的厂商也做了相同的事情 , 否则整个系统基本上是没法用的 , 就像我手上现在这台测试用的 pixel , 不断有进程因为整机内存太小被 LMK 杀掉, 然后马上被各种手段重新启动 , 耗电极快, 卡的连娘都不认识了.</p><p>我们从极光和个推的官方文档就可以看到各个手机厂商的应对方法和开关的界面, 这里列出来是方便大家进去看一下, 因为各个手机厂商的白名单配置不一样, 或者有时候用户自己改过但是忘记了 , 都可以进去重新设置一下 , 对于那些你退出了就不想让他继续活动的应用 ,果断去掉白名单.</p><h2 id="极光推送白名单配置"><a href="#极光推送白名单配置" class="headerlink" title="极光推送白名单配置"></a>极光推送白名单配置</h2><p><img src="/images/15888647965330.jpg" alt=""></p><h2 id="个推白名单配置"><a href="#个推白名单配置" class="headerlink" title="个推白名单配置"></a>个推白名单配置</h2><h3 id="EMUI-OS（华为）"><a href="#EMUI-OS（华为）" class="headerlink" title="EMUI OS（华为）"></a>EMUI OS（华为）</h3><ul><li>自启动管理：需要把应用加到【自启动管理】列表，否则杀进程或重新开机后进程不会开启，只能手动开启应用</li><li>后台应用保护：需要手动把应用加到此列表，否则设备进入睡眠后会自动杀掉应用进程，只有手动开启应用才能恢复运行</li><li>通知管理：应用状态有三种：提示、允许、禁止。禁止应用则通知栏不会有任何提醒</li></ul><h3 id="Flyme-OS（魅族）"><a href="#Flyme-OS（魅族）" class="headerlink" title="Flyme OS（魅族）"></a>Flyme OS（魅族）</h3><ul><li>自启动管理：需要把应用加到【自启动管理】列表，否则杀进程或重新开机后进程无法开启</li><li>通知栏推送：关闭应用通知则收到消息不会有任何展示</li></ul><h3 id="Funtouch-OS（VIVO）"><a href="#Funtouch-OS（VIVO）" class="headerlink" title="Funtouch OS（VIVO）"></a>Funtouch OS（VIVO）</h3><ul><li>自启动管理：需要将应用加入“i 管家”中的【自启动管理】列表，否则重启手机后进程不会自启。但强制手动杀进程，即使加了这个列表中，后续进程也无法自启动。</li></ul><h3 id="Color-OS（OPPO）"><a href="#Color-OS（OPPO）" class="headerlink" title="Color OS（OPPO）"></a>Color OS（OPPO）</h3><ul><li>冻结应用管理：需要将应用加入纯净后台，否则锁屏状态下无法及时收到消息</li><li>自启动管理：将应用加入【自启动管理】列表的同时，还需要到设置-应用程序-正在运行里锁定应用进程，否则杀进程或者开机后进程不会开启，只能手动开启应用</li></ul><h3 id="MIUI-OS-小米"><a href="#MIUI-OS-小米" class="headerlink" title="MIUI OS (小米)"></a>MIUI OS (小米)</h3><ul><li>自启动管理：需要把应用加到【自启动管理】列表，否则杀进程或重新开机后进程无法开启</li><li>省电策略：需要禁用应用省电策略，否则后台几分钟后会被系统限制联网</li><li>MIUI 7 神隐模式： 允许用户设置后台联网应用，开启后应用即可在后台保持联网，否则应用进入后台时，应用无法正常接收消息。【设置】-&gt;【电量和性能】-&gt;【神隐模式】</li></ul><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 - SurfaceFlinger 解读</title>
      <link href="/2020/02/14/Android-Systrace-SurfaceFlinger/"/>
      <url>/2020/02/14/Android-Systrace-SurfaceFlinger/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第五篇，主要是对 SurfaceFlinger 进行简单介绍，介绍了 SurfaceFlinger 中几个比较重要的线程，包括 Vsync 信号的解读、应用的 Buffer 展示、卡顿判定等，由于 Vsync 这一块在<a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a> 和 <a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Android 基于 Choreographer 的渲染机制详解</a> 这两篇文章里面已经介绍过，这里就不再做详细的讲解了。</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这里直接上官方对于 <a href="https://source.android.google.cn/devices/graphics/arch-sf-hwc.html?authuser=0&hl=de" target="_blank" rel="noopener">SurfaceFlinger 的定义</a></p><ol><li>大多数应用在屏幕上一次显示三个层：屏幕顶部的状态栏、底部或侧面的导航栏以及应用界面。有些应用会拥有更多或更少的层（例如，默认主屏幕应用有一个单独的壁纸层，而全屏游戏可能会隐藏状态栏）。每个层都可以单独更新。状态栏和导航栏由系统进程渲染，而应用层由应用渲染，两者之间不进行协调。</li><li>设备显示会按一定速率刷新，在手机和平板电脑上通常为 60 fps。如果显示内容在刷新期间更新，则会出现撕裂现象；因此，请务必只在周期之间更新内容。在可以安全更新内容时，系统便会收到来自显示设备的信号。由于历史原因，我们将该信号称为 VSYNC 信号。</li><li>刷新率可能会随时间而变化，例如，一些移动设备的帧率范围在 58 fps 到 62 fps 之间，具体要视当前条件而定。对于连接了 HDMI 的电视，刷新率在理论上可以下降到 24 Hz 或 48 Hz，以便与视频相匹配。由于每个刷新周期只能更新屏幕一次，因此以 200 fps 的帧率为显示设备提交缓冲区就是一种资源浪费，因为大多数帧会被舍弃掉。SurfaceFlinger 不会在应用每次提交缓冲区时都执行操作，而是在显示设备准备好接收新的缓冲区时才会唤醒。</li><li>当 VSYNC 信号到达时，SurfaceFlinger 会遍历它的层列表，以寻找新的缓冲区。如果找到新的缓冲区，它会获取该缓冲区；否则，它会继续使用以前获取的缓冲区。SurfaceFlinger 必须始终显示内容，因此它会保留一个缓冲区。如果在某个层上没有提交缓冲区，则该层会被忽略。</li><li>SurfaceFlinger 在收集可见层的所有缓冲区之后，便会询问 Hardware Composer 应如何进行合成。」  </li></ol><p>—- 引用自<a href="https://source.android.google.cn/devices/graphics/arch-sf-hwc.html?authuser=0&hl=de" target="_blank" rel="noopener">SurfaceFlinger 和 Hardware Composer</a></p><p>下面是上述流程所对应的流程图， 简单地说， SurfaceFlinger 最主要的功能:<strong>SurfaceFlinger 接受来自多个来源的数据缓冲区，对它们进行合成，然后发送到显示设备。</strong></p><p><img src="/images/15816781462135.jpg" alt=""></p><p>那么 Systrace 中，我们关注的重点就是上面这幅图对应的部分</p><ol><li>App 部分</li><li>BufferQueue 部分</li><li>SurfaceFlinger 部分</li><li>HWComposer 部分</li></ol><p>这四部分，在 Systrace 中都有可以对应的地方，以时间发生的顺序排序就是 1、2、3、4，下面我们从 Systrace 的这四部分来看整个渲染的流程</p><h2 id="App-部分"><a href="#App-部分" class="headerlink" title="App 部分"></a>App 部分</h2><p>关于 App 部分，其实在<a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a>这篇文章里面已经说得比较清楚了，不清楚的可以去这篇文章里面看，其主要的流程如下图：</p><p><img src="/images/15818258189902.jpg" alt=""></p><p>从 SurfaceFlinger 的角度来看，App 部分主要负责生产 SurfaceFlinger 合成所需要的 Surface。</p><p>App 与 SurfaceFlinger 的交互主要集中在三点</p><ol><li>Vsync 信号的接收和处理</li><li>RenderThread 的 dequeueBuffer</li><li>RenderThread 的 queueBuffer</li></ol><h3 id="Vsync-信号的接收和处理"><a href="#Vsync-信号的接收和处理" class="headerlink" title="Vsync 信号的接收和处理"></a>Vsync 信号的接收和处理</h3><p>关于这部分内容可以查看<a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android 基于 Choreographer 的渲染机制详解</a> 这篇文章，App 和 SurfaceFlinger 的第一个交互点就是 Vsync 信号的请求和接收，如上图中第一条标识，Vsync-App 信号到达，就是指的是 SurfaceFlinger 的 Vsync-App 信号。应用收到这个信号后，开始一帧的渲染准备</p><p><img src="/images/15822547481351.jpg" alt=""></p><h3 id="RenderThread-的-dequeueBuffer"><a href="#RenderThread-的-dequeueBuffer" class="headerlink" title="RenderThread 的 dequeueBuffer"></a>RenderThread 的 dequeueBuffer</h3><p>dequeue 有出队的意思，dequeueBuffer 顾名思义，就是从队列中拿出一个 Buffer，这个队列就是 SurfaceFlinger 中的 BufferQueue。如下图，应用开始渲染前，首先需要通过 Binder 调用从 SurfaceFlinger 的 BufferQueue 中获取一个 Buffer，其流程如下：</p><p><strong>App 端的 Systrace 如下所示</strong><br><img src="/images/15822556410563.jpg" alt="-w1249"></p><p><strong>SurfaceFlinger 端的 Systrace 如下所示</strong><br><img src="/images/15822558376614.jpg" alt="-w826"></p><h3 id="RenderThread-的-queueBuffer"><a href="#RenderThread-的-queueBuffer" class="headerlink" title="RenderThread 的 queueBuffer"></a>RenderThread 的 queueBuffer</h3><p>queue 有入队的意思，queueBuffer 顾名思义就是讲 Buffer 放回到 BufferQueue，App 处理完 Buffer 后（写入具体的 drawcall），会把这个 Buffer 通过 eglSwapBuffersWithDamageKHR -&gt; queueBuffer 这个流程，将 Buffer 放回 BufferQueue，其流程如下</p><p><strong>App 端的 Systrace 如下所示</strong><br><img src="/images/15822960954718.jpg" alt="-w1165"></p><p><strong>SurfaceFlinger 端的 Systrace 如下所示</strong><br><img src="/images/15822964913781.jpg" alt="-w1295"></p><p>通过上面三部分，大家应该对下图中的流程会有一个比较直观的了解了<br><img src="/images/15822965692055.jpg" alt="-w410"></p><h2 id="BufferQueue-部分"><a href="#BufferQueue-部分" class="headerlink" title="BufferQueue 部分"></a>BufferQueue 部分</h2><p>BufferQueue 部分其实在<a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/#BufferQueue" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a> 这里有讲，如下图，结合上面那张图，每个有显示界面的进程对应一个 BufferQueue，使用方创建并拥有 BufferQueue 数据结构，并且可存在于与其生产方不同的进程中，BufferQueue 工作流程如下：</p><p><img src="/images/15823652509728.jpg" alt=""></p><p>上图主要是 dequeue、queue、acquire、release ，在这个例子里面，App 是<strong>生产者</strong>，负责填充显示缓冲区（Buffer）；SurfaceFlinger 是<strong>消费者</strong>，将各个进程的显示缓冲区做合成操作</p><ol><li>dequeue(生产者发起) ： 当生产者需要缓冲区时，它会通过调用 dequeueBuffer() 从 BufferQueue 请求一个可用的缓冲区，并指定缓冲区的宽度、高度、像素格式和使用标记。</li><li>queue(生产者发起)：生产者填充缓冲区并通过调用 queueBuffer() 将缓冲区返回到队列。</li><li>acquire(消费者发起) ：消费者通过 acquireBuffer() 获取该缓冲区并使用该缓冲区的内容</li><li>release(消费者发起) ：当消费者操作完成后，它会通过调用 releaseBuffer() 将该缓冲区返回到队列</li></ol><h2 id="SurfaceFlinger-部分"><a href="#SurfaceFlinger-部分" class="headerlink" title="SurfaceFlinger 部分"></a>SurfaceFlinger 部分</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>从最前面我们知道 SurfaceFlinger 的主要工作就是合成：</p><blockquote><p>当 VSYNC 信号到达时，SurfaceFlinger 会遍历它的层列表，以寻找新的缓冲区。如果找到新的缓冲区，它会获取该缓冲区；否则，它会继续使用以前获取的缓冲区。SurfaceFlinger 必须始终显示内容，因此它会保留一个缓冲区。如果在某个层上没有提交缓冲区，则该层会被忽略。SurfaceFlinger 在收集可见层的所有缓冲区之后，便会询问 Hardware Composer 应如何进行合成。</p></blockquote><p>其 Systrace 主线程可用看到其主要是在收到 Vsync 信号后开始工作<br><img src="/images/15822972813466.jpg" alt="-w1296"></p><p>其对应的代码如下,主要是处理两个 Message</p><ol><li>MessageQueue::INVALIDATE — 主要是执行 handleMessageTransaction 和 handleMessageInvalidate 这两个方法</li><li>MessageQueue::REFRESH — 主要是执行 handleMessageRefresh 方法</li></ol><p>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">            refreshNeeded |= handleMessageInvalidate();</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//handleMessageInvalidate 实现如下</span></span><br><span class="line"><span class="keyword">bool</span> SurfaceFlinger::handleMessageInvalidate() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">bool</span> refreshNeeded = handlePageFlip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVisibleRegionsDirty) &#123;</span><br><span class="line">        computeLayerBounds();</span><br><span class="line">        <span class="keyword">if</span> (mTracingEnabled) &#123;</span><br><span class="line">            mTracing.notify(<span class="string">"visibleRegionsDirty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh) &#123;</span><br><span class="line">        Region visibleReg;</span><br><span class="line">        visibleReg.<span class="built_in">set</span>(layer-&gt;getScreenBounds());</span><br><span class="line">        invalidateLayerStack(layer, visibleReg);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersPendingRefresh.clear();</span><br><span class="line">    <span class="keyword">return</span> refreshNeeded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//handleMessageRefresh 实现如下， SurfaceFlinger 的大部分工作都是在handleMessageRefresh 中发起的</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = mRepaintEverything.exchange(<span class="literal">false</span>);</span><br><span class="line">    preComposition();</span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    calculateWorkingSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        beginFrame(display);</span><br><span class="line">        prepareFrame(display);</span><br><span class="line">        doDebugFlashRegions(display, repaintEverything);</span><br><span class="line">        doComposition(display, repaintEverything);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logLayerStats();</span><br><span class="line"></span><br><span class="line">    postFrame();</span><br><span class="line">    postComposition();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || getHwComposer().hasClientComposition(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || getHwComposer().hasDeviceComposition(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVsyncModulator.onRefreshed(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleMessageRefresh 中按照重要性主要有下面几个功能</p><ol><li>准备工作<ol><li>preComposition();</li><li>rebuildLayerStacks();</li><li>calculateWorkingSet();</li></ol></li><li>合成工作<ol><li>begiFrame(display);</li><li>prepareFrame(display);</li><li>doDebugFlashRegions(display, repaintEverything);</li><li>doComposition(display, repaintEverything);</li></ol></li><li>收尾工作<ol><li>logLayerStats();</li><li>postFrame();</li><li>postComposition();</li></ol></li></ol><p>由于显示系统有非常庞大的细节，这里就不一一进行讲解了，如果你的工作在这一部分，那么所有的流程都需要熟悉并掌握，如果只是想熟悉流程，那么不需要太深入，知道 SurfaceFlinger 的主要工作逻辑即可</p><h3 id="掉帧"><a href="#掉帧" class="headerlink" title="掉帧"></a>掉帧</h3><p>通常我们通过 Systrace 判断应用是否<strong>掉帧</strong>的时候，一般是直接看 SurfaceFlinger 部分，主要是下面几个步骤</p><ol><li>SurfaceFlinger 的主线程在每个 Vsync-SF 的时候是否没有合成？</li><li>如果没有合成操作，那么需要看没有合成的原因：<ol><li>因为 SurfaceFlinger 检查发现没有可用的 Buffer 而没有合成操作？</li><li>因为 SurfaceFlinger 被其他的工作占用（比如截图、HWC 等）？</li></ol></li><li>如果有合成操作，那么需要看对应的 App 的 可用 Buffer 个数是否正常：如果 App 此时可用 Buffer 为 0，那么看 App 端为何没有及时 queueBuffer（这就一般是应用自身的问题了），因为 SurfaceFlinger 合成操作触发可能是其他的进程有可用的 Buffer</li></ol><p>关于这一部分的 Systrace 怎么看，在 <a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/#%E9%80%BB%E8%BE%91%E6%8E%89%E5%B8%A7" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读-掉帧检测</a> 部分已经有比较详细的解读，大家可以过去看这一段</p><h2 id="HWComposer-部分"><a href="#HWComposer-部分" class="headerlink" title="HWComposer 部分"></a>HWComposer 部分</h2><p>关于 HWComposer 的功能部分我们就直接看<a href="https://source.android.google.cn/devices/graphics/arch-sf-hwc.html?authuser=0&hl=de" target="_blank" rel="noopener">官方的介绍</a>即可</p><ol><li>Hardware Composer HAL (HWC) 用于确定通过可用硬件来合成缓冲区的最有效方法。作为 HAL，其实现是特定于设备的，而且通常由显示设备硬件原始设备制造商 (OEM) 完成。</li><li>当您考虑使用叠加平面时，很容易发现这种方法的好处，它会在显示硬件（而不是 GPU）中合成多个缓冲区。例如，假设有一部普通 Android 手机，其屏幕方向为纵向，状态栏在顶部，导航栏在底部，其他区域显示应用内容。每个层的内容都在单独的缓冲区中。您可以使用以下任一方法处理合成（后一种方法可以显著提高效率）：<ol><li>将应用内容渲染到暂存缓冲区中，然后在其上渲染状态栏，再在其上渲染导航栏，最后将暂存缓冲区传送到显示硬件。</li><li>将三个缓冲区全部传送到显示硬件，并指示它从不同的缓冲区读取屏幕不同部分的数据。</li></ol></li><li>显示处理器功能差异很大。叠加层的数量（无论层是否可以旋转或混合）以及对定位和叠加的限制很难通过 API 表达。为了适应这些选项，HWC 会执行以下计算（由于硬件供应商可以定制决策代码，因此可以在每台设备上实现最佳性能）：<ol><li>SurfaceFlinger 向 HWC 提供一个完整的层列表，并询问“您希望如何处理这些层？”</li><li>HWC 的响应方式是将每个层标记为叠加层或 GLES 合成。</li><li>SurfaceFlinger 会处理所有 GLES 合成，将输出缓冲区传送到 HWC，并让 HWC 处理其余部分。</li></ol></li><li>当屏幕上的内容没有变化时，叠加平面的效率可能会低于 GL 合成。当叠加层内容具有透明像素且叠加层混合在一起时，尤其如此。在此类情况下，HWC 可以选择为部分或全部层请求 GLES 合成，并保留合成的缓冲区。如果 SurfaceFlinger 返回来要求合成同一组缓冲区，HWC 可以继续显示先前合成的暂存缓冲区。这可以延长闲置设备的电池续航时间。</li><li>运行 Android 4.4 或更高版本的设备通常支持 4 个叠加平面。尝试合成的层数多于叠加层数会导致系统对其中一些层使用 GLES 合成，这意味着应用使用的层数会对能耗和性能产生重大影响。 </li></ol><p>——– 引用自<a href="https://source.android.google.cn/devices/graphics/arch-sf-hwc.html?authuser=0&hl=de" target="_blank" rel="noopener">SurfaceFlinger 和 Hardware Composer</a></p><p>我们继续接着看 SurfaceFlinger 主线程的部分，对应上面步骤中的第三步，下图可以看到 SurfaceFlinger 与 HWC 的通信部分<br><img src="/images/15823673746926.jpg" alt="-w1149"></p><p>这也对应了最上面那张图的后面部分<br><img src="/images/15823674500263.jpg" alt="-w563"></p><p>不过这其中的细节非常多，这里就不详细说了。至于为什么要提 HWC，因为 HWC 不仅是渲染链路上重要的一环，其性能也会影响整机的性能，<a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/#3-WHC-Service-%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a> 这篇文章里面就有列有 HWC 导致的卡顿问题（性能不足，中断信号慢等问题）</p><p>想了解更多 HWC 的知识，可以参考这篇文章<a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">Android P 图形显示系统（一）硬件合成HWC2</a>,当然，作者的<a href="https://www.jianshu.com/nb/28304383" target="_blank" rel="noopener">Android P 图形显示系</a>这个系列大家可以仔细看一下</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">Android P 图形显示系统（一）硬件合成HWC2</a></li><li><a href="https://www.jianshu.com/nb/28304383" target="_blank" rel="noopener">Android P 图形显示系统</a></li><li><a href="https://source.android.google.cn/devices/graphics/arch-sf-hwc.html?authuser=0&hl=de" target="_blank" rel="noopener">SurfaceFlinger 的定义</a></li><li><a href="https://github.com/openthos/display-analysis/blob/master/repo/android%E5%90%AF%E5%8A%A8%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%9B%B8%E5%85%B3log%E6%8A%A5%E5%91%8A/surface%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3.md" target="_blank" rel="noopener">surfacefliner</a></li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发者学习路线(2020 版本)</title>
      <link href="/2020/02/03/android-development-learning-path-2020-edition/"/>
      <url>/2020/02/03/android-development-learning-path-2020-edition/</url>
      
        <content type="html"><![CDATA[<p>Medium 上 @MindOrks 发布了一篇 <a href="https://medium.com/mindorks/android-development-learning-path-2020-edition-3f464ac56dbf" target="_blank" rel="noopener">2020 年 Android 程序员的学习线路</a>，鉴于一部分人无法阅读原文(你懂得原因)，我把这篇文章的内容结合自己的 2020 年的学习计划，一起发出来，给大家一个参考</p><p><strong>原文比较简单，并没有介绍为什么要推荐这些，只是单纯地列了一下知识点，我这边针对每个知识点做一些简单的介绍，有些知识点原文并没有提到，我会根据自己的理解加上，仅供参考</strong></p><p>这篇文章主要针对 Android 开发者，如果你是新手，那么下面的内容可以帮助你找到学习的线路；如果你是老手，这篇文章列出的内容也可以帮助你查漏补缺。如果各位有什么其他的建议，欢迎留言交流</p><a id="more"></a><h1 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Java 是 Android App 开发默认的语言, Android Framework 也是默认使用 Java 语言，熟练掌握 Java 语言是 Android 开发者的必备技能。</p><p>希望深入 Java 虚拟机的同学，也可以参考下面两本书：</p><ol><li>周志明的<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机（第3版）》</a></li><li>邓老师的 <a href="https://book.douban.com/subject/33390277/" target="_blank" rel="noopener">《深入理解Android Java 虚拟机 ART》</a></li></ol><h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><p>Google 几年前就开始走 “Kotlin First” 的路线，目前很多官方的文档和 Demo 都是使用 Kotlin 语言作为默认，Kotlin 的重要性不言而喻。</p><p>Google 官方也出了个<a href="https://clmirror.storage.googleapis.com/codelabs/java-to-kotlin-zh/index.html#0" target="_blank" rel="noopener">“Refactoring to Kotlin”</a>的教程,其介绍如下：</p><blockquote><p>此 Codelab 的适用对象为任何使用 Java 并考虑将其项目迁移到 Kotlin 的开发者。我们将从数个 Java 类入手，引导您使用 IDE 将它们转换为 Kotlin。接着，我们会审视转换后的代码，研究如何加以改善，使其更符合使用习惯，同时避免常见错误</p></blockquote><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter</a> 作为 Google 的亲儿子，其官方的扶持力度大家有目共睹。 Flutter 于几天前发布了<a href="https://github.com/flutter/flutter/releases/tag/v1.12.13%2Bhotfix.7" target="_blank" rel="noopener">v1.12.13_hotfix.7</a> 版本，修复了几个比较严重的 Bug，如<a href="https://juejin.im/post/5e369be9f265da3e272912dc" target="_blank" rel="noopener">Flutter 1.12 最新 hotfix 与 2020 路线计划</a> 这篇文章介绍所述，“v1.12.13+hotfix.7 版本主要在于解决了我比较关心的三个问题，包括： reportFullyDrawn 异常、华为手机上崩溃、光标和键盘输入异常 这几个问题。”.感兴趣也可以看一下其 1 月 30 号发布的 <a href="https://github.com/flutter/flutter/wiki/Roadmap" target="_blank" rel="noopener">2020 Roadmap</a></p><p>Flutter 的发展大家可以看一下 Gityuan 的这一篇<a href="http://gityuan.com/flutter/" target="_blank" rel="noopener">Flutter 跨平台演进及架构开篇</a>,目前字节跳动的多个 App 已经接入 Flutter 进行混合开发。个人对 2020 年 Flutter 不再持观望态度，读者可以根据自己的技术规划决定是否开始学习</p><h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><h2 id="Android-Studio-IDE-Overview"><a href="#Android-Studio-IDE-Overview" class="headerlink" title="Android Studio IDE Overview"></a>Android Studio IDE Overview</h2><p>Android Studio 作为 Android 默认的开发者工具，目前的版本更新已经解决了诸多之前的性能问题，虽然目前对硬件资源的要求仍然比较高，但是一旦你接受了这个设定，真香预警！</p><p>AS 主要需要熟悉下面几点</p><ol><li>AS 快捷键</li><li>AS 插件</li><li>AS Profile （内存、CPU、IO、NetWork）</li></ol><h2 id="Project-Structure-—-Java-Kotlin-Flutter-XML-gradle-files"><a href="#Project-Structure-—-Java-Kotlin-Flutter-XML-gradle-files" class="headerlink" title="Project Structure — Java/Kotlin/Flutter, XML, .gradle files"></a>Project Structure — Java/Kotlin/Flutter, XML, .gradle files</h2><p>熟悉各种项目的目录结构，资源文件、Gradle 文件</p><h1 id="Android-基础知识"><a href="#Android-基础知识" class="headerlink" title="Android 基础知识"></a>Android 基础知识</h1><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><p>这部分不必做过多的解释，下面列出的就是大家熟悉的 Android 四大组件，Android 开发的基础</p><ol><li>Activity — Activity Lifecycle, Tasks &amp; Back Stack</li><li>Service</li><li>Broadcast Receiver</li><li>Content Provider</li></ol><h2 id="Intents"><a href="#Intents" class="headerlink" title="Intents"></a>Intents</h2><ol><li>Types of Intent - Implicit, Explicit</li><li>Intent Filter</li></ol><h2 id="Static-User-Interface"><a href="#Static-User-Interface" class="headerlink" title="Static User Interface"></a>Static User Interface</h2><ol><li>View — Button, ImageView, TextView, EditText, and etc :这是开发中会遇到的常用的组件，许多复杂的布局都是用简单基础的 View 组合而成</li><li>ViewGroup - LinearLayout, RelativeLayout, FrameLayout:三大传统布局，适用于不同的场合</li><li>ConstraintLayout : Google 新推的布局，目前已经取代 RelativeLayout 成为默认的 App 布局，具体使用可以参考<a href="https://developer.android.google.cn/reference/android/support/constraint/ConstraintLayout?hl=zh-cn" target="_blank" rel="noopener">官方文档</a></li></ol><h2 id="Dynamic-User-Interface"><a href="#Dynamic-User-Interface" class="headerlink" title="Dynamic User Interface"></a>Dynamic User Interface</h2><ol><li>RecyclerView - 列表类的布局首选控件，性能相对 ListView 要好一些，功能也比 ListView 要多一些</li><li>ViewPager</li><li>Spinner</li></ol><h2 id="CustomView"><a href="#CustomView" class="headerlink" title="CustomView"></a>CustomView</h2><p>Android 默认的布局很多时候都没法满足设计的需求，这时候就需要自定义 View，你需要掌握下面几个知识点的使用</p><ol><li>Canvas</li><li>Bitmap</li><li>Paint</li></ol><h2 id="UI-Resources"><a href="#UI-Resources" class="headerlink" title="UI Resources"></a>UI Resources</h2><p>相比 HardCode，使用资源文件会让代码的可修改性更高</p><ol><li>Drawables</li><li>String</li><li>Styles</li></ol><h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><p>许多人提倡 App 使用 单 Activity + 多个 Fragment 的组合，可见 Fragment 在开发中的重要性，但是 Fragment 的管理又是一门技术，Fragment 的坑，只能在实际开发中慢慢填平了，不过下面的 Fragment 基础还是要牢固</p><ol><li>Fragment Lifecycle</li><li>Fragment Manager</li></ol><h2 id="Support-User-Interface"><a href="#Support-User-Interface" class="headerlink" title="Support User Interface"></a>Support User Interface</h2><p>这里列的同样是一些功能组件，需要知道这是什么东西，基本的用法</p><ol><li>ProgressBar - 进度条</li><li>Dialogs - 弹框</li><li>Toast &amp; Snackbar - 提示</li></ol><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>App 开发不免要和文件打交道，文件的读写、存储都是必不可少的，下面列出了几种 Android 中存储相关的知识点</p><ol><li>Shared Preferences - 适合存储字段</li><li>File Systems - 文件存储</li><li>Database — RoomDB - 数据库存储，RoomDB 是 Google 新推出的数据库解决方案(在 AndroidX 中)，具体使用可以参考<a href="https://developer.android.google.cn/reference/androidx/room/RoomDatabase.html" target="_blank" rel="noopener">官方文档</a></li></ol><h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>Android App 默认使用 Gradle 进行编译，关于 Gradle 的使用必须要熟悉，以及如何区分开发版本和 Release 版本，以及国内特有的多渠道打包技术、以及 ASM 等</p><ol><li>Gradle</li><li>Debug / Release Configuration</li><li>多渠道打包</li><li>ASM</li></ol><h2 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h2><p>理解 Thread 非常重要，Android App 只有一个主线程，其余的我们称之为工作线程，我们的很多工作需要再工作线程和主线程直接切换，如何高效创建和释放线程、线程池、线程间通信、Message-Looper-Handler 模型这些知识点都要了熟于心，另外进阶的话 Binder 通信也是需要掌握的知识</p><ol><li>Threads</li><li>Handler / Looper / Message / MessageQueue</li><li>AIDL / Binder</li></ol><h1 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h1><p>这里列举了一些 Debug 的基本手段，实际开发中遇到具体问题的时候一般都会用到，不过有的可能入手难度要高一些，需要花时间去掌握。Debug 工具除了下面这几个还有很多</p><ol><li>Memory profiling - MAT，AS Memory Profile </li><li>Logging - Log 包含非常丰富的信息，可以帮助我们还原现场</li><li>Systrace - Systrace 工具可以查看一段时间内手机系统各个进程的运行状态，具体使用可以参考我博客的 <a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 系列教程</a></li><li>Exceptions - 各种异常，保证程序的健壮性</li><li>Error Handling - Error 是必须要解决的问题，一般会导致 App 直接闪退，需要非常重视</li></ol><h1 id="Memory-Leak"><a href="#Memory-Leak" class="headerlink" title="Memory Leak"></a>Memory Leak</h1><p>内存泄漏是一个很大的专题，包括 Java 内容泄漏和 Native 内存泄漏，涉及的知识点非常多，可以单独拿出来做一个大的知识栈。一般来说， Java 内存泄漏会比较好检测和修复，但是 Native 内存泄漏就会比较难。</p><ol><li>Detecting and Fixing Memory Leaks - 内存泄漏检测和修复，是一个比较大的工程，可以参考 LeakCanary、Matrix 等开源工具</li><li>Context - 使用不当会造成该释放的对象没有释放造成内存泄漏</li><li>Native Memory Leaks</li></ol><h1 id="3rd-Party-Library"><a href="#3rd-Party-Library" class="headerlink" title="3rd Party Library"></a>3rd Party Library</h1><p>经典的第三方类库，可以大幅节约我们的开发时间</p><ol><li>Image Loading - Glide, Picasso</li><li>Dependency Injection - Dagger</li><li>Networking - Fast Android Networking Library, Retrofit</li><li>MultiThreading - RxJava, Coroutines</li></ol><h1 id="Data-Format"><a href="#Data-Format" class="headerlink" title="Data Format"></a>Data Format</h1><p>常见的一些数据保存流格式</p><ol><li>JSON — GSON</li><li>Flat Buffer</li><li>Protocol Buffer</li></ol><h1 id="Android-Jetpack"><a href="#Android-Jetpack" class="headerlink" title="Android Jetpack"></a>Android Jetpack</h1><p><a href="https://developer.android.google.cn/jetpack?hl=zh-cn" target="_blank" rel="noopener">Jetpack</a> 是 Google 推出的一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。</p><ol><li>Foundation Components — AppCompat, Android KTX, Multidex</li><li>Architecture Components — LiveData, ViewModel, DataBinding, Paging, Work Manager, Navigation</li><li>Behaviour Components - Download Manager, Media Playback, Notification, Permissions, Preference, Sharing, Slice</li><li>UI Component - Animation &amp; Transition, Android Auto, Emoji, Palette, Android TV, Android Wear</li></ol><h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><p>传统的开发架构，没有绝对的哪个好哪个不好，只有哪个适合哪个不适合，下面三种你都应该知道并有一定的了解</p><ol><li>MVVM - MVVM 是 Model-View-ViewModel的简写。它本质上就是 MVC 的改进版。MVVM 就是将其中的 View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开</li><li>MVI ？</li><li>MVP - MVP 从更早的 MVC 框架演变过来，与 MVC 有一定的相似性：Controller/Presenter 负责逻辑的处理，Model 提供数据，View 负责显示</li></ol><h1 id="Unit-Testing"><a href="#Unit-Testing" class="headerlink" title="Unit Testing"></a>Unit Testing</h1><ol><li>Local Unit Testing</li><li>Instrumentation Testing</li></ol><h1 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h1><p>Firebase 国内很多开发者用不到，这里简单看一下即可（说不定哪天国内就可以用了呢）</p><ol><li>FCM</li><li>Crashlytics</li><li>Analytics</li><li>Remote Config</li><li>App Indexing</li><li>Dynamic Link</li></ol><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><p>安全方面接触毕竟多的应该是加密、解密、混淆等，毕竟用户数据安全大于一切，不重视这个欧盟会教你做人</p><ol><li>Encrypt / Decrypt</li><li>Proguard</li><li>R8</li></ol><h1 id="App-Release"><a href="#App-Release" class="headerlink" title="App Release"></a>App Release</h1><p>应用发布相关的知识，国内还得加上多渠道打包、插件化</p><ol><li>.keystore file</li><li>App Bundle</li><li>Playstore</li><li>多渠道打包</li><li>插件化</li></ol><h1 id="Keep-Learning-and-Improving"><a href="#Keep-Learning-and-Improving" class="headerlink" title="Keep Learning and Improving"></a>Keep Learning and Improving</h1><p>作为一个有进取心的 Android 开发者，拥有自己的技术栈和规划非常重要，技术栈确保你有足够的市场竞争力，从而形成护城河；技术规划则可以给你一个明确的学习目标。卸载抖音、微博、斗鱼、游戏吧，做好 2020 年的规划，<strong>Keep Learning and Improving</strong> ，共勉</p><p>如果你苦于没有好的时间管理方法，可以参考这个视频<a href="https://www.bilibili.com/video/av79348217" target="_blank" rel="noopener">我是怎么做周计划 | 生产力提升 | 我的方法</a>,这个是我熟悉的一个大佬的工作学习方法实践，推荐给大家</p><blockquote><p>凡是预则立，不预则废，年度计划太长，日计划又太短。实践下来发现以周为单位做时间管理（时间管理）最靠谱，既考虑了短期又考虑了长期，可以使自己长期坚持做某事，也有一定的时间长度用来甄有价值的事情。</p></blockquote><h1 id="本文其他地址"><a href="#本文其他地址" class="headerlink" title="本文其他地址"></a>本文其他地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎或者掘金页面</p><p><a href="https://zhuanlan.zhihu.com/p/104878641" target="_blank" rel="noopener">知乎 - Android 开发者学习路线（2020 版)</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 2020 年读书单</title>
      <link href="/2020/01/28/2020-read/"/>
      <url>/2020/01/28/2020-read/</url>
      
        <content type="html"><![CDATA[<p>下面记录了我 2020 年的读书单，所记录的，都是已经读完了的，技术书籍由于很难定义读完，所以不在此列。</p><p>我比较喜欢读历史相关的书，其中 <strong>汴京之围</strong> 这本书读起来非常难受，弱国无外交，真的是写实；<strong>坏小孩</strong> 书如其名，个人感觉是要比电视剧好很多；<strong>重来 2</strong> 和 <strong>重来 3</strong> 跟工作相关，讲的是远程工作和工作方法，跟 2020 年居家办公的大趋势一致，白领程序员推荐看一下；<strong>我的最后一本减肥书</strong> 则比较系统和专业地讲了一下减肥相关的知识，对于在减肥的我来说很有用；最后 <strong>镖人</strong> 也算是国漫经典了，等出完了之后我一定要买一套实体书典藏（巨人也是）</p><p>2020 读书不多，2021 要加大这方面的投入，<strong>读 + 记录 + 总结</strong> ，读书笔记后续都会补上</p><a id="more"></a><p>目前更新的书单</p><ol><li><input checked="" disabled="" type="checkbox"> 明朝历史的教训</li><li><input checked="" disabled="" type="checkbox"> 汴京之围:北宋末年的外交、战争和人</li><li><input checked="" disabled="" type="checkbox"> Android 高效进阶:从数据到 AI</li><li><input checked="" disabled="" type="checkbox"> 跌荡一百年</li><li><input checked="" disabled="" type="checkbox"> Remote：更为简单高效的远程工作</li><li><input checked="" disabled="" type="checkbox"> 鱼翅与花椒</li><li><input checked="" disabled="" type="checkbox"> 重来 2</li><li><input checked="" disabled="" type="checkbox"> 生来有罪</li><li><input checked="" disabled="" type="checkbox"> 低智商犯罪</li><li><input checked="" disabled="" type="checkbox"> 重来 3</li><li><input checked="" disabled="" type="checkbox"> 长夜难明</li><li><input checked="" disabled="" type="checkbox"> 坏小孩</li><li><input checked="" disabled="" type="checkbox"> 两京十五日</li><li><input checked="" disabled="" type="checkbox"> 永久记录</li><li><input checked="" disabled="" type="checkbox"> 我的最后一本减肥书</li><li><input checked="" disabled="" type="checkbox"> 镖人</li><li><input checked="" disabled="" type="checkbox"> 大中东行纪</li></ol><!-- more --><h1 id="明朝历史的教训"><a href="#明朝历史的教训" class="headerlink" title="明朝历史的教训"></a>明朝历史的教训</h1><p><img src="/images/15802103247651.jpg" alt="明朝历史的教训"></p><p>首先介绍一下作者，这样大家读书的时候，就会有一定的带入感</p><blockquote><p>吴晗，原名吴春晗，字辰伯。历史学教育家。浙江义乌人。1957 年加入中国共产党。1934 年毕业于清华大学。后任云南大学、西南联合大学教授，清华大学教授、系主任、文学院院长。1943 年参加中国民主政团同盟，积极从事民主运动。建国后，历任北京市副市长、北京市第一至四届政协副主席、中国科学院哲学社会科学部委员。1958 年当选为民盟中央副主席。是第一至三届全国人大代表，第一届全国下和协委员，第二、三届全国政协常委。生平从事中加古代史研究，对明史的厂家尤有成就。着有《朱元璋传》和历史剧《海瑞罢官》等。「文化大革命」开始后，吴晗从精神到肉体惨遭摧残，随后于 1968 年 3 月被捕入狱，1969 年 10 月 11 日被迫害致死。「文化大革命」结束后，其冤案才得以平反昭雪。</p></blockquote><p>这本明朝历史的教训是一本文章集，内容包括朱元璋的统治之术、统治阶级的内部矛盾、东西厂和锦衣卫、国民生活、党争、农民、奴隶和兵变、仕宦阶级、流寇等。如果说「明朝那些事」讲的是历朝大人物的事情，那么这本书则从另外一个角度，带我们了解明朝从统治阶级到被统治阶级的各种乱象，很多章节互相独立却又互相联系，可以说晚明时期的内忧外患，并非简单的清人入侵和流寇四起这么简单，这个朝代从顶到根就已经坏了，不是一两个人能救得来的</p><p>这本书微信读书上有，推荐。</p><h1 id="汴京之围：北宋末年的外交、战争和人"><a href="#汴京之围：北宋末年的外交、战争和人" class="headerlink" title="汴京之围：北宋末年的外交、战争和人"></a>汴京之围：北宋末年的外交、战争和人</h1><p><img src="/images/15802109582858.jpg" alt="汴京之围：北宋末年的外交、战争和人"></p><p>你肯定听过「靖康之耻」，本书就是详细描写靖康之耻产生的前因后果，说实话看之前并没有对这段历史有详细的了解，看了之后才觉得，叫靖康之耻真的是一点没错，尤其是军队一碰就没，谈判背信弃义，<strong>围城大半年对首都汴京一遍又一遍的搜刮</strong>，看着又气又无可奈何，没有实力就会被欺负，这个亘古不变的真理，历史上一次又一次的实践，从盛世到灭亡只花了三年……文中有一段话我很喜欢「<strong>它提醒我们居安思危，在任何时候，危机和盛世只差一步而已。和平并不是一种必然，它要求我们怀着谦卑的心态去看待世界，学习世界所长的同时，避免自大与狂傲。更重要的是，必须有意识地避免战争，谦卑不是错，错判了形势才是最可怕的，因为任何形势都是环环相扣的，一旦迈出了第一步，不仅无法回头，而且也无法把握未来的走向了</strong>」</p><blockquote><p>本书追溯北宋末年靖康之难的完整历史细节，讲述宋、辽、金三方的和与战，聚焦北宋历史大变局的关键时刻，以及帝国由内而外全局性危局大爆发的前因后果。北宋宣和年间，帝国上下一片繁荣景象，然而盛世之下的隐患已成暗涌。财政困难、军事痼疾、恶性党争等内部危机，北方辽、金两国的军事威胁等外部危机，使得帝国渐成风雨飘摇之势。为「收复」作为战略屏障的燕云十六州，宋徽宗决定联金灭辽。宋金联盟虽然逐渐将辽国蚕食，但金国借此窥见北宋的虚弱，加之两国复杂的利益纠纷，金国转而南下攻宋。靖康元年（1126），金军第二次围攻汴京，十一月汴京城陷。北宋轰然崩溃，从盛世到灭亡仅隔三年。作者以兼顾宋、辽、金三方立场的史料记载为基础，用通俗流畅的叙事笔法，试图复盘靖康之难历史发生的过程，探寻北宋盛衰之变背后的深层成因，以及超越时代的镜鉴意义。</p></blockquote><p>这本书微信读书上有，推荐。</p><h1 id="Android-高效进阶：从数据到-AI"><a href="#Android-高效进阶：从数据到-AI" class="headerlink" title="Android 高效进阶：从数据到 AI"></a>Android 高效进阶：从数据到 AI</h1><p><img src="/images/15802098163281.jpg" alt="Android 高效进阶：从数据到 AI"></p><p>《Android 高效进阶：从数据到 AI》是一本 Android 进阶技术与实践应用相结合的书籍，主要从 3 个方面来组织内容。第一个方面，Android 工程构建体系实践与进阶，其中不仅包含了移动数据技术、工具基建进阶、效能进阶，还包含了工具应用进阶、工程构建进阶等内容；第二个方面，对当前移动端前沿技术的探索，包含容器技术、大前端技术和 AI 技术；第三个方面，移动应用的安全攻防技术和设计模式进阶实践。本书内容全面，侧重实战经验和进阶技能，通过本书不仅能学到最新的移动端技术，以及进阶技术与实践应用相结合的知识，更重要的是能领悟到作者对技术的钻研精神和思维方式，从而帮助 Android 开发者高效进阶</p><p>《Android 高效进阶：从数据到 AI》适合移动应用开发者、Android 系统开发人员、Android 系统安全工程师，以及 Android 领域的移动技术负责人阅读</p><p>从书的内容来看，作者是一名经验丰富的开发者，很多专题都有比较详细的架构实现，读者可以根据这些架构实现一套，是一本不可多得的经验之书，这本书在微信读书可看</p><h1 id="跌荡一百年"><a href="#跌荡一百年" class="headerlink" title="跌荡一百年"></a>跌荡一百年</h1><p><img src="/images/15890825861013.jpg" alt=""></p><p>作者吴晓波从商业的角度，来展示了近代一百年来的中国的发展。作者提到发展中的三个现象：：一是意识形态争论对现代化的干扰，二是中央集权观念对国家商业主义的催生，三是传统的轻商和官商文化对新生企业家阶层的影响。让人叹息的是，在洋务运动后的多次经济变革运动中，这三个命题都幽灵般地随影而至，无法摆脱。</p><p>读完个人感受是：国家稳定对商业发展太重要的，我国近代起政局非常不稳定，商业的发展总是随着政局的变化而兴起和衰落；改革开放前的商业基本上停滞了。可以说我国的商业和科技发展是从改革开放后基本上从 0 开始发展的，与稳定发展了一百多年的美国的差距是非常巨大的，这一点是我看完这本书最大的感慨，虽然存在技术共享和技术爆炸，但是我们国家掌握的核心技术还是太少了。</p><blockquote><p>在这100多年的时间里，苦难让我们有机会凝神思索，学到不少东西。它使中国人得以细细体察所历之事，对千年历史进行更严苛的观察，若非受辱，我们对之也许根本不会留心，还沉浸在骄傲的大国幻境之中。<br>自1840年鸦片战争之后，有一个词汇覆盖了所有的主题，它成为无数热血国人的毕生理想，这就是“强国”。“强国”的急迫，让这个国家变得无比的焦虑，有时候甚至显得迫不及待，在一条道路还没有完全考察清楚的时候，便不惜铤而走险。在很多敏感关键的时刻，渐进式的思想往往被视为“反动”，颠覆式革命，甚至流血暴力，成为全民性的选择。百年春秋，闹剧、悲剧与喜剧交织上演。<br>在这个被“强国梦”激励着的100年里，中国的复兴开始于一个幽暗而绝望的梦醒时刻。商业的演进一直是国家进步和民族雪耻的重要方向，正是在这一进程中，新兴的企业家阶层崛起为一支独立的力量。而他们的曲折命运又与这个国家的政治变革和全民抉择纠缠在一起，它们时而合一，时而决裂，却在绝大多数时间里处在不和谐的状态中。百年以来，中国经济的问题，归根到底可以总结为三个利益关系的调整：一是政府利益与公众利益的调整，二是中央政府与地方政府利益的调整，三是富裕公众与贫穷公众的利益调整。作为富裕公众的代表阶层，企业家集团在与政府（包括中央政府及地方政府）、知识分子和贫穷公众的关系相处上，一直没有达成原则性和建设性的共识，这也成为中国商业进步总是被各种事件打断的重要原因之一。</p></blockquote><h1 id="Remote-更为简单高效的远程工作方式"><a href="#Remote-更为简单高效的远程工作方式" class="headerlink" title="Remote : 更为简单高效的远程工作方式"></a>Remote : 更为简单高效的远程工作方式</h1><p><img src="/images/15929815335750.jpg" alt="Remote"></p><p>这本书叫 Remote, 国内翻译成了重来2, 简直是瞎比翻译. </p><p>本书作者是 37Signals 两位创始人, 书中介绍了远程工作的方方面面, 包括远程工作的优点、远程工作中如何协作、远程工作的副作用、远程工作中的员工管理、远程工作中的自我管理等. 2020 年的一场新冠病毒, 使得大部分公司都尝试了一把远程工作, 这本书中所提到的一些事情, 在实际远程工作中也都有遇到.</p><p>摘抄其中一些, 大家可以品品</p><blockquote><p>真正重要的是把工作做好，而不是死守着上下班时间</p></blockquote><blockquote><p>新时代的奢侈就是摆脱“日后再享受生活”的思维桎梏，现在就去做你热爱的事，跟工作并行。何必要把时间浪费在那种“等我退休了，生活该有多美好”的白日梦上？在工作跟退休之间划一道界限，这其实是相当武断的。你的人生无须再遵循这样的规则。你可以把这两样混合在一起，既有趣又有钱挣——设计一种更好的、能把工作变得有趣的生活方式，因为工作不是这辈子唯一的事。那副金手铐令你没法过上你真心想过的人生，快从怨恨的情绪中解脱出来吧！</p></blockquote><blockquote><p>当你没法整天盯着某人的时候，唯一的判断标准就是工作成果。除此之外的一大堆琐碎标准全都不见了。你只需看工作成果，因此，你不必问远程工作的员工“你今天都做了些什么”，而是说一句“把你今天的成果给我看看”就行</p></blockquote><blockquote><p>当开会成为常态，成为探讨、争论的必备工具，无论解决什么问题都要用一用的时候，它就被滥用了，人人都变得麻木。会议应该像盐，小心翼翼地在菜品上洒上一点儿，用于提味，而不是一勺一勺地哗哗倒上许多。盐放得太多，菜就毁了；会开得太多，人们的士气和积极性就会降低</p></blockquote><blockquote><p>如果你没能好好地掌握生活与工作的平衡，远程工作的自由就会变成奴役。这种情况是可能的，因为当你从朝九晚五的工作中解脱出来之后，很容易又会套上全天不停工作的枷锁</p></blockquote><blockquote><p>远程工作把罩幕揭开，让人们看到一个一直存在却并不是总被人承认或被人看到的事实：优秀的远程员工就是优秀的员工，就是这么简单</p></blockquote><blockquote><p>内在动力：程序员编写开源软件，一般都是因为热爱这件事，不是为了钱。钱往往会相伴而来，但它极少是动力来源。也就是说，当你在解决一个特别感兴趣的、令你兴奋激动的问题的时候，你根本不需要有管理者经常从你背后伸脖子过来看看你是否在干活。<br>一切公开：绝大多数开源软件都是通过邮件列表和 GitHub 这样的代码追踪系统来协调运作的。只要有人想出手帮忙，就能做到，因为所有的信息都是公开的。你可以自告奋勇地参与进来，对某块内容最精通的人很容易就能切入。</p></blockquote><h1 id="鱼翅与花椒"><a href="#鱼翅与花椒" class="headerlink" title="鱼翅与花椒"></a>鱼翅与花椒</h1><p><img src="/images/15929848508400.jpg" alt="鱼翅与花椒"></p><p>作者<strong>扶霞·邓洛普</strong> Fuchsia Dunlop 在牛津长大，于剑桥大学取得英国文学学士学位，其后于伦敦亚非学院以名列前茅的优异成绩获得中国研究硕士学位。一九九四年，扶霞在获得了英国文化协会奖学金补助后，前往中国四川大学就读一年；其后又在四川烹饪高等专科学校接受了三个月的专业厨师训练，成为该校第一位外国学生</p><p>这本鱼翅与花椒，本来是怀着轻松的心情去读的，本书的前半部分气氛确实也是很轻松愉快，跟着作者在成都的大街小巷里面寻找家常菜，每一节之后还有一个家常菜的菜谱，作者对成都生活的描写也让人觉得惬意：</p><blockquote><p>这个地方本身那种慢悠悠的倦怠感也令人不知不觉地被影响。在成都这个城市，别说实现计划了，制定计划都根本不可能。从唐朝开始，这里就以生活安逸闲适著称。因为气候适宜，土壤更是传奇般地肥沃。成都人不用特别努力地工作也能吃得好、玩儿得开心。这座城市有点南方的感觉，甚至都有点像地中海沿岸了。成都人的脚步都比北京人或上海人要慢。他们在茶馆里一坐就是一下午加一晚上，打麻将、打牌、用节奏舒缓、语气甜腻的四川话开玩笑斗嘴，韵母都拖得长长的，还要加上娇俏的儿化音。他们把这叫做“摆龙门阵”，四川特有的谈天说地。而四川话里最生动的一句方言莫过于“好耍（特别有趣）”。他们说的时候总是懒洋洋的声气，咧嘴而笑，竹椅子发着嘎吱嘎吱的背景音。“沿海的那些人，”一位出租车司机跟我聊起广东人和福建人，“他们野心大得很，也肯干，所以他们就先富起来了噻。我们四川人喃，挣的钱可以吃香喝辣就够了。”</p></blockquote><p>书中描述的菜品有成都的家常菜、香港的粤菜、湖南的湘菜、扬州的江浙菜，不过由于作者四川呆的时间比较久，所以川菜和四川生活出现的更多一些，各地的美食各有特色，光看作者的描述，就能感觉到那扑鼻的香味</p><p>不过书的后半段也探讨了食品安全问题、吃野味、吃保护动物，以及中国官场的一些事情，越看越沉重，却也无能为力. 城市在变，社会在变，人也在变，事物也在变，作者再一次来到巨变后的成都，以一种旁观者的身份记录了这些变化：</p><blockquote><p>一方面，这样的拆除实在是个悲剧，是我个人的悲剧：竟然爱上了一个正如此迅速地消失着的地方。我对饮食烹饪的研究，初衷是想记录一个生机勃勃的城市。后来我才明白，从很多角度来说，我都在书写老成都的“墓志铭”。我感觉这也是成都人的悲剧，虽然他们并没有意识到。这个城市是多么迷人、多么独特啊，现在要用一个中国任何地方都存在的城市取而代之，暴殄天物、可悲可叹。</p></blockquote><blockquote><p>另一方面，九十年代的中国似乎又洋溢着满满的生机与乐观。之前那种功利主义、禁欲主义、千篇一律的呆板与单调乏味消失不见。全国上下都在动起来，十二亿人团结一心、一致向前。在英国，哪怕拆除一栋破旧的老楼，我们都会烦恼苦闷。而在四川，他们一路挥舞大锤，把整座城市都拆平了！这无所顾忌的信心让人不得不佩服。他们坚信，未来会比过去更好。</p></blockquote><blockquote><p>所以，尽管经过那些被夷为平地的街道时我的心还是会痛，但同时又被这充满活力的乐观鼓动着、躁动着。我也处在一种不稳定的状态，我的人生也在改变。我在挖掘潜在的创造力、在交很棒的朋友，像一条蛇一样慢慢蜕皮。</p></blockquote><h1 id="天生有罪"><a href="#天生有罪" class="headerlink" title="天生有罪"></a>天生有罪</h1><p><img src="/images/15946504381924.jpg" alt="天生有罪"></p><blockquote><p>出生不由自己，但人生可以</p></blockquote><p>因为 Daily Show 所以开始关注崔娃，这本书是崔娃的自传，名字起得就很让人困惑，什么叫天生有罪？之前对于非洲历史没有什么关注， 看了这本书之后才知道，天生有罪指的是非洲的种族隔离时期，黑人和白人是不能在一起的，更别说生小孩，但崔娃就是白人父亲和黑人母亲的儿子，所以说他天生就是有罪的.</p><p>贯穿文章的两个大的主题，一个是种族隔离，一个是种族认同。非洲白人统治时期实行种族隔离，这种隔离不仅仅是人的隔离，还包括语言隔离、文化隔离、思想隔离，甚至还有黑人部落之间的隔离；另外一个就是种族认同，崔娃在当地属于有色人种，属于那种既不被黑人团体容纳，也不被白人团体容纳，印度人、中国人也会自己抱团。这时候对于一个孩子来说，跟谁抱团玩（获得哪个团队的认同）是非常重要的事情，从小崔娃就被各个团体隔离，但是他在母亲和知识中找到了在各个种族和团体之间的生存之道，最终成为一位成功的喜剧演员、脱口秀表演者、电视电台节目主持人。</p><blockquote><p>种族隔离代表着一个警察国家，一个让黑人处于绝对控制下的各种法条和监视系统。若能将所有法条写下来堆到一起，那需要用掉三千多张纸，可重达五千克。但是南非种族隔离的精髓对美国人来说是非常容易理解的，在美国历史上，曾经发生过三件事：把原住民驱赶到保留地、黑人奴隶制、隔离制度。想象一下，这三件事在同一时间内发生在同一群人身上，那就是种族隔离。</p></blockquote><blockquote><p>我找到了我的位置。既然我不属于任何一个小圈子，那么我可以在不同的圈子之间游走。我还是一条变色龙，文化上的变色龙。我知道如何去融入。我可以和爱运动的小孩一起运动，和书呆子一起讨论电脑。我可以跳进人群里，和小镇男孩一起跳舞。我可以和每个人都产生短暂的交集，一起学习、聊天、讲笑话、送餐。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 - CPU Info 解读</title>
      <link href="/2019/12/21/Android-Systrace-CPU/"/>
      <url>/2019/12/21/Android-Systrace-CPU/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第十二篇，主要是对 Systrace 中的 CPU 信息区域(Kernel)进行简单介绍，简单介绍了如何在 Systrace 中查看 Kernel 模块输出的 CPU 相关的信息，了解 CPU 频率、调度、锁频、锁核相关的信息</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="CPU-区域图例"><a href="#CPU-区域图例" class="headerlink" title="CPU 区域图例"></a>CPU 区域图例</h1><p>下面是高通骁龙 845 手机 Systrace 对应的 Kernel 中的 CPU Info 区域（底下的一些这里不讲，主要是讲 Kernel  CPU 信息）</p><p><img src="/images/15769147700353.jpg" alt="CPU 区域图例"></p><p>Systrace 中 CPU Info 一般在最上面，里面经常会用到的信息包括：</p><ol><li>CPU 频率变化情况</li><li>任务执行情况</li><li>大小核的调度情况</li><li>CPU Boost 调度情况</li></ol><p>总的来说，Systrace 中的 Kernel CPU Info 这里一般是看任务调度信息，查看是否是频率或者调度导致当前任务出现性能问题，举例如下：</p><ol><li>某个场景的任务执行比较慢，我们就可以查看是不是这个任务被调度到了小核？</li><li>某个场景的任务执行比较慢，当前执行这个任务的 CPU 频率是不是不够？</li><li>我的任务比较特殊，比如指纹解锁，能不能把我这个任务放到大核去跑？</li><li>我这个场景对 CPU 要求很高，我能不能要求在我这个场景运行的时候，限制 CPU 最低频率？</li></ol><p>与 CPU 运行信息相关的内容在 <a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 – 分析 Systrace 预备知识</a> 这篇文章里面有详细的讲解，不熟悉的同学可以配合这篇文章一起食用</p><h1 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h1><p>简单来说目前的手机 CPU 按照核心数和架构来说，可以分为下面三类：</p><ol><li>非大小核架构</li><li>大小核架构</li><li>大中小核架构</li></ol><p>目前的大部分 CPU 都是大小核架构，当然也有一些 CPU 是大中小核架构，比如高通骁龙 855\865，也有少部分 CPU 是非大小核架构</p><p>下面就来说说各种架构的区别，方便大家后续查看 Systrace</p><p><img src="/images/15769147794281.jpg" alt="大小核架构"></p><h2 id="非大小核架构"><a href="#非大小核架构" class="headerlink" title="非大小核架构"></a>非大小核架构</h2><p>很早的机器 CPU 只有双核心或者四核心的时候，一般只有一种核心架构，也就是说这四个核心或者两个核心是同构的，相同的频率，相同的功耗，一起开启或者关闭；有些高通的中低端处理器也会使用同构的八核心处理器，比如高通骁龙 636</p><p>现在的大部分机器已经不使用非大小核的架构了</p><h2 id="大小核架构"><a href="#大小核架构" class="headerlink" title="大小核架构"></a>大小核架构</h2><p>现在的 CPU 一般采用 8 核心，八个核心中，CPU 0-3 一般是小核心，CPU 4-7，如下图中 Systrace 中就是按照这个排列的</p><p>小核心一般来说主频低，功耗也低，使用的一般是 arm A5X 系列，比如高通骁龙 845，小核心是由四个 A55 (最高主频 1.8GHz ) 组成</p><p>大核心一般来说最高主频比较高，功耗相对来说也会比较高，使用的一般是 arm A7X 系列，比如高通骁龙 845，大核心就是由四个 A75（最高主频 2.8GHz）组成</p><p>下图就是 845 的 CPU</p><p><img src="/images/15769147884550.jpg" alt="845"></p><p>当然大小核架构中还有一些变种，比如高通骁龙 636 (4 小核 + 2 大核）或者高通骁龙 710 (6 小核 + 2 大核），宗旨还是不变，<strong>大核心用来支持高负载场景，小核心用来日常使用，至于够不够用，就看你舍不舍得花银子，毕竟一分价钱一分货，高通爸爸也不是做福利的</strong></p><p>下面这些高通的主流大小核处理器的参数如下</p><p><img src="/images/15769147957115.jpg" alt=""></p><h2 id="大中小核架构"><a href="#大中小核架构" class="headerlink" title="大中小核架构"></a>大中小核架构</h2><p>部分 CPU 比较另辟蹊径，选择了大中小核的架构，比如高通骁龙 855 8 核 (1 个 A76 的大核+3 个 A76 的中核 + 4 个 A55 的小核）和之前的的 MTK X30 10 核 (2 个 A73 的大核 + 4 个 A53 的中核 + 4 个 A35 的小核）以及麒麟 980 8 核 (2 个 A76 的大核 + 2 个 A76 的中核 + 4 个 A55 的小核）</p><p>相比大小核架构，大中小核架构中的大核可以理解为超大核(高通称之为 Gold +) ，这个超大核的个数一般比较少(1-2 个)，主频一般会比较高，功耗相对也会高很多，这个是用来处理一些比较繁重的任务</p><p>下图是 855、845 和麒麟 980 的对比</p><p><img src="/images/15769148033244.jpg" alt=""></p><p>顺带提一嘴，今年的高通骁龙 865 依然是大中小核的架构，大核和中核用的是 A77 架构,小核用的是 A55，大核和中核最高频率不一样，<strong>大核只有一个，主频到 2.8GHz</strong>，不知道 865 Plus 会不会搞到 3GHz</p><p><img src="/images/15769148095558.jpg" alt=""></p><h1 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h1><p>绑核，顾名思义就是<strong>把某个任务绑定到某个或者某些核心上，来满足这个任务的性能需求</strong>：</p><ol><li>任务本身负载比较高，需要在大核心上面才能满足时间要求</li><li>任务本身不想被频繁切换，需要绑定在某一个核心上面</li><li>任务本身不重要，对时间要求不高，可以绑定或者限制在小核心上面运行</li></ol><p>上面是一些绑核的例子，目前 Android 中绑核操作一般是由系统来实现的，常用的有三种方法</p><h2 id="配置-CPUset"><a href="#配置-CPUset" class="headerlink" title="配置 CPUset"></a>配置 CPUset</h2><p>使用 CPUset 子系统可以限制某一类的任务跑在特定的 CPU 或者 CPU 组里面，比如下面，Android 中会划分一些默认的 CPU 组，厂商可以针对不同的 CPU 架构进行定制，目前默认划分</p><ol><li>system-background 一些低优先级的任务会被划分到这里，只能跑到小核心里面</li><li>foreground 前台进程</li><li>top-app 目前正在前台和用户交互的进程</li><li>background 后台进程</li><li>foreground/boost 前台 boost 进程，通常是用来联动的，现在已经没有用到了，之前的时候是应用启动的时候，会把所有 foreground 里面的进程都迁移到这个进程组里面</li></ol><p>每个 CPU 架构对应的 CPUset 的配置都不一样，每个厂商也会有不同的策略在里面，比如下面就是一个 Google 官方默认的配置，各位也可以查看对应的节点来查看自己的 CPUset 组的配置</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方默认配置</span></span><br><span class="line">write /dev/CPUset/top-app/CPUs <span class="number">0</span><span class="number">-7</span></span><br><span class="line">write /dev/CPUset/foreground/CPUs <span class="number">0</span><span class="number">-7</span></span><br><span class="line">write /dev/CPUset/foreground/boost/CPUs <span class="number">4</span><span class="number">-7</span></span><br><span class="line">write /dev/CPUset/background/CPUs <span class="number">0</span><span class="number">-7</span></span><br><span class="line">write /dev/CPUset/system-background/CPUs <span class="number">0</span><span class="number">-3</span></span><br><span class="line"><span class="comment">// 自己查看</span></span><br><span class="line">adb shell cat /dev/CPUset/top-app/CPUs</span><br><span class="line"><span class="number">0</span><span class="number">-7</span></span><br></pre></td></tr></table></figure><p>对应的，可以在每个 CPUset 组的 tasks 节点下面看有哪些进程和线程是跑在这个组里面的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell cat /dev/CPUset/top-app/tasks</span><br><span class="line"><span class="number">1687</span></span><br><span class="line"><span class="number">1689</span></span><br><span class="line"><span class="number">1690</span></span><br><span class="line"><span class="number">3559</span></span><br></pre></td></tr></table></figure><p>需要注意每个任务跑在哪个组里面，是动态的，并不是一成不变的，有权限的进程就可以改</p><p>部分进程也可以在启动的时候就配置好跑到哪个进程里面，下面是 lmkd 的启动配置，writepid /dev/CPUset/system-background/tasks 这一句把自己安排到了 system-background 这个组里面</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service lmkd /system/bin/lmkd</span><br><span class="line">    class core</span><br><span class="line">   <span class="built_in"> user </span>lmkd</span><br><span class="line">   <span class="built_in"> group </span>lmkd<span class="built_in"> system </span>readproc</span><br><span class="line">    capabilities DAC_OVERRIDE KILL IPC_LOCK SYS_NICE SYS_RESOURCE BLOCK_SUSPEND</span><br><span class="line">    critical</span><br><span class="line">    socket lmkd seqpacket 0660<span class="built_in"> system </span>system</span><br><span class="line">    writepid /dev/CPUset/system-background/tasks</span><br></pre></td></tr></table></figure><p>大部分 App 进程是根据状态动态去变化的,在 Process 这个类中有详细的定义</p><p>android/os/Process.java</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Default thread group -</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>has meaning with setProcessGroup() only, cannot be used with setThreadGroup().</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>When used with setProcessGroup(), </span>the<span class="markdown"> group of each thread in </span>the<span class="markdown"> process</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>is conditionally changed based on that thread's current priority, as follows:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>threads with priority numerically less than THREAD<span class="emphasis">_PRIORITY_</span>BACKGROUND</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span></span>are<span class="markdown"> moved to foreground thread group.  All other threads </span>are<span class="markdown"> left unchanged.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_DEFAULT = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Background thread group - All threads in</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>this group </span>are<span class="markdown"> scheduled with </span>a<span class="markdown"> reduced share of </span>the<span class="markdown"> CPU.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Value is same as constant SP_BACKGROUND of enum SchedPolicy.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>FIXME rename to THREAD<span class="emphasis">_GROUP_</span>BACKGROUND.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_BG_NONINTERACTIVE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Foreground thread group - All threads in</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>this group </span>are<span class="markdown"> scheduled with </span>a<span class="markdown"> normal share of </span>the<span class="markdown"> CPU.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Value is same as constant SP_FOREGROUND of enum SchedPolicy.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Not used at this level.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> **/</span></span></span><br><span class="line">private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_FOREGROUND = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>System thread group.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> **/</span></span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_SYSTEM = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Application audio thread group.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> **/</span></span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_AUDIO_APP = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>System audio thread group.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> **/</span></span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_AUDIO_SYS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread group for top foreground app.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> **/</span></span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_TOP_APP = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread group for RT app.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> **/</span></span></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_RT_APP = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Thread group for bound foreground services that </span>should</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>have additional CPU restrictions during screen off</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@hide</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> **/</span></span></span><br><span class="line"> public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> THREAD_GROUP_RESTRICTED = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>在 OomAdjuster 中会动态根据进程的状态修改其对应的 CPUset 组， 详细可以自行查看 OomAdjuster 中 computeOomAdjLocked、updateOomAdjLocked、applyOomAdjLocked 的执行逻辑(Android 10)</p><h2 id="配置-affinity"><a href="#配置-affinity" class="headerlink" title="配置 affinity"></a>配置 affinity</h2><p>使用 affinity 也可以设置任务跑在哪个核心上，其系统调用的 taskset， taskset 用来查看和设定“CPU 亲和力”，其实就是查看或者配置进程和 CPU 的绑定关系，让某进程在指定的 CPU 核上运行，即是“绑核”。</p><h3 id="taskset-的用法"><a href="#taskset-的用法" class="headerlink" title="taskset 的用法"></a>taskset 的用法</h3><p><strong>显示进程运行的CPU</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">taskset -p pid</span></span><br></pre></td></tr></table></figure><p>注意，此命令返回的是十六进制的，转换成二进制后，每一位对应一个逻辑 CPU，低位是 0 号CPU，依次类推。如果每个位置上是1，表示该进程绑定了该 CPU。例如，0101 就表示进程绑定在了 0 号和 3 号逻辑 CPU 上了</p><p><strong>绑核设定</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskset -pc <span class="number">3</span>  pid    表示将进程pid绑定到第<span class="number">3</span>个核上</span><br><span class="line">taskset -c <span class="number">3</span> command   表示执行 command 命令，并将 command 启动的进程绑定到第<span class="number">3</span>个核上。</span><br></pre></td></tr></table></figure><p>Android 中也可以使用这个系统调用，把任务绑定到某个核心上运行。部分较老的内核里面不支持 CPUset，就会用 taskset 来设置</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>在 Linux 的调度算法中修改调度逻辑，也可以让指定的 task 跑在指定的核上面，部分厂家的核调度优化就是使用的这种方法，这里就不具体来讲了</p><h1 id="锁频"><a href="#锁频" class="headerlink" title="锁频"></a>锁频</h1><p>正常情况下，CPU 的调度算法都可以满足日常的使用，但是在 Android 中的部分场景里面，单纯依靠调度器，可能会无法满足这个场景对性能的要求。比如说应用启动场景，如果让调度器去拉频率迁核，可能就会有一定的延迟，比如任务先在小核跑，发现小核频率不够，那就把小核频率往上拉，拉上去之后发现可能还是不够，经过几次一直拉到最高发现还是不够，然后把这个任务迁移到中核，频率也是一次一次拉，拉到最高发现还是不够，最好迁移到大核去做。这样一套下来，时间过去不少不说，启动速度也不是最快的</p><p>基于这种情况的考虑，系统中一般都会在这种特殊场景直接暴力拉核，将硬件资源直接拉到最高去运行，比如 CPU、GPU、IO、BUS 等；另外也会在某些场景把某些资源限制使用，比如发热太严重的时候，需要限制 CPU 的最高频率，来达到降温的目的；有时候基于功耗的考虑，也会限制一些资源在某些场景的使用</p><p>目前 Android 系统一般会在下面几个场景直接进行锁频（不同厂家也会自己定制）</p><ol><li>应用启动</li><li>应用安装</li><li>转屏</li><li>窗口动画</li><li>List Fling</li><li>Game</li></ol><p>以 高通平台为例，在 CPU Info 中我们也可以看到锁频的情况</p><p><img src="/images/15769148260464.jpg" alt=""></p><h1 id="CPU-状态"><a href="#CPU-状态" class="headerlink" title="CPU 状态"></a>CPU 状态</h1><p>CPU info 中还有标识 CPU 状态的标记，如下图所示，CPU 状态有 0 ，1，2，3 这四种<br><img src="/images/15769148355062.jpg" alt=""></p><p>之前的 CPU 支持热插拔，即不用的时候可以直接关闭，不过目前的 CPU 都不支持热插拔，而是使用 C-State</p><p>下面是摘抄的其他平台的支持 C0-C4 的处理器的状态和功耗状态，Android 中不同的平台表现不一致，大家可以做一下参考</p><ol><li>C0 状态（激活）<ol><li>这是 CPU 最大工作状态，在此状态下可以接收指令和处理数据</li><li>所有现代处理器必须支持这一功耗状态</li></ol></li><li>C1 状态（挂起）<ol><li>可以通过执行汇编指令“ HLT （挂起）”进入这一状态</li><li>唤醒时间超快！（快到只需 10 纳秒！）</li><li>可以节省 70% 的 CPU 功耗</li><li>所有现代处理器都必须支持这一功耗状态</li></ol></li><li>C2 状态（停止允许）<ol><li>处理器时钟频率和 I/O 缓冲被停止</li><li>换言之，处理器执行引擎和 I/0 缓冲已经没有时钟频率</li><li>在 C2 状态下也可以节约 70% 的 CPU 和平台能耗</li><li>从 C2 切换到 C0 状态需要 100 纳秒以上</li></ol></li><li>C3 状态（深度睡眠）<ol><li>总线频率和 PLL 均被锁定</li><li>在多核心系统下，缓存无效</li><li>在单核心系统下，内存被关闭，但缓存仍有效可以节省 70% 的 CPU 功耗，但平台功耗比 C2 状态下大一些</li><li>唤醒时间需要 50 微妙</li></ol></li></ol><h1 id="Systrace-中的详细信息"><a href="#Systrace-中的详细信息" class="headerlink" title="Systrace 中的详细信息"></a>Systrace 中的详细信息</h1><p>Systrace 我们一般用 Chrome 打开，转换成图形化信息之后更加方便从整体去看，但其实 Systrace 也可以以文本的方式打开，也可以看到一些详细的信息。</p><p>比如下面就是一条标识 CPU 调度的 Message，解析的时候，里面的信息会被解析到各个模块</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appEventThread-8193  [001] d<span class="built_in">..</span>2 1638545.400415: sched_switch: <span class="attribute">prev_comm</span>=appEventThread <span class="attribute">prev_pid</span>=8193 <span class="attribute">prev_prio</span>=97 <span class="attribute">prev_state</span>=S ==&gt; <span class="attribute">next_comm</span>=swapper/1 <span class="attribute">next_pid</span>=0 <span class="attribute">next_prio</span>=120</span><br></pre></td></tr></table></figure><p>详细来看</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appEventThread-<span class="number">8193</span>    <span class="comment">-- 标识 TASK-PID</span></span><br><span class="line">[<span class="number">001</span>]                  <span class="comment">-- 标识是哪个 CPU ，这里是 cpu0</span></span><br><span class="line">d..<span class="number">2</span>                   <span class="comment">-- 这是四个位，每个位分别对应 irqs-off、need-resched、hardirq/softirq、preempt-depth</span></span><br><span class="line"><span class="number">1638545.400415</span>         <span class="comment">-- 标识 delay TIMESTAMP</span></span><br><span class="line">sched_switch ...到最后  <span class="comment">-- 标识信息区，里面包含前一个任务描述，前一个任务的 pid，前一个任务的优先级 ，当前任务，当前任务 pid，当前任务优先级</span></span><br></pre></td></tr></table></figure><p>另外里面仔细看也可以看到许多有趣的输出，可以加深对调度的理解</p><ol><li>sched_waking: comm=kworker/u16:4 pid=17373 prio=120 target_cpu=003</li><li>sched_blocked_reason: pid=17373 iowait=0 caller=rpmh_write_batch+0x638/0x7d0</li><li>cpu_idle: state=0 cpu_id=3</li><li>softirq_raise: vec=6 [action=TASKLET]</li><li>cpu_frequency_limits: min=1555200 max=1785600 cpu_id=0</li><li>cpu_frequency_limits: min=710400 max=2419200 cpu_id=4</li><li>cpu_frequency_limits: min=825600 max=2841600 cpu_id=7</li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/breaksoftware/article/details/79160916" target="_blank" rel="noopener">绑定CPU逻辑核心的利器——taskset</a></li><li><a href="http://www.voidcn.com/article/p-kcjkqmld-bmg.html" target="_blank" rel="noopener">CPU 电源状态</a></li></ol><h1 id="春笋"><a href="#春笋" class="headerlink" title="春笋"></a>春笋</h1><p>拍了张照片，觉得还不错，分享给大家<br><img src="/images/15769151861715.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 - Triple Buffer 解读</title>
      <link href="/2019/12/15/Android-Systrace-Triple-Buffer/"/>
      <url>/2019/12/15/Android-Systrace-Triple-Buffer/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第十一篇，主要是对 Systrace 中的 Triple Buffer 进行简单介绍，简单介绍了如何在 Systrace 中判断卡顿情况的发生，进行初步的定位和分析，以及介绍 Triple Buffer 的引入对性能的影响</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="怎么定义掉帧？"><a href="#怎么定义掉帧？" class="headerlink" title="怎么定义掉帧？"></a>怎么定义掉帧？</h1><p>Systrace 中可以看到应用的掉帧情况，我们经常看到说主线程超过 16.6 ms 就会掉帧，其实不然，这和我们这一篇文章讲到的 Triple Buffer 和一定的关系，一般来说，Systrace 中我们从 App 端和 SurfaceFlinger 端一起来判断掉帧情况</p><h2 id="App-端判断掉帧"><a href="#App-端判断掉帧" class="headerlink" title="App 端判断掉帧"></a>App 端判断掉帧</h2><p>如果之前没有看过 Systrace 的话，仅仅从理论上来说，下面这个 Trace 中的应用是掉帧了，其主线程的绘制时间超过了 16.6ms ,但其实不一定，因为 BufferQueue 和 TripleBuffer 的存在，此时 BufferQueue 中可能还有上一帧或者上上一帧准备好的 Buffer，可以直接被 SurfaceFlinger 拿去做合成，当然也可能没有</p><p><img src="/images/15764245549172.jpg" alt=""></p><p><strong>所以从 Systrace 的 App 端我们是无法直接判断是否掉帧的，需要从 Systrace 里面的 SurfaceFlinger 端去看</strong></p><h2 id="SurfaceFlinger-端判断掉帧"><a href="#SurfaceFlinger-端判断掉帧" class="headerlink" title="SurfaceFlinger 端判断掉帧"></a>SurfaceFlinger 端判断掉帧</h2><p><img src="/images/15764245828175.jpg" alt=""></p><p>SurfaceFlinger 端可以看到 SurfaceFlinger 主线程和合成情况和应用对应的 BufferQueue 中 Buffer 的情况。如上图，就是一个掉帧的例子。App 没有及时渲染完成，且此时 BufferQueue 中也没有前几帧的 Buffer，所以这一帧 SurfaceFlinger 没有合成对应 App 的 Layer，在用户看来这里就掉了一帧</p><p>而在第一张图中我们说从 App 端无法看出是否掉帧，那张图对应的  SurfaceFlinger 的 Trace 如下, 可以看到由于有 Triple Buffer 的存在, SF 这里有之前 App 的 Buffer,所以尽管 App 测一帧超过了 16.6 ms, 但是 SF 这里依然有可用来合成的 Buffer, 所以没有掉帧</p><p><img src="/images/15764245923282.jpg" alt="SurfaceFlinger"></p><h2 id="逻辑掉帧"><a href="#逻辑掉帧" class="headerlink" title="逻辑掉帧"></a>逻辑掉帧</h2><p>上面的掉帧我们是从渲染这边来看的，这种掉帧在 Systrace 中可以很容易就发现；还存在一种掉帧情况叫<strong>逻辑掉帧</strong></p><p><strong>逻辑掉帧</strong>指的是由于应用自己的代码逻辑问题，导致画面更新的时候，不是以均匀或者物理曲线的方式，而是出现跳跃更新的情况，这种掉帧一般在 Systrace 上没法看出来，但是用户在使用的时候可以明显感觉到</p><p>举一个简单的例子，比如说列表滑动的时候，如果我们滑动松手后列表的每一帧前进步长是一个均匀变化的曲线，最后趋近于 0，这样就是完美的；但是如果出现这一帧相比上一帧走了 20，下一帧相比这一帧走了 10，下下一帧相比下一帧走了 30，这种就是跳跃更新，在 Systrace 上每一帧都是及时渲染且 SurfaceFlinger 都及时合成的，但是用户用起来就是觉得会卡. 不过我列举的这个例子中，Android 已经针对这种情况做了优化，感兴趣的可以去看一下 android/view/animation/AnimationUtils.java 这个类，重点看下面三个方法的使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lockAnimationClock</span><span class="params">(<span class="keyword">long</span> vsyncMillis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlockAnimationClock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentAnimationTimeMillis</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>Android 系统的动画一般不会有这个问题，但是应用开发者就保不齐会写这种代码，比如做动画的时候根据<strong>当前的时间(而不是 Vsync 到来的时间)</strong>来计算动画属性变化的情况，这种情况下，一旦出现掉帧，动画的变化就会变得不均匀，感兴趣的可以自己思考一下这一块</p><p>另外 Android 出现掉帧情况的原因非常多，各位可以参考下面三篇文章食用：</p><ol><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 方法论</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 应用篇</a></li></ol><h1 id="BufferQueue-和-Triple-Buffer"><a href="#BufferQueue-和-Triple-Buffer" class="headerlink" title="BufferQueue 和 Triple Buffer"></a>BufferQueue 和 Triple Buffer</h1><h2 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h2><p>首先看一下 BufferQueue，BufferQueue 是一个生产者(Producer)-消费者(Consumer)模型中的数据结构，一般来说，消费者(Consumer) 创建 BufferQueue，而生产者(Producer) 一般不和 BufferQueue 在同一个进程里面</p><p><img src="/images/15764246330689.jpg" alt=""></p><p>其运行逻辑如下</p><ol><li>当生产者(Producer) 需要 Buffer 时，它通过调用 dequeueBuffer（）并指定 Buffer 的宽度，高度，像素格式和使用标志，从 BufferQueue 请求释放 Buffer</li><li>生产者(Producer) 将填充缓冲区，并通过调用 queueBuffer（）将缓冲区返回到队列。</li><li>消费者(Consumer) 使用 acquireBuffer（）获取 Buffer 并消费 Buffer 的内容</li><li>使用完成后，消费者(Consumer)将通过调用 releaseBuffer（）将 Buffer 返回到队列</li></ol><p>Android 通过 Vsync 机制来控制 Buffer 在 BufferQueue 中的流动时机，如果对 Vsync 机制不了解，可以参考下面这两篇文章，看完后你会有个大概的了解</p><ol><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android 基于 Choreographer 的渲染机制详解</a></li></ol><p>上面的流程比较抽象，这里举一个具体的例子，方便大家理解上面那张图，对后续了解 Systrace 中的 BufferQueue 也会有帮助。</p><p>在 Android App 的渲染流程里面，App 就是个生产者(Producer) ，而 SurfaceFlinger 是一个消费者(Consumer)，所以上面的流程就可以翻译为</p><ol><li>当 <strong>App</strong> 需要 Buffer 时，它通过调用 dequeueBuffer（）并指定 Buffer 的宽度，高度，像素格式和使用标志，从 BufferQueue 请求释放 Buffer</li><li><strong>App</strong> 可以用 cpu 进行渲染也可以调用用 gpu 来进行渲染，渲染完成后，通过调用 queueBuffer（）将缓冲区返回到 App 对应的 BufferQueue(如果是 gpu 渲染的话，这里还有个 gpu 处理的过程)</li><li><strong>SurfaceFlinger</strong> 在收到 Vsync 信号之后，开始准备合成，使用 acquireBuffer（）获取 App 对应的 BufferQueue 中的  Buffer 并进行合成操作</li><li>合成结束后，<strong>SurfaceFlinger</strong> 将通过调用 releaseBuffer（）将 Buffer 返回到 App 对应的 BufferQueue</li></ol><p>理解了 BufferQueue 的作用后，接下来来讲解一下 BufferQueue 中的 Buffer </p><p>从上面的图可以看到，BufferQueue 中的生产者和消费者通过 dequeueBuffer、queueBuffer、acquireBuffer、releaseBuffer 来申请或者释放 Buffer，那么 BufferQueue 中需要几个 Buffer 来进行运转呢？下面从单 Buffer，双 Buffer 和 Triple Buffer 的角度分析(注意这里只是从 Buffer 的角度来做分析的, 比如 App 测涉及到 Buffer 的是 RenderThread , 不过由于 RenderThread 与 MainThread 有一定的联系, 比如 unBlockUiThread 执行的时机, MainThread 也会因为 RenderThread 执行慢而被 Block 住)</p><h2 id="Single-Buffer"><a href="#Single-Buffer" class="headerlink" title="Single Buffer"></a>Single Buffer</h2><p>单 Buffer 的情况下，因为只有一个 Buffer 可用，那么这个 Buffer 既要用来做合成显示，又要被应用拿去做渲染</p><p><img src="/images/15764246600451.jpg" alt="Single Buffer"></p><p>理想情况下，单 Buffer 是可以完成任务的（有 Vsync-Offset 存在的情况下）</p><ol><li>App 收到 Vsync 信号，获取 Buffer 开始渲染</li><li>间隔  Vsync-Offset 时间后，SurfaceFlinger 收到 Vsync 信号，开始合成</li><li>屏幕刷新，我们看到合成后的画面</li></ol><p><img src="/images/15764246714403.jpg" alt="Single Buffer"></p><p>但是很不幸，理想情况我们也就想一想，这期间如果 App 渲染或者 SurfaceFlinger 合成在屏幕显示刷新之前还没有完成，那么屏幕刷新的时候，拿到的 Buffer 就是不完整的，在用户看来，就有种撕裂的感觉</p><p><img src="/images/15764246782401.jpg" alt="Single Buffer"></p><p>当然 Single Buffer 已经没有在使用，上面只是一个例子</p><h2 id="Double-Buffer"><a href="#Double-Buffer" class="headerlink" title="Double Buffer"></a>Double Buffer</h2><p>Double Buffer 相当于 BufferQueue 中有两个 Buffer 可供轮转，消费者在消费 Buffer的同时，生产者也可以拿到备用的 Buffer 进行生产操作</p><p><img src="/images/15764246889873.jpg" alt="Double Buffer"></p><p>下面我们来看理想情况下，Double Buffer 的工作流程</p><p><img src="/images/DoubleBufferPipline_NoJank.png" alt="DoubleBufferPipline_NoJank"></p><p>但是 Double Buffer 也会存在性能上的问题，比如下面的情况，App 连续两帧生产都超过 Vsync 周期(准确的说是错过 SurfaceFlinger 的合成时机) ，就会出现掉帧情况</p><p><img src="/images/15764247063129.jpg" alt="Double Buffer"></p><h2 id="Triple-Buffer"><a href="#Triple-Buffer" class="headerlink" title="Triple Buffer"></a>Triple Buffer</h2><p>Triple Buffer 中，我们又加入了一个 BackBuffer ，这样的话 BufferQueue 里面就有三个 Buffer 可以轮转了，当 FrontBuffer 在被使用的时候，App 有两个空闲的 Buffer 可以拿去生产，就算生产过程中有 GPU 超时，CPU 任然可以拿到新的 Buffer 进行生产(<strong>即 SurfaceFling 消费 FrontBuffer，GPU 使用一个 BackBuffer，CPU使用一个 BackBuffer</strong>)</p><p><img src="/images/15764247163985.jpg" alt="Triple Buffer"></p><p>下面就是引入 Triple Buffer 之后，解决了 Double Buffer 中遇到的由于 Buffer 不足引起的掉帧问题</p><p><img src="/images/TripleBufferPipline_NoJank.png" alt="TripleBufferPipline_NoJank"></p><p>这里把两个图放到一起来看，方便大家做对比（一个是 Double Buffer 掉帧两次，一个是使用 Triple Buffer 只掉了一帧）</p><p><img src="/images/TripleBuffer_VS_DoubleBuffer.png" alt="TripleBuffer_VS_DoubleBuffer"></p><h1 id="Triple-Buffer-的作用"><a href="#Triple-Buffer-的作用" class="headerlink" title="Triple Buffer 的作用"></a>Triple Buffer 的作用</h1><h2 id="缓解掉帧"><a href="#缓解掉帧" class="headerlink" title="缓解掉帧"></a>缓解掉帧</h2><p>从上一节 Double Buffer 和 Triple Buffer 的对比图可以看到，在这种情况下（出现连续主线程超时），三个 Buffer 的轮转有助于缓解掉帧出现的次数（从掉帧两次 -&gt; 只掉帧一次）</p><p>所以从第一节如何定义掉帧这里我们就知道，App 主线程超时不一定会导致掉帧，由于 Triple Buffer 的存在，部分 App 端的掉帧(主要是由于 GPU 导致)，到 SurfaceFlinger 这里未必是掉帧，这是看 Systrace 的时候需要注意的一个点</p><p><img src="/images/15764247460509.jpg" alt="缓解掉帧"></p><h2 id="减少主线程和渲染线程等待时间"><a href="#减少主线程和渲染线程等待时间" class="headerlink" title="减少主线程和渲染线程等待时间"></a>减少主线程和渲染线程等待时间</h2><p><strong>双 Buffer 的轮转</strong>， App 主线程有时候必须要等待 SurfaceFlinger(消费者)释放 Buffer 后，才能获取 Buffer 进行生产，这时候就有个问题，现在大部分手机 SurfaceFlinger 和 App 同时收到 Vsync 信号，如果出现App 主线程等待 SurfaceFlinger(消费者)释放 Buffer ，那么势必会让 App 主线程的执行时间延后，比如下面这张图，可以明显看到：<strong>Buffer B 并不是在 Vsync 信号来的时候开始被消费(因为还在使用)，而是等 Buffer A 被消费后，Buffer B 被释放，App 才能拿到 Buffer B 进行生产，这期间就有一定的延迟，会让主线程可用的时间变短</strong></p><p><img src="/images/15764247531355.jpg" alt="减少主线程和渲染线程等待时间"></p><p>我们来看一下在 Systrace 中的上面这种情况发生的时候的表现</p><p><img src="/images/15764247599570.jpg" alt="减少主线程和渲染线程等待时间"></p><p>而 三个 Buffer 轮转的情况下，则基本不会有这种情况的发生，渲染线程一般在 dequeueBuffer 的时候，都可以顺利拿到可用的 Buffer （当然如果 dequeueBuffer 本身耗时那就不是这里的讨论范围了）</p><h2 id="降低-GPU-和-SurfaceFlinger-瓶颈"><a href="#降低-GPU-和-SurfaceFlinger-瓶颈" class="headerlink" title="降低 GPU 和 SurfaceFlinger 瓶颈"></a>降低 GPU 和 SurfaceFlinger 瓶颈</h2><p>这个比较好理解，双 Buffer 的时候，App 生产的 Buffer 必须要及时拿去让 GPU 进行渲染，然后 SurfaceFlinger 才能进行合成，一旦 GPU 超时，就很容易出现 SurfaceFlinger 无法及时合成而导致掉帧</p><p>在三个 Buffer 轮转的时候，App 生产的 Buffer 可以及早进入 BufferQueue，让 GPU 去进行渲染（因为不需要等待，就算这里积累了 2 个 Buffer，下下一帧才去合成，这里也会提早进行，而不是在真正使用之前去匆忙让 GPU 去渲染），另外 SurfaceFlinger 本身的负载如果比较大，三个 Buffer 轮转也会有效降低 dequeueBuffer 的等待时间</p><p>比如下面两张图，就是对应的 SurfaceFlinger 和 App 的<strong>双 Buffer 掉帧</strong>情况，由于 SurfaceFlinger 本身就比较耗时（特定场景），而 App 的 dequeueBuffer 得不到及时的响应，导致发生了比较严重的掉帧情况。在换成 Triple Buffer 之后，这种情况就基本上没有了</p><p><img src="/images/15764247685189.jpg" alt=""></p><p><img src="/images/15764247751046.jpg" alt=""></p><h1 id="Debug-Triple-Buffer"><a href="#Debug-Triple-Buffer" class="headerlink" title="Debug Triple Buffer"></a>Debug Triple Buffer</h1><h2 id="Dumpsys-SurfaceFlinger"><a href="#Dumpsys-SurfaceFlinger" class="headerlink" title="Dumpsys SurfaceFlinger"></a>Dumpsys SurfaceFlinger</h2><p>dumpsys SurfaceFlinger 可以查看 SurfaceFlinger 输出的众多当前的状态，比如一些性能指标、Buffer 状态、图层信息等，后续有篇幅的话可以单独拿出来讲，下面是截取的 Double Buffer 情况下和 Triple Buffer 情况下的各个 App 的 Buffer 使用情况，可以看到不同的 App，在负载不一样的情况下，对 Triple Buffer 的使用率是不一样的；Double Buffer 则完全使用的是双 Buffer</p><p><img src="/images/15764247853726.jpg" alt=""></p><h2 id="关闭-Triple-Buffer"><a href="#关闭-Triple-Buffer" class="headerlink" title="关闭 Triple Buffer"></a>关闭 Triple Buffer</h2><p>不同 Android 版本属性设置不一样(这是 Google 的一个逻辑 Bug，Android 10 上面已经修复了)</p><h3 id="Android-版本-lt-Android-P"><a href="#Android-版本-lt-Android-P" class="headerlink" title="Android 版本 &lt;= Android P"></a>Android 版本 &lt;= Android P</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制代码</span></span><br><span class="line">property<span class="constructor">_get(<span class="string">"ro.sf.disable_triple_buffer"</span>, <span class="params">value</span>, <span class="string">"1"</span>)</span>;</span><br><span class="line">mLayerTripleBufferingDisabled = atoi(value);</span><br><span class="line"><span class="constructor">ALOGI_IF(<span class="params">mLayerTripleBufferingDisabled</span>, <span class="string">"Disabling Triple Buffering"</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>修改对应的属性值，然后重启 Framework</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按顺序执行下面的语句(需要 Root 权限)</span></span><br><span class="line">adb root</span><br><span class="line">adb <span class="built_in">shell</span> setprop ro.sf.disable_triple_buffer <span class="number">0</span></span><br><span class="line">adb <span class="built_in">shell</span> <span class="keyword">stop</span> &amp;&amp; adb <span class="built_in">shell</span> start</span><br></pre></td></tr></table></figure><h3 id="Android-版本-gt-Android-P"><a href="#Android-版本-gt-Android-P" class="headerlink" title="Android 版本 &gt; Android P"></a>Android 版本 &gt; Android P</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制代码</span></span><br><span class="line">property<span class="constructor">_get(<span class="string">"ro.sf.disable_triple_buffer"</span>, <span class="params">value</span>, <span class="string">"0"</span>)</span>;</span><br><span class="line">mLayerTripleBufferingDisabled = atoi(value);</span><br><span class="line"><span class="constructor">ALOGI_IF(<span class="params">mLayerTripleBufferingDisabled</span>, <span class="string">"Disabling Triple Buffering"</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>修改对应的属性值，然后重启 Framework</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按顺序执行下面的语句(需要 Root 权限)</span></span><br><span class="line">adb root</span><br><span class="line">adb <span class="built_in">shell</span> setprop ro.sf.disable_triple_buffer <span class="number">1</span></span><br><span class="line">adb <span class="built_in">shell</span> <span class="keyword">stop</span> &amp;&amp; adb <span class="built_in">shell</span> start</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://source.android.google.cn/devices/graphics" target="_blank" rel="noopener">https://source.android.google.cn/devices/graphics</a></li></ol><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>本文涉及到的附件也上传了，各位下载后解压，使用 <strong>Chrome</strong> 浏览器打开即可<br><a href="https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_TripleBuffer" target="_blank" rel="noopener">点此链接下载文章所涉及到的 Systrace 附件</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 - Binder 和锁竞争解读</title>
      <link href="/2019/12/06/Android-Systrace-Binder/"/>
      <url>/2019/12/06/Android-Systrace-Binder/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第十篇，主要是对 Systrace 中的 Binder 和锁信息进行简单介绍，简单介绍了 Binder 的情况，介绍了 Systrace 中 Binder 通信的表现形式，以及 Binder 信息查看，SystemServer 锁竞争分析等</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h1><p>Android 的大部分进程间通信都使用 Binder，这里对 Binder 不做过多的解释，想对 Binder 的实现有一个比较深入的了解的话，推荐你阅读下面三篇文章</p><ol><li><a href="https://paul.pub/android-binder-driver/" target="_blank" rel="noopener">理解Android Binder机制1/3：驱动篇</a></li><li><a href="https://paul.pub/android-binder-cpp/" target="_blank" rel="noopener">理解Android Binder机制2/3：C++层</a></li><li><a href="https://paul.pub/android-binder-java/" target="_blank" rel="noopener">理解Android Binder机制3/3：Java层</a></li></ol><p><strong>之所以要单独讲 Systrace 中的 Binder 和锁，是因为很多卡顿问题和响应速度的问题，是因为跨进程 binder 通信的时候，锁竞争导致 binder 通信事件变长，影响了调用端。最常见的就是应用渲染线程 dequeueBuffer 的时候 SurfaceFlinger 主线程阻塞导致 dequeueBuffer 耗时，从而导致应用渲染出现卡顿; 或者 SystemServer 中的 AMS 或者 WMS 持锁方法等待太多, 导致应用调用的时候等待时间比较长导致主线程卡顿</strong></p><p>这里放一张文章里面的 Binder 架构图 ， 本文主要是以 Systrace 为主，所以会讲 Systrace 中的 Binder 表现，不涉及 Binder 的实现</p><p><img src="/images/15756309069397.jpg" alt=""></p><h1 id="Binder-调用图例"><a href="#Binder-调用图例" class="headerlink" title="Binder 调用图例"></a>Binder 调用图例</h1><p>Binder 主要是用来跨进程进行通信，可以看下面这张图，简单显示了在 Systrace 中 ，Binder 通信是如何显示的</p><p><img src="/images/15756309176435.jpg" alt=""></p><p>图中主要是 SystemServer 进程和 高通的 perf 进程通信，Systrace 中右上角 ViewOption 里面勾选 Flow Events  就可以看到 Binder 的信息</p><p><img src="/images/15756309267278.jpg" alt=""></p><p>点击 Binder 可以查看其详细信息，其中有的信息在分析问题的时候可以用到，这里不做过多的描述</p><p><img src="/images/15756309336019.jpg" alt=""></p><p>对于 Binder，这里主要介绍如何在 Systrace 中查看 Binder <strong>锁信息</strong>和<strong>锁等待</strong>这两个部分，很多卡顿和响应问题的分析，都离不开这两部分信息的解读，不过最后还是要回归代码，找到问题后，要读源码来理顺其代码逻辑，以方便做相应的优化工作</p><h1 id="Systrace-显示的锁的信息"><a href="#Systrace-显示的锁的信息" class="headerlink" title="Systrace 显示的锁的信息"></a>Systrace 显示的锁的信息</h1><p><img src="/images/15756309429683.jpg" alt=""></p><p><strong>monitor contention with owner Binder:1605_B (4667) at void com.android.server.wm.ActivityTaskManagerService.activityPaused(android.os.IBinder)(ActivityTaskManagerService.java:1733) waiters=2 blocking from android.app.ActivityManager$StackInfo com.android.server.wm.ActivityTaskManagerService.getFocusedStackInfo()(ActivityTaskManagerService.java:2064)</strong></p><p>上面的话分两段来看，以 <strong>blocking</strong> 为分界线　</p><h2 id="第一段信息解读"><a href="#第一段信息解读" class="headerlink" title="第一段信息解读"></a>第一段信息解读</h2><p><strong>monitor contention with owner Binder:1605_B (4667) at void com.android.server.wm.ActivityTaskManagerService.activityPaused(android.os.IBinder)(ActivityTaskManagerService.java:1733) waiters=2</strong></p><p><strong>Monitor</strong> 指的是当前锁对象的池，在 Java 中，每个对象都有两个池，锁(monitor)池和等待池：</p><p><strong>锁池</strong>（同步队列 SynchronizedQueue ）：假设线程 A 已经拥有了某个对象(注意:不是类 )的锁，而其它的线程想要调用这个对象的某个 synchronized 方法(或者 synchronized 块)，由于这些线程在进入对象的 synchronized 方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程 A 拥有，所以这些线程就进入了该对象的锁池中。</p><p>这里用了争夺(contention)这个词，意思是这里由于在和目前对象的锁正被其他对象（Owner）所持有，所以没法得到该对象的锁的拥有权，所以进入该对象的锁池</p><p><strong>Owner</strong> : 指的是当前<strong>拥有</strong>这个对象的锁的对象。这里是 Binder:1605_B，4667 是其线程 ID。</p><p><strong>at</strong> 后面跟的是<strong>拥有</strong>这个对象的锁的对象正在做什么。这里是在执行 void com.android.server.wm.ActivityTaskManagerService.activityPaused 这个方法，其代码位置是 ：ActivityTaskManagerService.java:1733 其对应的代码如下：</p><p>com/android/server/wm/ActivityTaskManagerService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123; <span class="comment">// 1733 是这一行</span></span><br><span class="line">        ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.activityPausedLocked(token, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里 synchronized (mGlobalLock) ，获取了 mGlobalLock 锁的拥有权，在他释放这个对象的锁之前，任何其他的调用 synchronized (mGlobalLock) 的地方都得在锁池中等待</p><p><strong>waiters</strong> 值得是锁池里面正在等待锁的操作的个数；这里 waiters=2 表示目前锁池里面已经有一个操作在等待这个对象的锁释放了，加上这个的话就是 3 个了</p><h2 id="第二段信息解读"><a href="#第二段信息解读" class="headerlink" title="第二段信息解读"></a>第二段信息解读</h2><p><strong>blocking from android.app.ActivityManager$StackInfo com.android.server.wm.ActivityTaskManagerService.getFocusedStackInfo()(ActivityTaskManagerService.java:2064)</strong></p><p>第二段信息相对来说简单一些，就是标识了当前被阻塞等锁的方法 ， 这里是 ActivityManager 的 getFocusedStackInfo 被阻塞，其对应的代码</p><p>com/android/server/wm/ActivityTaskManagerService.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ActivityManager.StackInfo get<span class="constructor">FocusedStackInfo()</span> throws RemoteException &#123;</span><br><span class="line">    enforce<span class="constructor">CallerIsRecentsOrHasPermission(MANAGE_ACTIVITY_STACKS, <span class="string">"getStackInfo()"</span>)</span>;</span><br><span class="line">    long ident = <span class="module-access"><span class="module"><span class="identifier">Binder</span>.</span></span>clear<span class="constructor">CallingIdentity()</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        synchronized (mGlobalLock) &#123; <span class="comment">// 2064 是这一行 </span></span><br><span class="line">            ActivityStack focusedStack = get<span class="constructor">TopDisplayFocusedStack()</span>;</span><br><span class="line">            <span class="keyword">if</span> (focusedStack != null) &#123;</span><br><span class="line">                return mRootActivityContainer.get<span class="constructor">StackInfo(<span class="params">focusedStack</span>.<span class="params">mStackId</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Binder</span>.</span></span>restore<span class="constructor">CallingIdentity(<span class="params">ident</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里也是调用了 synchronized (ActivityManagerService.this) ，从而需要等待获取 ams 对象的锁拥有权</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面这段话翻译过来就是</p><p><strong>ActivityTaskManagerService 的 getFocusedStackInfo 方法在执行过程中被阻塞，原因是因为执行同步方法块的时候，没有拿到同步对象的锁的拥有权；需要等待拥有同步对象的锁拥有权的另外一个方法 ActivityTaskManagerService.activityPaused 执行完成后，才能拿到同步对象的锁的拥有权，然后继续执行</strong></p><p>可以对照原文看上面的翻译</p><p><strong>monitor contention with owner Binder:1605_B (4667)<br>at void com.android.server.wm.ActivityTaskManagerService.activityPaused(android.os.IBinder)(ActivityTaskManagerService.java:1733)<br>waiters=2<br>blocking from android.app.ActivityManager$StackInfo com.android.server.wm.ActivityTaskManagerService.getFocusedStackInfo()(ActivityTaskManagerService.java:2064)</strong></p><h1 id="等锁分析"><a href="#等锁分析" class="headerlink" title="等锁分析"></a>等锁分析</h1><p>还是上面那个 Systrace，Binder 信息里面显示 waiters=2，意味着前面还有两个操作在等锁释放，也就是说总共有三个操作都在等待 Binder:1605_B (4667) 释放锁，我们来看一下 Binder:1605_B 的执行情况</p><p><img src="/images/15756309846544.jpg" alt=""></p><p>从上图可以看到，Binder:1605_B 正在执行 activityPaused，中间也有一些其他的 Binder 操作，最终 activityPaused 执行完成后，释放锁</p><p>下面我们就把这个逻辑里面的执行顺序理顺，包括两个 <strong>waiters</strong></p><h2 id="锁等待"><a href="#锁等待" class="headerlink" title="锁等待"></a>锁等待</h2><p><img src="/images/15756309922668.jpg" alt=""></p><p>上图中可以看到 mGlobalLock 这个对象锁的争夺情况</p><ol><li>Binder_1605_B 首先开始执行 <strong>activityPaused</strong>，这个方法中是要获取 mGlobalLock 对象锁的，由于此时 mGlobalLock 没有竞争，所以 activityPaused 获取对象锁之后开始执行</li><li>android.display 线程开始执行 <strong>checkVisibility</strong> 方法，这个方法也是要获取 mGlobalLock 对象锁的，但是此时 Binder_1605_B 的 activityPaused 持有 mGlobalLock 对象锁 ，所以这里 android.display 的 checkVisibility 开始等待，进入 sleep 状态</li><li>android.anim 线程开始执行 <strong>relayoutWindow</strong> 方法，这个方法也是要获取 mGlobalLock 对象锁的，但是此时 Binder_1605_B 的 activityPaused 持有 mGlobalLock 对象锁 ，所以这里 android.display 的 checkVisibility 开始等待，进入 sleep 状态</li><li>android.bg 线程开始执行 <strong>getFocusedStackInfo</strong> 方法，这个方法也是要获取 mGlobalLock 对象锁的，但是此时 Binder_1605_B 的 activityPaused 持有 mGlobalLock 对象锁 ，所以这里 android.display 的 checkVisibility 开始等待，进入 sleep 状态</li></ol><p>经过上面四步，就形成了 Binder_1605_B 线程在运行，其他三个争夺 mGlobalLock 对象锁失败的线程分别进入 sleep 状态，等待 Binder_1605_B 执行结束后释放 mGlobalLock 对象锁</p><h2 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h2><p><img src="/images/15756310021037.jpg" alt=""></p><p>上图可以看到 mGlobalLock 锁的释放和后续的流程</p><ol><li>Binder_1605_B 线程的 <strong>activityPaused</strong> 执行结束，mGlobalLock 对象锁释放</li><li>第一个进入等待的 android.display 线程开始执行 <strong>checkVisibility</strong> 方法 ，这里从  android.display 线程的唤醒信息可以看到，是被 Binder_1605_B(4667) 唤醒的</li><li>android.display 线程的 <strong>checkVisibility</strong> 执行结束，mGlobalLock 对象锁释放</li><li>第二个进入等待的 android.anim 线程开始执行 <strong>relayoutWindow</strong> 方法 ，这里从  android.anim 线程的唤醒信息可以看到，是被 android.display(1683) 唤醒的</li><li>android.anim 线程的 <strong>relayoutWindow</strong> 执行结束，mGlobalLock 对象锁释放</li><li>第三个进入等待的 android.bg 线程开始执行 <strong>getFocusedStackInfo</strong> 方法 ，这里从  android.bg 线程的唤醒信息可以看到，是被 android.anim(1684) 唤醒的</li></ol><p>经过上面 6 步，这一轮由于 mGlobalLock 对象锁引起的等锁现象结束。这里只是一个简单的例子，在实际情况下，SystemServer 中的 BInder 等锁情况会非常严重，经常 waiter 会到达 7 - 10 个，非常恐怖，比如下面这种：</p><p><img src="/images/15756310119592.jpg" alt=""></p><p>这也就可以解释为什么 Android 手机 App 安装多了、用的久了之后，系统就会卡的一个原因；另外重启后也会有短暂的时候出现这种情况</p><p>如果不知道怎么查看唤醒信息，可以查看： <a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/#%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92%E4%BF%A1%E6%81%AF%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Systrace中查看进程信息唤醒</a> 这篇文章</p><h1 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h1><h3 id="Monitor-信息"><a href="#Monitor-信息" class="headerlink" title="Monitor 信息"></a>Monitor 信息</h3><p>art/runtime/monitor.cc</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Monitor::PrettyContentionInfo(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; owner_name,</span><br><span class="line">                                          <span class="keyword">pid_t</span> owner_tid,</span><br><span class="line">                                          ArtMethod* owners_method,</span><br><span class="line">                                          <span class="keyword">uint32_t</span> owners_dex_pc,</span><br><span class="line">                                          <span class="keyword">size_t</span> num_waiters) &#123;</span><br><span class="line">  Locks::mutator_lock_-&gt;AssertSharedHeld(Thread::Current());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* owners_filename;</span><br><span class="line">  <span class="keyword">int32_t</span> owners_line_number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (owners_method != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    TranslateLocation(owners_method, owners_dex_pc, &amp;owners_filename, &amp;owners_line_number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line">  oss &lt;&lt; <span class="string">"monitor contention with owner "</span> &lt;&lt; owner_name &lt;&lt; <span class="string">" ("</span> &lt;&lt; owner_tid &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">  <span class="keyword">if</span> (owners_method != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    oss &lt;&lt; <span class="string">" at "</span> &lt;&lt; owners_method-&gt;PrettyMethod();</span><br><span class="line">    oss &lt;&lt; <span class="string">"("</span> &lt;&lt; owners_filename &lt;&lt; <span class="string">":"</span> &lt;&lt; owners_line_number &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  oss &lt;&lt; <span class="string">" waiters="</span> &lt;&lt; num_waiters;</span><br><span class="line">  <span class="keyword">return</span> oss.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Block-信息"><a href="#Block-信息" class="headerlink" title="Block 信息"></a>Block 信息</h3><p>art/runtime/monitor.cc</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (owner_ != <span class="literal">nullptr</span>) &#123;  <span class="comment">// Did the owner_ give the lock up?</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    owner_-&gt;GetThreadName(name);</span><br><span class="line">    oss &lt;&lt; PrettyContentionInfo(name,</span><br><span class="line">                                owner_-&gt;GetTid(),</span><br><span class="line">                                owners_method,</span><br><span class="line">                                owners_dex_pc,</span><br><span class="line">                                num_waiters);</span><br><span class="line">    <span class="comment">// Add info for contending thread.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pc;</span><br><span class="line">    ArtMethod* m = self-&gt;GetCurrentMethod(&amp;pc);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* filename;</span><br><span class="line">    <span class="keyword">int32_t</span> line_number;</span><br><span class="line">    TranslateLocation(m, pc, &amp;filename, &amp;line_number);</span><br><span class="line">    oss &lt;&lt; <span class="string">" blocking from "</span></span><br><span class="line">        &lt;&lt; ArtMethod::PrettyMethod(m) &lt;&lt; <span class="string">"("</span> &lt;&lt; (filename != <span class="literal">nullptr</span> ? filename : <span class="string">"null"</span>)</span><br><span class="line">        &lt;&lt; <span class="string">":"</span> &lt;&lt; line_number &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    ATRACE_BEGIN(oss.str().c_str());</span><br><span class="line">    started_trace = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://paul.pub/android-binder-driver/" target="_blank" rel="noopener">理解Android Binder机制1/3：驱动篇</a></li><li><a href="https://paul.pub/android-binder-cpp/" target="_blank" rel="noopener">理解Android Binder机制2/3：C++层</a></li><li><a href="https://paul.pub/android-binder-java/" target="_blank" rel="noopener">理解Android Binder机制3/3：Java层</a></li></ol><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>本文涉及到的附件也上传了，各位下载后解压，使用 <strong>Chrome</strong> 浏览器打开即可<br><a href="https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_Binder" target="_blank" rel="noopener">点此链接下载文章所涉及到的 Systrace 附件</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「置顶」博客文章目录</title>
      <link href="/2019/12/01/BlogMap/"/>
      <url>/2019/12/01/BlogMap/</url>
      
        <content type="html"><![CDATA[<p>本博客内容主要集中在 Android 开发和优化相关的话题，包括一些性能工具的使用、Android App 优化知识、Android Framework 知识讲解，性能理论知识讲解等，这里整理了一份目录供大家参考，大家可以挑感兴趣的部分来看。这里不仅仅包含博客中的内容，一些我在<a href="https://www.zhihu.com/people/gracker" target="_blank" rel="noopener">知乎</a>或者<a href="https://t.zsxq.com/mIimiey" target="_blank" rel="noopener">知识星球</a>的回答也会放到这里,不过这个目录里面放的都是我原创的博客，另外还收集了一些优秀文章 , 我也会不定期更新:<a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">Android 性能优化必知必会</a></p><p>博客的每次更新都会更新这篇目录，方便大家查阅。我会尽量保证每周一更，学无止境，与大家共勉，有什么想了解的或者博客中不足的地方，请大家在博客或者知乎、微博、微信留言给我，我会积极改正</p><a id="more"></a><h1 id="Systrace-系列"><a href="#Systrace-系列" class="headerlink" title="Systrace 系列"></a>Systrace 系列</h1><p>Systrace 工具是分析 Android 性能问题的利器，它可以从一个图形的角度，来展现整机的运行情况。Systrace 工具不仅可以分析性能问题，用它来进行 Framework 的学习也是很好的，这也是我写本系列文章的一个原因</p><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://androidperformance.com/2019/06/29/Android-Systrace-SystemServer/">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 产生与工作机制解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="流畅性"><a href="#流畅性" class="headerlink" title="流畅性"></a>流畅性</h1><p>流畅性主要指的是卡顿、掉帧，对应的英文是 Smooth vs Jank</p><ol><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 方法论</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 应用篇</a></li><li><a href="https://androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/">Android 中的卡顿丢帧原因概述 - 低内存篇</a></li><li><a href="https://androidperformance.com/2018/08/13/Some-Thoughts-on-the-Fluency-of-Android/">关于 Android 系统流畅性的一些思考</a></li><li><a href="https://androidperformance.com/2019/05/15/90hz-on-android/">新的流畅体验，90Hz 漫谈</a></li><li><a href="https://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/">Android性能优化之过渡绘制(一)</a></li><li><a href="https://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/">Android性能优化之过渡绘制( 二)</a></li><li><a href="https://androidperformance.com/2015/03/31/android-performance-case-study-follow-up/">Android性能优化后续</a></li><li><a href="https://www.androidperformance.com/2020/08/20/weibo-imageload-opt-on-huawei/" target="_blank" rel="noopener">华为手机刷微博体验更好？技术角度的一些分析和思考</a></li></ol><h1 id="响应速度"><a href="#响应速度" class="headerlink" title="响应速度"></a>响应速度</h1><p>响应速度主要指的是 App 冷热启动、界面跳转速度、亮灭屏速度等，对应的英文是 Fast vs Slow</p><ol><li><a href="https://androidperformance.com/2019/11/18/Android-App-Lunch-Optimize/">Android App 启动优化全记录</a></li><li><a href="https://androidperformance.com/2018/05/20/zhihu-startingwindow/">知乎 救救你的 StartingWindow</a></li><li><a href="https://androidperformance.com/2015/12/31/How-to-calculation-android-app-lunch-time/">Android 中如何计算 App 的启动时间？</a></li><li><a href="https://androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load/">Android 应用启动优化:一种 DelayLoad 的实现和原理(上篇)</a></li><li><a href="https://androidperformance.com/2015/12/29/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E4%B8%80%E7%A7%8DDelayLoad%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86-%E4%B8%8B%E7%AF%87/">Android 应用启动优化:一种 DelayLoad 的实现和原理(下篇)</a></li></ol><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>主要记录 Android 内存优化相关的知识和工具，以及对系统的影响</p><ol><li><a href="https://androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/">Android 中低内存对性能的影响</a></li><li><a href="https://androidperformance.com/2018/09/13/android-memory/">Android 系统不释放内存吗？</a></li><li><a href="https://androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource/">Android 代码内存优化建议-Android 资源篇</a></li><li><a href="https://androidperformance.com/2015/07/20/Android-Performance-Memory-Google/">Android 代码内存优化建议-Android 官方篇</a></li><li><a href="https://androidperformance.com/2015/07/20/Android-Performance-Memory-Java/">Android 代码内存优化建议-Java 官方篇</a></li><li><a href="https://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">Android 内存优化之一：MAT 使用入门</a></li><li><a href="https://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/">Android内存优化之二：MAT使用进阶</a></li><li><a href="https://androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/">Android内存优化之三：打开MAT中的Bitmap原图</a></li></ol><h1 id="Framework-知识"><a href="#Framework-知识" class="headerlink" title="Framework 知识"></a>Framework 知识</h1><p>博客中 Framework 相关的内容会集中在这里，包括一些 Framework 的运行原理、Framework 问题的解题思路、Framework 优化方法等</p><ol><li><a href="https://androidperformance.com/2019/10/24/Android-Background-Animation/">Android 中的“后台无效动画“行为分析</a></li><li><a href="https://androidperformance.com/2019/09/17/Android-Kill-Background-App-Debug/">Android 框架问题分析案例 - 谁杀了桌面?</a></li><li><a href="https://androidperformance.com/2019/09/01/Android-Activity-Lunch-Mode/">Android 中的 Activity Launch Mode 详解</a></li><li><a href="https://androidperformance.com/2019/07/27/Android-Hardware-Layer/">Android 中的 Hardware Layer 详解</a></li><li><a href="https://androidperformance.com/2019/01/21/android-performance-case-jank-accessbility/">Android 平台应用宝和讯飞输入法无障碍服务导致的全局卡顿分析</a></li><li><a href="https://androidperformance.com/2018/10/24/android-process-review-with-user-side/">从用户角度来理解 Android 应用的状态</a></li><li><a href="https://androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow/">Android hwui 中 RenderThread 工作流程</a></li><li><a href="https://androidperformance.com/2015/08/05/HashMap/">HashMap 源码分析</a></li><li><a href="https://androidperformance.com/2015/05/06/Java-Singleton/">细说Java单例模式</a></li><li><a href="https://androidperformance.com/2018/11/01/android-system-develop-0/">Android 系统开发源码环境搭建</a></li><li><a href="https://www.androidperformance.com/2020/05/07/Android-App-Chain-Wakeup/" target="_blank" rel="noopener">Android App 链式唤醒分析</a></li><li><a href="https://www.androidperformance.com/2020/05/26/samsung_crash/" target="_blank" rel="noopener">一个「闰」字引发的事故 - 三星系统重启分析</a></li></ol><h1 id="App-开发"><a href="#App-开发" class="headerlink" title="App 开发"></a>App 开发</h1><p>这里主要记录一些 App 开发相关的博文，由于写的比较早，大家随便看一下就可以了</p><ol><li><a href="https://androidperformance.com/2016/04/05/android-bottom-bar-1/">Android Bottom navigation 规范一：使用方法</a></li><li><a href="https://androidperformance.com/2016/04/05/android-bottom-bar-2/">Android Bottom navigation 规范二：样式、行为与规格</a></li><li><a href="https://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app/">Android Service：开发自己的通知中心(1):辅助性服务介绍</a></li><li><a href="https://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app/">Android Service：开发自己的通知中心(2):辅助性服务实战</a></li><li><a href="https://androidperformance.com/2014/05/02/android_log_to_file/">Android开发:Log2File工具类</a></li><li><a href="https://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices/">Android:Ubuntu下执行Adb命令找不到设备</a></li><li><a href="https://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus/">Android小技巧:如何让EditText不自动获取焦点</a></li></ol><h1 id="个人总结和好物推荐"><a href="#个人总结和好物推荐" class="headerlink" title="个人总结和好物推荐"></a>个人总结和好物推荐</h1><p>与技术无关，但是可以提高幸福感和工作效率</p><ol><li><a href="https://androidperformance.com/2019/04/07/liqi/">我是 Gracker，这是我的利器</a></li><li><a href="https://androidperformance.com/2019/01/12/recommend-of-2018/">Gracker 的 2018 年度最推荐 - 给辛勤工作的自己一点奖励</a></li><li><a href="https://androidperformance.com/2018/10/25/How-do-engineers-count-well/">陆奇：除了好代码，工程师怎样才算优秀？</a></li><li><a href="https://androidperformance.com/2018/01/06/2017%E5%B9%B4%E5%BA%A6%E6%9C%80%E6%8E%A8%E8%8D%90/">2017 年度最推荐 - 给辛勤工作的自己一点奖励</a></li><li><a href="https://androidperformance.com/2017/04/23/About-work/">关于 2017</a></li><li><a href="https://www.androidperformance.com/2020/02/03/android-development-learning-path-2020-edition/" target="_blank" rel="noopener">Android 开发者学习路线(2020 版本)</a></li><li><a href="https://www.androidperformance.com/2020/01/28/2020-read/" target="_blank" rel="noopener">我的 2020 年读书单</a></li></ol><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><h1 id="性能优化典范和-Tips"><a href="#性能优化典范和-Tips" class="headerlink" title="性能优化典范和 Tips"></a>性能优化典范和 Tips</h1><p>性能优化典范是 Google 出品的一系列性能相关的短视频，总共出了 6 季，之前想的是每一集都来一个文章配合，后面发现不是很现实；Android Tips 则是翻译的另外一个博主的文章</p><ol><li><a href="https://androidperformance.com/2015/04/19/Android-Performance-Patterns/">Android性能优化典范综述</a></li><li><a href="https://androidperformance.com/2015/04/19/Android-Performance-Patterns-1/">Android性能优化典范之Render Performance</a></li><li><a href="https://androidperformance.com/2015/04/19/Android-Performance-Patterns-2/">Android性能优化典范之Understanding Overdraw</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-3/" target="_blank" rel="noopener">Android性能优化典范之Understanding VSYNC</a></li><li><a href="https://androidperformance.com/2015/04/19/Android-Performance-Patterns-4/">Android性能优化典范之Profile GPU Rendering</a></li><li><a href="https://androidperformance.com/2014/05/28/android-tips-round-up-1/">Android Tips 1</a> </li><li><a href="https://androidperformance.com/2014/05/31/android-tips-round-up-2/">Android Tips 2</a> </li><li><a href="https://androidperformance.com/2015/03/15/android-tips-round-up-3/">Android Tips 3</a> </li><li><a href="https://androidperformance.com/2015/03/15/android-tips-round-up-4/">Android Tips 4</a></li><li><a href="https://androidperformance.com/2015/03/15/android-tips-round-up-5/">Android Tips 5</a></li></ol><h1 id="知乎问答"><a href="#知乎问答" class="headerlink" title="知乎问答"></a>知乎问答</h1><p>知乎专栏会搬运一部分文章，这里只贴一些高赞的回答</p><ol><li><a href="https://www.zhihu.com/question/67627009/answer/255199992" target="_blank" rel="noopener">如何看待小米部分机型运行《王者荣耀》时两个大核被锁</a></li><li><a href="https://www.zhihu.com/question/38533041/answer/77512815" target="_blank" rel="noopener">Flyme 5 相对于 Flyme 4 流畅得脱胎换骨，其中根本的变化是什么？</a></li><li><a href="https://www.zhihu.com/question/24976909/answer/49711238" target="_blank" rel="noopener">Android 系统不释放内存吗</a></li><li><a href="https://www.zhihu.com/question/350047125" target="_blank" rel="noopener">了解Android的Framework层对工作有什么帮助吗？</a></li></ol><h1 id="个人页"><a href="#个人页" class="headerlink" title="个人页"></a>个人页</h1><p><a href="https://androidperformance.com/about/">建武的个人简介</a></p><h1 id="个人演讲-amp-amp-培训-PPT"><a href="#个人演讲-amp-amp-培训-PPT" class="headerlink" title="个人演讲 &amp;&amp; 培训 PPT"></a>个人演讲 &amp;&amp; 培训 PPT</h1><p>这一部分整理之后会放出来，不过大家都知道，演讲或者培训的时候，PPT 里面不会有太多的东西，多数只是一个大纲</p><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 - Vsync 解读</title>
      <link href="/2019/12/01/Android-Systrace-Vsync/"/>
      <url>/2019/12/01/Android-Systrace-Vsync/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第七篇，主要是是介绍 Android 中的 Vsync 机制。文章会从 Systrace 的角度来看 Android 系统如何基于 Vsync 每一帧的展示。Vsync 是 Systrace 中一个非常关键的机制，虽然我们在操作手机的时候看不见，摸不着，但是在 Systrace 中我们可以看到，Android 系统在 Vsync 信号的指引下，有条不紊地进行者每一帧的渲染、合成操作，使我们可以享受稳定帧率的画面。</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><p>Vsync 信号可以由硬件产生，也可以用软件模拟，不过现在基本上都是硬件产生，负责产生硬件 Vsync 的是 HWC,HWC 可生成 VSYNC 事件并通过回调将事件发送到 SurfaceFlinge , DispSync 将 Vsync 生成由 Choreographer 和 SurfaceFlinger 使用的 VSYNC_APP 和 VSYNC_SF 信号</p><p><img src="/images/15751536260871.jpg" alt=""></p><p>在 <a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android 基于 Choreographer 的渲染机制详解</a> 这篇文章里面，我们有提到 ：Choreographer 的引入，主要是配合 Vsync，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对 Vsync 信号周期的调整，来控制每一帧绘制操作的时机. 目前大部分手机都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每个 16.6 ms，Vsync 信号唤醒 Choreographer 来做 App 的绘制操作 ，这就是引入 Choreographer 的主要作用</p><p>渲染层(App)与 Vsync 打交道的是 Choreographer，而合成层与 Vsync 打交道的，则是 SurfaceFlinger。SurfaceFlinger 也会在 Vsync 到来的时候，将所有已经准备好的 Surface 进行合成操作</p><p>下图显示在 Systrace 中，SurfaceFlinger 进程中的 VSYNC_APP 和 VSYNC_SF 的情况</p><p><img src="/images/15751536450451.jpg" alt=""></p><h1 id="Android-图形数据流向"><a href="#Android-图形数据流向" class="headerlink" title="Android 图形数据流向"></a>Android 图形数据流向</h1><p>首先我们要大概了解 Android 中的图形数据流的方向，从下面这张图，结合 Android 的图像流，我们大概把从 App 绘制到屏幕显示，分为下面几个阶段：</p><p><img src="/images/15751536542613.jpg" alt=""></p><ol><li>第一阶段：App 在收到 Vsync-App 的时候，在主线程进行 measure、layout、draw(构建 DisplayList , 里面包含 OpenGL 渲染需要的命令及数据) 。这里对应的 Systrace 中的主线程 <strong>doFrame</strong> 操作</li><li>第二阶段：CPU 将数据上传（共享或者拷贝）给 GPU,　这里 ARM 设备 内存一般是 GPU 和 CPU 共享内存。这里对应的 Systrace 中的渲染线程的 <strong>flush drawing commands</strong> 操作</li><li>第三阶段：通知 GPU 渲染，真机一般不会阻塞等待 GPU 渲染结束，CPU 通知结束后就返回继续执行其他任务，使用 Fence 机制辅助 GPU CPU 进行同步操作</li><li>第四 阶段：swapBuffers，并通知 SurfaceFlinger 图层合成。这里对应的 Systrace 中的渲染线程的 <strong>eglSwapBuffersWithDamageKHR</strong> 操作</li><li>第五阶段：SurfaceFlinger 开始合成图层，如果之前提交的 GPU 渲染任务没结束，则等待 GPU 渲染完成，再合成（Fence 机制），合成依然是依赖 GPU，不过这就是下一个任务了.这里对应的 Systrace 中的 SurfaceFlinger 主线程的 onMessageReceived 操作（包括 handleTransaction、handleMessageInvalidate、handleMessageRefresh）SurfaceFlinger 在合成的时候，会将一些合成工作委托给 Hardware Composer,从而降低来自 OpenGL 和 GPU 的负载，只有  Hardware Composer 无法处理的图层，或者指定用 OpenGL 处理的图层，其他的 图层偶会使用  Hardware Composer 进行合成</li><li>第六阶段 ：最终合成好的数据放到屏幕对应的 Frame Buffer 中，固定刷新的时候就可以看到了</li></ol><p>下面这张图也是官方的一张图，结合上面的阶段，从左到右看，可以看到一帧的数据是如何在各个进程之间流动的</p><p><img src="/images/15751536775887.jpg" alt=""></p><h1 id="Systrace-中的图像数据流"><a href="#Systrace-中的图像数据流" class="headerlink" title="Systrace 中的图像数据流"></a>Systrace 中的图像数据流</h1><p>了解了 Android 中的图形数据流的方向，我们就可以把上面这个比较抽象的数据流图，在 Systrace 上进行映射展示</p><p><img src="/images/15751536946754.jpg" alt=""></p><p>上图中主要包含 SurfaceFlinger、App 和 hwc 三个进程，下面就来结合图中的标号，来进一步说明数据的流向</p><ol><li>第一个 Vsync 信号到来, SurfaceFlinger 和 App 同时收到 Vsync 信号</li><li>SurfaceFlinger 收到 Vsync-sf 信号，开始进行 App 上一帧的 Buffer 的合成</li><li>App 收到 Vsycn-app 信号，开始进行这一帧的 Buffer 的渲染(对应上面的第一、二、三、四阶段)</li><li>第二个 Vsync 信号到来 ，SurfaceFlinger 和 App 同时收到 Vsync 信号，SurfaceFlinger 获取 App 在第二步里面渲染的 Buffer，开始合成（对应上面的第五阶段），App 收到 Vsycn-app 信号，开始新一帧的 Buffer 的渲染(对应上面的第一、二、三、四阶段)</li></ol><h1 id="Vsync-Offset"><a href="#Vsync-Offset" class="headerlink" title="Vsync Offset"></a>Vsync Offset</h1><p>文章最开始有提到，Vsync 信号可以由硬件产生，也可以用软件模拟，不过现在基本上都是硬件产生，负责产生硬件 Vsync 的是 HWC,HWC 可生成 VSYNC 事件并通过回调将事件发送到 SurfaceFlinge , DispSync 将 Vsync 生成由 Choreographer 和 SurfaceFlinger 使用的 VSYNC_APP 和 VSYNC_SF 信号.</p><p><img src="/images/disp_sync_arch.png" alt="disp_sync_arch"></p><p>其中 app 和 sf 相对 hw_vsync_0 都有一个偏移,即 phase-app 和 phase-sf，如下图</p><p><img src="/images/15751537168911.jpg" alt=""></p><p><strong>Vsync Offset 我们指的是 VSYNC_APP 和 VSYNC_SF 之间有一个 Offset，即上图中 phase-sf - phase-app 的值</strong>，这个 Offset 是厂商可以配置的。如果 Offset 不为 0，那么意味着 <strong>App 和 SurfaceFlinger 主进程不是同时收到 Vsync 信号，而是间隔 Offset (通常在 0 - 16.6ms 之间)</strong></p><p>目前大部分厂商都没有配置这个 Offset，所以 App 和 SurfaceFlinger 是同时收到 Vsync 信号的.</p><p>可以通过 Dumpsys SurfaceFlinger 来查看对应的值</p><p><strong>Offset 为 0</strong>：（sf phase - app phase = 0)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Sync configuration:</span> <span class="string">[using:</span> <span class="string">EGL_ANDROID_native_fence_sync</span> <span class="string">EGL_KHR_wait_sync]</span></span><br><span class="line"><span class="attr">DispSync configuration:</span> </span><br><span class="line">          <span class="string">app</span> <span class="string">phase</span> <span class="number">1000000</span> <span class="string">ns,</span>              <span class="string">sf</span> <span class="string">phase</span> <span class="number">1000000</span> <span class="string">ns</span> </span><br><span class="line">    <span class="string">early</span> <span class="string">app</span> <span class="string">phase</span> <span class="number">1000000</span> <span class="string">ns,</span>        <span class="string">early</span> <span class="string">sf</span> <span class="string">phase</span> <span class="number">1000000</span> <span class="string">ns</span> </span><br><span class="line"> <span class="string">early</span> <span class="string">app</span> <span class="string">gl</span> <span class="string">phase</span> <span class="number">1000000</span> <span class="string">ns,</span>     <span class="string">early</span> <span class="string">sf</span> <span class="string">gl</span> <span class="string">phase</span> <span class="number">1000000</span> <span class="string">ns</span> </span><br><span class="line">     <span class="string">present</span> <span class="string">offset</span> <span class="number">0</span> <span class="string">ns</span>                      <span class="string">refresh</span> <span class="number">16666666</span> <span class="string">ns</span></span><br></pre></td></tr></table></figure><p><strong>Offset 不为 0</strong> (SF phase - app phase = 4 ms)</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sync <span class="string">configuration:</span> [<span class="string">using:</span> EGL_ANDROID_native_fence_sync EGL_KHR_wait_sync]</span><br><span class="line"></span><br><span class="line">VSYNC <span class="string">configuration:</span></span><br><span class="line">         app <span class="string">phase:</span>   <span class="number">2000000</span> ns         SF <span class="string">phase:</span>   <span class="number">6000000</span> ns</span><br><span class="line">   early app <span class="string">phase:</span>   <span class="number">2000000</span> ns   early SF <span class="string">phase:</span>   <span class="number">6000000</span> ns</span><br><span class="line">GL early app <span class="string">phase:</span>   <span class="number">2000000</span> nsGL early SF <span class="string">phase:</span>   <span class="number">6000000</span> ns</span><br><span class="line">    present <span class="string">offset:</span>         <span class="number">0</span> ns     VSYNC <span class="string">period:</span>  <span class="number">16666666</span> ns</span><br></pre></td></tr></table></figure><p>下面以 Systrace 为例，来看 Offset 在 Systrace 中的表现</p><h2 id="Offset-为-0"><a href="#Offset-为-0" class="headerlink" title="Offset 为 0"></a>Offset 为 0</h2><p>首先说 Offset 为 0 的情况， 此时 App 和 SurfaceFlinger 是同时收到 Vsync 信号 ， 其对应的 Systrace 图如下：</p><p><img src="/images/15751537800460.jpg" alt=""></p><p>这个图上面也有讲解，这里就不再详细说明，大家只需要看到，App 渲染好的 Buffer，要等到下一个 Vsync-SF 来的时候才会被 SurfaceFlinger 拿去做合成，这个时间大概在 16.6 ms。这时候大家可能会想，<strong>如果 App 的 Buffer 渲染结束，Swap 到 BufferQueue 中 ，就触发 SurfaceFlinger 去做合成，那岂不是省了一些时间(0-16.6ms )</strong>? </p><p>答案是可行的，这也就引入了 Offset 机制，在这种情况下，App 先收到 Vsync 信号，进行一帧的渲染工作，然后过了 Offset 时间后，SurfaceFlinger 才收到 Vsync 信号开始合成，这时候如果 App 的 Buffer 已经 Ready 了，那么 SurfaceFlinger 这一次合成就可以包含 App 这一帧，用户也会早一点看到。</p><h2 id="Offset-不为-0"><a href="#Offset-不为-0" class="headerlink" title="Offset 不为 0"></a>Offset 不为 0</h2><p>下图中，就是一个 Offset 为 4ms 的案例，App 收到 Vsync 4 ms 之后，SurfaceFlinger 才收到 Vsync 信号</p><p><img src="/images/15751537928994.jpg" alt=""></p><h2 id="Offset-的优缺点"><a href="#Offset-的优缺点" class="headerlink" title="Offset 的优缺点"></a>Offset 的优缺点</h2><p>Offset 的一个比较难以确定的点就在于 Offset 的时间该如何设置，这也是众多厂商默认都不进行配置 Offset 的一个原因，其优缺点是动态的，与机型的性能和使用场景有很大的关系</p><ol><li>如果 Offset 配置过短，那么可能 App 收到 Vsync-App 后还没有渲染完成，SurfaceFlinger 就收到 Vsync-SF 开始合成，那么此时如果 App 的 BufferQueue 中没有之前累积的 Buffer，那么 SurfaceFlinger 这次合成就不会有 App 的东西在里面，需要等到下一个 Vsync-SF 才能合成这次 App 的内容，时间相当于变成了 Vsync 周期+Offset，而不是我们期待的 Offset</li><li>如果 Offset 配置过长，就起不到作用了</li></ol><h1 id="HW-Vsync"><a href="#HW-Vsync" class="headerlink" title="HW_Vsync"></a>HW_Vsync</h1><p>这里需要说明的是，不是每次申请 Vsync 都会由硬件产生 Vsync，只有此次请求 vsync 的时间距离上次合成时间大于 500ms，才会通知 hwc，请求 HW_VSYNC</p><p>以桌面滑动为例，看 SurfaceFlinger 的进程 Trace 可以看到 HW_VSYNC 的状态</p><p><img src="/images/15751538069738.jpg" alt=""></p><p>后续 App 申请 Vsync 时候，会有两种情况，一种是有 HW_VSYNC 的情况，一种是没有有 HW_VSYNC 的情况</p><h2 id="不使用HW-VSYNC"><a href="#不使用HW-VSYNC" class="headerlink" title="不使用HW_VSYNC"></a>不使用HW_VSYNC</h2><p><img src="/images/15751538170844.jpg" alt=""></p><h2 id="使用-HW-VSYNC"><a href="#使用-HW-VSYNC" class="headerlink" title="使用 HW_VSYNC"></a>使用 HW_VSYNC</h2><p><img src="/images/15751538247774.jpg" alt=""></p><p>HW_VSYNC 主要是利用最近的硬件 VSYNC 来做预测,最少要 3 个,最多是 32 个,实际上要用几个则不一定, DispSync 拿到 6 个 VSYNC 后就会计算出 SW_VSYNC,只要收到的 Present Fence 没有超过误差,硬件 VSYNC 就会关掉,不然会继续接收硬件 VSYNC 计算 SW_VSYNC 的值,直到误差小于 threshold.关于这一块的计算具体过程，可以参考这篇文章： <a href="https://juejin.im/post/5dbe658be51d452a45800e76#heading-20" target="_blank" rel="noopener">S</a>  <a href="https://juejin.im/post/5dbe658be51d452a45800e76#heading-20" target="_blank" rel="noopener">W-VS</a>  <a href="https://juejin.im/post/5dbe658be51d452a45800e76#heading-20" target="_blank" rel="noopener">YN</a>  <a href="https://juejin.im/post/5dbe658be51d452a45800e76#heading-20" target="_blank" rel="noopener">C</a><a href="https://juejin.im/post/5dbe658be51d452a45800e76#heading-20" target="_blank" rel="noopener"> 的生成与传递</a> ，关于这一块的流程大家也可以参考这篇文章，里面有更细节的内容，这里摘录了他的结论</p><blockquote><p>SurfaceFlinger 通过实现了 HWC2::ComposerCallback 接口，当 HW-VSYNC 到来的时候，SurfaceFlinger 将会收到回调并且发给 DispSync。DispSync 将会把这些 HW-VSYNC 的时间戳记录下来，当累计了足够的 HW-VSYNC 以后（目前是大于等于 6 个），就开始计算 SW-VSYNC 的偏移 mPeriod。计算出来的 mPeriod 将会用于 DispSyncThread 用来模拟 HW-VSYNC 的周期性起来并且通知对 VSYNC 感兴趣的 Listener，这些 Listener 包括 SurfaceFlinger 和所有需要渲染画面的 app。这些 Listener 通过 EventThread 以 Connection 的抽象形式注册到 EventThread。DispSyncThread 与 EventThread 通过 DispSyncSource 作为中间人进行连接。EventThread 在收到 SW-VSYNC 以后将会把通知所有感兴趣的 Connection，然后 SurfaceFlinger 开始合成，app 开始画帧。在收到足够多的 HW-VSYNC 并且在误差允许的范围内，将会关闭通过 EventControlThread 关闭 HW-VSYNC。</p></blockquote><h1 id="本文其他地址"><a href="#本文其他地址" class="headerlink" title="本文其他地址"></a>本文其他地址</h1><p>待更新</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://source.android.google.cn/devices/graphics/implement-vsync" target="_blank" rel="noopener">VSYNC</a> </li><li><a href="https://juejin.im/post/5b6948086fb9a04fb87771fb" target="_blank" rel="noopener">https://juejin.im/post/5b6948086fb9a04fb87771fb</a></li><li><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">http://gityuan.com/2017/02/05/graphic_arch/</a></li><li><a href="https://juejin.im/post/5dbe658be51d452a45800e76#heading-20" target="_blank" rel="noopener">SW-VSYNC 的生成与传递</a></li><li><a href="http://echuang54.blogspot.com/2015/01/dispsync.html" target="_blank" rel="noopener">http://echuang54.blogspot.com/2015/01/dispsync.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android App 启动优化全记录</title>
      <link href="/2019/11/18/Android-App-Lunch-Optimize/"/>
      <url>/2019/11/18/Android-App-Lunch-Optimize/</url>
      
        <content type="html"><![CDATA[<p>本文参考了目前大部分 Android 应用启动优化的方案，将大家的方案做一个汇总，如果你有这方面的需求，只需要对照这篇文章，看看其他人的方案，查漏补缺。很多方案是要根据具体的业务去做优化的，所以这里也没有对每一种方案进行详细的介绍，要用到哪一个方案的时候，可以具体去网上查找对应方案的具体实现方法，这里只是做一个汇总</p><p>另外我还加上了部分系统厂商所做的启动相关的优化，不过只写了一些我知道的，还有一些厂商有黑科技，就不在这里的讨论范围了。知道厂商做的事情，可能也会帮助到你，比如联系厂商做白名单、接入厂商 SDK 等</p><a id="more"></a><h1 id="应用启动概述"><a href="#应用启动概述" class="headerlink" title="应用启动概述"></a>应用启动概述</h1><h2 id="应用启动的一般流程"><a href="#应用启动的一般流程" class="headerlink" title="应用启动的一般流程"></a>应用启动的一般流程</h2><p>应用的启动，从桌面点击应用图标到主界面用户可操作，大致遵循下面的流程：</p><p><img src="/images/15740895170994.jpg" alt=""></p><p>可以看到应用启动过程中，最重要的两个进程就是 SystemServer 和 App Process . 其职责划分如下：</p><ul><li><strong>SystemServer 负责应用的启动流程调度、进程的创建和管理、窗口的创建和管理(StartingWindow 和 AppWindow) 等</strong></li><li><strong>应用进程被 SystemServer 创建后，进行一系列的进程初始化、组件初始化(Activity、Service、ContentProvider、Broadcast)、主界面的构建、内容填充等</strong></li></ul><h2 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h2><p>这里还需要引入冷启动和热启动的概念，这也是我们经常会碰到的两个概念</p><ul><li><strong>冷启动</strong>：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，然后再根据启动的参数，启动对应的进程组件，这个启动方式就是冷启动</li><li><strong>热启动</strong>：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动对应的进程组件，这个方式叫热启动</li></ul><h2 id="启动速度的测量"><a href="#启动速度的测量" class="headerlink" title="启动速度的测量"></a>启动速度的测量</h2><p>各家应该都有自己的方案，关键在于如何定义启动结束的点，这个也是一直困扰我的一个地方，有的应用很好定义，有的应用则因为比较复杂，无法直接衡量启动速度。像 adb 这种方法自己玩玩可以，生产环境没啥用；录屏本身就有性能损耗..</p><p>这里我建议大家学习<a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650403370&idx=1&sn=b4297b138eb7f73c95a6279c3458f025&chksm=83953a32b4e2b3247fc18cbee08a2682d8b09720a1c5fef0c36257ae92b1e201cb1ad3125455&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener">历时1年，上百万行代码！首次揭秘手淘全链路性能优化（上）</a>中提到的测量方法：自动化、稳定、持续集成</p><blockquote><p>通过OCR提取图片中的文字信息作为关键特征。该算法的优势：1. 在于应用页面上基本都是有文字的， OCR也可以识别到图片上的文字， 文字出现则图片加载完成， 和用户体感是一致的；2. 文字作为特征，过滤掉了很多图片特征可能带来的噪声， 减少了算法调试的工作量；另外阿里集团内有非常成熟和优秀的OCR服务——读光，文档识别率超过99.7%， 使用水滴平台封装的OCR服务，可以快速接入和使用。最终的识别方案就是基于OCR识别来进行的</p></blockquote><h1 id="App-优化"><a href="#App-优化" class="headerlink" title="App 优化"></a>App 优化</h1><h2 id="启动窗口优化"><a href="#启动窗口优化" class="headerlink" title="启动窗口优化"></a>启动窗口优化</h2><p>启动窗口，也叫启动页、SplashWindow、StartingWindow 等，指的是应用启动时候的预览窗口。iOS App 强制有一个启动页，用户点击桌面 App 图标之后，系统会立即显示这个启动窗口，等 App 主页加载好之后再显示主页面。Android 也有类似的机制 (启动窗口这个是 Android 系统提供的)，但是也提供了一个接口，让应用开发者设置是否显示这个启动窗口(默认是显示)，部分开发者会把这个系统提供的启动窗口禁掉，启动自己的窗口。</p><p>但是启动自己的窗口需要的时间要比直接显示系统的启动窗口所花的时间要长，这就会导致用户在使用的时候，点击图标启动 App 的时候，有一定的延迟，表现在点击图标过了一段时间才进行窗口动画进入 App，我们要尽量避免这种情况</p><ul><li><strong>不要禁止系统默认的启动窗口：即不要在主题里面设置 android:windowDisablePreview 为 true</strong></li><li>自己定制启动窗口的内容，比如将启动页主题背景设置成闪屏页图片，或者尽量使闪屏页面的主题和主页一致。可以参考知乎、抖音的做法</li><li>合并闪屏和主页面的 Activity ：微信的做法，不过由于微信设置了 android:windowDisablePreview ， 且他在各个厂商的白名单里面，一般不会被杀，冷启动的机会比较少。不过也是一个可以思考的地方</li></ul><h2 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h2><p>线程优化主要是减少 CPU 调度带来的波动，让启动时间更稳定。如果启动过程中有太多的线程一起启动，会给 CPU 带来非常大的压力，尤其是比较低端的机器。过多的线程同时跑会让主线程的 Sleep 和 Runnable 状态变多， 增加了应用的启动速度，优化的过程中要注意：</p><ul><li>控制线程数量 – 线程池</li><li>检查线程间的锁 ，防止依赖等待</li><li>使用合理的启动架构<ul><li>微信内部使用的 mmkernel</li><li>阿里 Alpha</li></ul></li></ul><h2 id="系统调度优化"><a href="#系统调度优化" class="headerlink" title="系统调度优化"></a>系统调度优化</h2><p>应用启动的时候，如果主线程的工作过多，也会造成主线程过于繁忙，下面几个系统调度相关的点需要注意：</p><ul><li><strong>启动过程中减少系统调用</strong>，避免与 AMS、WMS 竞争锁。启动过程中本身 AMS 和 WMS 的工作就很多，且 AMS 和 WMS 很多操作都是带锁的，如果此时 App 再有过多的 Binder 调用与 AMS、WMS 通信，SystemServer 就会出现大量的锁等待，阻塞关键操作</li><li><strong>启动过程中不要启动子进程</strong>，如果好几个进程同时启动，系统负担则会加倍，SystemServer 也会更繁忙</li><li><strong>启动过程中除了 Activity 之外的组件启动要谨慎</strong>，因为四大组件的启动都是在主线程的，如果组件启动慢，占用了 Message 通道，也会影响应用的启动速度</li><li>Application 和主 Activity 的 onCreate 中异步初始化某些代码</li></ul><p>启动过程中繁忙的 cpu<br><img src="/images/15740895432157.jpg" alt=""></p><p>启动过程中繁忙的 SystemServer<br><img src="/images/15740895514226.jpg" alt=""></p><h2 id="GC-优化"><a href="#GC-优化" class="headerlink" title="GC 优化"></a>GC 优化</h2><p>启动过程中减少 GC 的次数</p><ul><li>避免进行大量的字符串操作，特别是序列化和反序列化</li><li>频繁创建的对象需要考虑复用</li><li>转移到 Native 实现</li></ul><p>可以参考下面这篇文章 <a href="https://juejin.im/post/5be1077d518825171140dbfa" target="_blank" rel="noopener">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a>)</p><h2 id="IO-优化"><a href="#IO-优化" class="headerlink" title="IO 优化"></a>IO 优化</h2><p>启动过程中负载比较高，有许多系统 IO 都在此时发生，这时候 IO 的性能下降会比较快，此时 App 中的 IO 操作会比平时更慢一些，尤其是在性能比较差的机器上。</p><p>IO 分网络 IO 和磁盘 IO ，启动过程中不建议进行网络 IO ，对于磁盘 IO 则要细扣，邵文在高手课里面有讲到：</p><ol><li>我们要清楚启动过程中读了什么文件、多少个字节、 Buffer 是多大，使用了多长时间、在什么线程等一系列信息</li><li>进行启动过程中的 IO 监控，微信在监控 IO 时发现有用户的 db 文件达到了 500MB</li></ol><p><img src="/images/15740895712642.jpg" alt=""></p><p>下面图中可以看到低内存的时候，启动应用主线程有较多的 IO 等待（UI Thread 这一栏，橘红色代表 IO 等待 ）</p><p><img src="/images/15740895799020.jpg" alt=""></p><p><img src="/images/15740895863900.jpg" alt=""></p><h2 id="资源重排"><a href="#资源重排" class="headerlink" title="资源重排"></a>资源重排</h2><p>利用 Linux 的 IO 读取策略，PageCache 和 ReadAhead 机制，按照读取顺序重新排列，减少磁盘 IO 次数 。具体操作可以参考<a href="https://juejin.im/post/5be400c3f265da61476fb63c" target="_blank" rel="noopener">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a> 这篇文章</p><p>Linux 底层文件系统中 VFS 上次 App 进程之间，存在一层 pagecache，pagecache 由内存中的物理 page 组成，其内容对应磁盘上的 block。Pagecache 的大小是动态变化的，可以扩大，也可以在内存不足时缩小。Cache 缓存的存储设备被称为后备存储（backing store），一个 page 通常包含多个 block，这些 block 不一定是连续的</p><p><img src="/images/15740895943096.jpg" alt=""></p><p>利用文件重布局结合Pagecache 机制可以减少启动过程中的真正 IO 的次数，简单的说，通过文件重布局的目的，就是将启动阶段需要用到的文件在 APK 文件中排布在一起，尽可能的利用 pagecache 机制，用最少的磁盘 IO 次数，读取尽可能多的启动阶段需要的文件，减少 IO 开销，从而达到提升启动性能的目的</p><h2 id="类重排"><a href="#类重排" class="headerlink" title="类重排"></a>类重排</h2><p>类重排的实现通过 ReDex 的 Interdex 调整类在 Dex 中的排列顺序。Interdex 优化不需要去分析类引用，它只需要调整 Dex 中类的顺序，把启动时需要加载的类按顺序放到主 dex 里，这个工作我们完全可以在编译过程中实现，而且这个优化可以提升启动速度，优化效果从 facebook 公布的数据来看也比较可观，性价比高。具体实现可以参考 <a href="https://mp.weixin.qq.com/s/Bf41Kez_OLZTyty4EondHA?" target="_blank" rel="noopener">Redex 初探与 Interdex：Andorid 冷启动优化</a></p><h2 id="主页面布局优化"><a href="#主页面布局优化" class="headerlink" title="主页面布局优化"></a>主页面布局优化</h2><p>应用主界面布局优化是老生常谈了，综合起来无非就是下面两点，这个需要结合具体的界面布局去做优化，网上也有比较多的资料可以查阅</p><ul><li>通过减少冗余或者嵌套布局来降低视图层次结构</li><li>用 ViewStub 替代在启动过程中不需要显示的 UI 控件</li><li>使用自定义 View 替代复杂的 View 叠加</li></ul><h2 id="闲时调用"><a href="#闲时调用" class="headerlink" title="闲时调用"></a>闲时调用</h2><p>IdleHandler：当 Handler 空闲的时候才会被调用，如果返回 true, 则会一直执行，如果返回 false，执行完一次后就会被移除消息队列。比如，我们可以将从服务器获取推送 Token 的任务放在延迟 IdleHandler 中执行，或者把一些不重要的 View 的加载放到 IdleHandler 中执行</p><h2 id="类加载优化"><a href="#类加载优化" class="headerlink" title="类加载优化"></a>类加载优化</h2><p>可以在 systrace 生成的文件中看到 verifyClass 过程，因为需要校验方法的每一个指令，所以是一个比较耗时的操作。</p><p><img src="/images/15740896151484.jpg" alt=""></p><h2 id="App-瘦身"><a href="#App-瘦身" class="headerlink" title="App 瘦身"></a>App 瘦身</h2><p>App 瘦身包括代码瘦身和资源瘦身，通常的做法如下：</p><ul><li>Inspect  Code ：Android Studio 提供的代码审查工具，实际上是内嵌了 Lint </li><li>代码混淆</li><li>图片格式的选择：如果对图片的要求不高，可以换成 565</li><li>接入资源混淆</li><li>减少 Dex 数量</li></ul><h2 id="选择合适的启动框架"><a href="#选择合适的启动框架" class="headerlink" title="选择合适的启动框架"></a>选择合适的启动框架</h2><p>启动优化整个流程的梳理，流程的梳理，我们这里引入了一个有向无环图的概念，我们会把整个的概念梳理成有向无环图的结构，然后会去挨个加载。右边的部分，可以看到我们其实在启动的时候，首先会去加载一些必要的启动项，必要的启动项是左边流程，会用一个多进程的方式加载，以来有向无环图进行控制，比如说我是在非必须的时候启动加载我可以放在后面再去加载。当然在整个有向无环图的顺序加载，其实还是会做一些进程的判断，要判断某些项目是不是要在主进程里加载，某些要在初始进程里面加载</p><p>从 Spark 的 DAGScheduler 中领悟到它的核心思想，面向阶段调度（Stage-Oriented Scheduler）：把应用划分成一个个的阶段（Stage），再把任务（Task）安排到各个阶段中去，任务的编排则是通过构建 有向无环图（DAG），把任务依赖通过图的方式梳理得 井井有条。因为它分阶段执行，先集中资源把阶段一搞定，再齐心协力去执行阶段二，这样即能控制拥塞，又能保证时序，还能并发执行，让设备性能尽可能得到发挥</p><p><img src="/images/15740896407148.jpg" alt=""></p><p><img src="/images/15740896485396.jpg" alt=""></p><p><img src="/images/15740896590892.jpg" alt=""></p><p>大家可以参考淘宝的全链路优化的案例：<a href="https://yq.aliyun.com/articles/710466" target="_blank" rel="noopener">历时1年，上百万行代码！首次揭秘手淘全链路性能优化（上）</a></p><h2 id="启动网络链路优化"><a href="#启动网络链路优化" class="headerlink" title="启动网络链路优化"></a>启动网络链路优化</h2><h3 id="问题和优化点"><a href="#问题和优化点" class="headerlink" title="问题和优化点"></a>问题和优化点</h3><ul><li>发送处理阶段：网络库bindService影响前x个请求，图片并发限制图片库线程排队</li><li>网络耗时：部分请求响应size大，包括 SO文件，Cache资源，图片原图大尺寸等</li><li>返回处理：个别数据网关请求json串复杂解析严重耗时（3s）,且历史线程排队设计不合适</li><li>上屏阻塞：回调UI线程被阻，反映主线程卡顿严重。高端机达1s，低端机恶化达3s以上</li><li>回调阻塞：部分业务回调执行耗时，阻塞主线程或回调线程</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>多次重复的请求，业务方务必收敛请求次数，减少非必须请求。</li><li>数据大的请求如资源文件、so文件，非启动必须统一延后或取消。</li><li>业务方回调执行阻塞主线程耗时过长整改。我们知道，肉眼可见流畅运行，需要运行60帧/秒， 意味着每帧的处理时间不超过16ms。针对主线程执行回调超过16ms的业务方，推动主线程执行优化。</li><li>协议json串过于复杂导致解析耗时严重，网络并发线程数有限，解析耗时过长意味着请求长时间占用MTOP线程影响其他关键请求执行。推动业务方handler注入使用自己的线程解析或简化json串。</li></ul><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>Activity 打开之前就预加载数据，在 Activity 的 UI 布局初始化完成后显示预加载的数据，大大缩短启动时间。 可以参考 ：<a href="https://github.com/luckybilly/PreLoader/blob/master/README-zh-CN.md" target="_blank" rel="noopener">https://github.com/luckybilly/PreLoader/blob/master/README-zh-CN.md</a></p><h2 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h2><p>保活，是各个应用开发者的噩梦，也是 Android 厂商关注和打击的重点。不过从启动的角度来看，如果应用进程不被杀，那么启动自然就快了，所以保活对应用启动速度也是有极大的帮助。</p><p>当然这里说的保活，并不是建议大家用各种黑科技、相互唤醒、通知轰炸这种保活手段，而是提供真正的功能，能让用户觉得你在后台是合理的、可以接收的。比如在后台的时候，资源能释放的都释放掉，不要一直在后台做耗电操作，该停的服务停掉，该关的动画关掉。</p><p>当然对于应用开发者来说，上面说的都太多理想化了，而且目前的手机厂商也会很暴力，应用到了后台就会处理掉，不过这毕竟是一个方向，Google 也在规范应用后台行为和规范厂商处理应用这两方面都在做努力，Android 系统的生态，还是需要应用开发者和 Android 厂商一起取改善。</p><p>当然保活还有一条路就是走跟厂商的合作，优化后台内存、去掉重复拉起、去掉流氓逻辑、积极响应低内存警告，做好这些话后可以跟系统厂商联系，<strong>谈放到查杀白名单和自启动白名单的可行性</strong></p><h2 id="业务梳理"><a href="#业务梳理" class="headerlink" title="业务梳理"></a>业务梳理</h2><p>这里涉及到具体的业务，每个 App 都不一样，但是所要做的事情都是一样的，下面是邵文在高手课里面提到的：</p><ul><li>梳理清楚启动过程中的每一个模块，哪些是一定需要的，那些是可以砍掉，那些是可以懒加载的</li><li>根据不同的业务场景决定不同的启动模式</li><li>懒加载防止集中化</li></ul><p>可以把具体的业务分为下面四个维度（此处图文来自<a href="https://juejin.im/post/5c21ea325188254eaa5c45b1#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5c21ea325188254eaa5c45b1#heading-5</a>）</p><ul><li>必要且耗时：启动初始化，考虑用线程来初始化</li><li>必要不耗时：首页绘制</li><li>非必要但耗时：数据上报、插件初始化</li><li>非必要不耗时：不用想，这块直接去掉，在需要用的时再加载</li></ul><p>然后按需进行加载优化</p><p><img src="/images/15740896948509.jpg" alt=""></p><h2 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h2><ol><li>优化业务中的代码效率，抓大放小，先从比较明显的瓶颈处下手，逐步进行优化</li><li>历史债务要偿还，历史的代码要重构，不能一直拖着</li></ol><p>具体的业务会有具体的优化场景，大家可以参考这篇文章中的优化流程和优化项<a href="https://www.jianshu.com/p/f5514b1a826c" target="_blank" rel="noopener">https://www.jianshu.com/p/f5514b1a826c</a></p><blockquote><ol><li>数据库及IO操作都移到工作线程，并且设置线程优先级为THREAD_PRIORITY_BACKGROUND，这样工作线程最多能获取到10%的时间片，优先保证主线程执行</li><li>流程梳理，延后执行；实际上，这一步对项目启动加速最有效果。通过流程梳理发现部分流程调用时机偏失等，  例如<ol><li>更新等操作无需在首屏尚未展示就调用，造成资源竞争</li><li>调用了IOS为了规避审核而做的开关，造成网络请求密集</li><li>自有统计在Application的调用里创建数量固定为5的线程池，造成资源竞争</li><li>修改广告闪屏逻辑为下次生效</li></ol></li><li>去掉用无但被执行的老代码</li><li>去掉开发阶段使用但线上被执行的代码</li><li>去掉重复逻辑执行代码</li><li>去掉调用三方SDK里或者Demo里的多余代码</li><li>信息缓存，常用信息只在第一次获取，之后从缓存中取</li><li>项目是多进程架构，只在主进程执行Application的onCreate()</li></ol></blockquote><h2 id="减少Activity的跳转层次"><a href="#减少Activity的跳转层次" class="headerlink" title="减少Activity的跳转层次"></a>减少Activity的跳转层次</h2><p>StartingWindow 会在用户点击 App 后立即创建并显示(前提是 App 没有禁止 StartingWindow)，在 AppWindow 创建好之后，StartingWindow 消失，AppWindow 显示</p><h3 id="默认-App-的启动窗口流程"><a href="#默认-App-的启动窗口流程" class="headerlink" title="默认 App 的启动窗口流程"></a>默认 App 的启动窗口流程</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StartingWindow(<span class="name">SystemWindow</span>) </span><br><span class="line">  -&gt;MainActivity(<span class="name">AppWindow</span>)</span><br></pre></td></tr></table></figure><h3 id="大部分三方-App-启动流程"><a href="#大部分三方-App-启动流程" class="headerlink" title="大部分三方 App 启动流程"></a>大部分三方 App 启动流程</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StartingWindow(<span class="name">SystemWindow</span>) </span><br><span class="line">  -&gt; SplashActivity(<span class="name">AppWindow</span>)</span><br><span class="line">    -&gt; MainActivity(<span class="name">AppWindow</span>)</span><br></pre></td></tr></table></figure><h3 id="糟糕一点的启动流程是这样的"><a href="#糟糕一点的启动流程是这样的" class="headerlink" title="糟糕一点的启动流程是这样的"></a>糟糕一点的启动流程是这样的</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StartingWindow(SystemWindow) </span><br><span class="line"><span class="function">  -&gt;</span> MainActivity(AppWindow) </span><br><span class="line"><span class="function">    -&gt;</span> SplashActivity(AppWindow)</span><br><span class="line"><span class="function">      -&gt;</span> MainActivity(AppWindow)</span><br></pre></td></tr></table></figure><h3 id="更糟糕一点的启动流程：去掉了-StartingWindow"><a href="#更糟糕一点的启动流程：去掉了-StartingWindow" class="headerlink" title="更糟糕一点的启动流程：去掉了 StartingWindow"></a>更糟糕一点的启动流程：去掉了 StartingWindow</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">SplashActivity</span>(<span class="variable">AppWindow</span>)</span></span><br><span class="line">   -&gt; <span class="function"><span class="title">MainActivity</span>(<span class="variable">AppWindow</span>)</span></span><br></pre></td></tr></table></figure><p>其实对用户来说，第一种启动流程是最好的，只涉及到一次窗口的切换；但是部分 App 由于广告页的需求，会使用第二种流程 ；但是尽量不要使用第三种和第四种启动流程，体验非常不好</p><h1 id="厂商优化"><a href="#厂商优化" class="headerlink" title="厂商优化"></a>厂商优化</h1><p>除了 App 自身的优化之外，Android 框架对应用启动也是非常关注的，做了比较多的优化，下面简单说一下思路，各个厂商的实现也不太一样，但是基本上都会有，有些是硬核代码优化，有的是利用系统策略做优化。</p><p>厂商的策略各不相同，这里只是简单的提一下思路</p><h2 id="启动加速"><a href="#启动加速" class="headerlink" title="启动加速"></a>启动加速</h2><p>App 启动的时候，系统会对要启动的应用做绝对的资源倾斜，比如 CPU、IO、GPU 等，这一点大家抓个 Systrace 看一下即可，不管是频率还是调度算法，正在启动的 App 绝对是当时的系统 VIP 客户</p><p><img src="/images/15740897496735.jpg" alt=""></p><p>部分厂商也提供了资源调度的 SDK ，应用可以接入这些 SDK，在需要资源的时候直接调用 SDK 获取</p><h2 id="PreFork"><a href="#PreFork" class="headerlink" title="PreFork"></a>PreFork</h2><p>Android Q 加入了 PreFork 机制，会先 fork 几个空进程，当 App 启动的时候，可以直接复用这几个空进程，而不用重新去 fork</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">348</span>K: usap32 (pid <span class="number">18731</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">346</span>K: usap32 (pid <span class="number">18702</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">343</span>K: usap32 (pid <span class="number">18707</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">342</span>K: usap32 (pid <span class="number">18729</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">341</span>K: usap32 (pid <span class="number">18711</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">335</span>K: usap32 (pid <span class="number">20322</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">335</span>K: usap32 (pid <span class="number">20325</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">333</span>K: usap32 (pid <span class="number">20319</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">333</span>K: usap32 (pid <span class="number">20320</span>)</span><br><span class="line"><span class="number">2</span>,<span class="number">333</span>K: usap32 (pid <span class="number">20321</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,<span class="number">509</span>K: usap64 (pid <span class="number">21169</span>)</span><br><span class="line"><span class="number">1</span>,<span class="number">509</span>K: usap64 (pid <span class="number">21180</span>)</span><br><span class="line"><span class="number">1</span>,<span class="number">507</span>K: usap64 (pid <span class="number">21171</span>)</span><br><span class="line"><span class="number">1</span>,<span class="number">452</span>K: usap64 (pid <span class="number">21513</span>)</span><br><span class="line"><span class="number">1</span>,<span class="number">450</span>K: usap64 (pid <span class="number">21506</span>)</span><br><span class="line"><span class="number">1</span>,<span class="number">449</span>K: usap64 (pid <span class="number">21512</span>)</span><br><span class="line"><span class="number">1</span>,<span class="number">447</span>K: usap64 (pid <span class="number">21511</span>)</span><br><span class="line"><span class="number">1</span>,<span class="number">445</span>K: usap64 (pid <span class="number">21514</span>）</span><br></pre></td></tr></table></figure><h2 id="启动消息重排"><a href="#启动消息重排" class="headerlink" title="启动消息重排"></a>启动消息重排</h2><p>启动的时候，对启动过程中的 Message 进行重新排列</p><h2 id="主线程、渲染线程加速"><a href="#主线程、渲染线程加速" class="headerlink" title="主线程、渲染线程加速"></a>主线程、渲染线程加速</h2><p>部分厂家会对启动过程 App 的主线程和渲染线程做特殊对待，比如让他们直接跑到大核上，将其他不重要的线程移到小核</p><h2 id="启动预测"><a href="#启动预测" class="headerlink" title="启动预测"></a>启动预测</h2><p>部分场景会针对用户的使用习惯进行学习，比如在什么时间、什么场合、什么交通工具打开手机，系统会预测你要启动的 App，并在后台进行启动，这样你点击这个 App 的时候，就已经是热启动了</p><h2 id="后台保活"><a href="#后台保活" class="headerlink" title="后台保活"></a>后台保活</h2><p>系统也会对一些应用进行特殊处理，以提升用户体验：包括但不限于 <strong>进程\线程优先级调整、查杀白名单、用户常用应用记录</strong>等，进行适当的后台保活，下次启动的时候就是热启动了</p><h2 id="后台重启"><a href="#后台重启" class="headerlink" title="后台重启"></a>后台重启</h2><p>系统会对一些应用进行特殊处理，比如这个 App 比较重要但是不能杀掉，那么有的厂商会在这种应用退到后台之后，进行无感重启：比如说某个应用内存超标或者持续 Crash ，后台重启可以很好地解决这个问题，这样重启后的 App 是用户点击启动的时候就是热启动</p><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>部分应用启动的时候，需要大量的内存，比如现在的相机启动，这时候如果没有足够的内存，那么系统必须要通过杀掉很多应用、释放 Cache 等操作来给这个 App 让路，这个过程会使得这些大内存的 App 在启动的时候频繁进行内存操作，导致启动速度变慢</p><p>部分厂商会在监测到这种大内存 App 启动的时候，提前做内存的回收操作，这样在启动的时候，就有了足够的内存给这个 App 使用</p><h2 id="优化启动逻辑"><a href="#优化启动逻辑" class="headerlink" title="优化启动逻辑"></a>优化启动逻辑</h2><p>Android 系统更新也会对应用启动速度进行优化，比如上面提到的 Pre-Fork，又比如这里的简化 doFrame 个数</p><p><img src="/images/15740897674007.jpg" alt=""></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650829097&idx=2&sn=e59841d4b1ed7e12a30e29ec51072d70&chksm=80b7a5b7b7c02ca184e0c06289d90823d589e738c55712318875f51e4aeb8646294b8d426299&mpshare=1&scene=1&srcid=&sharer_sharetime=1571275213308&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">都9102年了，Android 冷启动优化除了老三样还有哪些新招？</a></li><li><a href="https://developer.android.google.cn/topic/performance/vitals/launch-time" target="_blank" rel="noopener">App startup time</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650403370&idx=1&sn=b4297b138eb7f73c95a6279c3458f025&chksm=83953a32b4e2b3247fc18cbee08a2682d8b09720a1c5fef0c36257ae92b1e201cb1ad3125455&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener">历时1年，上百万行代码！首次揭秘手淘全链路性能优化（上）</a></li><li><a href="https://time.geekbang.org/column/intro/142" target="_blank" rel="noopener">极客时间 ： Android 高手开发课</a></li><li><a href="https://github.com/facebook/redex" target="_blank" rel="noopener">Facebook-Redex</a></li><li><a href="http://yummylau.com/2019/03/15/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%20alpha/" target="_blank" rel="noopener">关于 Android 异步启动框架 alpha 的思考</a></li><li><a href="https://mp.weixin.qq.com/s/79tAFx6zi3JRG-ewoapIVQ" target="_blank" rel="noopener">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></li><li><a href="https://github.com/facebook/redex" target="_blank" rel="noopener">Redex 官网</a></li><li><a href="https://mp.weixin.qq.com/s/Bf41Kez_OLZTyty4EondHA?" target="_blank" rel="noopener">Redex 初探与 Interdex：Andorid 冷启动优化</a></li><li><a href="https://juejin.im/post/5c21ea325188254eaa5c45b1#heading-5" target="_blank" rel="noopener">Android性能优化笔记（一）——启动优化</a></li></ol><h1 id="本文其他地址"><a href="#本文其他地址" class="headerlink" title="本文其他地址"></a>本文其他地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎或者掘金页面</p><p><a href="https://zhuanlan.zhihu.com/p/92497570" target="_blank" rel="noopener">知乎 - Android App 启动优化全记录</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Lunch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 - MainThread 和 RenderThread 解读</title>
      <link href="/2019/11/06/Android-Systrace-MainThread-And-RenderThread/"/>
      <url>/2019/11/06/Android-Systrace-MainThread-And-RenderThread/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第九篇，主要是是介绍 Android App 中的 MainThread 和 RenderThread，也就是大家熟悉的<strong>主线程</strong>和<strong>渲染线程</strong>。文章会从 Systrace 的角度来看 MainThread 和 RenderThread 的工作流程，以及涉及到的相关知识：卡顿、软件渲染、掉帧计算等</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这里以滑动列表为例 ，我们截取主线程和渲染线程<strong>一帧</strong>的工作流程(每一帧都会遵循这个流程，不过有的帧需要处理的事情多，有的帧需要处理的事情少) ，重点看 “UI Thread ” 和 RenderThread 这两行</p><p><img src="/images/15732904872967.jpg" alt=""></p><p><strong>这张图对应的工作流程如下</strong></p><ol><li>主线程处于 Sleep 状态，等待 Vsync 信号</li><li>Vsync 信号到来，主线程被唤醒，Choreographer 回调 FrameDisplayEventReceiver.onVsync 开始一帧的绘制</li><li>处理 App 这一帧的 Input 事件(如果有的话)</li><li>处理 App 这一帧的 Animation 事件(如果有的话)</li><li>处理 App 这一帧的 Traversal 事件(如果有的话)</li><li>主线程与渲染线程同步渲染数据，同步结束后，主线程结束一帧的绘制，可以继续处理下一个 Message(如果有的话，IdleHandler 如果不为空，这时候也会触发处理)，或者进入 Sleep 状态等待下一个 Vsync</li><li>渲染线程首先需要从 BufferQueue 里面取一个 Buffer(dequeueBuffer) , 进行数据处理之后，调用 OpenGL 相关的函数，真正地进行渲染操作，然后将这个渲染好的 Buffer 还给 BufferQueue (queueBuffer) , SurfaceFlinger 在 Vsync-SF 到了之后，将所有准备好的 Buffer 取出进行合成(这个流程在讲 SurfaceFlinger 的时候会提到)</li></ol><p>上面这个流程在 <a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android 基于 Choreographer 的渲染机制详解</a> 这篇文章里面已经介绍的很详细了，包括每一帧的 doFrame 都在做什么、卡顿计算的原理、APM 相关. 没有看过这篇文章的同学，建议先去扫一眼</p><p>那么这篇文章我们主要从 <a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android 基于 Choreographer 的渲染机制详解</a> 这篇文章没有讲到的几个点来入手，帮你更好地理解主线程和渲染线程</p><ol><li>主线程的发展</li><li>主线程的创建</li><li>渲染线程的创建</li><li>主线程和渲染线程的分工</li><li>游戏的主线程与渲染线程</li><li>Flutter 的主线程和渲染线程</li></ol><h1 id="主线程的创建"><a href="#主线程的创建" class="headerlink" title="主线程的创建"></a>主线程的创建</h1><p>Android App 的进程是基于 Linux 的，其管理也是基于 Linux 的进程管理机制，所以其创建也是调用了 fork 函数</p><p>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid = fork()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>Fork 出来的进程，我们这里可以把他看做主线程，但是这个线程还没有和 Android 进行连接，所以无法处理 Android App 的 Message ；由于 Android App 线程运行<strong>基于消息机制</strong> ，那么这个 Fork 出来的主线程需要和 Android 的 Message 消息绑定，才能处理 Android App 的各种 Message </p><p>这里就引入了 <strong>ActivityThread</strong> ，确切的说，ActivityThread 应该起名叫 ProcessThread 更贴切一些。ActivityThread 连接了 Fork 出来的进程和 App 的 Message ，他们的通力配合组成了我们熟知的 Android App 主线程。所以说 ActivityThread 其实并不是一个 Thread，而是他初始化了 Message 机制所需要的 MessageQueue、Looper、Handler ，而且其 Handler 负责处理大部分 Message 消息，所以我们习惯上觉得 ActivityThread 是主线程，其实他只是主线程的一个逻辑处理单元。</p><h2 id="ActivityThread-的创建"><a href="#ActivityThread-的创建" class="headerlink" title="ActivityThread 的创建"></a>ActivityThread 的创建</h2><p>App 进程 fork 出来之后，回到 App 进程，查找 ActivityThread 的 Main函数</p><p>com/android/internal/os/ZygoteInit.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Runnable childZygoteInit(</span><br><span class="line">        <span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader) &#123;</span><br><span class="line">    RuntimeInit.Arguments args = <span class="keyword">new</span> RuntimeInit.Arguments(argv);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> RuntimeInit.<span class="title">findStaticMain</span><span class="params">(args.startClass, args.startArgs, classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 startClass 就是 ActivityThread，找到之后调用，逻辑就到了 ActivityThread的main函数</p><p>android/app/ActivityThread.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">    <span class="comment">//1. 初始化 Looper、MessageQueue</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>prepare<span class="constructor">MainLooper()</span>;</span><br><span class="line">    <span class="comment">// 2. 初始化 ActivityThread</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> <span class="constructor">ActivityThread()</span>;</span><br><span class="line">    <span class="comment">// 3. 主要是调用 AMS.attachApplicationLocked，同步进程信息，做一些初始化工作</span></span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line">    <span class="comment">// 4. 获取主线程的 Handler，这里是 H ，基本上 App 的 Message 都会在这个 Handler 里面进行处理 </span></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler<span class="operator"> == </span>null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.get<span class="constructor">Handler()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 初始化完成，Looper 开始工作</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>loop<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释里面都很清楚，这里就不详细说了，main 函数处理完成之后，主线程就算是正式上线开始工作，其 Systrace 流程如下：</p><p><img src="/images/15732905074966.jpg" alt=""></p><h2 id="ActivityThread-的功能"><a href="#ActivityThread-的功能" class="headerlink" title="ActivityThread 的功能"></a>ActivityThread 的功能</h2><p>另外我们经常说的，Android 四大组件都是运行在主线程上的，其实这里也很好理解，看一下 ActivityThread 的 Handler 的 Message 就知道了</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">H</span> <span class="symbol">extends</span> <span class="symbol">Handler</span> &#123; <span class="comment">//摘抄了部分</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> BIND_APPLICATION        = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> EXIT_APPLICATION        = <span class="number">111</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> RECEIVER                = <span class="number">113</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> CREATE_SERVICE          = <span class="number">114</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> STOP_SERVICE            = <span class="number">116</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> BIND_SERVICE            = <span class="number">121</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> UNBIND_SERVICE          = <span class="number">122</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> DUMP_SERVICE            = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> REMOVE_PROVIDER         = <span class="number">131</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> DISPATCH_PACKAGE_BROADCAST = <span class="number">133</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> DUMP_PROVIDER           = <span class="number">141</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> UNSTABLE_PROVIDER_DIED  = <span class="number">142</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> INSTALL_PROVIDER        = <span class="number">145</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> ON_NEW_ACTIVITY_OPTIONS = <span class="number">146</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，进程创建、Activity 启动、Service 的管理、Receiver 的管理、Provider 的管理这些都会在这里处理，然后进到具体的 handleXXX </p><p><img src="/images/15732905186985.jpg" alt=""></p><h1 id="渲染线程的创建和发展"><a href="#渲染线程的创建和发展" class="headerlink" title="渲染线程的创建和发展"></a>渲染线程的创建和发展</h1><p>主线程讲完了我们来讲渲染线程，渲染线程也就是 RenderThread ，最初的 Android 版本里面是没有渲染线程的，渲染工作都是在主线程完成，使用的也都是 CPU ，调用的是 libSkia 这个库，RenderThread 是在 Android Lollipop 中新加入的组件，负责承担一部分之前主线程的渲染工作，减轻主线程的负担</p><h2 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h2><p>我们一般提到的硬件加速，指的就是 GPU 加速，这里可以理解为用 RenderThread 调用 GPU 来进行渲染加速 。 硬件加速在目前的 Android 中是默认开启的， 所以如果我们什么都不设置，那么我们的进程默认都会有主线程和渲染线程(有可见的内容)。我们如果在 App 的 AndroidManifest 里面，在 Application 标签里面加一个 </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>hardwareAccelerated=<span class="string">"false"</span></span><br></pre></td></tr></table></figure><p>我们就可以关闭硬件加速，系统检测到你这个 App 关闭了硬件加速，就不会初始化 RenderThread ，直接 cpu 调用 libSkia 来进行渲染。其 Systrace 的表现如下</p><p><img src="/images/15732905305035.jpg" alt=""></p><p>与这篇文章开头的开了硬件加速的那个图对比，可以看到主线程由于要进行渲染工作，所以执行的时间变长了，也更容易出现卡顿，同时帧与帧直接的空闲间隔也变短了，使得其他 Message 的执行时间被压缩</p><h2 id="硬件加速绘制"><a href="#硬件加速绘制" class="headerlink" title="硬件加速绘制"></a>硬件加速绘制</h2><p>正常情况下，硬件加速是开启的，主线程的 draw 函数并没有真正的执行 drawCall ，而是把要 draw 的内容记录到 DIsplayList 里面，同步到 RenderThread 中，一旦同步完成，主线程就可以被释放出来做其他的事情，RenderThread 则继续进行渲染工作</p><p><img src="/images/15732905407683.jpg" alt=""></p><h2 id="渲染线程初始化"><a href="#渲染线程初始化" class="headerlink" title="渲染线程初始化"></a>渲染线程初始化</h2><p>渲染线程初始化在真正需要 draw 内容的时候，一般我们启动一个 Activity ，在第一个 draw 执行的时候，会去检测渲染线程是否初始化，如果没有则去进行初始化</p><p>android/view/ViewRootImpl.java</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mAttachInfo</span><span class="selector-class">.mThreadedRenderer</span><span class="selector-class">.initializeIfNeeded</span>(</span><br><span class="line">        <span class="selector-tag">mWidth</span>, <span class="selector-tag">mHeight</span>, <span class="selector-tag">mAttachInfo</span>, <span class="selector-tag">mSurface</span>, <span class="selector-tag">surfaceInsets</span>);</span><br></pre></td></tr></table></figure><p>后续直接调用 draw </p><p>android/graphics/HardwareRenderer.java</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mAttachInfo.mThreadedRenderer.<span class="title">draw</span>(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">void</span> <span class="title">draw</span>(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123;</span><br><span class="line">    <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">    choreographer.mFrameInfo.markDrawStart();</span><br><span class="line"></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attachInfo.mPendingAnimatingRenderNodes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> count = attachInfo.mPendingAnimatingRenderNodes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            registerAnimatingRenderNode(</span><br><span class="line">                    attachInfo.mPendingAnimatingRenderNodes.<span class="built_in">get</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes.<span class="built_in">clear</span>();</span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_LOST_SURFACE_REWARD_IF_FOUND) != <span class="number">0</span>) &#123;</span><br><span class="line">        setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        attachInfo.mViewRootImpl.mSurface.release();</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_REDRAW_REQUESTED) != <span class="number">0</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 draw 只是更新 DIsplayList ，更新结束后，调用 syncAndDrawFrame ，通知渲染线程开始工作，主线程释放。渲染线程的核心实现在 libhwui 库里面，其代码位于 frameworks/base/libs/hwui</p><p>frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> RenderProxy::syncAndDrawFrame() &#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 RenderThread 的工作流程这里就不细说了，后续会有专门的篇幅来讲解这个，目前 hwui 这一块的流程也有很多优秀的文章，大家可以对照文章和源码来看，其核心流程在 Systrace 上的表现如下:</p><p><img src="/images/15732905545821.jpg" alt=""></p><h2 id="主线程和渲染线程的分工"><a href="#主线程和渲染线程的分工" class="headerlink" title="主线程和渲染线程的分工"></a>主线程和渲染线程的分工</h2><p>主线程负责处理进程 Message、处理 Input 事件、处理 Animation 逻辑、处理 Measure、Layout、Draw ，更新 DIsplayList ，但是不涉及 SurfaceFlinger 打交道；渲染线程负责渲染渲染相关的工作，一部分工作也是 CPU 来完成的，一部分操作是调用 OpenGL 函数来完成的</p><p>当启动硬件加速后，在 Measure、Layout、Draw 的 Draw 这个环节，Android 使用 DisplayList 进行绘制而非直接使用 CPU 绘制每一帧。DisplayList 是一系列绘制操作的记录，抽象为 RenderNode 类，这样间接的进行绘制操作的优点如下</p><ol><li>DisplayList 可以按需多次绘制而无须同业务逻辑交互</li><li>特定的绘制操作（如 translation， scale 等）可以作用于整个 DisplayList 而无须重新分发绘制操作</li><li>当知晓了所有绘制操作后，可以针对其进行优化：例如，所有的文本可以一起进行绘制一次</li><li>可以将对 DisplayList 的处理转移至另一个线程（也就是 RenderThread）</li><li>主线程在 sync 结束后可以处理其他的 Message，而不用等待 RenderThread 结束</li></ol><p>RenderThread 的具体流程大家可以看这篇文章 ： <a href="http://www.cocoachina.com/articles/35302" target="_blank" rel="noopener">http://www.cocoachina.com/articles/35302</a></p><h1 id="游戏的主线程与渲染线程"><a href="#游戏的主线程与渲染线程" class="headerlink" title="游戏的主线程与渲染线程"></a>游戏的主线程与渲染线程</h1><p>游戏大多使用单独的渲染线程，有单独的 Surface ，直接跟 SurfaceFlinger 进行交互，其主线程的存在感比较低，绝大部分的逻辑都是自己在自己的渲染线程里面实现的。</p><p>大家可以看一下王者荣耀对应的 Systrace ，重点看应用进程和 SurfaceFlinger 进程（30fps）</p><p><img src="/images/15732905635210.jpg" alt=""></p><p>可以看到王者荣耀主线程的主要工作，就是把 Input 事件传给 Unity 的渲染线程，渲染线程收到 Input 事件之后，进行逻辑处理，画面更新等。</p><p><img src="/images/15732905704149.jpg" alt=""></p><h1 id="Flutter-的主线程和渲染线程"><a href="#Flutter-的主线程和渲染线程" class="headerlink" title="Flutter 的主线程和渲染线程"></a>Flutter 的主线程和渲染线程</h1><p>这里提一下 Flutter App 在 Systrace 上的表现，由于 Flutter 的渲染是基于 libSkia 的，所以它也没有 RenderThread ，而是他自建的 RenderEngine ， Flutter 比较重要的两个线程是 ui 线程和 gpu 线程，对应到下面提到的  Framework 和 Engine 两层</p><p><img src="/images/15732905786714.jpg" alt=""></p><p>Flutter 中也会监听 Vsync 信号 ，其 VsyncView 中会以 postFrameCallback 的形式，监听 doFrame 回调，然后调用 nativeOnVsync ，将 Vsync  到来的信息传给 Flutter UI 线程，开始一帧的绘制。</p><p><img src="/images/15732905861662.jpg" alt=""></p><p>可以看到 Flutter 的思路跟游戏开发的思路差不多，不依赖具体的平台，自建渲染管道，更新快，跨平台优势明显。</p><p>Flutter SDK 自带 Skia 库，不用等系统升级就可以用到最新的 Skia 库，而且 Google 团队在 Skia 上做了很多优化，所以官方号称性能可以媲美原生应用</p><p><img src="/images/15732905929654.jpg" alt=""></p><p>Flutter 的框架分为 Framework 和 Engine 两层，应用是基于 Framework 层开发的，Framework 负责渲染中的 Build，Layout，Paint，生成 Layer 等环节。Engine 层是 C++实现的渲染引擎，负责把 Framework 生成的 Layer 组合，生成纹理，然后通过 Open GL 接口向 GPU 提交渲染数据。</p><p><img src="/images/15732906008462.jpg" alt=""></p><p>当需要更新 UI 的时候，Framework 通知 Engine，Engine 会等到下个 Vsync 信号到达的时候，会通知 Framework，然后 Framework 会进行 animations, build，layout，compositing，paint，最后生成 layer 提交给 Engine。Engine 会把 layer 进行组合，生成纹理，最后通过 Open Gl 接口提交数据给 GPU，GPU 经过处理后在显示器上面显示。整个流程如下图：</p><p><img src="/images/15732906073036.jpg" alt=""></p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>如果主线程需要处理所有任务，则执行耗时较长的操作（例如，网络访问或数据库查询）将会阻塞整个界面线程。一旦被阻塞，线程将无法分派任何事件，包括绘图事件。主线程执行超时通常会带来两个问题</p><ol><li>卡顿：如果主线程 + 渲染线程每一帧的执行都超过 16.6ms(60fps 的情况下)，那么就可能会出现掉帧。</li><li>卡死：如果界面线程被阻塞超过几秒钟时间（根据组件不同 , 这里的阈值也不同），用户会看到 “<a href="http://developer.android.google.cn/guide/practices/responsiveness.html" target="_blank" rel="noopener">应用无响应</a>” (ANR) 对话框(部分厂商屏蔽了这个弹框,会直接 Crash 到桌面)</li></ol><p>对于用户来说，这两个情况都是用户不愿意看到的，所以对于 App 开发者来说，两个问题是发版本之前必须要解决的，ANR 这个由于有详细的调用栈，所以相对来说比较好定位；但是间歇性卡顿这个，可能就需要使用工具来进行分析了：Systrace + TraceView，所以理解主线程和渲染线程的关系和他们的工作原理是非常重要的，这也是本系列的一个初衷</p><p>另外关于卡顿，可以参考下面三篇文章，你的 App 卡顿不一定是你 App 的问题，也有可能是系统的问题，不过不管怎么说，首先要会分析卡顿问题。</p><ol><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 方法论</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 应用篇</a></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.im/post/5a9e01c3f265da239d48ce32" target="_blank" rel="noopener">https://juejin.im/post/5a9e01c3f265da239d48ce32</a></li><li><a href="http://www.cocoachina.com/articles/35302" target="_blank" rel="noopener">http://www.cocoachina.com/articles/35302</a></li><li><a href="https://juejin.im/post/5b7767fef265da43803bdc65" target="_blank" rel="noopener">https://juejin.im/post/5b7767fef265da43803bdc65</a></li><li><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="noopener">http://gityuan.com/2019/06/15/flutter_ui_draw/</a></li><li><a href="https://developer.android.google.cn/guide/components/processes-and-threads" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/processes-and-threads</a></li></ol><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>本文涉及到的附件也上传了，各位下载后解压，使用 <strong>Chrome</strong> 浏览器打开即可</p><p><a href="https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace-MainThread-RenderThread" target="_blank" rel="noopener">点此链接下载文章所涉及到的 Systrace 附件</a></p><h1 id="本文其他地址"><a href="#本文其他地址" class="headerlink" title="本文其他地址"></a>本文其他地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎或者掘金页面<br><a href="https://juejin.im/post/5dc68556f265da4cff702742" target="_blank" rel="noopener">掘金 - Systrace 基础知识 - MainThread 和 RenderThread 解读</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 - Input 解读</title>
      <link href="/2019/11/04/Android-Systrace-Input/"/>
      <url>/2019/11/04/Android-Systrace-Input/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第六篇，主要是对 Systrace 中的 Input 进行简单介绍，介绍其 Input 的流程； Systrace 中 Input 信息的体现 ，以及如何结合 Input 信息，分析与 Input 相关的问题</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在<a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android 基于 Choreographer 的渲染机制详解</a> 这篇文章中，我有讲到，Android App 的主线程运行的本质是靠 Message 驱动的，这个 Message 可以是循环动画、可以是定时任务、可以是其他线程唤醒，不过我们最常见的还是 Input Message ，这里的 Input 是以 InputReader 这里的分类，不仅包含触摸事件(Down、Up、Move) ， 可包含 Key 事件(Home Key  、 Back Key) . 这里我们着重讲的是<strong>触摸事件</strong></p><p>由于 Android 系统在 Input 链上加了一些 Trace 点，且这些 Trace 点也比较完善，部分厂家可能会自己加一些，不过我们这里以标准的 Trace 点来讲解，这样不至于你换了个手机抓的 Trace 就不一样了</p><p>Input 在 Android 中的地位是很高的，我们在玩手机的时候，大部分应用的滑动、跳转这些都依靠 Input 事件来驱动，后续我会专门写一篇文章，来介绍 Android 中基于 Input 的运行机制。这里是从 Systrace 的角度来看 Input 。看下面的流程之前，脑子里先有个关于 Input 的大概处理流程，这样看的时候，就可以代入：</p><ol><li><strong>触摸屏每隔几毫秒扫描一次，如果有触摸事件，那么把事件上报到对应的驱动</strong></li><li><strong>InputReader 读取触摸事件交给 InputDispatcher 进行事件派发</strong></li><li><strong>InputDispatcher 将触摸事件发给注册了 Input 事件的 App</strong></li><li><strong>App 拿到事件之后，进行 Input 事件分发，如果此事件分发的过程中，App 的 UI 发生了变化，那么会请求 Vsync，则进行一帧的绘制</strong></li></ol><p><strong>另外在看 Systrace 的时候，要牢记 Systrace 中时间是从左到右流逝的，也就是说如果你在 Systrace 上画一条竖直线，那么竖直线左边的事件永远比右边的事件先发生，这也是我们分析源码流程的一个基石。我希望大家在看基于  Systrace 的源码流程分析之后，脑子里有一个图形化的、立体的流程图，你跟的代码走到哪一步了在图形你在脑中可以快速定位出来</strong></p><h1 id="Input-in-Systrace"><a href="#Input-in-Systrace" class="headerlink" title="Input in Systrace"></a>Input in Systrace</h1><p>下面这张图是一个概览图，以滑动桌面为例 (<strong>滑动桌面包括一个 Input_Down 事件 + 若干个 Input_Move 事件 + 一个 Input_Up 事件，这些事件和事件流都会在 Systrace 上有所体现，这也是我们分析 Systrace 的一个重要的切入点</strong>)，主要牵扯到的模块是 SystemServer 和 App 模块，其中用蓝色标识的是事件的流动信息，红色的是辅助信息。</p><p><img src="/images/15728723423427.jpg" alt=""></p><p><strong>InputReader</strong> 和 <strong>InputDispatcher</strong> 是跑在 SystemServer 里面的两个 Native 线程，负责读取和分发 Input 事件，我们分析 Systrace 的 Input 事件流，首先是找到这里。下面针对上图中标号进行简单说明</p><ol><li><strong>InputReader</strong> 负责从 EventHub 里面把 Input 事件读取出来，然后交给 InputDispatcher 进行事件分发</li><li><strong>InputDispatcher</strong> 在拿到 InputReader 获取的事件之后，对事件进行包装和分发 (也就是发给对应的)</li><li><strong>OutboundQueue</strong> 里面放的是即将要被派发给对应 AppConnection 的事件</li><li><strong>WaitQueue</strong> 里面记录的是已经派发给 AppConnection 但是 App 还在处理没有返回处理成功的事件</li><li><strong>PendingInputEventQueue</strong> 里面记录的是 App 需要处理的 Input 事件，这里可以看到已经到了应用进程</li><li><strong>deliverInputEvent</strong> 标识 App UI Thread 被 Input 事件唤醒</li><li><strong>InputResponse</strong> 标识 Input 事件区域，这里可以看到一个 Input_Down 事件 + 若干个 Input_Move 事件 + 一个 Input_Up 事件的处理阶段都被算到了这里</li><li><strong>App 响应 Input 事件</strong> ： 这里是滑动然后松手，也就是我们熟悉的桌面滑动的操作，桌面随着手指的滑动更新画面，松手后触发 Fling 继续滑动，从 Systrace 就可以看到整个事件的流程</li></ol><p>下面以第一个 Input_Down 事件的处理流程来进行详细的工作流说明，其他的 Move 事件和 Up 事件的处理是一样的（部分不一样，不过影响不大）</p><h2 id="InputDown-事件在-SystemServer-的工作流"><a href="#InputDown-事件在-SystemServer-的工作流" class="headerlink" title="InputDown 事件在 SystemServer 的工作流"></a>InputDown 事件在 SystemServer 的工作流</h2><p>放大 SystemServer 的部分，可以看到其工作流(蓝色)，<strong>滑动桌面包括 Input_Down + 若干个 Input_Move + Input_Up ，我们这里看的是 Input_Down 这个事件</strong></p><p><img src="/images/15728723576583.jpg" alt=""></p><h2 id="InputDown-事件在-App-的工作流"><a href="#InputDown-事件在-App-的工作流" class="headerlink" title="InputDown 事件在 App 的工作流"></a>InputDown 事件在 App 的工作流</h2><p>应用在收到 Input 事件后，有时候会马上去处理 (没有 Vsync 的情况下)，有时候会等 Vsync 信号来了之后去处理，这里 Input_Down 事件就是直接去唤醒主线程做处理，其 Systrace 比较简单，最上面有个 Input 事件队列，主线程则是简单的处理</p><p><img src="/images/15728723679523.jpg" alt=""></p><h3 id="App-的-Pending-队列"><a href="#App-的-Pending-队列" class="headerlink" title="App 的 Pending 队列"></a>App 的 Pending 队列</h3><p><img src="/images/15728723758398.jpg" alt=""></p><h3 id="主线程处理-Input-事件"><a href="#主线程处理-Input-事件" class="headerlink" title="主线程处理 Input 事件"></a>主线程处理 Input 事件</h3><p>主线程处理 Input 事件这个大家比较熟悉，从下面的调用栈可以看到，Input 事件传到了 ViewRootImpl，最终到了 DecorView ，然后就是大家熟悉的 Input 事件分发机制</p><p><img src="/images/15728723834004.jpg" alt=""></p><h1 id="关键知识点和流程"><a href="#关键知识点和流程" class="headerlink" title="关键知识点和流程"></a>关键知识点和流程</h1><p>从上面的 Systrace 来看，Input 事件的基本流向如下：</p><ol><li><strong>InputReader 读取 Input 事件</strong></li><li><strong>InputReader 将读取的 Input 事件放到 InboundQueue 中</strong></li><li><strong>InputDispatcher 从 InboundQueue 中取出 Input 事件派发到各个 App(连接) 的 OutBoundQueue</strong></li><li><strong>同时将事件记录到各个 App(连接) 的  WaitQueue</strong></li><li><strong>App 接收到 Input 事件，同时记录到 PendingInputEventQueue ，然后对事件进行分发处理</strong></li><li><strong>App 处理完成后，回调 InputManagerService 将负责监听的 WaitQueue 中对应的 Input 移除</strong></li></ol><p>通过上面的流程，一次 Input 事件就被消耗掉了(当然这只是正常情况，还有很多异常情况、细节处理，这里就不细说了，自己看相关流程的时候可以深挖一下) ， 那么本节就从上面的关键流中取几个重要的知识点讲解（部分流程和图参考和拷贝了 Gityuan 的博客的图，链接在最下面<strong>参考</strong>那一节）</p><h2 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h2><p>InputReader 是一个 Native 线程，跑在 SystemServer 进程里面，其核心功能是从 EventHub 读取事件、进行加工、将加工好的事件发送到 InputDispatcher</p><p>InputReader Loop 流程如下</p><ol><li>getEvents：通过 EventHub (监听目录 /dev/input )读取事件放入 mEventBuffer ,而mEventBuffer 是一个大小为256的数组, 再将事件 input_event 转换为 RawEvent </li><li>processEventsLocked: 对事件进行加工, 转换 RawEvent -&gt; NotifyKeyArgs(NotifyArgs) </li><li>QueuedListener-&gt;flush：将事件发送到 InputDispatcher 线程, 转换 NotifyKeyArgs -&gt; KeyEntry(EventEntry)</li></ol><p>核心代码 loopOnce 处理流程如下：<br><img src="/images/15728723980792.jpg" alt=""></p><p>InputReader 核心 Loop 函数 loopOnce 逻辑如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取输入事件、设备增删事件，count 为事件数量</span></span><br><span class="line">    <span class="keyword">size_t</span> count = mEventHub -&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">    &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (count) &#123;<span class="comment">//处理事件</span></span><br><span class="line">            processEventsLocked(mEventBuffer, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mQueuedListener-&gt;flush();<span class="comment">//将事件传到 InputDispatcher，这里getListener 得到的就是 InputDispatcher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InputDispatcher"><a href="#InputDispatcher" class="headerlink" title="InputDispatcher"></a>InputDispatcher</h2><p>上面的 InputReader 调用 mQueuedListener-&gt;flush 之后 ，将 Input 事件加入到InputDispatcher 的 mInboundQueue ，然后唤醒 InputDispatcher ， 从 Systrace 的唤醒信息那里也可以看到 InputDispatch 线程是被 InputReader 唤醒的</p><p><img src="/images/15728724564781.jpg" alt=""></p><p>InputDispatcher 的核心逻辑如下：</p><ol><li>dispatchOnceInnerLocked(): 从 InputDispatcher 的 mInboundQueue 队列，取出事件 EventEntry。另外该方法开始执行的时间点 (currentTime) 便是后续事件 dispatchEntry 的分发时间 (deliveryTime）</li><li>dispatchKeyLocked()：满足一定条件时会添加命令 doInterceptKeyBeforeDispatchingLockedInterruptible；</li><li>enqueueDispatchEntryLocked()：生成事件 DispatchEntry 并加入 connection 的 outbound 队列</li><li>startDispatchCycleLocked()：从 outboundQueue 中取出事件 DispatchEntry, 重新放入 connection 的 waitQueue 队列；</li><li>InputChannel.sendMessage 通过 socket 方式将消息发送给远程进程；</li><li>runCommandsLockedInterruptible()：通过循环遍历的方式，依次处理 mCommandQueue 队列中的所有命令。而 mCommandQueue 队列中的命令是通过 postCommandLocked() 方式向该队列添加的。</li></ol><p><img src="/images/15728724685263.jpg" alt=""></p><p>其核心处理逻辑在 dispatchOnceInnerLocked 这里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don't already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poke user activity for this event.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            pokeUserActivityLocked(mPendingEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get ready to dispatch the event.</span></span><br><span class="line">        resetANRTimeoutsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastDropReason = dropReason;</span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InboundQueue"><a href="#InboundQueue" class="headerlink" title="InboundQueue"></a>InboundQueue</h2><p>InputDispatcher 执行 notifyKey 的时候，会将 Input 事件封装后放到  InboundQueue 中，后续 InputDispatcher 循环处理 Input 事件的时候，就是从 InboundQueue 取出事件然后做处理</p><p><img src="/images/15728724936139.jpg" alt=""></p><h2 id="OutboundQueue"><a href="#OutboundQueue" class="headerlink" title="OutboundQueue"></a>OutboundQueue</h2><p>Outbound 意思是出站，这里的 OutboundQueue 指的是要被 App 拿去处理的事件队列，每一个 App(Connection) 都对应有一个 OutboundQueue ，从 InboundQueue 那一节的图来看，事件会先进入 InboundQueue ，然后被 InputDIspatcher 派发到各个 App 的 OutboundQueue </p><p><img src="/images/15728725023006.jpg" alt=""></p><h2 id="WaitQueue"><a href="#WaitQueue" class="headerlink" title="WaitQueue"></a>WaitQueue</h2><p>当 InputDispatcher 将 Input 事件分发出去之后，将 DispatchEntry 从 outboundQueue 中取出来放到 WaitQueue 中，当 publish 出去的事件被处理完成（finished），InputManagerService 就会从应用中得到一个回复，此时就会取出 WaitQueue 中的事件，从 Systrace 中看就是对应 App 的 WaitQueue 减少</p><p>如果主线程发生卡顿，那么 Input 事件没有及时被消耗，也会在 WaitQueue 这里体现出来，如下图：</p><p><img src="/images/15728725102137.jpg" alt=""></p><h2 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><p>图来自 <a href="http://gityuan.com/" target="_blank" rel="noopener">Gityuan 博客</a><br><img src="/images/15728725219191.jpg" alt=""></p><h1 id="Input-刷新与-Vsync"><a href="#Input-刷新与-Vsync" class="headerlink" title="Input 刷新与 Vsync"></a>Input 刷新与 Vsync</h1><p>Input 的刷新取决于触摸屏的采样，目前比较多的屏幕采样率是 120Hz 和 160Hz ，对应就是 8ms 采样一次或者 6.25ms 采样一次，我们来看一下其在 Systrace 上的展示</p><p><img src="/images/15728725296687.jpg" alt=""></p><p>可以看到上图中， InputReader 每隔 6.25ms 就可以读上来一个数据，交给 InputDispatcher 去分发给 App ，那么是不是屏幕采样率越高越好呢？也不一定，比如上面那张图，虽然 InputReader 每隔 6.25ms 就可以读上来一个数据给 InputDispatcher 去分发给 App ，但是从 WaitQueue 的表现来看，应用并没有消耗这个 Input 事件，这是为什么呢？</p><p>原因在于应用消耗 Input 事件的时机是 Vsync 信号来了之后，刷新率为 60Hz 的屏幕，一般系统也是 60 fps ，也就是说两个 Vsync 的间隔在 16.6ms ，这期间如果有两个或者三个 Input 事件，那么必然有一个或者两个要被抛弃掉，只拿最新的那个。也就是说：</p><ol><li><strong>在屏幕刷新率和系统 FPS 都是 60 的时候，盲目提高触摸屏的采样率，是没有太大的效果的，反而有可能出现上面图中那样，有的 Vsync 周期中有两个 Input 事件，而有的 Vsync 周期中有三个 Input 事件，这样造成事件不均匀，可能会使 UI 产生抖动</strong></li><li><strong>在屏幕刷新率和系统 FPS 都是 60 的时候，使用 120Hz 采样率的触摸屏就可以了</strong></li><li><strong>如果在屏幕刷新率和系统 FPS 都是 90 的时候 ，那么 120Hz 采样率的触摸屏显然不够用了，这时候应该采用 180Hz 采样率的屏幕</strong></li></ol><h1 id="Input-调试信息"><a href="#Input-调试信息" class="headerlink" title="Input 调试信息"></a>Input 调试信息</h1><p>Dumpsys Input 主要是 Debug 用，我们也可以来看一下其中的一些关键信息，到时候遇到了问题也可以从这里面找 ， 其命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys input</span><br></pre></td></tr></table></figure><p>其中的输出比较多，我们终点截取 Device 信息、InputReader、InputDispatcher 三段来看就可以了</p><h2 id="Device-信息"><a href="#Device-信息" class="headerlink" title="Device 信息"></a>Device 信息</h2><p>主要是目前连接上的 Device 信息，下面摘取的是 touch 相关的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    3: main_touch</span><br><span class="line">      Classes: 0x00000015</span><br><span class="line">      Path: /dev/input/event6</span><br><span class="line">      Enabled: true</span><br><span class="line">      Descriptor: 4055b8a032ccf50ef66dbe2ff99f3b2474e9eab5</span><br><span class="line">      Location: main_touch/input0</span><br><span class="line">      ControllerNumber: 0</span><br><span class="line">      UniqueId: </span><br><span class="line">      Identifier: bus=0x0000, vendor=0xbeef, product=0xdead, version=0x28bb</span><br><span class="line">      KeyLayoutFile: /system/usr/keylayout/main_touch.kl</span><br><span class="line">      KeyCharacterMapFile: /system/usr/keychars/Generic.kcm</span><br><span class="line">      ConfigurationFile: </span><br><span class="line">      HaveKeyboardLayoutOverlay: false</span><br></pre></td></tr></table></figure><h2 id="Input-Reader-状态"><a href="#Input-Reader-状态" class="headerlink" title="Input Reader 状态"></a>Input Reader 状态</h2><p>InputReader 这里就是当前 Input 事件的一些展示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">  Device 3: main_touch</span><br><span class="line">    Generation: 24</span><br><span class="line">    IsExternal: false</span><br><span class="line">    HasMic:     false</span><br><span class="line">    Sources: 0x00005103</span><br><span class="line">    KeyboardType: 1</span><br><span class="line">    Motion Ranges:</span><br><span class="line">      X: source=0x00005002, min=0.000, max=1079.000, flat=0.000, fuzz=0.000, resolution=0.000</span><br><span class="line">      Y: source=0x00005002, min=0.000, max=2231.000, flat=0.000, fuzz=0.000, resolution=0.000</span><br><span class="line">      PRESSURE: source=0x00005002, min=0.000, max=1.000, flat=0.000, fuzz=0.000, resolution=0.000</span><br><span class="line">      SIZE: source=0x00005002, min=0.000, max=1.000, flat=0.000, fuzz=0.000, resolution=0.000</span><br><span class="line">      TOUCH_MAJOR: source=0x00005002, min=0.000, max=2479.561, flat=0.000, fuzz=0.000, resolution=0.000</span><br><span class="line">      TOUCH_MINOR: source=0x00005002, min=0.000, max=2479.561, flat=0.000, fuzz=0.000, resolution=0.000</span><br><span class="line">      TOOL_MAJOR: source=0x00005002, min=0.000, max=2479.561, flat=0.000, fuzz=0.000, resolution=0.000</span><br><span class="line">      TOOL_MINOR: source=0x00005002, min=0.000, max=2479.561, flat=0.000, fuzz=0.000, resolution=0.000</span><br><span class="line">    Keyboard Input Mapper:</span><br><span class="line">      Parameters:</span><br><span class="line">        HasAssociatedDisplay: false</span><br><span class="line">        OrientationAware: false</span><br><span class="line">        HandlesKeyRepeat: false</span><br><span class="line">      KeyboardType: 1</span><br><span class="line">      Orientation: 0</span><br><span class="line">      KeyDowns: 0 keys currently down</span><br><span class="line">      MetaState: 0x0</span><br><span class="line">      DownTime: 521271703875000</span><br><span class="line">    Touch Input Mapper (mode - direct):</span><br><span class="line">      Parameters:</span><br><span class="line">        GestureMode: multi-touch</span><br><span class="line">        DeviceType: touchScreen</span><br><span class="line">        AssociatedDisplay: hasAssociatedDisplay=true, isExternal=false, displayId=''</span><br><span class="line">        OrientationAware: true</span><br><span class="line">      Raw Touch Axes:</span><br><span class="line">        X: min=0, max=1080, flat=0, fuzz=0, resolution=0</span><br><span class="line">        Y: min=0, max=2232, flat=0, fuzz=0, resolution=0</span><br><span class="line">        Pressure: min=0, max=127, flat=0, fuzz=0, resolution=0</span><br><span class="line">        TouchMajor: min=0, max=512, flat=0, fuzz=0, resolution=0</span><br><span class="line">        TouchMinor: unknown range</span><br><span class="line">        ToolMajor: unknown range</span><br><span class="line">        ToolMinor: unknown range</span><br><span class="line">        Orientation: unknown range</span><br><span class="line">        Distance: unknown range</span><br><span class="line">        TiltX: unknown range</span><br><span class="line">        TiltY: unknown range</span><br><span class="line">        TrackingId: min=0, max=65535, flat=0, fuzz=0, resolution=0</span><br><span class="line">        Slot: min=0, max=20, flat=0, fuzz=0, resolution=0</span><br><span class="line">      Calibration:</span><br><span class="line">        touch.size.calibration: geometric</span><br><span class="line">        touch.pressure.calibration: physical</span><br><span class="line">        touch.orientation.calibration: none</span><br><span class="line">        touch.distance.calibration: none</span><br><span class="line">        touch.coverage.calibration: none</span><br><span class="line">      Affine Transformation:</span><br><span class="line">        X scale: 1.000</span><br><span class="line">        X ymix: 0.000</span><br><span class="line">        X offset: 0.000</span><br><span class="line">        Y xmix: 0.000</span><br><span class="line">        Y scale: 1.000</span><br><span class="line">        Y offset: 0.000</span><br><span class="line">      Viewport: displayId=0, orientation=0, logicalFrame=[0, 0, 1080, 2232], physicalFrame=[0, 0, 1080, 2232], deviceSize=[1080, 2232]</span><br><span class="line">      SurfaceWidth: 1080px</span><br><span class="line">      SurfaceHeight: 2232px</span><br><span class="line">      SurfaceLeft: 0</span><br><span class="line">      SurfaceTop: 0</span><br><span class="line">      PhysicalWidth: 1080px</span><br><span class="line">      PhysicalHeight: 2232px</span><br><span class="line">      PhysicalLeft: 0</span><br><span class="line">      PhysicalTop: 0</span><br><span class="line">      SurfaceOrientation: 0</span><br><span class="line">      Translation and Scaling Factors:</span><br><span class="line">        XTranslate: 0.000</span><br><span class="line">        YTranslate: 0.000</span><br><span class="line">        XScale: 0.999</span><br><span class="line">        YScale: 1.000</span><br><span class="line">        XPrecision: 1.001</span><br><span class="line">        YPrecision: 1.000</span><br><span class="line">        GeometricScale: 0.999</span><br><span class="line">        PressureScale: 0.008</span><br><span class="line">        SizeScale: 0.002</span><br><span class="line">        OrientationScale: 0.000</span><br><span class="line">        DistanceScale: 0.000</span><br><span class="line">        HaveTilt: false</span><br><span class="line">        TiltXCenter: 0.000</span><br><span class="line">        TiltXScale: 0.000</span><br><span class="line">        TiltYCenter: 0.000</span><br><span class="line">        TiltYScale: 0.000</span><br><span class="line">      Last Raw Button State: 0x00000000</span><br><span class="line">      Last Raw Touch: pointerCount=1</span><br><span class="line">        [0]: id=0, x=660, y=1338, pressure=44, touchMajor=44, touchMinor=44, toolMajor=0, toolMinor=0, orientation=0, tiltX=0, tiltY=0, distance=0, toolType=1, isHovering=false</span><br><span class="line">      Last Cooked Button State: 0x00000000</span><br><span class="line">      Last Cooked Touch: pointerCount=1</span><br><span class="line">        [0]: id=0, x=659.389, y=1337.401, pressure=0.346, touchMajor=43.970, touchMinor=43.970, toolMajor=43.970, toolMinor=43.970, orientation=0.000, tilt=0.000, distance=0.000, toolType=1, isHovering=false</span><br><span class="line">      Stylus Fusion:</span><br><span class="line">        ExternalStylusConnected: false</span><br><span class="line">        External Stylus ID: -1</span><br><span class="line">        External Stylus Data Timeout: 9223372036854775807</span><br><span class="line">      External Stylus State:</span><br><span class="line">        When: 9223372036854775807</span><br><span class="line">        Pressure: 0.000000</span><br><span class="line">        Button State: 0x00000000</span><br><span class="line">        Tool Type: 0</span><br></pre></td></tr></table></figure><h2 id="InputDispatcher-状态"><a href="#InputDispatcher-状态" class="headerlink" title="InputDispatcher 状态"></a>InputDispatcher 状态</h2><p>InputDispatch 这里的重要信息主要包括</p><ol><li>FocusedApplication ：当前获取焦点的应用</li><li>FocusedWindow ： 当前获取焦点的窗口</li><li>TouchStatesByDisplay</li><li>Windows ：所有的 Window</li><li>MonitoringChannels ：Window 对应的 Channel</li><li>Connections ：所有的连接</li><li>AppSwitch: not pending</li><li>Configuration</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Input Dispatcher State:</span><br><span class="line">  DispatchEnabled: 1</span><br><span class="line">  DispatchFrozen: 0</span><br><span class="line">  FocusedApplication: name='AppWindowToken&#123;ac6ec28 token=Token&#123;a38a4b ActivityRecord&#123;7230f1a u0 com.meizu.flyme.launcher/.Launcher t13&#125;&#125;&#125;', dispatchingTimeout=5000.000ms</span><br><span class="line">  FocusedWindow: name='Window&#123;3c007ad u0 com.meizu.flyme.launcher/com.meizu.flyme.launcher.Launcher&#125;'</span><br><span class="line">  TouchStatesByDisplay:</span><br><span class="line">    0: down=true, split=true, deviceId=3, source=0x00005002</span><br><span class="line">      Windows:</span><br><span class="line">        0: name='Window&#123;3c007ad u0 com.meizu.flyme.launcher/com.meizu.flyme.launcher.Launcher&#125;', pointerIds=0x80000000, targetFlags=0x105</span><br><span class="line">        1: name='Window&#123;8cb8f7 u0 com.android.systemui.ImageWallpaper&#125;', pointerIds=0x0, targetFlags=0x4102</span><br><span class="line">  Windows:</span><br><span class="line">    2: name='Window&#123;ba2fc6b u0 NavigationBar&#125;', displayId=0, paused=false, hasFocus=false, hasWallpaper=false, visible=true, canReceiveKeys=false, flags=0x21840068, type=0x000007e3, layer=0, frame=[0,2136][1080,2232], scale=1.000000, touchableRegion=[0,2136][1080,2232], inputFeatures=0x00000000, ownerPid=26514, ownerUid=10033, dispatchingTimeout=5000.000ms</span><br><span class="line">    3: name='Window&#123;72b7776 u0 StatusBar&#125;', displayId=0, paused=false, hasFocus=false, hasWallpaper=false, visible=true, canReceiveKeys=false, flags=0x81840048, type=0x000007d0, layer=0, frame=[0,0][1080,84], scale=1.000000, touchableRegion=[0,0][1080,84], inputFeatures=0x00000000, ownerPid=26514, ownerUid=10033, dispatchingTimeout=5000.000ms</span><br><span class="line">    9: name='Window&#123;3c007ad u0 com.meizu.flyme.launcher/com.meizu.flyme.launcher.Launcher&#125;', displayId=0, paused=false, hasFocus=true, hasWallpaper=true, visible=true, canReceiveKeys=true, flags=0x81910120, type=0x00000001, layer=0, frame=[0,0][1080,2232], scale=1.000000, touchableRegion=[0,0][1080,2232], inputFeatures=0x00000000, ownerPid=27619, ownerUid=10021, dispatchingTimeout=5000.000ms</span><br><span class="line">  MonitoringChannels:</span><br><span class="line">    0: 'WindowManager (server)'</span><br><span class="line">  RecentQueue: length=10</span><br><span class="line">    MotionEvent(deviceId=3, source=0x00005002, action=MOVE, actionButton=0x00000000, flags=0x00000000, metaState=0x00000000, buttonState=0x00000000, edgeFlags=0x00000000, xPrecision=1.0, yPrecision=1.0, displayId=0, pointers=[0: (524.5, 1306.4)]), policyFlags=0x62000000, age=61.2ms</span><br><span class="line">    MotionEvent(deviceId=3, source=0x00005002, action=MOVE, actionButton=0x00000000, flags=0x00000000, metaState=0x00000000, buttonState=0x00000000, edgeFlags=0x00000000, xPrecision=1.0, yPrecision=1.0, displayId=0, pointers=[0: (543.5, 1309.4)]), policyFlags=0x62000000, age=54.7ms</span><br><span class="line">  PendingEvent: &lt;none&gt;</span><br><span class="line">  InboundQueue: &lt;empty&gt;</span><br><span class="line">  ReplacedKeys: &lt;empty&gt;</span><br><span class="line">  Connections:</span><br><span class="line">    0: channelName='WindowManager (server)', windowName='monitor', status=NORMAL, monitor=true, inputPublisherBlocked=false</span><br><span class="line">      OutboundQueue: &lt;empty&gt;</span><br><span class="line">      WaitQueue: &lt;empty&gt;</span><br><span class="line">    5: channelName='72b7776 StatusBar (server)', windowName='Window&#123;72b7776 u0 StatusBar&#125;', status=NORMAL, monitor=false, inputPublisherBlocked=false</span><br><span class="line">      OutboundQueue: &lt;empty&gt;</span><br><span class="line">      WaitQueue: &lt;empty&gt;</span><br><span class="line">    6: channelName='ba2fc6b NavigationBar (server)', windowName='Window&#123;ba2fc6b u0 NavigationBar&#125;', status=NORMAL, monitor=false, inputPublisherBlocked=false</span><br><span class="line">      OutboundQueue: &lt;empty&gt;</span><br><span class="line">      WaitQueue: &lt;empty&gt;</span><br><span class="line">    12: channelName='3c007ad com.meizu.flyme.launcher/com.meizu.flyme.launcher.Launcher (server)', windowName='Window&#123;3c007ad u0 com.meizu.flyme.launcher/com.meizu.flyme.launcher.Launcher&#125;', status=NORMAL, monitor=false, inputPublisherBlocked=false</span><br><span class="line">      OutboundQueue: &lt;empty&gt;</span><br><span class="line">      WaitQueue: length=3</span><br><span class="line">        MotionEvent(deviceId=3, source=0x00005002, action=MOVE, actionButton=0x00000000, flags=0x00000000, metaState=0x00000000, buttonState=0x00000000, edgeFlags=0x00000000, xPrecision=1.0, yPrecision=1.0, displayId=0, pointers=[0: (634.4, 1329.4)]), policyFlags=0x62000000, targetFlags=0x00000105, resolvedAction=2, age=17.4ms, wait=16.8ms</span><br><span class="line">        MotionEvent(deviceId=3, source=0x00005002, action=MOVE, actionButton=0x00000000, flags=0x00000000, metaState=0x00000000, buttonState=0x00000000, edgeFlags=0x00000000, xPrecision=1.0, yPrecision=1.0, displayId=0, pointers=[0: (647.4, 1333.4)]), policyFlags=0x62000000, targetFlags=0x00000105, resolvedAction=2, age=11.1ms, wait=10.4ms</span><br><span class="line">        MotionEvent(deviceId=3, source=0x00005002, action=MOVE, actionButton=0x00000000, flags=0x00000000, metaState=0x00000000, buttonState=0x00000000, edgeFlags=0x00000000, xPrecision=1.0, yPrecision=1.0, displayId=0, pointers=[0: (659.4, 1337.4)]), policyFlags=0x62000000, targetFlags=0x00000105, resolvedAction=2, age=5.2ms, wait=4.6ms</span><br><span class="line">  AppSwitch: not pending</span><br><span class="line">  Configuration:</span><br><span class="line">    KeyRepeatDelay: 50.0ms</span><br><span class="line">    KeyRepeatTimeout: 500.0ms</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文部分图文参考和拷贝自下面几篇文章，同时下面几篇文章讲解了 Input 流程的细节部分，推荐大家在看完这篇文章后，如果对代码细节感兴趣，可以仔细研读下面这几篇非常棒的文章。</p><ol><li><a href="http://gityuan.com/2016/12/11/input-reader/" target="_blank" rel="noopener">http://gityuan.com/2016/12/11/input-reader/</a></li><li><a href="http://gityuan.com/2016/12/10/input-manager/" target="_blank" rel="noopener">http://gityuan.com/2016/12/10/input-manager/</a></li><li><a href="http://gityuan.com/2016/12/17/input-dispatcher/" target="_blank" rel="noopener">http://gityuan.com/2016/12/17/input-dispatcher/</a></li><li><a href="https://zhuanlan.zhihu.com/p/29386642" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29386642</a></li></ol><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>本文涉及到的附件也上传了，各位下载后解压，使用 <strong>Chrome</strong> 浏览器打开即可<br><a href="https://github.com/Gracker/SystraceForBlog/tree/master/Android_Systrace_Input" target="_blank" rel="noopener">点此链接下载文章所涉及到的 Systrace 附件</a></p><h1 id="本文其他地址"><a href="#本文其他地址" class="headerlink" title="本文其他地址"></a>本文其他地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎或者掘金页面<br><a href="https://juejin.im/post/5dc1838ef265da4d02626ae0" target="_blank" rel="noopener">掘金 - Systrace 基础知识 - Input 解读</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的“后台无效动画“行为分析</title>
      <link href="/2019/10/24/Android-Background-Animation/"/>
      <url>/2019/10/24/Android-Background-Animation/</url>
      
        <content type="html"><![CDATA[<p>当一个 Android App 退到后台之后，只要他没有被杀死，那么他做什么事情大家都不要奇怪，因为这就是 Android。但是当用户知道一个你一个 App 退到后台之后还在持续做无效的动画，而这个动画完全是无意义的，而且用户还不知道他在做动画，消耗用户那可怜的电量的时候，轻则被多任务杀掉，禁止后台运行，重则直接卸载。</p><p>一般的开发者很难发现这个问题，但是如果你经常使用 <a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace</a> ，多开几十个应用然后退回到桌面，左右滑动抓取 <a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace</a> ，就可以很容易发现，总有那么几个后台的应用，还在频繁地做无效的动画。</p><p>这里说的后台做动画，指的是由于某种原因，应用在退到后台之后，用户看不到任何这个 App 界面的时候，他仍然在后台不断地更新，耗费 CPU。引起这个问题的原因可能有好多个，毕竟 往 <a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Choreographer</a> 扔 CALLBACK_ANIMATION 的地方太多了，而且每个应用可能都不一样，但最终还是需要各个应用去做修复</p><a id="more"></a><p>下面我们就以两个实例，从技术的角度来看一下事件发生时候的情况和原因，<strong>希望看到这篇文章的开发者，检查一下自己的应用是否有这个问题，有则改之，无则恭喜</strong></p><h1 id="实例-网易新闻"><a href="#实例-网易新闻" class="headerlink" title="实例 - 网易新闻"></a>实例 - 网易新闻</h1><p>我们在使用网易新闻后，将网易新闻退到后台，然后左右滑动桌面，抓 Systrace 来看：</p><p>网易新闻到后台之后还在持续做 Animation 的回调（红框内），每一帧都还是在 doFrame 操作</p><p><img src="/images/15718769486548.jpg" alt=""></p><p>放大每一个 doFrame 来看，<a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Choreographer</a>  中的 input 和 traversal 都没有触发，只有 animation 的回调一直在执行</p><p><img src="/images/15718769576130.jpg" alt=""></p><p>我们把这份 Trace 上的 cpu 部分全选，然后下面按照 Wall Duration 排序，可以发现网易新闻后台动画执行时间最长。应用已经在后台且不可见的时候，还在这么频繁地工作，占用 CPU 资源，消耗电量，实在是不应该</p><p><img src="/images/15718769674934.jpg" alt=""></p><p>抓对应的 MethodTrace 来看，就是在做动画，没有进行关闭 ，动画依旧在每一帧进行 onAnimationUpdate 的回调 ，可以看到这里是因为使用了 Airbnb 的 <a href="https://airbnb.design/lottie/" target="_blank" rel="noopener">Lottie</a> 库导致的，动画没有关闭，所以还是一直在做触发</p><p><img src="/images/15718769752471.jpg" alt=""></p><h1 id="实例-QQ音乐"><a href="#实例-QQ音乐" class="headerlink" title="实例 - QQ音乐"></a>实例 - QQ音乐</h1><p>启动 QQ 音乐，然后回到桌面， 左右滑动桌面并抓取 Systrace 和 MethodTrace ，可以看到跟上面的网易新闻的表现一致</p><p><img src="/images/15718769826711.jpg" alt=""></p><p>抓取了 QQ 音乐的后台动画时候的 MethodTrace 发现，也是由于退到后台之后，没有暂停动画导致的，也是 Airbnb 的 <a href="https://airbnb.design/lottie/" target="_blank" rel="noopener">Lottie</a> 的锅， 而且 QQ 音乐有三个动画没有停止，比网易新闻还要严重一些</p><p><img src="/images/15718769926973.jpg" alt=""></p><p>放大后可以看到</p><p><img src="/images/15718770037520.jpg" alt=""></p><p>当然也不是每一个都是 Airbnb 的 <a href="https://airbnb.design/lottie/" target="_blank" rel="noopener">Lottie</a> 动画库引起的，比如下面这个，就是普通的动画没有结束</p><p><img src="/images/15718770123948.jpg" alt=""></p><h1 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h1><p>根本原因是应用在不可见之后，没有将动画暂停，导致应用切换到后台之后，依然在刷新动画的回调，但此时由于是不可见的，不会触发 Input Callback 和 draw Callback ，所以也不会有任何的绘制操作，也就是说这个 Animation 的刷新完全是没有意义的（当然也有可能是业务需求？）</p><p>上面两个例子里面，网易新闻和 QQ 音乐都是因为使用了 <a href="https://airbnb.design/lottie/" target="_blank" rel="noopener">Lottie</a> 来实现动画，但是没有正确的关闭导致的。</p><h1 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h1><p><a href="https://airbnb.design/lottie/" target="_blank" rel="noopener">Lottie</a> 库的 issue 列表里面有人提到了这个情况：</p><p>提出问题：</p><blockquote><p>I recently did some benchmarking on an app which uses lottie to do some animations (autoplay and looping). I noticed that there is quite some CPU usage <strong>when the app is in the background</strong> and tried to investigate.</p></blockquote><blockquote><p>It seems to me looping animations do not pause/stop when the containing LottieAnimationView is off screen, and/or the Activity is paused.</p></blockquote><blockquote><p>I believe this is due to the cleanup code being only in onDetachedFromWindow() which is not necessarily being called once the Activity goes into a paused state and most definitely not, when the view is simply not visible (GONE, INVISIBLE ) anymore.</p></blockquote><p>解决方法：</p><blockquote><p>Overriding LottieAnimationView and doing the following solves the visibility issue for me and Lottie is paused when not visible.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onVisibilityChanged</span><span class="params">(@NonNull View changedView, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onVisibilityChanged(changedView, visibility);</span><br><span class="line">    <span class="keyword">if</span> (visibility == VISIBLE &amp;&amp; wasAnimatingWhenVisibilityChanged) &#123;</span><br><span class="line">        resumeAnimation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAnimating()) &#123;</span><br><span class="line">            wasAnimatingWhenVisibilityChanged = <span class="keyword">true</span>;</span><br><span class="line">            pauseAnimation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wasAnimatingWhenVisibilityChanged = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之就是 ： 当 App 不可见的时候，停止所有的动画：<strong>pauseAnimation</strong>！！！</p><h1 id="本文其他地址"><a href="#本文其他地址" class="headerlink" title="本文其他地址"></a>本文其他地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎或者掘金页面<br><a href="https://zhuanlan.zhihu.com/p/88221952" target="_blank" rel="noopener">知乎 - Android 中的“后台无效动画“行为分析</a><br><a href="https://juejin.im/post/5db0ef7ef265da4cfd2951fd" target="_blank" rel="noopener">掘金 - Android 中的“后台无效动画“行为分析</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong><br><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 基于 Choreographer 的渲染机制详解</title>
      <link href="/2019/10/22/Android-Choreographer/"/>
      <url>/2019/10/22/Android-Choreographer/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了 App 开发者不经常接触到但是在 Android Framework 渲染链路中非常重要的一个类 Choreographer。包括 Choreographer 的引入背景、Choreographer 的简介、部分源码解析、Choreographer 与 MessageQueue、Choreographer 和 APM，以及手机厂商基于 Choreographer 的一些优化思路</p><p>Choreographer 的引入，主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对  Vsync 信号周期的调整，来控制每一帧绘制操作的时机. 目前大部分手机都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每个 16.6 ms ， Vsync 信号唤醒 Choreographer 来做 App 的绘制操作 ，这就是引入 Choreographer 的主要作用. 了解 Choreographer 还可以帮助 App 开发者知道程序每一帧运行的基本原理，也可以加深对 Message、Handler、Looper、MessageQueue、Measure、Layout、Draw 的理解</p><a id="more"></a><p>本文是 Systrace 系列文章的第八篇，主要是对 Systrace 中的 Choreographer 进行简单介绍</p><p>本系列的<strong>目的</strong>是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="主线程运行机制的本质"><a href="#主线程运行机制的本质" class="headerlink" title="主线程运行机制的本质"></a>主线程运行机制的本质</h1><p>在讲 Choreographer 之前，我们先理一下 Android 主线程运行的本质，其实就是 Message 的处理过程，我们的各种操作，包括每一帧的渲染操作 ，都是通过 Message 的形式发给主线程的 MessageQueue ，MessageQueue 处理完消息继续等下一个消息，如下图所示</p><p><strong>MethodTrace 图示</strong></p><p><img src="/images/15717420275540.jpg" alt=""></p><p><strong>Systrace 图示</strong></p><p><img src="/images/15717420373518.jpg" alt=""></p><h2 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h2><p>引入 Vsync 之前的 Android 版本，渲染一帧相关的 Message ，中间是没有间隔的，上一帧绘制完，下一帧的 Message 紧接着就开始被处理。这样的问题就是，帧率不稳定，可能高也可能低，不稳定，如下图</p><p><strong>MethodTrace 图示</strong></p><p><img src="/images/15717420453069.jpg" alt=""></p><p><strong>Systrace 图示</strong></p><p><img src="/images/15717420572997.jpg" alt=""></p><p>可以看到这时候的瓶颈是在 dequeueBuffer, 因为屏幕是有刷新周期的, FB 消耗 Front Buffer 的速度是一定的, 所以 SF 消耗 App Buffer 的速度也是一定的, 所以 App 会卡在 dequeueBuffer 这里,这就会导致 App Buffer 获取不稳定, 很容易就会出现卡顿掉帧的情况.</p><p>对于用户来说，稳定的帧率才是好的体验，比如你玩王者荣耀，相比 fps 在 60 和 40 之间频繁变化，用户感觉更好的是稳定在 50 fps 的情况.</p><p>所以 Android 的演进中，引入了 <strong>Vsync + TripleBuffer + Choreographer</strong> 的机制，其主要目的就是提供一个稳定的帧率输出机制，让软件层和硬件层可以以共同的频率一起工作。</p><h2 id="引入-Choreographer"><a href="#引入-Choreographer" class="headerlink" title="引入 Choreographer"></a>引入 Choreographer</h2><p>Choreographer 的引入，主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对  Vsync 信号周期的调整，来控制每一帧绘制操作的时机. 至于为什么 Vsync 周期选择是 16.6ms (60 fps) ，是因为目前大部分手机的屏幕都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每隔 16.6 ms ，Vsync 信号到来唤醒 Choreographer 来做 App 的绘制操作 ，如果每个 Vsync 周期应用都能渲染完成，那么应用的 fps 就是 60 ，给用户的感觉就是非常流畅，这就是引入 Choreographer 的主要作用</p><p><img src="/images/15722752299458.jpg" alt=""></p><p>当然目前使用 90Hz 刷新率屏幕的手机越来越多，Vsync 周期从 16.6ms 到了 11.1ms，上图中的操作要在更短的时间内完成，对性能的要求也越来越高，具体可以看<a href="https://www.androidperformance.com/2019/05/15/90hz-on-android/" target="_blank" rel="noopener">新的流畅体验，90Hz 漫谈</a> 这篇文章</p><h1 id="Choreographer-简介"><a href="#Choreographer-简介" class="headerlink" title="Choreographer 简介"></a>Choreographer 简介</h1><p>Choreographer 扮演 Android 渲染链路中承上启下的角色</p><ol><li><strong>承上</strong>：负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等</li><li><strong>启下</strong>：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync) .</li></ol><p>从上面可以看出来， Choreographer 担任的是一个工具人的角色，他之所以重要，是因为通过 <strong>Choreographer + SurfaceFlinger + Vsync + TripleBuffer</strong> 这一套从上到下的机制，保证了 Android App 可以以一个稳定的帧率运行(目前大部分是 60fps)，减少帧率波动带来的不适感.</p><p>了解 Choreographer 还可以帮助 App 开发者知道程序每一帧运行的基本原理，也可以加深对 <strong>Message、Handler、Looper、MessageQueue、Measure、Layout、Draw</strong> 的理解 , 很多 <strong>APM</strong> 工具也用到了 <strong>Choreographer( 利用 FrameCallback + FrameInfo )</strong> + <strong>MessageQueue ( 利用 IdleHandler )</strong> + <strong>Looper ( 设置自定义 MessageLogging)</strong> 这些组合拳，深入了解了这些之后，再去做优化，脑子里的思路会更清晰。</p><p>另外虽然画图是一个比较好的解释流程的好路子，但是我个人不是很喜欢画图，因为平时 Systrace 和 MethodTrace 用的比较多，Systrace 是按从左到右展示整个系统的运行情况的一个工具(包括 cpu、SurfaceFlinger、SystemServer、App 等关键进程)，使用 <strong>Systrace</strong> 和 <strong>MethodTrace</strong> 也可以很方便地展示关键流程。当你对系统代码比较熟悉的时候，看 Systrace 就可以和手机运行的实际情况对应起来。所以下面的文章除了一些网图之外，其他的我会多以 Systrace 来展示.</p><h2 id="从-Systrace-的角度来看-Choreogrepher-的工作流程"><a href="#从-Systrace-的角度来看-Choreogrepher-的工作流程" class="headerlink" title="从 Systrace 的角度来看 Choreogrepher 的工作流程"></a>从 Systrace 的角度来看 Choreogrepher 的工作流程</h2><p>下图以滑动桌面为例子，我们先看一下从左到右滑动桌面的一个完整的预览图（App 进程），可以看到 Systrace 中从左到右，每一个绿色的帧都表示一帧，表示最终我们可以手机上看到的画面</p><ol><li>图中每一个灰色的条和白色的条宽度是一个 Vsync 的时间，也就是 16.6ms</li><li>每一帧处理的流程：接收到 Vsync 信号回调-&gt; UI Thread –&gt; RenderThread –&gt; SurfaceFlinger(图中未显示)</li><li>UI Thread 和 RenderThread 就可以完成 App 一帧的渲染，渲染完的 Buffer 抛给 SurfaceFlinger 去合成，然后我们就可以在屏幕上看到这一帧了</li><li>可以看到桌面滑动的每一帧耗时都很短（Ui Thread 耗时 + RenderThread 耗时），但是由于 Vsync 的存在，每一帧都会等到 Vsync 才会去做处理</li></ol><p><img src="/images/15717420793673.jpg" alt=""></p><p>有了上面这个整体的概念，我们将 UI Thread 的每一帧放大来看，看看 Choreogrepher 的位置以及 Choreogrepher 是怎么组织每一帧的</p><p><img src="/images/15717420863795.jpg" alt=""></p><h2 id="Choreographer-的工作流程"><a href="#Choreographer-的工作流程" class="headerlink" title="Choreographer 的工作流程"></a>Choreographer 的工作流程</h2><ol><li>Choreographer 初始化<ol><li>初始化 FrameHandler ，绑定 Looper</li><li>初始化 FrameDisplayEventReceiver ，与 SurfaceFlinger 建立通信用于接收和请求 Vsync</li><li>初始化 CallBackQueues</li></ol></li><li>SurfaceFlinger 的 appEventThread 唤醒发送 Vsync ，Choreographer 回调 FrameDisplayEventReceiver.onVsync , 进入 Choreographer 的主处理函数  doFrame</li><li>Choreographer.doFrame 计算掉帧逻辑</li><li>Choreographer.doFrame 处理 Choreographer 的第一个 callback ： input </li><li>Choreographer.doFrame 处理 Choreographer 的第二个 callback ： animation </li><li>Choreographer.doFrame 处理 Choreographer 的第三个 callback ： insets animation </li><li>Choreographer.doFrame 处理 Choreographer 的第四个 callback ： traversal <ol><li>traversal-draw 中 UIThread 与 RenderThread 同步数据</li></ol></li><li>Choreographer.doFrame 处理 Choreographer 的第五个 callback ： commit ?</li><li>RenderThread 处理绘制数据，真正进行渲染</li><li>将渲染好的 Buffer swap 给 SurfaceFlinger 进行合成</li></ol><p><strong>第一步初始化完成后，后续就会在步骤 2-9 之间循环</strong></p><p>同时也附上这一帧所对应的 MethodTrace（这里预览一下即可，下面会有详细的大图）</p><p><img src="/images/15717420948412.jpg" alt=""></p><p>下面我们就从源码的角度，来看一下具体的实现</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>下面从源码的角度来简单看一下，源码只摘抄了部分重要的逻辑，其他的逻辑则被剔除，另外 Native 部分与 SurfaceFlinger 交互的部分也没有列入，不是本文的重点，有兴趣的可以自己去跟一下。</p><h2 id="Choreographer-的初始化"><a href="#Choreographer-的初始化" class="headerlink" title="Choreographer 的初始化"></a>Choreographer 的初始化</h2><h3 id="Choreographer-的单例初始化"><a href="#Choreographer-的单例初始化" class="headerlink" title="Choreographer 的单例初始化"></a>Choreographer 的单例初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread local storage for the choreographer.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的 Looper</span></span><br><span class="line">        Looper looper = Looper.myLooper();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 构造 Choreographer 对象</span></span><br><span class="line">        Choreographer choreographer = <span class="keyword">new</span> Choreographer(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">            mMainInstance = choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> choreographer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Choreographer-的构造函数"><a href="#Choreographer-的构造函数" class="headerlink" title="Choreographer 的构造函数"></a>Choreographer 的构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    <span class="comment">// 1. 初始化 FrameHandler</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    <span class="comment">// 2. 初始化 DisplayEventReceiver</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line">    mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line">    <span class="comment">//3. 初始化 CallbacksQueues</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FrameHandler"><a href="#FrameHandler" class="headerlink" title="FrameHandler"></a>FrameHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME:<span class="comment">//开始渲染下一帧的操作</span></span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:<span class="comment">//请求 Vsync </span></span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:<span class="comment">//处理 Callback</span></span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Choreographer-初始化链"><a href="#Choreographer-初始化链" class="headerlink" title="Choreographer 初始化链"></a>Choreographer 初始化链</h3><p>在 Activity 启动过程，执行完 onResume 后，会调用 Activity.makeVisible()，然后再调用到 addView()， 层层调用会进入如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.handleResumeActivity(IBinder, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, String) (android.app) </span><br><span class="line">--&gt;WindowManagerImpl.addView(View, LayoutParams) (android.view) </span><br><span class="line">  --&gt;WindowManagerGlobal.addView(View, LayoutParams, Display, Window) (android.view) </span><br><span class="line">    --&gt;ViewRootImpl.ViewRootImpl(Context, Display) (android.view) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="FrameDisplayEventReceiver-简介"><a href="#FrameDisplayEventReceiver-简介" class="headerlink" title="FrameDisplayEventReceiver 简介"></a>FrameDisplayEventReceiver 简介</h2><p>Vsync 的注册、申请、接收都是通过 FrameDisplayEventReceiver 这个类，所以可以先简单介绍一下。 FrameDisplayEventReceiver 继承 DisplayEventReceiver ， 有三个比较重要的方法</p><ol><li>onVsync – Vsync 信号回调</li><li>run – 执行 doFrame</li><li>scheduleVsync  – 请求 Vsync 信号</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">long</span> physicalDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......  </span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Choreographer-中-Vsync-的注册"><a href="#Choreographer-中-Vsync-的注册" class="headerlink" title="Choreographer 中 Vsync 的注册"></a>Choreographer 中 Vsync 的注册</h2><p>从下面的函数调用栈可以看到，Choreographer 的内部类 FrameDisplayEventReceiver.onVsync 负责接收 Vsync 回调，通知 UIThread 进行数据处理。</p><p>那么 FrameDisplayEventReceiver 是通过什么方式在 Vsync 信号到来的时候回调 onVsync 呢？答案是 FrameDisplayEventReceiver 的初始化的时候，最终通过监听文件句柄的形式，其对应的初始化流程如下</p><p>android/view/Choreographer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android/view/Choreographer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(looper, vsyncSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android/view/DisplayEventReceiver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;DisplayEventReceiver&gt;(<span class="keyword">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nativeInit 后续的代码可以自己跟一下，可以对照这篇文章和源码，由于篇幅比较多，这里就不细写了(<a href="https://www.jianshu.com/p/304f56f5d486" target="_blank" rel="noopener">https://www.jianshu.com/p/304f56f5d486</a>) ， 后续梳理好这一块的逻辑后，会在另外的文章更新。</p><p>简单来说，FrameDisplayEventReceiver 的初始化过程中，通过 BitTube(本质是一个 socket pair)，来传递和请求 Vsync 事件，当 SurfaceFlinger 收到 Vsync 事件之后，通过 appEventThread 将这个事件通过 BitTube 传给 DisplayEventDispatcher ，DisplayEventDispatcher 通过 BitTube 的接收端监听到 Vsync 事件之后，回调 Choreographer.FrameDisplayEventReceiver.onVsync ，触发开始一帧的绘制，如下图</p><p><img src="/images/15717421215251.jpg" alt=""></p><h2 id="Choreographer-处理一帧的逻辑"><a href="#Choreographer-处理一帧的逻辑" class="headerlink" title="Choreographer 处理一帧的逻辑"></a>Choreographer 处理一帧的逻辑</h2><p>Choreographer 处理绘制的逻辑核心在 Choreographer.doFrame 函数中，从下图可以看到，FrameDisplayEventReceiver.onVsync post 了自己，其 run 方法直接调用了 doFrame 开始一帧的逻辑处理</p><p>android/view/Choreographer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">long</span> physicalDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doFrame 函数主要做下面几件事</p><ol><li>计算掉帧逻辑</li><li>记录帧绘制信息</li><li>执行 CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_INSETS_ANIMATION、CALLBACK_TRAVERSAL、CALLBACK_COMMIT </li></ol><h3 id="计算掉帧逻辑"><a href="#计算掉帧逻辑" class="headerlink" title="计算掉帧逻辑"></a>计算掉帧逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                        + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Choreographer.doFrame 的掉帧检测比较简单，从下图可以看到，Vsync 信号到来的时候会标记一个 start_time ，执行 doFrame 的时候标记一个 end_time ，这两个时间差就是 Vsync 处理时延，也就是掉帧</p><p><img src="/images/15717421364722.jpg" alt=""></p><p>我们以 Systrace 的掉帧的实际情况来看掉帧的计算逻辑</p><p><img src="/images/15717421441350.jpg" alt=""></p><p>这里需要注意的是，这种方法计算的掉帧，是前一帧的掉帧情况，而不是这一帧的掉帧情况，这个计算方法是有缺陷的，会导致有的掉帧没有被计算到</p><h3 id="记录帧绘制信息"><a href="#记录帧绘制信息" class="headerlink" title="记录帧绘制信息"></a>记录帧绘制信息</h3><p>Choreographer 中 FrameInfo 来负责记录帧的绘制信息，doFrame 执行的时候，会把每一个关键节点的绘制时间记录下来，我们使用 dumpsys gfxinfo 就可以看到。当然 Choreographer 只是记录了一部分，剩余的部分在 hwui 那边来记录。</p><p>从 FrameInfo 这些标志就可以看出记录的内容，后面我们看 dumpsys gfxinfo 的时候数据就是按照这个来排列的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Various flags set to provide extra metadata about the current frame</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAGS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is this the first-draw following a window layout?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> FLAG_WINDOW_LAYOUT_CHANGED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A renderer associated with just a Surface, not with a ViewRootImpl instance.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> FLAG_SURFACE_CANVAS = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LongDef</span>(flag = <span class="keyword">true</span>, value = &#123;</span><br><span class="line">        FLAG_WINDOW_LAYOUT_CHANGED, FLAG_SURFACE_CANVAS &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FrameInfoFlags &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The intended vsync time, unadjusted by jitter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTENDED_VSYNC = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jitter-adjusted vsync time, this is what was used as input into the</span></span><br><span class="line"><span class="comment">// animation &amp; drawing system</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VSYNC = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The time of the oldest input event</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OLDEST_INPUT_EVENT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The time of the newest input event</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEWEST_INPUT_EVENT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When input event handling started</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HANDLE_INPUT_START = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When animation evaluations started</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANIMATION_START = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When ViewRootImpl#performTraversals() started</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERFORM_TRAVERSALS_START = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When View:draw() started</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DRAW_START = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>doFrame 函数记录从 Vsync time 到 markPerformTraversalsStart 的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_INPUT Callbacks </span></span><br><span class="line">    mFrameInfo.markInputHandlingStart();</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_ANIMATION Callbacks</span></span><br><span class="line">    mFrameInfo.markAnimationsStart();</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_INSETS_ANIMATION Callbacks</span></span><br><span class="line">    <span class="comment">// 处理 CALLBACK_TRAVERSAL Callbacks</span></span><br><span class="line">    mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_COMMIT Callbacks</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行-Callbacks"><a href="#执行-Callbacks" class="headerlink" title="执行 Callbacks"></a>执行 Callbacks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_INPUT Callbacks </span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_ANIMATION Callbacks</span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_INSETS_ANIMATION Callbacks</span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_TRAVERSAL Callbacks</span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line">    <span class="comment">// 处理 CALLBACK_COMMIT Callbacks</span></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Input 回调调用栈</strong></p><p><strong>input callback</strong> 一般是执行 ViewRootImpl.ConsumeBatchedInputRunnable</p><p>android/view/ViewRootImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeBatchedInputRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doConsumeBatchedInput(mChoreographer.getFrameTimeNanos());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doConsumeBatchedInput</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mConsumeBatchedInputScheduled) &#123;</span><br><span class="line">        mConsumeBatchedInputScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mInputEventReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInputEventReceiver.consumeBatchedInputEvents(frameTimeNanos)</span><br><span class="line">                    &amp;&amp; frameTimeNanos != -<span class="number">1</span>) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doProcessInputEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Input 时间经过处理，最终会传给 DecorView 的 dispatchTouchEvent，这就到了我们熟悉的 Input 事件分发</p><p><img src="/images/15717421837064.jpg" alt=""></p><p><strong>Animation 回调调用栈</strong></p><p>一般我们接触的多的是调用 View.postOnAnimation 的时候，会使用到 CALLBACK_ANIMATION </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOnAnimation</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_ANIMATION, action, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Postpone the runnable until we know</span></span><br><span class="line">        <span class="comment">// on which thread it needs to run.</span></span><br><span class="line">        getRunQueue().post(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么一般是什么时候回调用到 View.postOnAnimation 呢，我截取了一张图，大家可以自己去看一下，接触最多的应该是 startScroll，Fling 这种操作</p><p><img src="/images/15717421963577.jpg" alt=""></p><p>其调用栈根据其 post 的内容，下面是桌面滑动松手之后的 fling 动画。</p><p><img src="/images/15717422041938.jpg" alt=""></p><p>另外我们的 Choreographer 的 FrameCallback 也是用的 CALLBACK_ANIMATION </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallbackDelayed</span><span class="params">(FrameCallback callback, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callback must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class="line">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Traversal 调用栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//为了提高优先级，先 postSyncBarrier</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 真正开始执行 measure、layout、draw</span></span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 这里把 SyncBarrier remove</span></span><br><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="comment">// 真正开始</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// measure 操作</span></span><br><span class="line">      <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123;</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// layout 操作</span></span><br><span class="line">      <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">          performLayout(lp, mWidth, mHeight);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// draw 操作</span></span><br><span class="line">      <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">          performDraw();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doTraversal 的 TraceView 示例</strong></p><p><img src="/images/15717422180571.jpg" alt=""></p><h2 id="下一帧的-Vsync-请求"><a href="#下一帧的-Vsync-请求" class="headerlink" title="下一帧的 Vsync 请求"></a>下一帧的 Vsync 请求</h2><p>由于动画、滑动、Fling 这些操作的存在，我们需要一个连续的、稳定的帧率输出机制。这就涉及到了 Vsync 的请求逻辑，在连续的操作，比如动画、滑动、Fling 这些情况下，每一帧的 doFrame 的时候，都会根据情况触发下一个 Vsync 的申请，这样我们就可以获得连续的 Vsync 信号。</p><p>看下面的 scheduleTraversals 调用栈(scheduleTraversals 中会触发 Vsync 请求)<br><img src="/images/15724225347501.jpg" alt=""><br>我们比较熟悉的 invalidate 和 requestLayout 都会触发 Vsync 信号请求</p><p>我们下面以 Animation 为例，看看 Animation 是如何驱动下一个 Vsync ，来持续更新画面的</p><h3 id="ObjectAnimator-动画驱动逻辑"><a href="#ObjectAnimator-动画驱动逻辑" class="headerlink" title="ObjectAnimator 动画驱动逻辑"></a>ObjectAnimator 动画驱动逻辑</h3><p>android/animation/ObjectAnimator.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android/animation/ValueAnimator.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    addAnimationCallback(<span class="number">0</span>); <span class="comment">// 动画 start 的时候添加 Animation Callback </span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAnimationCallback</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    getAnimationHandler().addAnimationFrameCallback(<span class="keyword">this</span>, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android/animation/AnimationHandler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnimationFrameCallback</span><span class="params">(<span class="keyword">final</span> AnimationFrameCallback callback, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// post FrameCallback</span></span><br><span class="line">        getProvider().postFrameCallback(mFrameCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 mFrameCallback 回调 doFrame，里面 post了自己</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        doAnimationFrame(getProvider().getFrameTime());</span><br><span class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// post 自己</span></span><br><span class="line">            getProvider().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用 postFrameCallback 会走到 mChoreographer.postFrameCallback ，这里就会触发 Choreographer 的 Vsync 请求逻辑</p><p>android/animation/AnimationHandler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallback</span><span class="params">(Choreographer.FrameCallback callback)</span> </span>&#123;</span><br><span class="line">    mChoreographer.postFrameCallback(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android/view/Choreographer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">// 请求 Vsync scheduleFrameLocked -&gt;scheduleVsyncLocked-&gt; mDisplayEventReceiver.scheduleVsync -&gt;nativeScheduleVsync</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的 Animation.start 设置，利用了 Choreographer.FrameCallback 接口，每一帧都去请求下一个 Vsync<br><strong>动画过程中一帧的 TraceView 示例</strong></p><p><img src="/images/15717422327935.jpg" alt=""></p><h2 id="源码小结"><a href="#源码小结" class="headerlink" title="源码小结"></a>源码小结</h2><ol><li><strong>Choreographer</strong> 是线程单例的，而且必须要和一个 Looper 绑定，因为其内部有一个 Handler 需要和 Looper 绑定，一般是 App 主线程的 Looper 绑定</li><li><strong>DisplayEventReceiver</strong> 是一个 abstract class，其 JNI 的代码部分会创建一个IDisplayEventConnection 的 Vsync 监听者对象。这样，来自 AppEventThread 的 VSYNC 中断信号就可以传递给 Choreographer 对象了。当 Vsync 信号到来时，DisplayEventReceiver 的 onVsync 函数将被调用。</li><li><strong>DisplayEventReceiver</strong> 还有一个 scheduleVsync 函数。当应用需要绘制UI时，将首先申请一次 Vsync 中断，然后再在中断处理的 onVsync 函数去进行绘制。</li><li><strong>Choreographer</strong> 定义了一个 <strong>FrameCallback</strong> <strong>interface</strong>，每当 Vsync 到来时，其 doFrame 函数将被调用。这个接口对 Android Animation 的实现起了很大的帮助作用。以前都是自己控制时间，现在终于有了固定的时间中断。</li><li><strong>Choreographer</strong> 的主要功能是，当收到 Vsync 信号时，去调用使用者通过 postCallback 设置的回调函数。目前一共定义了五种类型的回调，它们分别是：<ol><li><strong>CALLBACK_INPUT</strong>  : 处理输入事件处理有关</li><li><strong>CALLBACK_ANIMATION</strong> ： 处理 Animation 的处理有关</li><li><strong>CALLBACK_INSETS_ANIMATION</strong> ： 处理 Insets Animation 的相关回调</li><li><strong>CALLBACK_TRAVERSAL</strong>  : 处理和 UI 等控件绘制有关</li><li><strong>CALLBACK_COMMIT</strong> ： 处理 Commit 相关回调</li></ol></li><li><strong>ListView</strong> 的 Item 初始化(obtain\setup) 会在 input 里面也会在 animation 里面，这取决于</li><li><strong>CALLBACK_INPUT</strong> 、<strong>CALLBACK_ANIMATION</strong> 会修改 view 的属性，所以要先与 CALLBACK_TRAVERSAL 执行</li></ol><h1 id="APM-与-Choreographer"><a href="#APM-与-Choreographer" class="headerlink" title="APM 与 Choreographer"></a>APM 与 Choreographer</h1><p>由于 Choreographer 的位置，许多性能监控的手段都是利用 Choreographer 来做的，除了自带的掉帧计算，Choreographer 提供的 FrameCallback 和 FrameInfo 都给 App 暴露了接口，让 App 开发者可以通过这些方法监控自身 App 的性能，其中常用的方法如下：</p><ol><li>利用 FrameCallback 的 doFrame 回调</li><li>利用 FrameInfo 进行监控<ol><li>使用 ：adb shell dumpsys gfxinfo <packagename> framestats</li><li>示例 ：adb shell dumpsys gfxinfo com.meizu.flyme.launcher framestats</li></ol></li><li>利用 SurfaceFlinger 进行监控<ol><li>使用 ：adb shell dumpsys SurfaceFlinger –latency</li><li>示例 ：adb shell dumpsys SurfaceFlinger –latency com.meizu.flyme.launcher/com.meizu.flyme.launcher.Launcher#0</li></ol></li><li>利用 SurfaceFlinger PageFlip 机制进行监控<ol><li>使用 ： adb service call SurfaceFlinger 1013</li><li>备注：需要系统权限</li></ol></li><li>Choreographer 自身的掉帧计算逻辑</li><li>BlockCanary 基于 Looper 的性能监控</li></ol><h2 id="利用-FrameCallback-的-doFrame-回调"><a href="#利用-FrameCallback-的-doFrame-回调" class="headerlink" title="利用 FrameCallback 的 doFrame 回调"></a>利用 FrameCallback 的 doFrame 回调</h2><h3 id="FrameCallback-接口"><a href="#FrameCallback-接口" class="headerlink" title="FrameCallback 接口"></a>FrameCallback 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FrameCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Choreographer.getInstance().postFrameCallback(youOwnFrameCallback );</span><br></pre></td></tr></table></figure><h3 id="接口处理"><a href="#接口处理" class="headerlink" title="接口处理"></a>接口处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallbackDelayed</span><span class="params">(FrameCallback callback, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class="line">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TinyDancer 就是使用了这个方法来计算 FPS (<a href="https://github.com/friendlyrobotnyc/TinyDancer" target="_blank" rel="noopener">https://github.com/friendlyrobotnyc/TinyDancer</a>)</p><h2 id="利用-FrameInfo-进行监控"><a href="#利用-FrameInfo-进行监控" class="headerlink" title="利用 FrameInfo 进行监控"></a>利用 FrameInfo 进行监控</h2><p>adb shell dumpsys gfxinfo <packagename> framestats</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Window: StatusBar</span><br><span class="line">Stats since: 17990256398ns</span><br><span class="line">Total frames rendered: 1562</span><br><span class="line">Janky frames: 361 (23.11%)</span><br><span class="line">50th percentile: 6ms</span><br><span class="line">90th percentile: 23ms</span><br><span class="line">95th percentile: 36ms</span><br><span class="line">99th percentile: 101ms</span><br><span class="line">Number Missed Vsync: 33</span><br><span class="line">Number High input latency: 683</span><br><span class="line">Number Slow UI thread: 273</span><br><span class="line">Number Slow bitmap uploads: 8</span><br><span class="line">Number Slow issue draw commands: 18</span><br><span class="line">Number Frame deadline missed: 287</span><br><span class="line">HISTOGRAM: 5ms=670 6ms=128 7ms=84 8ms=63 9ms=38 10ms=23 11ms=21 12ms=20 13ms=25 14ms=39 15ms=65 16ms=36 17ms=51 18ms=37 19ms=41 20ms=20 21ms=19 22ms=18 23ms=15 24ms=14 25ms=8 26ms=4 27ms=6 28ms=3 29ms=4 30ms=2 31ms=2 32ms=6 34ms=12 36ms=10 38ms=9 40ms=3 42ms=4 44ms=5 46ms=8 48ms=6 53ms=6 57ms=4 61ms=1 65ms=0 69ms=2 73ms=2 77ms=3 81ms=4 85ms=1 89ms=2 93ms=0 97ms=2 101ms=1 105ms=1 109ms=1 113ms=1 117ms=1 121ms=2 125ms=1 129ms=0 133ms=1 150ms=2 200ms=3 250ms=0 300ms=1 350ms=1 400ms=0 450ms=0 500ms=0 550ms=0 600ms=0 650ms=0 </span><br><span class="line"></span><br><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,</span><br><span class="line">0,10158314881426,10158314881426,9223372036854775807,0,10158315693363,10158315760759,10158315769821,10158316032165,10158316627842,10158316838988,10158318055915,10158320387269,10158321770654,428000,773000,</span><br><span class="line">0,10158332036261,10158332036261,9223372036854775807,0,10158332799196,10158332868519,10158332877269,10158333137738,10158333780654,10158333993206,10158335078467,10158337689561,10158339307061,474000,885000,</span><br><span class="line">0,10158348665353,10158348665353,9223372036854775807,0,10158349710238,10158349773102,10158349780863,10158350405863,10158351135967,10158351360446,10158352300863,10158354305654,10158355814509,471000,836000,</span><br><span class="line">0,10158365296729,10158365296729,9223372036854775807,0,10158365782373,10158365821019,10158365825238,10158365975290,10158366547946,10158366687217,10158367240706,10158368429248,10158369291852,269000,476000,</span><br></pre></td></tr></table></figure><h2 id="利用-SurfaceFlinger-进行监控"><a href="#利用-SurfaceFlinger-进行监控" class="headerlink" title="利用 SurfaceFlinger 进行监控"></a>利用 SurfaceFlinger 进行监控</h2><p>命令解释：</p><ol><li>数据的单位是纳秒，时间是以开机时间为起始点</li><li>每一次的命令都会得到128行的帧相关的数据</li></ol><p>数据：</p><ol><li>第一行数据，表示刷新的时间间隔refresh_period</li><li>第1列：这一部分的数据表示应用程序绘制图像的时间点</li><li>第2列：在SF(软件)将帧提交给H/W(硬件)绘制之前的垂直同步时间，也就是每帧绘制完提交到硬件的时间戳，该列就是垂直同步的时间戳</li><li>第3列：在SF将帧提交给H/W的时间点，算是H/W接受完SF发来数据的时间点，绘制完成的时间点。</li></ol><p><strong>掉帧 jank 计算</strong></p><p>每一行都可以通过下面的公式得到一个值，该值是一个标准，我们称为jankflag，如果当前行的jankflag与上一行的jankflag发生改变，那么就叫掉帧</p><p>ceil((C - A) / refresh-period)</p><h2 id="利用-SurfaceFlinger-PageFlip-机制进行监控"><a href="#利用-SurfaceFlinger-PageFlip-机制进行监控" class="headerlink" title="利用 SurfaceFlinger PageFlip 机制进行监控"></a>利用 SurfaceFlinger PageFlip 机制进行监控</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Parcel data = Parcel.obtain();</span><br><span class="line">Parcel reply = Parcel.obtain();</span><br><span class="line">                data.writeInterfaceToken(<span class="string">"android.ui.ISurfaceComposer"</span>);</span><br><span class="line">mFlinger.transact(<span class="number">1013</span>, data, reply, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> pageFlipCount = reply.readInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> frames = pageFlipCount - mLastPageFlipCount;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> duration = now - mLastUpdateTime;</span><br><span class="line">mFps = (<span class="keyword">float</span>) (frames * <span class="number">1e9</span> / duration);</span><br><span class="line">mLastPageFlipCount = pageFlipCount;</span><br><span class="line">mLastUpdateTime = now;</span><br><span class="line">reply.recycle();</span><br><span class="line">data.recycle();</span><br></pre></td></tr></table></figure><h2 id="Choreographer-自身的掉帧计算逻辑"><a href="#Choreographer-自身的掉帧计算逻辑" class="headerlink" title="Choreographer 自身的掉帧计算逻辑"></a>Choreographer 自身的掉帧计算逻辑</h2><p>SKIPPED_FRAME_WARNING_LIMIT 默认为30 , 由 debug.choreographer.skipwarning 这个属性控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">    <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockCanary"><a href="#BlockCanary" class="headerlink" title="BlockCanary"></a>BlockCanary</h2><p>Blockcanary 做性能监控使用的是 Looper 的消息机制，通过对 MessageQueue 中每一个 Message 的前后进行记录，打到监控性能的目的</p><p>android/os/Looper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MessageQueue-与-Choreographer"><a href="#MessageQueue-与-Choreographer" class="headerlink" title="MessageQueue 与 Choreographer"></a>MessageQueue 与 Choreographer</h1><p>所谓的异步消息其实就是这样的，我们可以通过 enqueueBarrier 往消息队列中插入一个 Barrier，那么队列中执行时间在这个 Barrier 以后的同步消息都会被这个 Barrier 拦截住无法执行，直到我们调用 removeBarrier 移除了这个 Barrier，而异步消息则没有影响，消息默认就是同步消息，除非我们调用了 Message 的 setAsynchronous，这个方法是隐藏的。只有在初始化 Handler 时通过参数指定往这个 Handler 发送的消息都是异步的，这样在 Handler 的 enqueueMessage 中就会调用 Message 的 setAsynchronous 设置消息是异步的，从上面 Handler.enqueueMessage 的代码中可以看到。</p><p>所谓异步消息，其实只有一个作用，就是在设置 Barrier 时仍可以不受 Barrier 的影响被正常处理，如果没有设置 Barrier，异步消息就与同步消息没有区别，可以通过 removeSyncBarrier 移除 Barrier</p><h2 id="SyncBarrier-在-Choreographer-中使用的一个示例"><a href="#SyncBarrier-在-Choreographer-中使用的一个示例" class="headerlink" title="SyncBarrier 在 Choreographer 中使用的一个示例"></a>SyncBarrier 在 Choreographer 中使用的一个示例</h2><p>scheduleTraversals 的时候 postSyncBarrier</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//为了提高优先级，先 postSyncBarrier</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doTraversal 的时候 removeSyncBarrier</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 这里把 SyncBarrier remove</span></span><br><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="comment">// 真正开始</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Choreographer post Message 的时候，会把这些消息设为 Asynchronous ，这样Choreographer 中的这些 Message 的优先级就会比较高，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">msg.arg1 = callbackType;</span><br><span class="line">msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">mHandler.sendMessageAtTime(msg, dueTime);</span><br></pre></td></tr></table></figure><h1 id="厂商优化"><a href="#厂商优化" class="headerlink" title="厂商优化"></a>厂商优化</h1><p>系统厂商由于可以直接修改源码，也利用这方面的便利，做一些功能和优化，不过由于保密的问题，代码就不直接放上来了，我可以大概说一下思路，感兴趣的可以私下讨论</p><h2 id="移动事件优化"><a href="#移动事件优化" class="headerlink" title="移动事件优化"></a>移动事件优化</h2><p>Choreographer 本身是没有 input 消息的， 不过修改源码之后，input 消息可以直接给到 Choreographer 这里， 有了这些 Input 消息，Choreographer 就可以做一些事情，比如说提前响应，不去等 Vsync</p><h2 id="后台动画优化"><a href="#后台动画优化" class="headerlink" title="后台动画优化"></a>后台动画优化</h2><p>当一个 Android App 退到后台之后，只要他没有被杀死，那么他做什么事情大家都不要奇怪，因为这就是 Android。有的 App 退到后台之后还在持续调用 Choreographer 中的 Animation Callback，而这个 Callback 的执行完全是无意义的，而且用户还不知道，但是对 cpu 的占用是比较高的。</p><p>所以在 Choreographer 中会针对这种情况做优化，禁止不符合条件的 App 在后台继续无用的操作</p><p><img src="/images/15717422623134.jpg" alt=""></p><h2 id="帧绘制优化"><a href="#帧绘制优化" class="headerlink" title="帧绘制优化"></a>帧绘制优化</h2><p>和移动事件优化一样，由于有了 Input 事件的信息，在某些场景下我们可以通知 SurfaceFlinger 不用去等待 Vsync 直接做合成操作</p><h2 id="应用启动优化"><a href="#应用启动优化" class="headerlink" title="应用启动优化"></a>应用启动优化</h2><p>我们前面说，主线程的所有操作都是给予 Message 的 ，如果某个操作，非重要的 Message 被排列到了队列后面，那么对这个操作产生影响；而通过重新排列 MessageQueue，在应用启动的时候，把启动相关的重要的启动 Message 放到队列前面，来起到加快启动速度的作用</p><h2 id="高帧率优化"><a href="#高帧率优化" class="headerlink" title="高帧率优化"></a>高帧率优化</h2><p>90 fps 的手机上 ， Vsync 间隔从 16.6ms 变成了 11.1ms ，这带来了巨大的性能和功耗挑战，如何在一帧内完成渲染的必要操作，是手机厂商必须要思考和优化的地方：</p><ol><li>超级 App 的性能表现以及优化</li><li>游戏高帧率合作</li><li>90 fps 和 60 fps 相互切换的逻辑</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/304f56f5d486" target="_blank" rel="noopener">https://www.jianshu.com/p/304f56f5d486</a></li><li><a href="http://gityuan.com/2017/02/25/choreographer/" target="_blank" rel="noopener">http://gityuan.com/2017/02/25/choreographer/</a></li><li><a href="https://developer.android.com/reference/android/view/Choreographer" target="_blank" rel="noopener">https://developer.android.com/reference/android/view/Choreographer</a></li><li><a href="https://www.jishuwen.com/d/2Vcc" target="_blank" rel="noopener">https://www.jishuwen.com/d/2Vcc</a></li><li><a href="https://juejin.im/entry/5c8772eee51d456cda2e8099" target="_blank" rel="noopener">https://juejin.im/entry/5c8772eee51d456cda2e8099</a></li><li><a href="https://time.geekbang.org/column/intro/142" target="_blank" rel="noopener">Android 开发高手课</a></li></ol><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/87954949" target="_blank" rel="noopener">知乎 - Android 基于 Choreographer 的渲染机制详解</a><br><a href="https://juejin.im/post/5daedc65e51d457834735c65" target="_blank" rel="noopener">掘金 - Android 基于 Choreographer 的渲染机制详解</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"> </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的卡顿丢帧原因概述 - 低内存篇</title>
      <link href="/2019/09/18/Android-Jank-Due-To-Low-Memory/"/>
      <url>/2019/09/18/Android-Jank-Due-To-Low-Memory/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a> 这篇文章中 , 实际案例这里我们有列举一些由于系统低内存导致的卡顿 , 由于 Android 低内存对整机性能影响比较大 , 所以单独写一篇文章 , 来概述系统低内存对整机性能的影响 .</p><p>随着 Android 系统版本的更迭 , 以及 App 的代码膨胀 , Android 系统对内存的需求越来越大 , 但是目前市面上还存在着大量的 4G 内存以下的机器 , 这部分用户就很容易遇到整机低内存的情况 , 尤其是在系统大版本更新和 App 越装越多的情况下 . </p><p>Android 低内存会导致性能问题 , 具体表现就是响应慢和卡顿 . 比如启动一个应用要花比平时更长的时间 ; 滑动列表会掉更多帧 ; 后台的进程减少导致冷启动变多 ; 手机很容易发热发烫等 , 下面我会概述发生这些性能问题的原因 . Debug 的方法 , 以及可能的优化措施 . </p><a id="more"></a><p><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">0. Android 中的卡顿丢帧原因概述 - 方法论</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">1. Android 中的卡顿丢帧原因概述 - 系统篇</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">2. Android 中的卡顿丢帧原因概述 - 应用篇</a><br><a href="https://www.androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/" target="_blank" rel="noopener">3. Android 中的卡顿丢帧原因概述 - 低内存篇</a></p><h1 id="低内存的数据特征和行为特征"><a href="#低内存的数据特征和行为特征" class="headerlink" title="低内存的数据特征和行为特征"></a>低内存的数据特征和行为特征</h1><h2 id="Meminfo-信息"><a href="#Meminfo-信息" class="headerlink" title="Meminfo 信息"></a>Meminfo 信息</h2><p>最简单的方法是使用 Android 系统自带的 Dumpsys meminfo 工具</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo</span><br><span class="line">......</span><br><span class="line">Total RAM: <span class="number">7</span>,<span class="number">658</span>,<span class="number">060</span>K (status moderate)</span><br><span class="line"> Free RAM:   <span class="number">550</span>,<span class="number">200</span>K (   <span class="number">78</span>,<span class="number">760</span>K cached pss +   <span class="number">156</span>,ba480K cached kernel +   <span class="number">314</span>,<span class="number">960</span>K free)</span><br><span class="line"> Used RAM: <span class="number">7</span>,<span class="number">718</span>,<span class="number">091</span>K (<span class="number">6</span>,<span class="number">118</span>,<span class="number">703</span>K used pss + <span class="number">1</span>,<span class="number">599</span>,<span class="number">388</span>K kernel)</span><br><span class="line"> Lost RAM:  <span class="number">-319</span>,<span class="number">863</span>K</span><br><span class="line">     ZRAM:     <span class="number">2</span>,<span class="number">608</span>K physical used <span class="keyword">for</span>   <span class="number">301</span>,<span class="number">256</span>K <span class="keyword">in</span> swap (<span class="number">4</span>,<span class="number">247</span>,<span class="number">544</span>K total swap)</span><br><span class="line">   Tuning: <span class="number">256</span> (large <span class="number">512</span>), oom   <span class="number">322</span>,<span class="number">560</span>K, restore limit   <span class="number">107</span>,<span class="number">520</span>K (high-end-gfx)</span><br></pre></td></tr></table></figure><p>如果系统处于低内存的话 , 会有如下特征:</p><ol><li>FreeRam 的值非常少 , Used RAM 的值非常大</li><li>ZRAM 使用率非常高（如果开了 Zram 的话）</li></ol><h2 id="LMK-amp-amp-kswapd-线程活跃"><a href="#LMK-amp-amp-kswapd-线程活跃" class="headerlink" title="LMK &amp;&amp; kswapd 线程活跃"></a>LMK &amp;&amp; kswapd 线程活跃</h2><p>低内存的时候， LKMD 会非常活跃， 在 Kernel Log 里面可以看到 LMK 杀进程的信息:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[kswapd0] lowmemorykiller: Killing <span class="string">'u.mzsyncservice'</span> (<span class="number">15609</span>) (tgid <span class="number">15609</span>), adj <span class="number">906</span>,</span><br><span class="line">to free <span class="number">28864</span>kB on behalf of <span class="string">'kswapd0'</span> (<span class="number">91</span>) because</span><br><span class="line">cache <span class="number">258652</span>kB <span class="keyword">is</span> below limit <span class="number">261272</span>kB <span class="keyword">for</span> oom score <span class="number">906</span></span><br><span class="line">Free memory <span class="keyword">is</span> <span class="number">-5540</span>kB above reserved.</span><br><span class="line">Free CMA <span class="keyword">is</span> <span class="number">3172</span>kB</span><br><span class="line">Total reserve <span class="keyword">is</span> <span class="number">227288</span>kB</span><br><span class="line">Total free pages <span class="keyword">is</span> <span class="number">271748</span>kB</span><br><span class="line">Total file cache <span class="keyword">is</span> <span class="number">345384</span>kB</span><br><span class="line">GFP mask <span class="keyword">is</span> <span class="number">0x14000c0</span></span><br></pre></td></tr></table></figure><p>上面这段 Log 的意思是说， 由于 mem 低于我们设定的 900 的水位线 （261272kB），所以把 pid 为 15609 的 mzsyncservice 这个进程杀掉（这个进程的 adj 是 906 ）</p><h2 id="proc-meminfo"><a href="#proc-meminfo" class="headerlink" title="proc/meminfo"></a>proc/meminfo</h2><p>这里是 Linux Kernel 展示 meminfo 的地方 , 关于 meminfo 的解读，可以参考这篇文章：<a href="http://linuxperf.com/?p=142" target="_blank" rel="noopener">/PROC/MEMINFO之谜</a></p><p>从结果来 , 当系统处于低内存的情况时候 , MemFree 和 MemAvailable 的值都很小</p><figure class="highlight plain"><figcaption><span>shell cat proc/meminfo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">MemTotal:        5630104 kB</span><br><span class="line">MemFree:          148928 kB</span><br><span class="line">MemAvailable:     864172 kB</span><br><span class="line">Buffers:           28464 kB</span><br><span class="line">Cached:          1003144 kB</span><br><span class="line">SwapCached:        19844 kB</span><br><span class="line">Active:          1607512 kB</span><br><span class="line">Inactive:         969208 kB</span><br><span class="line">Active(anon):    1187828 kB</span><br><span class="line">Inactive(anon):   426192 kB</span><br><span class="line">Active(file):     419684 kB</span><br><span class="line">Inactive(file):   543016 kB</span><br><span class="line">Unevictable:       62152 kB</span><br><span class="line">Mlocked:           62152 kB</span><br><span class="line">SwapTotal:       2097148 kB</span><br><span class="line">SwapFree:          42576 kB</span><br><span class="line">Dirty:              3604 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:       1602928 kB</span><br><span class="line">Mapped:           996768 kB</span><br><span class="line">Shmem:              7284 kB</span><br><span class="line">Slab:             306440 kB</span><br><span class="line">SReclaimable:      72320 kB</span><br><span class="line">SUnreclaim:       234120 kB</span><br><span class="line">KernelStack:       89776 kB</span><br><span class="line">PageTables:       107572 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:     4912200 kB</span><br><span class="line">Committed_AS:   118487976 kB</span><br><span class="line">VmallocTotal:   263061440 kB</span><br><span class="line">VmallocUsed:           0 kB</span><br><span class="line">VmallocChunk:          0 kB</span><br><span class="line">CmaTotal:         303104 kB</span><br><span class="line">CmaFree:            3924 kB</span><br></pre></td></tr></table></figure><h2 id="整机卡顿-amp-amp-响应慢"><a href="#整机卡顿-amp-amp-响应慢" class="headerlink" title="整机卡顿 &amp;&amp; 响应慢"></a>整机卡顿 &amp;&amp; 响应慢</h2><p>低内存的时候，整机使用的时候要比非低内存的时候要卡很多，点击应用或者启动 App 都会有不顺畅或者响应慢的感觉</p><h1 id="低内存对性能的具体影响"><a href="#低内存对性能的具体影响" class="headerlink" title="低内存对性能的具体影响"></a>低内存对性能的具体影响</h1><h2 id="影响主线程-IO-操作"><a href="#影响主线程-IO-操作" class="headerlink" title="影响主线程 IO 操作"></a>影响主线程 IO 操作</h2><p>主线程出现大量的 IO 相关的问题 ， </p><ol><li>反馈到 Trace 上就是有大量的黄色 Trace State 出现 , 例如 : Uninterruptible Sleep | WakeKill - Block I/O .</li><li>查看其 Block 信息 （kernel callsite when blocked:: “wait_on_page_bit_killable+0x78/0x88）</li></ol><p><strong>Linux 系统的 page cache 链表中有时会出现一些还没准备好的 page ( 即还没把磁盘中的内容完全地读出来 ) , 而正好此时用户在访问这个 page 时就会出现 wait_on_page_locked_killable 阻塞了. 只有系统当 io 操作很繁忙时, 每笔的 io 操作都需要等待排队时, 极其容易出现且阻塞的时间往往会比较长.</strong></p><p><strong>当出现大量的 IO 操作的时候，应用主线程的 Uninterruptible Sleep 也会变多，此时涉及到 io 操作（比如  view ，读文件，读配置文件、读 odex 文件），都会触发 Uninterruptible Sleep ， 导致整个操作的时间变长</strong></p><p><img src="/images//15688217911224.jpg" alt=""></p><p><img src="/images//15688217985878.jpg" alt=""></p><h2 id="出现-CPU-竞争"><a href="#出现-CPU-竞争" class="headerlink" title="出现 CPU 竞争"></a>出现 CPU 竞争</h2><p>低内存会触发 Low Memory Killer  进程频繁进行扫描和杀进程，kswapd0 是一个内核工作线程，内存不足时会被唤醒，做内存回收的工作。 当内存频繁在低水位的时候，kswapd0 会被频繁唤醒，占用 cpu ，造成卡顿和耗电。</p><p>比如下面这个情况， kswapd0 占用了 855 的超大核 cpu7 ，而且是满频在跑，耗电可想而知，如果此时前台应用的主线程跑到了 cpu7 上，很大可能会出现 cpu 竞争，导致调度不到而丢帧。 </p><p>HeapTaskDaemon 通常也会在低内存的时候跑的很高 </p><p><img src="/images//15688218269079.jpg" alt="">, 来做内存相关的操作</p><h2 id="进程频繁查杀和重启"><a href="#进程频繁查杀和重启" class="headerlink" title="进程频繁查杀和重启"></a>进程频繁查杀和重启</h2><p>对 AMS 的影响主要集中在进程的查杀上面 , 由于 LMK 的介入 , 处于 Cache 状态的进程很容易被杀掉 , 然后又被他们的父进程或者其他的应用所拉起来 , 导致陷入了一种死循环 . 对系统 CPU \ Memory \ IO 等资源的影响非常大.</p><p>比如下面就是一次 Monkey 之后的结果 , QQ 在短时间内频繁被杀和重启 .</p><figure class="highlight plain"><figcaption><span>14:32:16.932  1435  1510 I am_proc_start: [0,30387,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">07-23 14:32:16.969  1435  3420 I am_proc_bound: [0,30387,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:16.979  1435  3420 I am_kill : [0,30387,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:16.996  1435  3420 I am_proc_died: [0,30387,com.tencent.mobileqq,901,18]</span><br><span class="line">07-23 14:32:17.028  1435  1510 I am_proc_start: [0,30400,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.054  1435  3420 I am_proc_bound: [0,30400,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.064  1435  3420 I am_kill : [0,30400,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:17.082  1435  3420 I am_proc_died: [0,30400,com.tencent.mobileqq,901,18]</span><br><span class="line">07-23 14:32:17.114  1435  1510 I am_proc_start: [0,30413,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.139  1435  3420 I am_proc_bound: [0,30413,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.149  1435  3420 I am_kill : [0,30413,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:17.166  1435  3420 I am_proc_died: [0,30413,com.tencent.mobileqq,901,18]</span><br><span class="line">07-23 14:32:17.202  1435  1510 I am_proc_start: [0,30427,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.216  1435  3420 I am_proc_bound: [0,30427,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.226  1435  3420 I am_kill : [0,30427,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:17.249  1435  3420 I am_proc_died: [0,30427,com.tencent.mobileqq,901,18]</span><br><span class="line">07-23 14:32:17.278  1435  1510 I am_proc_start: [0,30440,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.299  1435  3420 I am_proc_bound: [0,30440,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.309  1435  3420 I am_kill : [0,30440,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:17.329  1435  2116 I am_proc_died: [0,30440,com.tencent.mobileqq,901,18]</span><br><span class="line">07-23 14:32:17.362  1435  1510 I am_proc_start: [0,30453,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.387  1435  2116 I am_proc_bound: [0,30453,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.398  1435  2116 I am_kill : [0,30453,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:17.420  1435  2116 I am_proc_died: [0,30453,com.tencent.mobileqq,901,18]</span><br><span class="line">07-23 14:32:17.447  1435  1510 I am_proc_start: [0,30466,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.474  1435  2116 I am_proc_bound: [0,30466,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.484  1435  2116 I am_kill : [0,30466,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:17.507  1435  2116 I am_proc_died: [0,30466,com.tencent.mobileqq,901,18]</span><br><span class="line">07-23 14:32:17.533  1435  1510 I am_proc_start: [0,30479,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.556  1435  2116 I am_proc_bound: [0,30479,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.566  1435  2116 I am_kill : [0,30479,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:17.587  1435  2116 I am_proc_died: [0,30479,com.tencent.mobileqq,901,18]</span><br><span class="line">07-23 14:32:17.613  1435  1510 I am_proc_start: [0,30492,10145,com.tencent.mobileqq,restart,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.636  1435  2116 I am_proc_bound: [0,30492,com.tencent.mobileqq]</span><br><span class="line">07-23 14:32:17.646  1435  2116 I am_kill : [0,30492,com.tencent.mobileqq,901,empty #3]</span><br><span class="line">07-23 14:32:17.667  1435  2116 I am_proc_died: [0,30492,com.tencent.mobileqq,901,18]</span><br></pre></td></tr></table></figure><p>其对应的 Systrace - SystemServer 中可以看到 AM 在频繁杀 QQ 和起 QQ<br><img src="/images//15688220198874.jpg" alt=""></p><p>此 Trace 对应的 Kernel 部分也可以看到繁忙的 cpu<br><img src="/images//15688220915505.jpg" alt=""></p><h2 id="影响内存分配和触发-IO"><a href="#影响内存分配和触发-IO" class="headerlink" title="影响内存分配和触发 IO"></a>影响内存分配和触发 IO</h2><p>手机经过长时间老化使用整机卡顿一下 , 或者整体比刚刚开机的时候操作要慢 , 可能是因为触发了内存回收或者 block io , 而这两者又经常有关联 . 内存回收可能触发了 fast path  回收 \ kswapd 回收 \ direct reclaim 回收 \ LMK杀进程回收等。（fast path 回收不进行回写）</p><p>回收的内容是匿名页 swapout 或者 file-backed 页写回和清空。（假设手机都是 swap file 都是内存，不是 disk）, 涉及到 file 的，都可能操作 io，增加 block io 的概率。</p><p>还有更常见的是打开之前打开过的应用，没有第一次打开的快，需要加载或者卡一段时间 . 可能发生了 do_page_fault，这条路径经常见到 block io 在 wait_on_page_bit_killable()，如果是 swapout 内存，就要 swapin 了。如果是普通文件，就要 read out in pagecache/disk.</p><p>do_page_fault —&gt; lock_page_or_retry -&gt; wait_on_page_bit_killable 里面会判断 page 是否置位 PG_locked, 如果置位就一直阻塞, 直到 PG_locked 被清除  , 而 PG_locked 标志位是在回写开始时和 I/O 读完成时才会被清除，而 readahead 到 pagecache 功能也对 block io 产生影响，太大了增加阻塞概率。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面这个 Trace 是低内存情况下 ， 抓取的一个 App 的冷启动 ， 我们只取应用启动到第一帧显示的部分 ，总耗时为2s 。<br>可以看到其 Running 的总时间是 682 ms ，</p><h2 id="低内存的启动情况"><a href="#低内存的启动情况" class="headerlink" title="低内存的启动情况"></a>低内存的启动情况</h2><p>低内存情况下 , 这个 App 从 bindApplication 到第一帧显示 , 共花费了 2s . 从下面的 Thread 信息那里可以看到 </p><ol><li>Uninterruptible Sleep | WakeKill - Block I/O 和 Uninterruptible Sleep 这两栏总共花费 750 ms 左右(对比下面正常情况才 130 ms)</li><li>Running 的时间在 600 ms (对比下面正常情况才 624 ms , 相差不大) </li></ol><p><img src="/images//15688227815756.jpg" alt=""></p><p>从这段时间内的 CPU 使用情况来看 , 除了 HeapTaskDeamon 跑的比较多之外 , 其他的内存和 io 相关的进程也非常多 , 比如若干个 kworker 和 kswapd0.</p><p><img src="/images//15688227887581.jpg" alt=""></p><h2 id="正常内存情况下"><a href="#正常内存情况下" class="headerlink" title="正常内存情况下"></a>正常内存情况下</h2><p>正常内存情况下 , 这个 App 从 bindApplication 到第一帧显示 , 只需要 1.22s . 从下面的 Thread 信息那里可以看到 </p><ol><li>Uninterruptible Sleep | WakeKill - Block I/O 和 Uninterruptible Sleep 这两栏总共才 130 ms.</li><li>Running 的时间是 624 ms<br><img src="/images//15688228638217.jpg" alt=""></li></ol><p>从这段时间内的 CPU 使用情况来看 , 除了 HeapTaskDeamon 跑的比较多之外 , 其他的内存和 io 相关的进程非常少.<br><img src="/images//15688228721814.jpg" alt=""></p><h1 id="可能的优化方案-来自实际的经验和大佬分享的经验"><a href="#可能的优化方案-来自实际的经验和大佬分享的经验" class="headerlink" title="可能的优化方案 (来自实际的经验和大佬分享的经验)"></a>可能的优化方案 (来自实际的经验和大佬分享的经验)</h1><p>下面列举的只是一些经验之谈 , 具体问题还是得具体分析 , 在 Android 平台上 , 对三方应用的管控是非常重要的 , 很多小白用户 , 一大堆常驻通知和后台服务 , 导致这些 App 的优先级非常高 , 很难被杀掉 . 导致整机的内存长时间比较低 . 所以做系统的必要的优化之后 , 就要着重考虑对三方应用的查杀和管控逻辑 , 尽量减少后台进程的个数 , 在必要的时候 , 清理掉无用的进程来释放内存个前台应用使用.</p><ol><li>提高 extra_free_kbytes 值</li><li>提高 disk I/O 读写速率，如用 UFS3.0，用固态硬盘</li><li>避免设置太大的 read_ahead_kb 值</li><li>使用 cgroup 的 blkio 来限制后台进程的 io 读操作，缩短前台 io 响应时间</li><li>提前做内存回收的操作，避免在用户使用应用时碰到而感受到稍微卡顿</li><li>增加 LMK 效率，避免无效的 kill</li><li>kswapd 周期性回收更多的 high 水位</li><li>调整 swappiness 来平衡 pagecache 和 swap </li><li>策略 : 针对低内存机器做特殊的策略 , 比如杀进程更加激进 (这会带来用户体验的降低 , 所以这个度需要兼顾性能和用户体验)</li><li>策略 : 在内存不足的时候提醒用户(或者不提醒用户) , 杀掉不必要的后台进程 .</li><li>策略 : 在内存严重不足且无法恢复的情况下 , 可以提示用户重启手机.</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/qkhhyga2016/article/details/79540119" target="_blank" rel="noopener">https://blog.csdn.net/qkhhyga2016/article/details/79540119</a></li><li><a href="https://blog.csdn.net/zsj100213/article/details/82427527" target="_blank" rel="noopener">https://blog.csdn.net/zsj100213/article/details/82427527</a></li></ol><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/84687400" target="_blank" rel="noopener">知乎 - Android 中的卡顿丢帧原因概述 - 低内存篇</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 桌面被杀问题分析案例</title>
      <link href="/2019/09/17/Android-Kill-Background-App-Debug/"/>
      <url>/2019/09/17/Android-Kill-Background-App-Debug/</url>
      
        <content type="html"><![CDATA[<p>写这篇文章的契机是因为一个实际遇到的问题 , 这个问题其实不难 , 不过在分析了这个问题然后写日记的时候 , 我突然觉得这个问题分析的过程有必要记录一下 , 分享给大家 . 分析过程中有用到一些工具 , 一些方法 , 也从另外一个聪明的小伙伴梅明那里学到了一些分析技巧和工具的使用技巧 .</p><p>这篇文章中分析过程包括我之前在<a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 方法论</a> 里面提到的一些工具 , 包括 : 复现视频 \ Event Log \ Android Studio 源码和 App Debug  \ Android Studio Profile \ Systrace \ Dumpsys \ PS 等 . 大多数工具大家都在开发过程中使用过 , 这次分析正是使用了这些工具相互配合 , 最终找到的问题的原因.</p><p>大家看下来可能会觉得 , 这么简单一个问题还需要写一篇文章 ? 我写这篇文章的目的一是为了记录给自己 , 二是觉得分析过程比较有普遍性 , 包括分析思路和工具的使用 , 如果可以帮助到大家 , 那么最好不过了 , 如果你也有好的思路或者独家调试技巧 , 欢迎大家扫描<a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> 里面的讨论群二维码加入群聊 , 共同进步!</p><a id="more"></a><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>这个问题是测试直接报过来的 , Bug 描述是典型的按现象描述 : “<strong>从应用返回桌面 , 桌面图标加载慢</strong>“. 测试这边提供了录制的视频和抓取的 Log , 以及对应的 Systrace 等. 既然现象和 Log 都在 , 那么就开始分析吧.</p><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="确定问题发生的时间点"><a href="#确定问题发生的时间点" class="headerlink" title="确定问题发生的时间点"></a>确定问题发生的时间点</h2><ol><li>由于测试提供的复现视频 , 首先看复现视频 , 确定时间发生的时间</li><li>根据视频里面的大概时间(精确到分) , 查看对应的 EventLog ，跟视频比对，确定发生的确切时间点 (精确到秒)</li><li>查看 EventLog 和 MainLog ， 还原发生时候的用户操作 ，这个例子里面就发现启动和我信这个 App 之后，Launcher 被杀了</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">EventLog</span><br><span class="line"><span class="comment">// 启动 com.jx.cmcc.ict.ibelieve 这个 App</span></span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">48.877</span>  <span class="number">1456</span>  <span class="number">2269</span> I am_set_resumed_activity: [<span class="number">0</span>,com.jx.cmcc.ict.ibelieve/.ui.MainTabActivity,resumeTopActivityInnerLocked]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">48.886</span>  <span class="number">1456</span>  <span class="number">2269</span> I am_resume_activity: [<span class="number">0</span>,<span class="number">80317506</span>,<span class="number">54938</span>,com.jx.cmcc.ict.ibelieve/.ui.MainTabActivity]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">48.891</span>  <span class="number">1456</span>  <span class="number">1485</span> I sysui_count: [window_time_0,<span class="number">0</span>]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">48.891</span>  <span class="number">1456</span>  <span class="number">1485</span> I sysui_multi_action: [<span class="number">757</span>,<span class="number">803</span>,<span class="number">799</span>,window_time_0,<span class="number">802</span>,<span class="number">0</span>]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">48.902</span>  <span class="number">1456</span>  <span class="number">2269</span> I am_uid_stopped: <span class="number">10021</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里桌面被杀</span></span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">48.903</span>  <span class="number">1456</span>  <span class="number">2269</span> I am_kill : [<span class="number">0</span>,<span class="number">13509</span>,com.meizu.flyme.launcher,<span class="number">600</span>,kill background]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里开始从 App 返回桌面</span></span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">51.990</span>  <span class="number">1456</span>  <span class="number">1791</span> I am_pause_activity: [<span class="number">0</span>,<span class="number">80317506</span>,com.jx.cmcc.ict.ibelieve/.ui.MainTabActivity]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">51.994</span>  <span class="number">1456</span>  <span class="number">1791</span> I am_task_to_front: [<span class="number">0</span>,<span class="number">54923</span>]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">51.996</span> <span class="number">13674</span> <span class="number">13674</span> I am_on_paused_called: [<span class="number">0</span>,com.jx.cmcc.ict.ibelieve.ui.MainTabActivity,handlePauseActivity]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">52.013</span>  <span class="number">1456</span>  <span class="number">2270</span> I am_uid_running: <span class="number">10021</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新创建桌面进程</span></span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">52.025</span>  <span class="number">1456</span>  <span class="number">2270</span> I am_proc_start: [<span class="number">0</span>,<span class="number">14013</span>,<span class="number">10021</span>,com.meizu.flyme.launcher,activity,com.meizu.flyme.launcher/.Launcher]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">52.045</span>  <span class="number">1456</span>  <span class="number">2270</span> I am_proc_bound: [<span class="number">0</span>,<span class="number">14013</span>,com.meizu.flyme.launcher]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">52.069</span>  <span class="number">1456</span>  <span class="number">2270</span> I am_uid_active: <span class="number">10021</span></span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">52.069</span>  <span class="number">1456</span>  <span class="number">2270</span> I am_restart_activity: [<span class="number">0</span>,<span class="number">238217861</span>,<span class="number">54923</span>,com.meizu.flyme.launcher/.Launcher]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桌面显示</span></span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">52.071</span>  <span class="number">1456</span>  <span class="number">2270</span> I am_set_resumed_activity: [<span class="number">0</span>,com.meizu.flyme.launcher/.Launcher,minimalResumeActivityLocked]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">52.335</span> <span class="number">14013</span> <span class="number">14013</span> I am_on_resume_called: [<span class="number">0</span>,com.meizu.flyme.launcher.Launcher,LAUNCH_ACTIVITY]</span><br><span class="line"><span class="number">09</span><span class="number">-10</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">52.437</span>  <span class="number">1456</span>  <span class="number">1504</span> I am_activity_launch_time: [<span class="number">0</span>,<span class="number">238217861</span>,com.meizu.flyme.launcher/.Launcher,<span class="number">413</span>,<span class="number">413</span>]</span><br></pre></td></tr></table></figure><p>那么这里就可以简单还原问题了 , 测试报的是<strong>从应用返回桌面 , 桌面图标加载慢</strong> , 从 Event Log 来看 , 桌面显示慢 , 是因为<strong>桌面被杀了</strong> , 所以从 App 返回的时候 , 桌面需要重新加载 , 从桌面进程创建到桌面完全显示 , 花费了 413ms(实际到桌面完全显示,花费了至少 2s 左右,因为 Launcher 冷启动还要重新加载内容).</p><h2 id="分析被杀原因"><a href="#分析被杀原因" class="headerlink" title="分析被杀原因"></a>分析被杀原因</h2><p>从上面的分析来看 , 我们需要找到 Launcher 被杀的原因 , 从现象上来看 , 似乎是和 com.jx.cmcc.ict.ibelieve 这个进程有关系 , 但是我们目前是没有办法确认的 .</p><p>这里我们重点看这个这个 Event Log</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">am_kill : [<span class="number">0</span>,<span class="number">13509</span>,com<span class="selector-class">.meizu</span><span class="selector-class">.flyme</span><span class="selector-class">.launcher</span>,<span class="number">600</span>,kill <span class="attribute">background</span>]</span><br></pre></td></tr></table></figure><p>这里可以看到 Launcher 被杀的原因是 kill background , 查看对应的源码可知，reason =  kill background 是 AMS.killBackgroundProcesses 这里发出的.</p><p>ActivityManagerService.killBackgroundProcesses</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBackgroundProcesses</span><span class="params">(<span class="keyword">final</span> String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                killPackageProcessesLocked(packageName, appId, targetUserId,</span><br><span class="line">                        ProcessList.SERVICE_ADJ, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">"kill background"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对源码比较熟悉的同学可以很快知道 , AMS.killBackgroundProcesses 这个接口会提供给三方应用去调用 , 其 Binder 的客户端在 ActivityManager.killBackgroundProcesses 这里</p><p>ActivityManager.killBackgroundProcesses</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Have </span>the<span class="markdown"> system immediately kill all background processes associated</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>with </span>the<span class="markdown"> given package.  This is </span>the<span class="markdown"> same as </span>the<span class="markdown"> kernel killing those</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>processes to reclaim memory; </span>the<span class="markdown"> system </span>will<span class="markdown"> take care of restarting</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>these processes in </span>the<span class="markdown"> future as needed.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param packageName The name of </span>the<span class="markdown"> package whose processes </span>are<span class="markdown"> to</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>be killed.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="meta">@RequiresPermission</span>(Manifest.permission.KILL_BACKGROUND_PROCESSES)</span><br><span class="line">public <span class="keyword">void</span> killBackgroundProcesses(<span class="built_in">String</span> packageName) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getService().killBackgroundProcesses(packageName,</span><br><span class="line">                mContext.getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对-SystemServer-进程进行断点-Debug"><a href="#对-SystemServer-进程进行断点-Debug" class="headerlink" title="对 SystemServer 进程进行断点 Debug"></a>对 SystemServer 进程进行断点 Debug</h2><p>知道了上面的代码逻辑 , 我们需要做的就是找到在这个场景下 , 是哪个应用调用 ActivityManager.killBackgroundProcesses 杀掉了桌面. 由于不知道具体是哪个应用(这里虽然我们怀疑是 com.jx.cmcc.ict.ibelieve , 但是没有证据) , 我们先对 SystemServer 进程进行 Debug .</p><p>1.首先对源码进行 debug , 首先在 Android 中点击 debug 按钮 , 选择 system_process 这个进程(就是我们所说的 SystemServer) , 然后点击 OK . 代码的断点我们打在上面列出的 ActivityManagerService.killBackgroundProcesses 方法里面.<br><img src="/images//15687205494479.jpg" alt=""><br>2.点击启动怀疑的 App ( 可以从 EventLog 和视频里面倒推，找到比较可疑的 App , 安装后进行本地测试复现 , 这里选择了视频中出现的几个应用,包括我们之前怀疑的 com.jx.cmcc.ict.ibelieve- <strong>和我信</strong> ) , 点击其他的应用都不会进入到这个断点, 而在点击 <strong>和我信</strong> 这个 App 启动后走到的断点<br><img src="/images//15687209172754.jpg" alt=""></p><p>3.这里我们可以看到调用栈是一个 Binder 调用 , 我们需要找到这个 Binder 调用的客户端. 在 AS 里面继续操作 , 点击如下图的计算器按钮 , 输入 getRealCallingPid() 点击下面的 Evaluate , 就可以看到结果. result = 29771<br><img src="/images//15687209855094.jpg" alt=""></p><p>4.通过 PS 命令 , 查看这个 pid 对应的 app<br><img src="/images//15687210593143.jpg" alt=""></p><p>可以看到就是这个应用调用的 killBackgroundProcesses</p><h2 id="对-App-进程进行断点-Debug"><a href="#对-App-进程进行断点-Debug" class="headerlink" title="对 App 进程进行断点 Debug"></a>对 App 进程进行断点 Debug</h2><p>为了进一步调查，我们对这个 app 进行 debug ， 由于没有源码，我们直接把断点打到 android/app/ActivityManager.killBackgroundProcesses 这里(因为这里是客户端代码 , 所以调试 App 进程的时候 , 可以直接打断点 )</p><p><img src="/images//15687211973509.jpg" alt=""></p><p>本地安装这个应用进行调试， 发现登录后，再次启动， 桌面必会被杀 ，确定就是这个 App 的问题<br><img src="/images//15687212469647.jpg" alt=""></p><p>到了这一步我们已经基本上确定问题就是这个 App 引起的了 , 不过如果我们想看比较详细的调用情况 , 可以使用 Android Studio Profile</p><h2 id="使用-Android-Studio-Profiler-工具"><a href="#使用-Android-Studio-Profiler-工具" class="headerlink" title="使用 Android Studio Profiler 工具"></a>使用 Android Studio Profiler 工具</h2><p>打开 Android Studio , 点击 Profiler 按钮 , 点击 + 号 , 选择 com.jx.cmcc.ict.ibelieve 这个进程 , 然后点击 CPU 这一栏<br><img src="/images//15687213642261.jpg" alt=""></p><p>这里选择了 Trace Java Methods , 然后点击旁边的 Record , 就可以开始进行操作 , 操作结束后 , 点击 Stop , AS 会自动开始解析.<br><img src="/images//15687214604910.jpg" alt=""></p><p>解析结果我们可以看这里<br><img src="/images//15687215343839.jpg" alt=""></p><p>最下面就是刚刚操作所对应的详细函数调用栈 , 以真正运行的顺序展示在我们面前(我经常会用这个工具来查看源码逻辑和三方应用的代码逻辑 , 不管是学习还是解决问题 , 都是一个非常好的方法)</p><p>我们使用 ctrl+f 进行搜索 killBackgroundProcesses , 如果有的话 , 会以高亮显示, 我们只需要用鼠标放大就可以看到详细的调用栈<br><img src="/images//15687217316253.jpg" alt=""></p><p>可以看到这个 App 在 loadComplete 回调里面执行了 killBackground 方法.(到了这里，应用开发者就已经知道是哪里的问题了，修复起来飞快)</p><h2 id="权限问题分析"><a href="#权限问题分析" class="headerlink" title="权限问题分析"></a>权限问题分析</h2><p>如上面所示 , 调用 killBackgroundProcesses 是需要Manifest.permission.KILL_BACKGROUND_PROCESSES 这个权限的 .  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">RequiresPermission</span>(<span class="keyword">Manifest</span>.<span class="keyword">permission</span>.<span class="keyword">KILL_BACKGROUND_PROCESSES</span>)</span><br><span class="line"><span class="keyword">public</span> void killBackgroundProcesses(String packageName) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 adb shell dumpsys package com.jx.cmcc.ict.ibelieve 查看 com.jx.cmcc.ict.ibelieve 这个进程所申请的权限 , 发现这个应用在安装的时候就申请了KILL_BACKGROUND_PROCESSES 这个权限 , 且默认是授予的.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">install permissions:</span><br><span class="line">  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">  android.permission.ACCESS_NETWORK_STATE: <span class="attribute">granted</span>=<span class="literal">true</span></span><br><span class="line">  android.permission.KILL_BACKGROUND_PROCESSES: <span class="attribute">granted</span>=<span class="literal">true</span></span><br><span class="line">  android.permission.WRITE_USER_DICTIONARY: <span class="attribute">granted</span>=<span class="literal">true</span></span><br><span class="line">  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p>对应的权限级别为 normal<br><img src="/images//15687220008286.jpg" alt=""><br>也就是说 , 所有的第三方应用都可以默认有这个权限 , 只要你申请 . 这个案例里面 , 就是因为这个 App 申请了这个权限 , 且执行了错误的行为 , 导致把桌面杀掉 , 严重影响用户体验. Sad !</p><h2 id="Systrace-工具可以找出来-Kill-桌面的元凶么"><a href="#Systrace-工具可以找出来-Kill-桌面的元凶么" class="headerlink" title="Systrace 工具可以找出来 Kill 桌面的元凶么?"></a>Systrace 工具可以找出来 Kill 桌面的元凶么?</h2><p>由于经常使用 Systrace , 那么 Systrace 是否可以找到元凶呢? 答案是可以 (这里如果对如何在 Systrace 上查看唤醒信息不了解 , 可以看一下这篇文章<a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">分析 Systrace 预备知识</a>). 我们录制一段 Systrace , 安装下面的顺序去看</p><p>1.首先看 system_server 进程对应的 trace ,找到 killProcessGroup 对应的点 , 查看其唤醒情况 , 可以看到是 19688 这个线程唤醒执行 AMS 的 killProcessGroup<br><img src="/images//15687222368417.jpg" alt=""></p><p>在 Systrace 中搜索 19688 , 可以看到是 Binder:1295_1E , 1295 就是 SystemServer<br><img src="/images//15687224005673.jpg" alt=""></p><p>查看对应的 Binder:1295_1E , 看看是哪个线程唤醒这个线程<br><img src="/images//15687224679939.jpg" alt=""></p><p>搜索 7289这个线程 ， 可以看到这个线程就是和我信这个 App 的主线程。<br><img src="/images//15687225307555.jpg" alt=""></p><p>查看 7289 , 确定就是 com.jx.cmcc.ict.ibelieve 这个进程 . 也就是<strong>和我信</strong>这个 App(瘤子).<br><img src="/images//15687225541312.jpg" alt=""></p><p>这里也可以反推出来这个 Kill 是 <strong>和我信</strong> 这个 App 发起的 ， 进一步确认可以使用上面 AS 的 MethodTrace </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面的分析来看 , 这个问题是由于应用申请了不恰当的权限并错误使用对应的函数导致的一个严重影响用户使用的问题. 一般分析到这一步 , 我们的工作就基本上结束了 , 后续只需要和商店沟通 , 跟 App 开发者联系进行修改即可.</p><p>不过令我感到意外的是 android.permission.KILL_BACKGROUND_PROCESSES 这个权限 Google 居然放的这么松 , 我一直以为这个权限是要专门申请以防止 App 滥用或者卵用的(毕竟涉及到其他 App 的生死存亡).</p><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/82904693" target="_blank" rel="noopener">知乎 - Android 框架问题分析案例 - 谁杀了桌面?</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Systrace </tag>
            
            <tag> Framework </tag>
            
            <tag> MethodTrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的卡顿丢帧原因概述 - 应用篇</title>
      <link href="/2019/09/05/Android-Jank-Due-To-App/"/>
      <url>/2019/09/05/Android-Jank-Due-To-App/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a> 这篇文章中我们列举了系统自身原因导致的手机卡顿问题 , 这一篇文章我们主要列举一些由于 App 自身原因导致的卡顿问题. 各位用户在使用 App 的时候 , 如果遇见卡顿现象 , 先别第一时间骂手机厂商优化烂 , 先想想是不是这个 App 自己的问题.</p><p>Android 手机使用中的卡顿问题 , 一般来说手机厂商和 App 开发商都会非常重视 , 所以不管是手机厂商还是 App 开发者 , 都会对卡顿问题非常重视 , 内部一般也会有专门的基础组或者优化组来进行优化 . 目前市面上有一些非常棒的第三方性能监控工具 , 比如腾讯的 Matrix ; 手机厂商一般也会有自己的性能监控方案 , 由于可以修改源码和避免权限问题 , 所以手机厂商可以拿到更多的数据 , 分析起来也会更方便一些.</p><p>说回流畅度 , 其实就是操作过程中的丢帧 , 本来一秒中画面需要更新 60 帧,但是如果这期间只更新了 55 帧 , 那么在用户看来就是丢帧了 , 主观感觉就是卡了 , 尤其是帧率波动 , 用户的感知会更明显. 引起丢帧的原因非常多, 有硬件层面的 , 有软件层面的 , 也有 App 自身的问题. 所以这一部分我分为四篇文章去讲 , 会简单讲一下哪些原因会用户觉得卡顿丢帧 :</p><p><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">0. Android 中的卡顿丢帧原因概述 - 方法论</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">1. Android 中的卡顿丢帧原因概述 - 系统篇</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">2. Android 中的卡顿丢帧原因概述 - 应用篇</a><br><a href="https://www.androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/" target="_blank" rel="noopener">3. Android 中的卡顿丢帧原因概述 - 低内存篇</a></p><a id="more"></a><h1 id="Android-App-自身导致的性能问题"><a href="#Android-App-自身导致的性能问题" class="headerlink" title="Android App 自身导致的性能问题"></a>Android App 自身导致的性能问题</h1><p>在<a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a> 这篇文章中我们列举了系统自身原因导致的手机卡顿问题 , 这一篇文章我们主要列举一些由于 App 自身原因导致的卡顿问题. 各位用户在使用 App 的时候 , 如果遇见卡顿现象 , 先别第一时间骂手机厂商优化烂 , 先想想是不是这个 App 自己的问题.</p><p>这些实际的案例 , 很多都可以在 Systrace 上看出来 , 所以我的很多贴图都是 Systrace 上实际被发现的问题 , 如果你对 Systrace 不了解 , 可以查看这个 <a href="https://www.androidperformance.com/2019/05/26/Android_Systrace_0/" target="_blank" rel="noopener">Systrace 系列</a> , 这里你只需要知道 , Systrace 从系统全局的角度 , 来展示当前系统的运行状况 , 通常被用来 Debug Android 性能问题 .</p><h2 id="1-App-主线程执行时间长"><a href="#1-App-主线程执行时间长" class="headerlink" title="1.App 主线程执行时间长"></a>1.App 主线程执行时间长</h2><p>主线程执行 Input \ Animation \ Measure \ Layout \ Draw \ decodeBitmap 等操作超时都会导致卡顿 , 下面就是一些真实的案例 </p><h3 id="Measure-Layout-耗时-超时-或者没有调度到"><a href="#Measure-Layout-耗时-超时-或者没有调度到" class="headerlink" title="Measure \ Layout 耗时\超时 (或者没有调度到)"></a>Measure \ Layout 耗时\超时 (或者没有调度到)</h3><p><img src="/images//15683672071047.jpg" alt=""></p><h3 id="Draw-耗时"><a href="#Draw-耗时" class="headerlink" title="Draw 耗时"></a>Draw 耗时</h3><p><img src="/images//15683674644517.jpg" alt=""></p><p><img src="/images//15683674720923.jpg" alt=""></p><h3 id="Animation回调耗时"><a href="#Animation回调耗时" class="headerlink" title="Animation回调耗时"></a>Animation回调耗时</h3><p><img src="/images//15683674907408.jpg" alt=""></p><h3 id="View-初始化耗时-PlayStore"><a href="#View-初始化耗时-PlayStore" class="headerlink" title="View 初始化耗时 (PlayStore)"></a>View 初始化耗时 (PlayStore)</h3><p><img src="/images//15683675067851.jpg" alt=""></p><h3 id="List-Item-初始化耗时（WeChat）"><a href="#List-Item-初始化耗时（WeChat）" class="headerlink" title="List Item 初始化耗时（WeChat）"></a>List Item 初始化耗时（WeChat）</h3><p><img src="/images//15683675156787.jpg" alt=""></p><h3 id="decodeBitmap-耗时-或者没有调度到"><a href="#decodeBitmap-耗时-或者没有调度到" class="headerlink" title="decodeBitmap 耗时 (或者没有调度到)"></a>decodeBitmap 耗时 (或者没有调度到)</h3><p><img src="/images//15683675235793.jpg" alt=""></p><h2 id="2-uploadBitmap-耗时"><a href="#2-uploadBitmap-耗时" class="headerlink" title="2.uploadBitmap 耗时"></a>2.uploadBitmap 耗时</h2><p>这里的 uploadBitmap 主要是 upload bitmap to gpu 的操作 , 如果 bitmap 过大 , 或者每一帧内容都在变化 , 那么就需要频繁 upload , 导致渲染线程耗时.</p><h2 id="3-BuildDrawingCache-耗时"><a href="#3-BuildDrawingCache-耗时" class="headerlink" title="3.BuildDrawingCache 耗时"></a>3.BuildDrawingCache 耗时</h2><p>应用本身频繁调用 buildDrawingCache 会导致主线程执行耗时从而导致卡顿 , 从下图来看, 主线程每一帧明显超过了 Vsync 周期<br><img src="/images//15683676076418.jpg" alt=""></p><p>微信对话框有多个动态表情的时候, 也会出现这种情况导致的卡顿<br><img src="/images//15683676141497.jpg" alt=""></p><h2 id="4-使用-CPU-渲染而不是-GPU-渲染"><a href="#4-使用-CPU-渲染而不是-GPU-渲染" class="headerlink" title="4.使用 CPU 渲染而不是 GPU 渲染"></a>4.使用 CPU 渲染而不是 GPU 渲染</h2><p>如果应用在 Activity 中设置了软件渲染, 那么就不会走 hwui , 直接走 skia, 纯 cpu 进程渲染, 由于这么做会加重 UI Thread 的负载, 所以大部分情况下这种写法都会导致卡顿 , 详细技术分析可以看这篇文章 <a href="https://www.androidperformance.com/2019/07/27/Android-Hardware-Layer/" target="_blank" rel="noopener">Android 中的 Hardware Layer 详解</a><br><img src="/images//15683676219380.jpg" alt=""></p><h2 id="5-主线程-Binder-耗时"><a href="#5-主线程-Binder-耗时" class="headerlink" title="5.主线程 Binder 耗时"></a>5.主线程 Binder 耗时</h2><p>Activity resume 的时候, 与 AMS 通信要持有 AMS 锁, 这时候如果碰到后台比较繁忙的时候, 等锁操作就会比较耗时, 导致部分场景因为这个卡顿, 比如多任务手势操作<br><img src="/images//15683676787549.jpg" alt=""></p><h2 id="6-游戏-SurfaceView-内容绘制不均匀"><a href="#6-游戏-SurfaceView-内容绘制不均匀" class="headerlink" title="6.游戏 SurfaceView 内容绘制不均匀"></a>6.游戏 SurfaceView 内容绘制不均匀</h2><p>这一项指的是游戏自身的绘制问题, 会导致总是不能满帧去跑, 如下图, 红框部分是SurfaceFlinger 显示掉帧, 原因是底下的游戏在绘制的时候, 刚好这一帧超过了 Vsync SF 的信号.这种一般是游戏自身的问题.<br><img src="/images//15683676909566.jpg" alt=""></p><h2 id="7-WebView-性能不足"><a href="#7-WebView-性能不足" class="headerlink" title="7.WebView 性能不足"></a>7.WebView 性能不足</h2><p>应用里面涉及到 WebView 的时候, 如果页面比较复杂, WebView 的性能就会比较差, 从而造成卡顿<br><img src="/images//15683677032582.jpg" alt=""></p><h2 id="8-帧率与刷新率不匹配"><a href="#8-帧率与刷新率不匹配" class="headerlink" title="8.帧率与刷新率不匹配"></a>8.帧率与刷新率不匹配</h2><p>如果屏幕帧率和系统的 fps 不相符 , 那么有可能会导致画面不是那么顺畅. 比如使用 90 Hz 的屏幕搭配 60 fps 的动画</p><p><img src="/images//15683677178211.jpg" alt=""></p><h2 id="9-应用性能跟不上高帧率屏幕和系统"><a href="#9-应用性能跟不上高帧率屏幕和系统" class="headerlink" title="9.应用性能跟不上高帧率屏幕和系统"></a>9.应用性能跟不上高帧率屏幕和系统</h2><p>部分应用由于设计比较复杂, 每一帧绘制的耗时都比较长 , 这么做的话在 60 fps 的机器上可能没有问题 , 但是在 90 fps 的机器上就会很卡, 因为从 60 -&gt; 90 , 每帧留给应用的绘制时间从 16.6 ms 变成了 11.1 ms , 如果没有在 11.1 ms 内完成, 就会出现掉帧的情况.</p><p>如下图, 这个 App 的性能比较差, 每一帧耗时都很长<br><img src="/images//15683677971989.jpg" alt=""></p><h2 id="10-主线程-IO-操作"><a href="#10-主线程-IO-操作" class="headerlink" title="10.主线程 IO 操作"></a>10.主线程 IO 操作</h2><p>主线程操作数据库<br>使用 SharedPerforence 的 Commit 而不是 Apply</p><h2 id="11-WebView-与主线程交互"><a href="#11-WebView-与主线程交互" class="headerlink" title="11.WebView 与主线程交互"></a>11.WebView 与主线程交互</h2><p>与 WebView 进行交互的时候, 如果 WebView 出现问题, 那么也会出现卡顿<br><img src="/images//15683678262079.jpg" alt=""></p><p><img src="/images//15683678319540.jpg" alt=""></p><p>微信文章页卡顿<br><img src="/images//15683678397112.jpg" alt=""><br><img src="/images//15683678453850.jpg" alt=""></p><h2 id="12-RenderThread-耗时"><a href="#12-RenderThread-耗时" class="headerlink" title="12.RenderThread 耗时"></a>12.RenderThread 耗时</h2><p>RenderThread 自身比较耗时, 导致一帧的时长超过 Vsync 间隔.<br><img src="/images//15683678598642.jpg" alt=""></p><p>渲染线程耗时过长阻塞了主线程的下一次 sync<br><img src="/images//15683678667847.jpg" alt=""></p><p><img src="/images//15683678744405.jpg" alt=""></p><h2 id="13-多个-RenderThread-同步导致主线程卡顿"><a href="#13-多个-RenderThread-同步导致主线程卡顿" class="headerlink" title="13.多个 RenderThread 同步导致主线程卡顿"></a>13.多个 RenderThread 同步导致主线程卡顿</h2><p>有的 App 会产生多个 RenderThread ，在某些场景下 RenderThread 在 sync 的时候花费比较多的时间，导致主线程卡顿</p><p><img src="/images//15683678855008.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps -AT | grep <span class="number">10300</span> | grep RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">16228</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> SyS_epoll_wait      <span class="number">0</span> S RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">17394</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> futex_wait_queue_me <span class="number">0</span> S RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">17395</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> futex_wait_queue_me <span class="number">0</span> S RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">17396</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> futex_wait_queue_me <span class="number">0</span> S RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">17397</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> futex_wait_queue_me <span class="number">0</span> S RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">17399</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> futex_wait_queue_me <span class="number">0</span> S RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">17400</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> futex_wait_queue_me <span class="number">0</span> S RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">17401</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> futex_wait_queue_me <span class="number">0</span> S RenderThread</span><br><span class="line">u0_a170      <span class="number">10300</span> <span class="number">17402</span>  <span class="number">6709</span> <span class="number">2693260</span> <span class="number">305172</span> futex_wait_queue_me <span class="number">0</span> S RenderThread</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android 原生系统是一个不断进化的过程 , 目前已经进化到了 Android Q , 每个版本都会解决非常多的性能问题 , 同时也会引进一些问题 ; 到了手机厂商这里 , 由于硬件差异和软件定制 , 会在系统中加入大量的自己的代码 , 这无疑也会影响系统的性能 . 同样由于 Android 的开放 , App 的质量和行为也影响着整机的用户体验.</p><p>本篇主要列出了 App 自身的实现问题导致的流畅性问题 , Android App 最大的问题就是质量良莠不齐 , 不同于 App Store 这样的强力管理市场 , Android App 不仅可以在 Google Play 上面进行安装 , 也可以在其他的软件市场上面安装 , 甚至可以下载安装包自行安装 , 可以说上架的门槛非常低 , 那么质量就只能由 App 开发者自己来把握了.</p><p>许多大厂的 App 质量自然不必多说 , 他们对性能和用户体验都是非常关注的 , 但也会有需求和功能过多导致的性能问题 , 比如微信就非常占内存 ; 新版本的 QQ 要比之前版本的使用起来流畅性差好多 . 中小厂的 App 就更不用说了. 再加上 Android 平台的开放性 , 需要 App 玩起来黑科技 , 什么保活 \ 相互唤醒 \ 热更新 \ 跑后台任务等 . 站在 App 开发者的角度来说这无可厚非 , 但是系统开发者则希望系统能在用户使用的时候 , 前后台 App 都能有正常的行为 , 来保证前台 App 的用户体验 . 也希望 App 开发者能重视自己 App 的性能体验 , 给用户一个好印象.</p><p>系统这边发现 App 自身的性能问题 , 且在其他厂商的手机上也是一样的表现的时候 , 通常会与 App 开发者进行联系 , 沟通一起解决 . </p><p>大家可以看看这个问题 : <a href="https://www.zhihu.com/question/335226118/answer/751587534" target="_blank" rel="noopener">当手机厂商说安卓手机性能优化的时候，他们到底在做什么</a></p><p>这也是流畅性的一个系列文章中的一篇 , 可以点击下面的链接查看本系列的其他文章.</p><p><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">0. Android 中的卡顿丢帧原因概述 - 方法论</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">1. Android 中的卡顿丢帧原因概述 - 系统篇</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">2. Android 中的卡顿丢帧原因概述 - 应用篇</a></p><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/82520887" target="_blank" rel="noopener">知乎 - Android 中的卡顿丢帧原因概述 - 应用篇</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的卡顿丢帧原因概述 - 系统篇</title>
      <link href="/2019/09/05/Android-Jank-Due-To-System/"/>
      <url>/2019/09/05/Android-Jank-Due-To-System/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 应用篇</a>这篇文章中我们列举了应用自身原因导致的手机卡顿问题 , 这一篇文章我们主要列举一些由 Android 平台自身原因导致的卡顿问题. 各大国内 Android 厂商的产品由于硬件性能有高有低 , 功能实现各有差异 , 团队技术能力各有千秋 , 所以其系统的质量也有高有低 , 这里我们就来列举一下 , 由于系统的硬件和软件原因导致的性能问题.</p><p>Android 手机使用中的卡顿问题 , 一般来说手机厂商和 App 开发商都会非常重视 , 所以不管是手机厂商还是 App 开发者 , 都会对卡顿问题非常重视 , 内部一般也会有专门的基础组或者优化组来进行优化 . 目前市面上有一些非常棒的第三方性能监控工具 , 比如腾讯的 Matrix ; 手机厂商一般也会有自己的性能监控方案 , 由于可以修改源码和避免权限问题 , 所以手机厂商可以拿到更多的数据 , 分析起来也会更方便一些.</p><p>说回流畅度 , 其实就是操作过程中的丢帧 , 本来一秒中画面需要更新 60 帧,但是如果这期间只更新了 55 帧 , 那么在用户看来就是丢帧了 , 主观感觉就是卡了 , 尤其是帧率波动 , 用户的感知会更明显. 引起丢帧的原因非常多, 有硬件层面的 , 有软件层面的 , 也有 App 自身的问题. 所以这一部分我分为四篇文章去讲 , 会简单讲一下哪些原因会用户觉得卡顿丢帧 :</p><p><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">0. Android 中的卡顿丢帧原因概述 - 方法论</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">1. Android 中的卡顿丢帧原因概述 - 系统篇</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">2. Android 中的卡顿丢帧原因概述 - 应用篇</a><br><a href="https://www.androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/" target="_blank" rel="noopener">3. Android 中的卡顿丢帧原因概述 - 低内存篇</a></p><a id="more"></a><h1 id="Android-平台性能导致的性能案例"><a href="#Android-平台性能导致的性能案例" class="headerlink" title="Android 平台性能导致的性能案例"></a>Android 平台性能导致的性能案例</h1><p>下面我会列出来一些实际的卡顿案例 , 这些导致卡顿的原因都是由于 Android 系统平台的一些问题导致的 , 有些问题在开发阶段就会暴露出来 , 这一类通常会在发给用户之前就解决掉 ; 有些问题是用户在长时间使用之后才会暴露出来 , 这一类问题最多 , 但是也比较难以解决 ; 还有一些问题 , 只有非常特殊的场景或者特殊的硬件才会暴露出来 .</p><p>这些实际的案例 , 很多都可以在 Systrace 上看出来 , 所以我的很多贴图都是 Systrace 上实际被发现的问题 , 如果你对 Systrace 不了解 , 可以查看这个 <a href="https://www.androidperformance.com/2019/05/26/Android_Systrace_0/" target="_blank" rel="noopener">Systrace 系列</a> , 这里你只需要知道 , Systrace 从系统全局的角度 , 来展示当前系统的运行状况 , 通常被用来 Debug Android 性能问题 .</p><h2 id="1-SurfaceFlinger-主线程耗时"><a href="#1-SurfaceFlinger-主线程耗时" class="headerlink" title="1.SurfaceFlinger 主线程耗时"></a>1.SurfaceFlinger 主线程耗时</h2><p>SurfaceFlinger 负责 Surface 的合成 , 一旦 SurfaceFlinger 主线程调用超时 , 就会产生掉帧 .</p><p>SurfaceFlinger 主线程耗时会也会导致 hwc service 和 crtc 不能及时完成, 也会阻塞应用的 binder 调用, 如 dequeueBuffer \ queueBuffer 等.</p><p>下图中的 SurfaceFlinger 主线程在后半部分明显超时:<br><img src="/images//15683627237452.jpg" alt=""></p><p><img src="/images//15683628900498.jpg" alt=""></p><p>SurfaceFlinger 主线程处理不及时导致应用卡顿(第一帧卡顿,后续都为黄帧)<br><img src="/images//15683629041129.jpg" alt=""></p><p><img src="/images//15683629162707.jpg" alt=""></p><h2 id="2-屏下光感截图导致-SurfaceFlinger-渲染不及时"><a href="#2-屏下光感截图导致-SurfaceFlinger-渲染不及时" class="headerlink" title="2.屏下光感截图导致 SurfaceFlinger 渲染不及时"></a>2.屏下光感截图导致 SurfaceFlinger 渲染不及时</h2><p>有的 Android 机型使用了屏下光感 , 屏下光感的实现方法也会影响 SurfaceFlinger 主线程的运行 . 屏下指纹需要频繁截图 , 来区分光线和屏幕的变化 , 进行对应的亮度变化, 但是其主线程截图的方法会导致 SurfaceFlinger 主线程被截图操作所耽误, 从而导致卡顿<br><img src="/images//15683630179644.jpg" alt=""></p><h2 id="3-WHC-Service-执行耗时"><a href="#3-WHC-Service-执行耗时" class="headerlink" title="3.WHC Service 执行耗时"></a>3.WHC Service 执行耗时</h2><p>hwc Service 耗时也会导致 SurfaceFlinger 下一帧不会做合成操作, 导致应用的 dequeueBuffer 和 setTransationState 方法被阻塞, 导致卡顿.<br>如下图, 可以看到 SurfaceFlinger 的掉帧情况, Binder 的阻塞情况 和 CRTC 的耗时情况<br><img src="/images//15683630365546.jpg" alt=""></p><p>hwc 耗时<br><img src="/images//15683630455701.jpg" alt=""></p><p>crtc 等待 hwc<br><img src="/images//15683630524199.jpg" alt=""></p><p><img src="/images//15683630594588.jpg" alt=""></p><h2 id="4-CRTC-执行耗时"><a href="#4-CRTC-执行耗时" class="headerlink" title="4.CRTC 执行耗时"></a>4.CRTC 执行耗时</h2><p>crtc 执行耗时的结果就是 SurfaceFlinger 下一帧不会做合成操作, 导致应用的 dequeueBuffer 和 setTransationState 方法被阻塞, 导致卡顿.<br>如下图, 可以看到 SurfaceFlinger 的掉帧情况, Binder 的阻塞情况 和 CRTC 的耗时情况<br><img src="/images//15683630801893.jpg" alt=""></p><h2 id="5-CPU-调度问题"><a href="#5-CPU-调度问题" class="headerlink" title="5.CPU 调度问题"></a>5.CPU 调度问题</h2><h3 id="重要任务跑小核性能不足导致卡顿"><a href="#重要任务跑小核性能不足导致卡顿" class="headerlink" title="重要任务跑小核性能不足导致卡顿"></a>重要任务跑小核性能不足导致卡顿</h3><p>如下图 , RenderThread 跑到了小核, 导致这一帧执行时间过长,造成卡顿图片:<br><img src="/images//15683631259781.jpg" alt=""></p><p>如下图 , cpu 频率对性能的影响图片:<br><img src="/images//15683631426131.jpg" alt=""></p><h3 id="优先级低未能及时获取-cpu-时间片导致卡顿"><a href="#优先级低未能及时获取-cpu-时间片导致卡顿" class="headerlink" title="优先级低未能及时获取 cpu 时间片导致卡顿"></a>优先级低未能及时获取 cpu 时间片导致卡顿</h3><p>在调度器看来的低优先级任务 , 在用户这里未必是低优先级任务 , 他可能正在和 App 的主线程交互 , 或者正在和 system_server 进行交互 </p><h3 id="被-RT-进程抢占"><a href="#被-RT-进程抢占" class="headerlink" title="被 RT 进程抢占"></a>被 RT 进程抢占</h3><p>App 主线程或者渲染线程被 RT 进程抢占也会导致系统卡顿或者响应慢 , Google 也意识到了这个问题 , 也在尝试在应用启动的时候 , 把 App 主线程和渲染线程的优先级也设置为 RT , 不过这个属性一直没开 , 因为会导致应用启动速度变慢.</p><h3 id="大小核调度导致"><a href="#大小核调度导致" class="headerlink" title="大小核调度导致"></a>大小核调度导致</h3><p>大小核调度的问题通常表现在该跑在大核的任务跑到了小核 , 或者该在小核运行的任务却持续跑到大核 ,或者错误的被绑定在了某一个核心上 .</p><p>如下图, 这是一个 CTS 问题, CTS 主线程由于被绑定到了 cpu7 , 由于 cpu7 在执行 RenderThread , 所以主线程没有调度到, 导致 CTS 失败<br><img src="/images//15683634973760.jpg" alt=""></p><h2 id="6-触发-Thermal-导致限频"><a href="#6-触发-Thermal-导致限频" class="headerlink" title="6.触发 Thermal 导致限频"></a>6.触发 Thermal 导致限频</h2><p>触发 Thermal 发热限频也有可能导致卡顿 , 这算是一种硬件级别的保护 , 如果手机已经过热 , 此时如果不进行干涉 , 那么可能会导致用户手机太烫而无法持续使用手机. 一般这个时候都会对系统的资源进行一些限制 , 比如降低 cpu\gpu 的最高频率之类的 , 这么做的话 , 势必也会对流畅性造成影响.</p><p>如果你手机非常热 , 而且变卡了 , 那么放下手机休息一会 , 查杀一下后台 , 或者重启一下手机 .</p><h2 id="7-后台活动进程太多导致系统繁忙"><a href="#7-后台活动进程太多导致系统繁忙" class="headerlink" title="7.后台活动进程太多导致系统繁忙"></a>7.后台活动进程太多导致系统繁忙</h2><p>后台进程活动太多,会导致系统非常繁忙, cpu \ io \ memory 等资源都会被占用, 这时候很容易出现卡顿问题 , 这也是系统这边经常会碰到的问题 </p><h3 id="CPU-繁忙"><a href="#CPU-繁忙" class="headerlink" title="CPU 繁忙"></a>CPU 繁忙</h3><p>dumpsys cpuinfo 可以查看一段时间内 cpu 的使用情况<br><img src="/images//15683636957732.jpg" alt=""></p><h3 id="主线程调度不到-处于-Runnable-状态"><a href="#主线程调度不到-处于-Runnable-状态" class="headerlink" title="主线程调度不到 , 处于 Runnable 状态"></a>主线程调度不到 , 处于 Runnable 状态</h3><p>当线程为 Runnable 状态的时候 , 调度器如果迟迟不能对齐进行调度 , 那么就会产生长时间的 Runnable 线程状态 , 导致错过 Vsync 而产生流畅性问题.</p><p><img src="/images//15683637577609.jpg" alt=""></p><h3 id="无关进程活跃耗时"><a href="#无关进程活跃耗时" class="headerlink" title="无关进程活跃耗时"></a>无关进程活跃耗时</h3><p>无关进程通常是人为定义的 , 指的是与当前前台 App 运行无关的进程 , 这些活跃进程势必会对 App 主线程的调度产生影响 , 不管这些无关进程是系统的还是 App 自身的 , 或者是其他三方 App 的.<br><img src="/images//15683638623825.jpg" alt=""></p><h3 id="cpu-被占用"><a href="#cpu-被占用" class="headerlink" title="cpu 被占用"></a>cpu 被占用</h3><p>原因同上 , 当后台任务过多的时候 , cpu 资源就会异常紧缺 , 如下图就是在系统低内存的时候 , HeapTask 和 kswapD 几乎占满了整个 cpu , 在疯狂地向系统申请内存 .</p><p><img src="/images//15683639544904.jpg" alt=""></p><h3 id="System-锁"><a href="#System-锁" class="headerlink" title="System 锁"></a>System 锁</h3><p>system_server 的 AMS 锁和 WMS 锁 , 在系统异常的情况下 , 会变得非常严重 , 如下图所示 , 许多系统的关键任务都被阻塞 , 等待锁的释放 , 这时候如果有 App 发来的 Binder 请求带锁 , 那么也会进入等待状态 , 这时候 App 就会产生性能问题 ; 如果此时做 Window 动画 , 那么 system_server  的这些锁也会导致窗口动画卡顿</p><p><img src="/images//15683640875442.jpg" alt=""></p><h2 id="8-Layer过多导致-SurfaceFlinger-Layer-Compute-耗时"><a href="#8-Layer过多导致-SurfaceFlinger-Layer-Compute-耗时" class="headerlink" title="8.Layer过多导致 SurfaceFlinger Layer Compute 耗时"></a>8.Layer过多导致 SurfaceFlinger Layer Compute 耗时</h2><p>Android P 修改了 Layer 的计算方法 , 把这部分放到了 SurfaceFlinger 主线程去执行, 如果后台 Layer 过多, 就会导致 SurfaceFlinger 在执行 rebuildLayerStacks 的时候耗时 , 导致 SurfaceFlinger 主线程执行时间过长.<br><img src="/images//15683642678680.jpg" alt=""></p><p>所以在使用 Android 系统的时候 , 记得多用多任务清理后台任务.</p><h2 id="9-Input-报点不均匀"><a href="#9-Input-报点不均匀" class="headerlink" title="9.Input 报点不均匀"></a>9.Input 报点不均匀</h2><p>如果出现 Input 报点不均匀或者没有报点的情况, 那么主线程由于没有收到 Input 事件, 所以不去做绘制, 也会导致卡顿<br>如下图 , 这是一个连续滑动的 Systrace 图 , 最下面两行是 InputReader 和  InputDispatcher , 可以看到在滑动的过程中, InputReader 和 InputDispatcher 没有读出来 Input 事件, 导致卡顿<br><img src="/images//15683643028408.jpg" alt=""></p><h2 id="10-LMK-频繁工作抢占-cpu"><a href="#10-LMK-频繁工作抢占-cpu" class="headerlink" title="10.LMK 频繁工作抢占 cpu"></a>10.LMK 频繁工作抢占 cpu</h2><p>LMK 工作时, 会占用 cpu 资源 , 其表现主要有下面几点</p><ol><li>CPU 资源 : 由于 LMK 杀掉的进程通常都是一些 Cache 或者 Service , 这些进程由于低内存被杀之后 , 通常会很快就被其主进程拉起来, 然后又被 LMK 杀掉, 从而进入了一种循环. 由于起进程是一件很消耗 cpu 的操作, 所以如果后台一直有进程被杀和重启, 那么前台的进程很容易出现卡顿</li><li>Memory : 由于低内存的原因, 很容易触发各个进程的 GC , 如下图的 CPU 状态可以看到, 用于内存回收的 HeapTaskDeamon 出现非常频繁</li><li>IO  : 低内存会导致磁盘 IO 变多, 如果频繁进行磁盘 IO , 由于磁盘IO 很慢, 那么主线程会有很多进程处于等 IO 的状态, 也就是我们经常看到的 Uninterruptible Sleep</li></ol><p><img src="/images//15683643604442.jpg" alt=""></p><p><img src="/images//15683643666942.jpg" alt=""></p><h2 id="11-低内存导致-IO-耗时"><a href="#11-低内存导致-IO-耗时" class="headerlink" title="11.低内存导致 IO 耗时"></a>11.低内存导致 IO 耗时</h2><p>低内存情况下, 很容易出现主线程 IO 从而导致应用卡顿<br><img src="/images//15683643799246.jpg" alt=""></p><h3 id="主线程-IO-导致卡顿"><a href="#主线程-IO-导致卡顿" class="headerlink" title="主线程 IO 导致卡顿"></a>主线程 IO 导致卡顿</h3><p><img src="/images//15683643881605.jpg" alt=""></p><h3 id="主线程-IO-导致应用启动速度慢"><a href="#主线程-IO-导致应用启动速度慢" class="headerlink" title="主线程 IO 导致应用启动速度慢"></a>主线程 IO 导致应用启动速度慢</h3><p><img src="/images//15683643961578.jpg" alt=""></p><p><img src="/images//15683644028471.jpg" alt=""></p><h3 id="滑动列表时候-IO-导致卡顿"><a href="#滑动列表时候-IO-导致卡顿" class="headerlink" title="滑动列表时候 IO 导致卡顿"></a>滑动列表时候 IO 导致卡顿</h3><p><img src="/images//15683644093621.jpg" alt=""></p><h2 id="12-GPU-合成导致-SurfaceFlinger-耗时"><a href="#12-GPU-合成导致-SurfaceFlinger-耗时" class="headerlink" title="12.GPU 合成导致 SurfaceFlinger 耗时"></a>12.GPU 合成导致 SurfaceFlinger 耗时</h2><p>当 SurfaceFlinger 有 GPU 合成时, 其主线程的执行时间就会变长, 也会导致合成不及时而卡顿<br><img src="/images//15683644397329.jpg" alt=""></p><p><img src="/images//15683644447973.jpg" alt=""></p><h2 id="13-KSWAPD-跑大核"><a href="#13-KSWAPD-跑大核" class="headerlink" title="13.KSWAPD 跑大核"></a>13.KSWAPD 跑大核</h2><p>低内存时, kswapd 由于负载比较高 , 其 cpu 占用比较高, 且经常会跑到大核上 , 导致机器发热限频, 或者抢占主线程的 cpu 时间片<br><img src="/images//15683644582339.jpg" alt=""></p><h2 id="14-SurfaceFlinger-Vsync-不均匀"><a href="#14-SurfaceFlinger-Vsync-不均匀" class="headerlink" title="14.SurfaceFlinger Vsync 不均匀"></a>14.SurfaceFlinger Vsync 不均匀</h2><p>SurfaceFlinger 有时候会出现 Vsync 不均匀的情况, 不均匀指的是 Vsync 间隔会持续地变化, 一会大一会小, 就会导致用户看到的画面不均匀, 有卡顿感<br>如下图 , 可以明显看到 SurfaceFlinger 的 VSYNC-sf 这一行间隔是不一样的. 这种问题一般是由于 SurfaceFlinger 这边的修改或者 HWC 的修改导致的 .<br><img src="/images//15683644891039.jpg" alt=""></p><h2 id="15-三方应用使用-Accessibility-服务导致系统卡顿"><a href="#15-三方应用使用-Accessibility-服务导致系统卡顿" class="headerlink" title="15.三方应用使用 Accessibility 服务导致系统卡顿"></a>15.三方应用使用 Accessibility 服务导致系统卡顿</h2><p>三方应用如果使用 Accessibility 服务监听了 Input 事件的话, InputDispatcher 的行为就会与预期的出现偏差, 导致 InputDispatcher 没有及时把事件传给主线程导致卡顿</p><p><img src="/images//15683644982138.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android 原生系统是一个不断进化的过程 , 目前已经进化到了 Android Q , 每个版本都会解决非常多的性能问题 , 同时也会引进一些问题 ; 到了手机厂商这里 , 由于硬件差异和软件定制 , 会在系统中加入大量的自己的代码 , 这无疑也会影响系统的性能 . </p><p>上面列出的这些影响流畅性的案例 , 只是 Android 系统开发中遇到的性能问题的冰山一角 , 任何一个问题都会对用户的使用产生影响 , 这也是为什么手机厂商越来越重视系统优化 . 手机厂商非常重视开发过程中和用户使用过程中遇到的性能问题 , 并开发和提出各项优化措施 , 从硬件到软件 , 从用户行为优化到系统策略动态学习 . 这也是为什么现在的手机厂商的系统越做越好 , 质量越来越高的一个原因 , 那些不重视质量只重视设计和产品的手机厂商 , 都渐渐地被消费者淘汰了.</p><p>大家可以看看这个问题 : <a href="https://www.zhihu.com/question/335226118/answer/751587534" target="_blank" rel="noopener">当手机厂商说安卓手机性能优化的时候，他们到底在做什么</a></p><p>这也是流畅性的一个系列文章中的一篇 , 可以点击下面的链接查看本系列的其他文章.</p><p><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">0. Android 中的卡顿丢帧原因概述 - 方法论</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">1. Android 中的卡顿丢帧原因概述 - 系统篇</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">2. Android 中的卡顿丢帧原因概述 - 应用篇</a><br><a href="https://www.androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/" target="_blank" rel="noopener">3. Android 中的卡顿丢帧原因概述 - 低内存篇</a></p><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/82521327" target="_blank" rel="noopener">知乎 - Android 中的卡顿丢帧原因概述 - 系统篇</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的卡顿丢帧原因概述 - 方法论</title>
      <link href="/2019/09/05/Android-Jank-Debug/"/>
      <url>/2019/09/05/Android-Jank-Debug/</url>
      
        <content type="html"><![CDATA[<p>Android 手机使用中的卡顿问题 , 一般来说手机厂商和 App 开发商都会非常重视 , 所以不管是手机厂商还是 App 开发者 , 都会对卡顿问题非常重视 , 内部一般也会有专门的基础组或者优化组来进行优化 . </p><p>目前市面上有一些非常棒的第三方性能监控工具 , 比如腾讯的 Matrix ; 手机厂商一般也会有自己的性能监控方案 , 由于可以修改源码和避免权限问题 , 所以手机厂商可以拿到更多的数据 , 分析起来也会更方便一些.</p><p>说回流畅度 , 其实就是操作过程中的丢帧 , 本来一秒中画面需要更新 60 帧,但是如果这期间只更新了 55 帧 , 那么在用户看来就是丢帧了 , 主观感觉就是卡了 , 尤其是帧率波动 , 用户的感知会更明显. 引起丢帧的原因非常多, 有硬件层面的 , 有软件层面的 , 也有 App 自身的问题. 所以这一部分我分为四篇文章去讲 , 会简单讲一下哪些原因会用户觉得卡顿丢帧 :</p><p><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">0. Android 中的卡顿丢帧原因概述 - 方法论</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">1. Android 中的卡顿丢帧原因概述 - 系统篇</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">2. Android 中的卡顿丢帧原因概述 - 应用篇</a><br><a href="https://www.androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/" target="_blank" rel="noopener">3. Android 中的卡顿丢帧原因概述 - 低内存篇</a></p><a id="more"></a><h1 id="1-流畅度相关工作内容概述"><a href="#1-流畅度相关工作内容概述" class="headerlink" title="1. 流畅度相关工作内容概述"></a>1. 流畅度相关工作内容概述</h1><p>作为手机厂商优化组的一员 , 我有必要在开始之前简单描述一下我们工作的流程 . 系统开发的过程中, 有很多引起 Android 卡顿的原因,但是用户和测试感受最直观的是正在使用的应用掉帧和不流畅 . 由于测试和用户没有办法直接确定卡顿的原因, 所以一般会直接将 Bug 提到我们这边, 所以我们的角色更像是一个卡顿问题接口人, 负责分析引起卡顿的原因, 再把 Bug 分配给对应的模块负责人去解决 , 如框架 \ App \ 多媒体 \ Display \ BSP 等.</p><p>所以直接由我们来解决的问题并不是很多, 我们更多的时候是通过专门的分析工具 , 结合<strong>源码</strong>来定位和分析问题 , 最多使用的工具如下:</p><ol><li>Systrace\strace\ftrace : 从整个系统的层面来看问题的大致原因</li><li>MethodTrace : 可以从进程的角度 , 以详细调用栈的形式来显示</li><li>Android Studio 的 Profile 工具</li><li>MAT : 用来分析内存问题</li><li>Log : LogReport 抓取或者录制的 Log , 里面包含大量的信息 , 包括各种常规 Log (Main Log , System Log , Event Log , Kernel Log , Crash Log 等) , 也包含了厂商自己加的一些 Log ( Power Log , Performance Log 等) , 也包含事故发生时候的截图 \ 录制的视频等</li><li>复现视频</li><li>本地复现等</li></ol><p>确定卡顿的根本原因 , 这需要对 Android App 开发 \ Android Framework 知识 \ Display 知识 \ Linux Kernel 知识有一定的了解 , 知道基本的工作流程 , 并能熟练使用对应的工具 , 区分不同的场景 , 迅速找到问题的原因 , 然后和相关模块的负责人一起讨论优化.</p><p>对于一些系统全局性的方案则需要与对应的模块负责人一起分析和解决, 必要的时候我们也会开发一些 Feature 来解决问题 .</p><h1 id="2-性能问题分析的一些工具和套路"><a href="#2-性能问题分析的一些工具和套路" class="headerlink" title="2. 性能问题分析的一些工具和套路"></a>2. 性能问题分析的一些工具和套路</h1><p>应用卡顿问题的原因比较多, 在数据埋点还没有完善的情况下, 更多的依赖 Systrace 来从全局的角度来分析卡顿的具体原因:</p><ol><li>Systrace 分析<ol><li>首先确认卡顿的 App</li><li>通过 App 的主线程和 SurfaceFlinger 的主线程信息可以确定卡顿的现场</li><li>分析 Systrace , Systrace 的分析需要一定的知识储备 : 需要知道 Systrace 每一个模块展示的内容是如何与用户感受到的内容相对应的 ; 需要知道 Systrace 上各个模块的交互式如何展示的 ; 需要知道 Binder 调用信息 ; 需要会看 Kernel 信息 (后续会继续完善 <a href="https://www.androidperformance.com/2019/05/26/Android_Systrace_0/" target="_blank" rel="noopener">Systrace 系列</a>)<ol><li>如果是 App 主线程耗时, 则分析 App 主线程的原因 ( 案例里有 App 的卡顿原因 )</li><li>如果是 System 的问题, 则需要分析 System_Server \ SurfaceFlinger \ HWC \ CRTC \ CPU 等 ( 详细参考下面系统卡顿原因)</li></ol></li></ol></li><li>TraceView + 源码分析<ol><li>使用 Systrace 确定原因后, 可以使用 TraceView 结合源码查看对应的代码逻辑 , Android Studio 的 Profile 工具可以以进程为单位 , 进行 Method 的 Profile , 可以打出非常详细的函数调用栈 , 并且可以与 Systrace 相对应</li><li>源码分析可以使用 Android Studio 进行断点调试 App 或者 Framework , 观察 Debug 信息是否与预期相符</li></ol></li><li>很多问题也需要借助 Log 工具抓上来的 Log 进行分析 , Log 分析 Log 里面一些比较重要的点 (一般从 Log 里面很难确定卡顿的原因, 但是可以结合 Systrace 做一定的辅助分析)<ol><li>截图 : 确定卡顿发生的时间点 \ 卡顿的界面  (如果没有尽量提供)</li><li>dumpsys meminfo 信息</li><li>dumpsys cpuinfo 信息</li><li>“Slow dispatch” 和 “Slow delivery” Log 信息</li><li>卡顿发生的一段时间内的 EventLog , 还原卡顿时候用户的操作</li></ol></li><li>本地尝试复现<ol><li>可以录高速录像, 观察细节,如果必现,可以让测试这边提供录像.</li><li>过滤 Log , 找到卡顿时候的异常 Log</li><li>多抓几份 Systrace , 有助于确定原因</li></ol></li><li>可以让测试提供 LogReport 中没有的一些信息, 来分析当时用户的手机的整体的状态.<ol><li>adb shell dumpsys activity oom</li><li>adb shell dumpsys meminfo</li><li>adb shell cat /proc/buddyinfo</li><li>adb shell dumpsys cpuinfo</li><li>adb shell dumpsys input</li><li>adb shell dumpsys window</li></ol></li></ol><h1 id="3-通过性能数据数据分析"><a href="#3-通过性能数据数据分析" class="headerlink" title="3. 通过性能数据数据分析"></a>3. 通过性能数据数据分析</h1><p>由于用户反馈的不确定性 , 和内部测试的不完备性 , 通过系统或者 App 的性能埋点数据来做分析 , 是改进系统的一个好的方法 . 一方面不用用户主动参与 , 一方面有大量的数据可以来做分析 , 看趋势 .</p><p>目前国内各大手机厂商和 App 厂商基本都有自己的 APM 平台 , 负责监控 App 或者系统的监控程度 , 来做对应的优化方案 , 比如腾讯的 Matrix 平台已经监控了下面这些内容 , 其他的 App 厂商可以直接接入</p><p><img src="/images//15676894655479.jpg" alt="-w1256"></p><p>手机厂商由于有代码权限 , 所以可以采集到更多的数据 , 比如 Kernel 相关的数据 : cpu 负载 \ io 负载 \ Memory 负载 \ FSync \ 异常监控 \ 温度监控 \ 存储大小监控 等 , 每一个大项又都有几十个小项 . 所以可以监控的数据会非常多 , 遇到问题也可以从多个技术指标去分析 . 这就需要在这方面经验非常丰富的团队 , 去定义这些监控指标 , 确定最终要收集那些信息 , 收集上来的数据如何去分析等.</p><p>至于后续的优化工作 , 就考验各个厂商的研发能力了 , 正如伟琳在这篇文章:<a href="https://mp.weixin.qq.com/s/RqywGvblWi29irkXO2oM1g" target="_blank" rel="noopener">那些年，我们一起经历过的 Android 系统性能优化</a> 所说 , 目前能力比较强的手机厂商 , 都在底层各个模块 , 结合硬件做优化 , 因为归根结底都是资源的分配 ; 而一些研发实力不是很强的厂商 , 则重点还是围绕在根据场景分配资源.</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>这里简单概述了一下流畅性问题的一般分析思路和分析工具 , 而且由于我的方向主要在 Framework 和 App , 所以很多东西都是从上层的角度来说的 , 想必 Kernel 优化团队会有更好的角度和分析 .</p><p>各个厂商的优化大家可以看看这篇总结 , <a href="https://mp.weixin.qq.com/s/RqywGvblWi29irkXO2oM1g" target="_blank" rel="noopener">那些年，我们一起经历过的 Android 系统性能优化</a> , 华米 OV 都有涉及 , 下面摘录了一段总结 , 大家可以看看</p><blockquote><p>展望一下，这里想把手机厂商分为三类:</p><ol><li>一类是苹果，自己研发芯片和核心元件，有自己的OS和生态；</li><li>二类是三星、华为，自己研发芯片和核心元件(当然华为和三星还是有所区别)，共享 Android OS 和生态，当然三星在本土化这一块做的是不如华为和其他 Top 厂商的；</li><li>三类是其他 Android 手机厂商，芯片和核心元件来自于不同供应商，共享 Android OS和生态；</li></ol><p>从技术层面看:</p><ol><li>苹果始终会是在性能的第一阵营，可以顺利推行从硬件到 OS 到 APP 级别的任何性能保障方案；</li><li>三星、华为属于第二阵营，可以实现芯片-OS层面的整合优化；</li><li>其他 Top Android 手机厂商差距不会太大，他们有多个不同的 SoC 供应商，方案有差异，非常芯片底层的地方，往往不会去涉及，更多是做纯软件层面的策略性的优化，有价值但是不容易形成壁垒，注意这个不容易形成壁垒指的是在 top 厂商中间，一些小的厂商往往还是心有余而力不足。不过还是很期待看到有更多的突破出现。</li></ol></blockquote><p>这也是流畅性的一个系列文章中的一篇 , 可以点击下面的链接查看本系列的其他文章.</p><p><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">0. Android 中的卡顿丢帧原因概述 - 方法论</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">1. Android 中的卡顿丢帧原因概述 - 系统篇</a><br><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">2. Android 中的卡顿丢帧原因概述 - 应用篇</a></p><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/82521741" target="_blank" rel="noopener">知乎 - Android 中的卡顿丢帧原因概述 - 方法论</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的 Activity Launch Mode 详解</title>
      <link href="/2019/09/01/Android-Activity-Lunch-Mode/"/>
      <url>/2019/09/01/Android-Activity-Lunch-Mode/</url>
      
        <content type="html"><![CDATA[<p>Android 中的 Activity 有几种比较重要的启动模式,Standard\SingleTop\SingleTask\SingleInstance , 每一种启动模式有不同的使用场景, 网上也有许多分析这个的文章, 这里我以 Demo 的模式, 从 Activity 栈的角度来展示不同启动模式下的 Activity 的行为.</p><p>Activity 栈是一个先进后出的数据结构, 各位可以关注在每一步操作之后, 栈内容那一栏 , 可以更好地帮助理解不同的启动模式.</p><p>Demo 比较简单, 我也放到了 Github 上 , <a href="https://github.com/Gracker/AndroidlunchModeTest" target="_blank" rel="noopener">https://github.com/Gracker/AndroidLaunchModeTest</a> , 有兴趣的可以自己跑一下 , 看看结果 , 只需要修改 StandardActivity 里面的跳转 Activity 就可以了.</p><a id="more"></a><h1 id="Standard-标准模式"><a href="#Standard-标准模式" class="headerlink" title="Standard 标准模式"></a>Standard 标准模式</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>launchMode=<span class="string">"standard"</span></span><br></pre></td></tr></table></figure><p>最基本的模式，每次启动都会创建一个新的 Activity</p><figure class="highlight plain"><figcaption><span>模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 1. 启动 Activity</span><br><span class="line">MainActivity</span><br><span class="line"></span><br><span class="line">//栈内容</span><br><span class="line">com.example.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">// 2. 启动 StandardActivity</span><br><span class="line">MainActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line">//栈内容</span><br><span class="line">com.example.launchmodetest/.StandardActivity</span><br><span class="line">com.example.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">// 3. 启动 StandardActivity</span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  StandardActivity</span><br><span class="line"></span><br><span class="line">//栈内容</span><br><span class="line">com.example.launchmodetest/.StandardActivity</span><br><span class="line">com.example.launchmodetest/.StandardActivity</span><br><span class="line">com.example.launchmodetest/.MainActivity</span><br></pre></td></tr></table></figure><h1 id="SingleTop-栈顶复用模式"><a href="#SingleTop-栈顶复用模式" class="headerlink" title="SingleTop 栈顶复用模式"></a>SingleTop 栈顶复用模式</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>launchMode=<span class="string">"singleTop"</span></span><br></pre></td></tr></table></figure><p>如果当前 Activity 已经在栈顶，那么其 onNewIntent 会被调用；否则会重新创建 Activity</p><h2 id="测试1-：-SingleTopActivity-不在栈顶"><a href="#测试1-：-SingleTopActivity-不在栈顶" class="headerlink" title="测试1 ： SingleTopActivity 不在栈顶"></a>测试1 ： SingleTopActivity 不在栈顶</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 启动 MainActivity</span></span><br><span class="line">MainActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 2. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 3. 启动 SingleTopActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  SingleTopActivity</span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTopActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  SingleTopActivity -&gt; StandardActivity</span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTopActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 5. 启动 SingleTopActivity：</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleTopActivity -&gt; StandardActivity -&gt; SingleTopActivity</span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTopActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTopActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里由于第三个 SingleTopActivity 不在栈顶，栈顶是 StandardActivity ，所以启动新的 SingleTopActivity 时会重新创建 SingleTopActivity</span></span><br></pre></td></tr></table></figure><h2 id="测试2-：-SingleTopActivity-在栈顶"><a href="#测试2-：-SingleTopActivity-在栈顶" class="headerlink" title="测试2 ： SingleTopActivity 在栈顶"></a>测试2 ： SingleTopActivity 在栈顶</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 启动 MainActivity</span></span><br><span class="line">MainActivity</span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 2. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity</span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 3. 启动 SingleTopActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  SingleTopActivity</span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTopActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 4. 启动 SingleTopActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  SingleTopActivity -&gt; SingleTopActivity</span><br><span class="line"><span class="comment">//栈内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTopActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//SingleTopActivity 收到 am_new_intent ，而不是创建新的 Activity</span></span><br></pre></td></tr></table></figure><h1 id="SingleTask-栈内复用模式"><a href="#SingleTask-栈内复用模式" class="headerlink" title="SingleTask 栈内复用模式"></a>SingleTask 栈内复用模式</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>launchMode=<span class="string">"singleTask"</span></span><br></pre></td></tr></table></figure><ol><li>如果不加 Affinity ， 那么 SingleTask 标记的 Activity 创建还是在当前的 Task 中</li><li>SingleTask 标记的 Activity 是栈内复用模式，如果当前 Task 内没有这个 Activity，那么创建新的 Activity，如果当前 Task 内有这个 Activity，不管他在 Task 的哪个位置，都会直接复用这个 Activity (收到 onNewIntent)</li><li>如果栈内复用，那么会 Clear Task 中这个 Activity 上面的其他的 Activity </li></ol><h2 id="测试1：SingleTask（Without-Affinity）"><a href="#测试1：SingleTask（Without-Affinity）" class="headerlink" title="测试1：SingleTask（Without Affinity）"></a>测试1：SingleTask（Without Affinity）</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 启动 MainActivity：</span></span><br><span class="line">MainActivity</span><br><span class="line"><span class="comment">//栈内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 2. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity</span><br><span class="line"><span class="comment">//栈内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 3. 启动 SingleTaskActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  SingleTaskActivity</span><br><span class="line"><span class="comment">//栈内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTaskActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 4. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleTaskActivity -&gt; StandardActivity</span><br><span class="line"><span class="comment">//栈内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTaskActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 5. 启动 SingleTaskActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleTaskActivity -&gt; StandardActivity -&gt; SingleTaskActivity</span><br><span class="line"><span class="comment">//栈内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTaskActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//备注：SingleTaskActivity 收到 am_new_intent ，将其上面的 StandardActivity Clear 调</span></span><br></pre></td></tr></table></figure><h2 id="测试2：SingleTask（WithAffinity）"><a href="#测试2：SingleTask（WithAffinity）" class="headerlink" title="测试2：SingleTask（WithAffinity）"></a>测试2：SingleTask（WithAffinity）</h2><p>在 Manifest 中设置了 android:taskAffinity=”” 之后，启动 SingleTask 会启动一个新的 Task</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 启动 MainActivity</span></span><br><span class="line">MainActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 2. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 3. 启动 SingleTaskWithAffinity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  SingleTaskWithAffinity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTaskWithAffinity</span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 4. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  SingleTaskWithAffinity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTaskWithAffinity</span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 5. 启动 SingleTaskWithAffinity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt;  SingleTaskWithAffinity -&gt; StandardActivity -&gt; SingleTaskWithAffinity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleTaskWithAffinity</span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>与 SingleTask 相比， SingleTaskWithAffinity 会创建新的 Stack</li><li>在 SingleTaskWithAffinity 启动 StandardActivity ， 这个 StandardActivity 与 SingleTaskWithAffinity 在同一个栈</li><li>在栈 0 里面再启动 SingleTaskWithAffinity ，不会创建新的 Task</li><li>多任务里面会出现 SingleTaskWithAffinity</li></ol><h1 id="SingleInstance-单实例模式"><a href="#SingleInstance-单实例模式" class="headerlink" title="SingleInstance 单实例模式"></a>SingleInstance 单实例模式</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>launchMode=<span class="string">"singleInstance"</span></span><br></pre></td></tr></table></figure><p>单示例模式顾名思义，启动时，无论从哪里启动都会给 A 创建一个唯一的任务栈，后续的创建都不会再创建新的 A，除非 A 被销毁了</p><h2 id="测试1：SingleInstance-（Without-Affinity）"><a href="#测试1：SingleInstance-（Without-Affinity）" class="headerlink" title="测试1：SingleInstance （Without Affinity）"></a>测试1：SingleInstance （Without Affinity）</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">taskAffinity=com<span class="selector-class">.example</span>.launchmodetest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 启动 MainActivity</span></span><br><span class="line">MainActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 2. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 3. 启动 SingleInstanceActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceActivity </span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容(多任务里面没有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceActivity</span><br><span class="line"><span class="comment">//栈0内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 4. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容(多任务里面没有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceActivity</span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 5. 启动 SingleInstanceActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceActivity -&gt; StandardActivity -&gt; SingleInstanceActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内： (多任务里面没有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceActivity</span><br><span class="line"><span class="comment">//栈0内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 6. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceActivity -&gt; StandardActivity -&gt; SingleInstanceActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内： (多任务里面没有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceActivity</span><br><span class="line"><span class="comment">//栈0内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 7. 启动 SingleInstanceActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceActivity -&gt; StandardActivity -&gt; SingleInstanceActivity -&gt; StandardActivity -&gt; SingleInstanceActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容 (多任务里面没有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceActivity</span><br><span class="line"><span class="comment">//栈0内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br></pre></td></tr></table></figure><h2 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h2><ol><li>SingleInstanceActivity 会创建新的 Task ，但是不会在多任务中出现</li><li>SingleInstanceActivity 是全局唯一的，如果复用，其 onNewIntent 会被调用</li><li>SingleInstanceActivity 启动新的 Activity，新的 Activity 不会在当前的 Task 里面，而是会回到上一个 Task 里面</li></ol><h2 id="测试2：-SingleInstance-（With-Affinity）"><a href="#测试2：-SingleInstance-（With-Affinity）" class="headerlink" title="测试2： SingleInstance （With Affinity）"></a>测试2： SingleInstance （With Affinity）</h2><p>在 Manifest 中设置了 android:taskAffinity=”” 之后，启动 SingleInstanceActivity 会出现在多任务中 ，其余的表现与没有设置 Affinity 一致</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">taskAffinity</span>=null</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 启动 MainActivity</span></span><br><span class="line">MainActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 2. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 3. 启动 SingleInstanceWithAffinityActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity </span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容：(多任务里面有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceWithAffinityActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 4. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容：(多任务里面有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceWithAffinityActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 5. 启动 SingleInstanceWithAffinityActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容：(多任务里面有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceWithAffinityActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 6. 启动 StandardActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity -&gt; StandardActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容：(多任务里面有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceWithAffinityActivity</span><br><span class="line"><span class="comment">//栈0内容</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 7. 启动 SingleInstanceWithAffinityActivity</span></span><br><span class="line">MainActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity -&gt; StandardActivity -&gt; SingleInstanceWithAffinityActivity</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈1内容：(多任务里面有 Task)</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.SingleInstanceWithAffinityActivity</span><br><span class="line"><span class="comment">//栈0内容：</span></span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.StandardActivity</span><br><span class="line">com<span class="selector-class">.example</span>.launchmodetest/.MainActivity</span><br></pre></td></tr></table></figure><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="TaskAffinity"><a href="#TaskAffinity" class="headerlink" title="TaskAffinity"></a>TaskAffinity</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">taskAffinity</span>=null</span><br></pre></td></tr></table></figure><p>与 Activity 有着亲和关系的任务。从概念上讲，具有相同亲和关系的 Activity 归属同一Task（从用户的角度来看，则是归属同一“ Application ”）。 Task 的亲和关系由其根 Activity 的亲和关系确定。</p><p>亲和关系确定两件事 - Activity 更改到的父项 Task（请参阅 allowTaskReparenting 属性）和通过 FLAG_ACTIVITY_NEW_TASK 标志启动 Activity 时将用来容纳它的 Task。<br>默认情况下，应用中的所有 Activity 都具有相同的亲和关系。您可以设置该属性来以不同方式组合它们，甚至可以将在不同应用中定义的 Activity 置于同一 Task 内。 要指定 Activity 与任何 Task 均无亲和关系，请将其设置为空字符串。</p><p>如果未设置该属性，则 Activity 继承为应用设置的亲和关系（请参阅 <application> 元素的 taskAffinity 属性）。 应用默认亲和关系的名称是 <manifest> 元素设置的软件包名称。</p><h2 id="ActivityRecord、TaskRecord、ActivityStack-之间的关系"><a href="#ActivityRecord、TaskRecord、ActivityStack-之间的关系" class="headerlink" title="ActivityRecord、TaskRecord、ActivityStack 之间的关系"></a>ActivityRecord、TaskRecord、ActivityStack 之间的关系</h2><ol><li>一个 ActivityRecord 对应一个 Activity 实例，保存了一个 Activity 的所有信息 ; 但是一个 Activity可能会有多个 ActivityRecord ,因为 Activity 可以被多次启动，这个主要取决于其启动模式。</li><li>一个 TaskRecord 由一个或者多个 ActivityRecord 组成，这就是我们常说的任务栈，具有后进先出的特点</li><li>ActivityStack 则是用来管理 TaskRecord 的，包含了多个 TaskRecord<br><img src="/images//15673131853333.jpg" alt=""><br><img src="/images//15673132050635.jpg" alt=""></li></ol><p>（From <a href="http://gityuan.com/2017/06/11/activity_record/）" target="_blank" rel="noopener">http://gityuan.com/2017/06/11/activity_record/）</a></p><ol><li>一般地，对于没有分屏功能以及虚拟屏的情况下，ActivityStackSupervisor 与ActivityDisplay 都是系统唯一；</li><li>ActivityDisplay 主要有 Home Stack 、 App Stack、Recents Stack 这三个栈；</li><li>每个 ActivityStack 中可以有若干个 TaskRecord 对象；</li><li>每个 TaskRecord 包含如果若干个 ActivityRecord 对象；</li><li>每个 ActivityRecord记 录一个 Activity 信息。</li></ol><p>下面是一个 dump 的例子，可以看到当前手机的 ActivityRecord、TaskRecord、ActivityStack<br>(adb shell dumpsys activity containers)<br><img src="/images//15673132395730.jpg" alt=""></p><h2 id="Activity-的几种类型"><a href="#Activity-的几种类型" class="headerlink" title="Activity 的几种类型"></a>Activity 的几种类型</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Activity type is currently not defined. */</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> ACTIVITY_TYPE_UNDEFINED = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** Standard activity type. Nothing special about the activity... */</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> ACTIVITY_TYPE_STANDARD = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** Home/Launcher activity type. */</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> ACTIVITY_TYPE_HOME = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** Recents/Overview activity type. There is only one activity with this type in the system. */</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> ACTIVITY_TYPE_RECENTS = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/** Assistant activity type. */</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> ACTIVITY_TYPE_ASSISTANT = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果觉得文章有帮助, 欢迎分享到社交网站 , 希望能帮到大家.</p></blockquote><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中的 Hardware Layer 详解</title>
      <link href="/2019/07/27/Android-Hardware-Layer/"/>
      <url>/2019/07/27/Android-Hardware-Layer/</url>
      
        <content type="html"><![CDATA[<h1 id="硬件加速与软件加速"><a href="#硬件加速与软件加速" class="headerlink" title="硬件加速与软件加速"></a>硬件加速与软件加速</h1><p>很多人会把 Android 中的硬件加速和 Hardware Layer 搞混，会以为启用了硬件加速，就是启用了 Hardware Layer. 所以在说 Hardware Layer 之前，我们先说一下硬件加速</p><p>关于硬件加速的比较详细的文章，推荐大家看这三篇</p><ol><li><a href="https://www.mtyun.com/library/hardware-accelerate" target="_blank" rel="noopener">Android硬件加速原理与实现简介</a></li><li><a href="https://juejin.im/post/5a1f7b3e6fb9a0451b0451bb" target="_blank" rel="noopener">理解Android硬件加速的小白文</a></li><li><a href="https://developer.android.google.cn/guide/topics/graphics/hardware-accel" target="_blank" rel="noopener">官方文档：Hardware acceleration</a></li></ol><p>硬件加速，实际上应该叫 GPU 加速，软硬件加速的区别主要是图形的绘制究竟是 GPU 来处理还是 CPU，如果是 GPU，就认为是硬件加速绘制，反之，则是软件绘制</p><p>目前的 Android 版本， 默认情况下都是开了硬件加速的，如果你的 App 没有特殊声明，那么硬件加速就是默认开启的</p><p>上面三篇文章都有介绍，代码级别和原理级别都讲的比较深，这里我从 Systrace 的角度来给大家展示一下硬件加速下 App 的绘制与软件加速的区别</p><h2 id="硬件加速-App-的表现"><a href="#硬件加速-App-的表现" class="headerlink" title="硬件加速 App 的表现"></a>硬件加速 App 的表现</h2><p>由于默认情况下就是硬件加速，所以我们以最常见的滑动桌面为例，看一下硬件加速情况下 App 在 Systrace 上的表现</p><p>硬件加速情况下，App 存在主线程和渲染线程，一帧的绘制是主线程和渲染线程一起配合执行的<br><img src="/images//15642078929850.jpg" alt=""></p><p>我们把 Systrace 放大，来看每一帧主线程和渲染线程是怎么工作的，GPU 是什么时候介入工作，实现”加速”的<br><img src="/images//15642079103161.jpg" alt=""></p><p>GPU 的真正介入是在 RenderThread 中的部分操作中</p><h2 id="软件加速-App-的表现"><a href="#软件加速-App-的表现" class="headerlink" title="软件加速 App 的表现"></a>软件加速 App 的表现</h2><p>对应的，软件加速我们也找一个 App 来进行演示：云闪付</p><p>首先放一张全景图，可以看到软件渲染下，只有主线程，没有渲染线程，所有的渲染工作，都在主线程完成，同时可以看到，软件渲染下，每一帧的执行时间都非常长，超过1个 Vsync 周期，所以滑动的时候会一卡一卡的，非常难受 <a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/%E8%BD%AF%E4%BB%B6%E6%B8%B2%E6%9F%93%E7%A4%BA%E4%BE%8B-%E4%BA%91%E9%97%AA%E4%BB%98.html" target="_blank" rel="noopener">Systrace 下载</a><br><img src="/images//15642079446767.jpg" alt=""></p><p>我们把 Systrace 放大，来看每一帧主线程是怎么工作的<br><img src="/images//15642079799345.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的对比以及推荐的三篇文章的阅读，你应该对硬件渲染和软件渲染的区别了然于胸，这里总结一下</p><ol><li>硬件渲染情况下，app 存在主线程和渲染线程；软件渲染情况下， app 只有主线程没有渲染线程</li><li>硬件渲染情况下，app 最终绘制是借助 GPU 来实现 ；软件渲染情况下， app 最终绘制是使用 CPU 来实现（调用 skia 库）</li><li>硬件渲染情况下，App 的性能是要优于软件渲染的</li><li>由于部分 api 硬件渲染不支持，所以只能是要软件渲染，做 App 开发的时候，应该尽量避免使用此类 Api(支持情况可以直接在 Android 官方文档里面查看 ：<a href="https://developer.android.google.cn/guide/topics/graphics/hardware-accel" target="_blank" rel="noopener">https://developer.android.google.cn/guide/topics/graphics/hardware-accel</a>)</li></ol><h1 id="Software-Layer-VS-Hardware-Layer"><a href="#Software-Layer-VS-Hardware-Layer" class="headerlink" title="Software Layer VS Hardware Layer"></a>Software Layer VS Hardware Layer</h1><p>说完了硬件渲染，我们来说一下　Software Layer 和 Hardware Layer , 这两个概念主要是针对 View 的说的， 与此时 App 是硬件渲染还是软件渲染没有直接关系（但是有依赖关系，稍后会讲）.</p><p>一个 View 的 layerType 共有三种状态( 后面的英文是官方文档，先读英文我再讲解)：</p><ol><li>LAYER_TYPE_NONE ： Indicates that the view does not have a layer.</li><li>LAYER_TYPE_SOFTWARE ：Indicates that the view has a software layer. A software layer is backed by a  and causes the view to be rendered using Android’s software rendering pipeline, even if hardware acceleration is enabled</li><li>LAYER_TYPE_HARDWARE  ：Indicates that the view has a hardware layer. A hardware layer is backed by a hardware specific texture (generally Frame Buffer Objects or FBO on OpenGL hardware) and causes the view to be rendered using Android’s hardware rendering pipeline, but only if hardware acceleration is turned on for the view hierarchy. When hardware acceleration is turned off, hardware layers behave exactly as LAYER_TYPE_SOFTWARE</li></ol><h2 id="LAYER-TYPE-NONE"><a href="#LAYER-TYPE-NONE" class="headerlink" title="LAYER_TYPE_NONE"></a>LAYER_TYPE_NONE</h2><p>默认情况下，所有的 View 都是这个 layerType，这种情况下，这个 View 不会做任何的特殊处理，该怎么走怎么走</p><h2 id="LAYER-TYPE-SOFTWARE"><a href="#LAYER-TYPE-SOFTWARE" class="headerlink" title="LAYER_TYPE_SOFTWARE"></a>LAYER_TYPE_SOFTWARE</h2><p>Software layerType ,  标识这个 View 有一个软件实现的 Layer ，怎么个软件实现法呢，实际上就是把这个 View，根据一定的条件，变成一个  Bitmap 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android/view/View.java</span><br><span class="line"> Bitmap bitmap = createBitmap(mResources.getDisplayMetrics(),</span><br><span class="line">        width, height, quality);</span><br></pre></td></tr></table></figure><h4 id="Software-layer-的作用如下"><a href="#Software-layer-的作用如下" class="headerlink" title="Software layer 的作用如下"></a>Software layer 的作用如下</h4><ol><li>When the application is not using hardware acceleration, a software layer is useful to apply a specific color filter and/or blending mode and/or  to a view and all its children.（当应用程序不使用硬件加速时，Software layer 可用于将特定的颜色过滤器、混合模式或半透明应用于 View 及其所有子 View）</li><li>When the application is using hardware acceleration, a software layer is useful to render drawing primitives not supported by the hardware accelerated pipeline. It can also be used to cache a complex view tree into a texture and reduce the complexity of drawing operations. For instance, when  a complex view tree with a translation, a software layer can be used to render the view tree only once.（当应用程序使用硬件加速时，软件层可用于呈现硬件加速管道不支持的绘图基元。 它还可用于将复杂视图树缓存到纹理中，并降低绘制操作的复杂性。 例如，在使用转换动画复杂视图树时，可以使用软件层仅渲染视图树一次）</li><li>Software layers should be avoided when the affected view tree updates often. Every update will require to re-render the software layer, which can potentially be slow (particularly when hardware acceleration is turned on since the layer will have to be uploaded into a hardware texture after every update（当受影响的视图树经常更新时，应避免使用软件层。 每次更新都需要重新渲染软件层，这可能会很慢（特别是在打开硬件加速时，因为每次更新后都必须将图层上传到硬件纹理中）</li></ol><h2 id="LAYER-TYPE-HARDWARE"><a href="#LAYER-TYPE-HARDWARE" class="headerlink" title="LAYER_TYPE_HARDWARE"></a>LAYER_TYPE_HARDWARE</h2><p>Hardware layerType ，标识这个 View 有一个硬件实现的 Layer ，通过第一小节我知道，这里的硬件指的是 GPU ，那么硬件实现的 Layer 顾名思义就是通过 GPU 来实现的，通常是OpenGL硬件上的帧缓冲对象或FBO（离屏渲染 Buffer）</p><p>注意：这里 Hardware layerType  是依赖硬件加速的，如果硬件加速开启，那么才会有 FBO 或者帧缓冲 ； 如果硬件加速关闭，那么就算你设置一个 View 的 LayerType 是 Hardware Layer ，也会按照 Software Layer 去做处理</p><h3 id="Hardware-layer-的作用："><a href="#Hardware-layer-的作用：" class="headerlink" title="Hardware layer 的作用："></a>Hardware layer 的作用：</h3><ol><li>A hardware layer is useful to apply a specific color filter and/or blending mode and/or  to a view and all its children.（硬件层可用于将特定颜色过滤器和/或混合模式和/或半透明应用于视图及其所有子视图</li><li>A hardware layer can be used to cache a complex view tree into a texture and reduce the complexity of drawing operations. For instance, when  a complex view tree with a translation, a hardware layer can be used to render the view tree only once.(hardware layer 可用于将复杂视图树缓存到纹理中，并降低绘制操作的复杂性。 例如，在使用转换动画复杂视图树时，可以使用硬件层仅渲染视图树一次，这个是最主要的一个点)</li><li>A hardware layer can also be used to increase the rendering quality when rotation transformations are applied on a view. It can also be used to prevent potential  issues when applying 3D transforms on a view (在视图上应用旋转变换时，还可以使用硬件层来提高渲染质量。 它还可用于在视图上应用3D变换时防止潜在的剪切问题)</li></ol><p>而设置 Hardware Layer 对 alpha\translation  \ scale \ rotation \  这几个属性动画性能有帮助(同样的, 设置 Software Layer 也有相同的功效，下面的小例子环节会有详细的讲解)，具体的使用如下</p><p>动画开始前，设置 LayerType 为 LAYER_TYPE_HARDWARE（代码为官方示例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="keyword">null</span>);</span><br><span class="line">ObjectAnimator.ofFloat(view, <span class="string">"rotationY"</span>, <span class="number">180</span>).start();</span><br></pre></td></tr></table></figure><p>动画结束的时候，重新设置为LAYER_TYPE_NONE（代码为官方示例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">view.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="keyword">null</span>);</span><br><span class="line">ObjectAnimator  = ObjectAnimator.ofFloat(view, <span class="string">"rotationY"</span>, <span class="number">180</span>);</span><br><span class="line">.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">( animation)</span> </span>&#123;</span><br><span class="line">        view.setLayerType(View.LAYER_TYPE_NONE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">.start();</span><br></pre></td></tr></table></figure><p>由于 Hardware Layer 的特性，属性动画( alpha \ translation  \ scale \ rotation \  )过程中只更新 View 的 property，不会每一帧都去销毁和重建 FBO，其动画性能会有很大的提升。当然这里要注意属性动画的过程中( 比如 AnimationUpdate 回调中)，不要做除了上述属性更新之外的其他事情，比如添加删除子 View、修改 View 的显示内容等，这会使得 FBO 失效，性能反而变差</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>从上面对 Hardware Layer 和 Software Layer 的描述可以看到，<br>Software Layer 是对 Hardware Layer 的一个补充，如果 App 处于某种情况不能使用 Hardware Layer ，那么 Software Layer 就会派上用场 。 Hardware Layer 不支持的 API 的实现也得用   Software Layer 来实现</li><li>Software Layer 和 Hardware Layer 都可以对 View 进行操作，比如颜色过滤器、混合模式等</li><li>Software Layer 和 Hardware Layer 对 alpha \ translation  \ scale \ rotation \ pivot 这几个属性动画性能有帮助，这也是 Software Layer 和 Hardware Layer  使用最频繁的优化 (也就是我们常说的 ： 在做上述动画的时候，在动画开始前，将这个 View 的 LayerType 设置为 LAYER_TYPE_HARDWARE ，在动画结束后，将 layerType 重新设置为 LAYER_TYPE_NONE , 设置回来的原因是 Hardware Layer 使用的是 Video Memory，设置为 NONE 之后这部分使用的内存将会回收 ) </li></ol><h1 id="不正确使用-LayerType-导致的性能问题案例"><a href="#不正确使用-LayerType-导致的性能问题案例" class="headerlink" title="不正确使用 LayerType 导致的性能问题案例"></a>不正确使用 LayerType 导致的性能问题案例</h1><h2 id="不正确使用-Software-layer-引起的性能问题"><a href="#不正确使用-Software-layer-引起的性能问题" class="headerlink" title="不正确使用 Software layer 引起的性能问题"></a>不正确使用 Software layer 引起的性能问题</h2><p>看 Trace 经常会有这样的情况出现 ， 我们知道 Software layer 的生成过程本质上是生成一个 Bitmap Cache  ，这个 Cache 的生成是很耗时的， 从下面的 Trace 也可以看出来，每一帧都比一个 Vsync 周期要长。</p><p>之所以下面的 Trace 每一帧都去调用了 buildDrawingCache/SW ，是因为每一帧的过程中，这个 View 的内容进行了更新，导致 Cache 失效，所以每一帧都去触发销毁 Cache 和重建 Cache，导致界面滑动卡顿</p><p>下面这个 Trace 是微信朋友圈的大图滑动情况 <a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/%E4%B8%8D%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8SoftwareLayer%E7%A4%BA%E4%BE%8B-%E5%BE%AE%E4%BF%A1%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF.html" target="_blank" rel="noopener">Trace 在 Github 上可以下载</a><br><img src="/images//15642082974929.jpg" alt=""></p><p>放大来看，每一帧都在做 buildDrawingCache 操作，说明每一帧的缓存都失效了，在进行销毁和重建，性能极差，滑动的时候顿挫感非常严重<br><img src="/images//15642083215860.jpg" alt=""></p><h3 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h3><p>简单看一下 LAYER_TYPE_HARDWARE 的代码流程，详细的流程可以看上面推荐的文章</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildLayer  -&gt; buildDrawingCache -&gt; buildDrawingCacheImpl</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildLayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayerType == LAYER_TYPE_NONE) <span class="keyword">return</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (mLayerType) &#123;</span><br><span class="line">        <span class="keyword">case</span> LAYER_TYPE_HARDWARE:  <span class="comment">// 硬件渲染</span></span><br><span class="line">            updateDisplayListIfDirty();</span><br><span class="line">            <span class="keyword">if</span> (attachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mRenderNode.isValid()) &#123;</span><br><span class="line">                attachInfo.mThreadedRenderer.buildLayer(mRenderNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LAYER_TYPE_SOFTWARE:</span><br><span class="line">            buildDrawingCache(<span class="keyword">true</span>);  <span class="comment">// 软件渲染</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 buildDrawingCache 的实现， 可以看到对应的 Trace 就是在这里打印的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDrawingCache</span><span class="params">(<span class="keyword">boolean</span> autoScale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span> || (autoScale ?</span><br><span class="line">            mDrawingCache == <span class="keyword">null</span> : mUnscaledDrawingCache == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW,</span><br><span class="line">                    <span class="string">"buildDrawingCache/SW Layer for "</span> + getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildDrawingCacheImpl(autoScale);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不正确使用-Hardware-layer-引起的性能问题"><a href="#不正确使用-Hardware-layer-引起的性能问题" class="headerlink" title="不正确使用 Hardware layer 引起的性能问题"></a>不正确使用 Hardware layer 引起的性能问题</h2><p>不正确使用 Hardware Layer 和不正确使用 Software Layer 会引起相同的性能问题，比如下面这个场景 (桌面打开文件夹)，由于开发的实现问题，多个文件夹小图标都被设置了 Hardware LayerType , 导致 RenderThread 非常耗时，又因为每一帧其中的内容都在变，导致每一帧的 Hardware Layer 都失效，被销毁后重建，所以就有了下面的 Systrace 所展示的情况</p><p><a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/%E4%B8%8D%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8HardwareLayer%E7%A4%BA%E4%BE%8B-%E6%A1%8C%E9%9D%A2%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%93%E5%BC%80.html" target="_blank" rel="noopener">Trace 在 Github 上可以下载</a><br><img src="/images//15642083692800.jpg" alt=""></p><p>我们放大 RenderThread 的一帧来看<br><img src="/images//15642083808990.jpg" alt=""></p><h2 id="Debug-工具"><a href="#Debug-工具" class="headerlink" title="Debug 工具"></a>Debug 工具</h2><p>我们可以在 设置 - 辅助功能 - 开发者选项 - 显示硬件层更新（Show hardware layers updates） 这个工具来追踪硬件层更新导致的性能问题 。</p><p>当 View 渲染 Hardware Layer 的时候整个界面会闪烁绿色，正常情况下，它应该在动画开始的时候闪烁一次（也就是 Layer 渲染初始化的时候），后续的动画不应该再有绿色出现；如果你的 View 在整个动画期间保持绿色不变，这就是持续的缓存失效问题了<br>查看 Systrace 也可以发现相同的问题， 两个工具可以一起使用，早些发现动画的性能问题。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ol><li>记住 LayerType 使用的场景：View 做 alpha \ translation  \ scale \ rotation \  这几个属性动画</li><li>做动画的时候，如果可以，尽量多使用 Hardware Layer ，使用完成后记得设置为 None，除非有硬件层不支持的 api，才去考虑使用 Software Layer</li><li>如果是使用 setAlpha(), AlphaAnimation, or ObjectAnimator 来设置 View 的透明度的话，默认就会走 off-screen buffer ， 所以如果你操作的 View 比较大的话，也可以把这个 View 的 Type 设置为 LAYER_TYPE_HARDWARE（官方建议）</li><li>在某些情况下，实际上 Hardware Layer 可能要做非常多的工作，而不仅仅是渲染视图。缓存一个层需要花费时间，因为这一步要划分为两个过程：首先，视图渲染入 GPU 上的一个层中，然后，GPU 再渲染那个层到窗口，如果 View 的渲染十分简单（比如一个纯色），那么在初始化的时候设置 Hardware Layer 可能增加不必要的开销</li><li>对所有缓存来讲，存在一个缓存失效的可能性。动画运行时，如果某个地方调用了View.invalidate( )，那么 Layer 就不得不重新渲染一遍。倘若不断地失效，你的Hardware Layer 实际上要比不添加任何 Layer 性能更差(下面的例子可以佐证)，因为Hardware Layer 在设置缓存的时候增加了开销。如果你不断的重缓存 Layer，会对性能造成极大地负担(做动画的 View 越复杂，带来的负担就越重)</li></ol><h1 id="LayerType-对动画性能的影响示例"><a href="#LayerType-对动画性能的影响示例" class="headerlink" title="LayerType 对动画性能的影响示例"></a>LayerType 对动画性能的影响示例</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>为了说明上面所说的情况，我们用一个小例子来做示例，演示在各种情况下，其性能表现，代码非常简单(代码项目地址 ：<a href="https://github.com/Gracker/Android_HardwareLayer_Example" target="_blank" rel="noopener">https://github.com/Gracker/Android_HardwareLayer_Example</a>), 项目 Systrace 文件夹中包含此文章中涉及的所有例子(这都是好东西，值得收藏)</p><ol><li>两个 TextView ，一个负责开始动画，一个负责做动画</li><li>动画类型有 TRANSLATION_X 、ALPHA、TRANSLATION_Y、SCALE_X、SCALE_Y</li><li>我们会控制 AnimatorListener 和 AnimatorUpdateListener ，使得动画的实现不一样<ol><li>onAnimationStart 和 onAnimationEnd 中主要是设置是否启用 LAYER_TYPE_HARDWARE 或者 LAYER_TYPE_SOFTWARE</li><li>onAnimationUpdate 主要演示如果在动画过程中改变了 View 的内容，会造成什么影响</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//设置动画</span></span><br><span class="line">  animatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">  objectAnimator1 = ObjectAnimator.ofFloat(animationText, View.TRANSLATION_X,<span class="number">150</span>);</span><br><span class="line">  objectAnimator2 = ObjectAnimator.ofFloat(animationText, View.ALPHA,<span class="number">0</span>);</span><br><span class="line">  objectAnimator3 = ObjectAnimator.ofFloat(animationText, View.TRANSLATION_Y,<span class="number">150</span>);</span><br><span class="line">  objectAnimator4 = ObjectAnimator.ofFloat(animationText, View.SCALE_X,<span class="number">150</span>);</span><br><span class="line">  objectAnimator5 = ObjectAnimator.ofFloat(animationText, View.SCALE_Y,<span class="number">150</span>);</span><br><span class="line">animatorSet.playTogether(objectAnimator1,objectAnimator2,objectAnimator3,objectAnimator4,objectAnimator5);</span><br><span class="line">  animatorSet.setDuration(<span class="number">500</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//添加动画监听器</span></span><br><span class="line">  objectAnimator1.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">          animationText.setLayerType(View.LAYER_TYPE_HARDWARE,<span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// animationText.setLayerType(View.LAYER_TYPE_SOFTWARE,null);</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">          animationText.setLayerType(View.LAYER_TYPE_NONE,<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  objectAnimator1.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// text.setText(String.format("%s%d", text.getText().toString(), i));</span></span><br><span class="line">          <span class="comment">// i ++ ;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//开始动画</span></span><br><span class="line">  startText.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">          animatorSet.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="统计工具-GFXInfo"><a href="#统计工具-GFXInfo" class="headerlink" title="统计工具:GFXInfo"></a>统计工具:GFXInfo</h3><p>为了得到准确的数据，我们使用 gfxinfo 得到的数据来进行对比（ adb shell dumpsys gfxinfo）<br><img src="/images//15642085055284.jpg" alt=""></p><p>gfxInfo 记录的是每一帧的耗时，我们重点看下面几个指标</p><ol><li>Janky Frames ：超过 16 ms 的帧数 （超过 16 ms 不一定会卡顿，但是会增加卡顿情况出现的风险）</li><li>耗时帧统计：可以看到大部分帧的区间，以及最大耗时</li></ol><h2 id="案例一：Normal-Layer-不动态更新-View-内容"><a href="#案例一：Normal-Layer-不动态更新-View-内容" class="headerlink" title="案例一：Normal Layer  + 不动态更新 View 内容"></a>案例一：Normal Layer  + 不动态更新 View 内容</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AnimatorListener 和 AnimatorUpdateListener 都不重写, 如下，函数内的都注释掉</span><br><span class="line">objectAnimator1.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objectAnimator1.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Systrace-现象"><a href="#Systrace-现象" class="headerlink" title="Systrace 现象"></a>Systrace 现象</h3><p>可以看到有部分黄帧， 渲染线程中 flush commands 方法执行比较久<a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/Normal_Layer.html" target="_blank" rel="noopener">Systrace 下载</a><br><img src="/images//15642085469278.jpg" alt=""></p><h3 id="gfxInfo-数据"><a href="#gfxInfo-数据" class="headerlink" title="gfxInfo 数据"></a>gfxInfo 数据</h3><p>可以看到 Janky Frames 比例为 46%，99th percentile: 32ms ，说明性能比较差，同时 Number High input latency = 30 说明主线程的负载是比较高的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Total frames rendered: <span class="number">30</span></span><br><span class="line">Janky frames: <span class="number">14</span> (<span class="number">46.67</span>%)</span><br><span class="line"><span class="number">50</span>th percentile: <span class="number">16</span>ms</span><br><span class="line"><span class="number">90</span>th percentile: <span class="number">29</span>ms</span><br><span class="line"><span class="number">95</span>th percentile: <span class="number">32</span>ms</span><br><span class="line"><span class="number">99</span>th percentile: <span class="number">32</span>ms</span><br><span class="line">Number Missed Vsync: <span class="number">0</span></span><br><span class="line">Number High input latency: <span class="number">30</span></span><br><span class="line">Number Slow UI thread: <span class="number">0</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">0</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">0</span></span><br><span class="line">Number Frame deadline missed: <span class="number">0</span></span><br><span class="line">HISTOGRAM: <span class="number">5</span>ms=<span class="number">0</span> <span class="number">6</span>ms=<span class="number">0</span> <span class="number">7</span>ms=<span class="number">0</span> <span class="number">8</span>ms=<span class="number">0</span> <span class="number">9</span>ms=<span class="number">0</span> <span class="number">10</span>ms=<span class="number">2</span> <span class="number">11</span>ms=<span class="number">2</span> <span class="number">12</span>ms=<span class="number">5</span> <span class="number">13</span>ms=<span class="number">1</span> <span class="number">14</span>ms=<span class="number">2</span> <span class="number">15</span>ms=<span class="number">1</span> <span class="number">16</span>ms=<span class="number">3</span> <span class="number">17</span>ms=<span class="number">2</span> <span class="number">18</span>ms=<span class="number">0</span> <span class="number">19</span>ms=<span class="number">0</span> <span class="number">20</span>ms=<span class="number">0</span> <span class="number">21</span>ms=<span class="number">1</span> <span class="number">22</span>ms=<span class="number">1</span> <span class="number">23</span>ms=<span class="number">1</span> <span class="number">24</span>ms=<span class="number">1</span> <span class="number">25</span>ms=<span class="number">2</span> <span class="number">26</span>ms=<span class="number">2</span> <span class="number">27</span>ms=<span class="number">0</span> <span class="number">28</span>ms=<span class="number">1</span> <span class="number">29</span>ms=<span class="number">1</span> <span class="number">30</span>ms=<span class="number">0</span> <span class="number">31</span>ms=<span class="number">0</span> <span class="number">32</span>ms=<span class="number">2</span> <span class="number">34</span>ms=<span class="number">0</span> <span class="number">36</span>ms=<span class="number">0</span> <span class="number">38</span>ms=<span class="number">0</span> <span class="number">40</span>ms=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="案例二：Software-Layer-不动态更新-View-内容"><a href="#案例二：Software-Layer-不动态更新-View-内容" class="headerlink" title="案例二：Software Layer + 不动态更新 View 内容"></a>案例二：Software Layer + 不动态更新 View 内容</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> objectAnimator1.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        animationText.setLayerType(View.LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        animationText.setLayerType(View.LAYER_TYPE_NONE,<span class="keyword">null</span>);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objectAnimator1.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Systrace-现象-1"><a href="#Systrace-现象-1" class="headerlink" title="Systrace 现象"></a>Systrace 现象</h3><p>第一帧执行  buildDrawingCache/SW Layer for AppCompatTextView ，后续的属性动画中，都没有在执行这个方法，可以看到动画过程中所有的帧都是绿色，说明性能很好<a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/Software_Layer.html" target="_blank" rel="noopener">Systrace 下载</a><br><img src="/images//15642086306643.jpg" alt=""></p><h3 id="gfxInfo-数据-1"><a href="#gfxInfo-数据-1" class="headerlink" title="gfxInfo 数据"></a>gfxInfo 数据</h3><p>可以看到 Janky Frames 比例为 3%，99th percentile: 16ms ，说明性能非常好，同时 Number High input latency = 0 说明主线程的负载是比较低的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Total frames rendered: <span class="number">31</span></span><br><span class="line">Janky frames: <span class="number">1</span> (<span class="number">3.23</span>%)</span><br><span class="line"><span class="number">50</span>th percentile: <span class="number">9</span>ms</span><br><span class="line"><span class="number">90</span>th percentile: <span class="number">12</span>ms</span><br><span class="line"><span class="number">95</span>th percentile: <span class="number">16</span>ms</span><br><span class="line"><span class="number">99</span>th percentile: <span class="number">16</span>ms</span><br><span class="line">Number Missed Vsync: <span class="number">0</span></span><br><span class="line">Number High input latency: <span class="number">0</span></span><br><span class="line">Number Slow UI thread: <span class="number">1</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">0</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">0</span></span><br><span class="line">Number Frame deadline missed: <span class="number">1</span></span><br><span class="line">HISTOGRAM: <span class="number">5</span>ms=<span class="number">2</span> <span class="number">6</span>ms=<span class="number">2</span> <span class="number">7</span>ms=<span class="number">4</span> <span class="number">8</span>ms=<span class="number">3</span> <span class="number">9</span>ms=<span class="number">5</span> <span class="number">10</span>ms=<span class="number">11</span> <span class="number">11</span>ms=<span class="number">0</span> <span class="number">12</span>ms=<span class="number">1</span> <span class="number">13</span>ms=<span class="number">0</span> <span class="number">14</span>ms=<span class="number">1</span> <span class="number">15</span>ms=<span class="number">0</span> <span class="number">16</span>ms=<span class="number">2</span> <span class="number">17</span>ms=<span class="number">0</span> <span class="number">18</span>ms=<span class="number">0</span> <span class="number">19</span>ms=<span class="number">0</span> <span class="number">20</span>ms=<span class="number">0</span> <span class="number">21</span>ms=<span class="number">0</span> <span class="number">22</span>ms=<span class="number">0</span> <span class="number">23</span>ms=<span class="number">0</span> <span class="number">24</span>ms=<span class="number">0</span> <span class="number">25</span>ms=<span class="number">0</span> <span class="number">26</span>ms=<span class="number">0</span> <span class="number">27</span>ms=<span class="number">0</span> <span class="number">28</span>ms=<span class="number">0</span> <span class="number">29</span>ms=<span class="number">0</span> <span class="number">30</span>ms=<span class="number">0</span> <span class="number">31</span>ms=<span class="number">0</span> <span class="number">32</span>ms=<span class="number">0</span> <span class="number">34</span>ms=<span class="number">0</span> <span class="number">36</span>ms=<span class="number">0</span> <span class="number">38</span>ms=<span class="number">0</span> <span class="number">40</span>ms=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="案例三：Hardware-Layer-不动态更新-View-内容"><a href="#案例三：Hardware-Layer-不动态更新-View-内容" class="headerlink" title="案例三：Hardware Layer + 不动态更新 View 内容"></a>案例三：Hardware Layer + 不动态更新 View 内容</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">objectAnimator1.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        animationText.setLayerType(View.LAYER_TYPE_HARDWARE,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        animationText.setLayerType(View.LAYER_TYPE_NONE,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objectAnimator1.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Systrace-现象-2"><a href="#Systrace-现象-2" class="headerlink" title="Systrace 现象"></a>Systrace 现象</h2><p>可以看到，动画过程全是绿帧，性能非常好<a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/Hardware_Layer.html" target="_blank" rel="noopener">Systrace 下载</a><br><img src="/images//15642086995840.jpg" alt=""></p><h3 id="gfxInfo-数据-2"><a href="#gfxInfo-数据-2" class="headerlink" title="gfxInfo 数据"></a>gfxInfo 数据</h3><p>可以看到 Janky Frames 比例为 0%，99th percentile: 14ms ，说明性能非常好，同时 Number High input latency = 0 说明主线程的负载是非常低的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Total frames rendered: <span class="number">31</span></span><br><span class="line">Janky frames: <span class="number">0</span> (<span class="number">0.00</span>%)</span><br><span class="line"><span class="number">50</span>th percentile: <span class="number">7</span>ms</span><br><span class="line"><span class="number">90</span>th percentile: <span class="number">9</span>ms</span><br><span class="line"><span class="number">95</span>th percentile: <span class="number">12</span>ms</span><br><span class="line"><span class="number">99</span>th percentile: <span class="number">14</span>ms</span><br><span class="line">Number Missed Vsync: <span class="number">0</span></span><br><span class="line">Number High input latency: <span class="number">0</span></span><br><span class="line">Number Slow UI thread: <span class="number">0</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">0</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">0</span></span><br><span class="line">Number Frame deadline missed: <span class="number">0</span></span><br><span class="line">HISTOGRAM: <span class="number">5</span>ms=<span class="number">3</span> <span class="number">6</span>ms=<span class="number">2</span> <span class="number">7</span>ms=<span class="number">15</span> <span class="number">8</span>ms=<span class="number">7</span> <span class="number">9</span>ms=<span class="number">2</span> <span class="number">10</span>ms=<span class="number">0</span> <span class="number">11</span>ms=<span class="number">0</span> <span class="number">12</span>ms=<span class="number">1</span> <span class="number">13</span>ms=<span class="number">0</span> <span class="number">14</span>ms=<span class="number">1</span> <span class="number">15</span>ms=<span class="number">0</span> <span class="number">16</span>ms=<span class="number">0</span> <span class="number">17</span>ms=<span class="number">0</span> <span class="number">18</span>ms=<span class="number">0</span> <span class="number">19</span>ms=<span class="number">0</span> <span class="number">20</span>ms=<span class="number">0</span> <span class="number">21</span>ms=<span class="number">0</span> <span class="number">22</span>ms=<span class="number">0</span> <span class="number">23</span>ms=<span class="number">0</span> <span class="number">24</span>ms=<span class="number">0</span> <span class="number">25</span>ms=<span class="number">0</span> <span class="number">26</span>ms=<span class="number">0</span> <span class="number">27</span>ms=<span class="number">0</span> <span class="number">28</span>ms=<span class="number">0</span> <span class="number">29</span>ms=<span class="number">0</span> <span class="number">30</span>ms=<span class="number">0</span> <span class="number">31</span>ms=<span class="number">0</span> <span class="number">32</span>ms=<span class="number">0</span> <span class="number">34</span>ms=<span class="number">0</span> <span class="number">36</span>ms=<span class="number">0</span> <span class="number">38</span>ms=<span class="number">0</span> <span class="number">40</span>ms=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="案例四：Normal-Layer-动态更新-View-内容"><a href="#案例四：Normal-Layer-动态更新-View-内容" class="headerlink" title="案例四：Normal Layer + 动态更新 View 内容"></a>案例四：Normal Layer + 动态更新 View 内容</h2><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objectAnimator1.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objectAnimator1.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">        animationText.setText(String.format(<span class="string">"%s%d"</span>, animationText.getText().toString(), i));</span><br><span class="line">        i ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Systrace-现象-3"><a href="#Systrace-现象-3" class="headerlink" title="Systrace 现象"></a>Systrace 现象</h3><p>可以看到动画过程中有部分黄帧，部分帧的 Animation、measure、layout、draw 比较耗时<a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/Normal_Layer_UpdateView.html" target="_blank" rel="noopener">Systrace 下载</a><br><img src="/images//15642087831154.jpg" alt=""></p><h3 id="gfxInfo-数据-3"><a href="#gfxInfo-数据-3" class="headerlink" title="gfxInfo 数据"></a>gfxInfo 数据</h3><p>可以看到 Janky Frames 比例为 38%，99th percentile: 29ms ，说明性能比较差，同时 Number High input latency = 31 说明主线程的负载是比较高的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Total frames rendered: <span class="number">31</span></span><br><span class="line">Janky frames: <span class="number">12</span> (<span class="number">38.71</span>%)</span><br><span class="line"><span class="number">50</span>th percentile: <span class="number">14</span>ms</span><br><span class="line"><span class="number">90</span>th percentile: <span class="number">25</span>ms</span><br><span class="line"><span class="number">95</span>th percentile: <span class="number">29</span>ms</span><br><span class="line"><span class="number">99</span>th percentile: <span class="number">29</span>ms</span><br><span class="line">Number Missed Vsync: <span class="number">0</span></span><br><span class="line">Number High input latency: <span class="number">31</span></span><br><span class="line">Number Slow UI thread: <span class="number">0</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">0</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">0</span></span><br><span class="line">Number Frame deadline missed: <span class="number">0</span></span><br><span class="line">HISTOGRAM: <span class="number">5</span>ms=<span class="number">0</span> <span class="number">6</span>ms=<span class="number">0</span> <span class="number">7</span>ms=<span class="number">1</span> <span class="number">8</span>ms=<span class="number">2</span> <span class="number">9</span>ms=<span class="number">4</span> <span class="number">10</span>ms=<span class="number">1</span> <span class="number">11</span>ms=<span class="number">1</span> <span class="number">12</span>ms=<span class="number">4</span> <span class="number">13</span>ms=<span class="number">2</span> <span class="number">14</span>ms=<span class="number">1</span> <span class="number">15</span>ms=<span class="number">2</span> <span class="number">16</span>ms=<span class="number">2</span> <span class="number">17</span>ms=<span class="number">1</span> <span class="number">18</span>ms=<span class="number">2</span> <span class="number">19</span>ms=<span class="number">0</span> <span class="number">20</span>ms=<span class="number">2</span> <span class="number">21</span>ms=<span class="number">1</span> <span class="number">22</span>ms=<span class="number">0</span> <span class="number">23</span>ms=<span class="number">0</span> <span class="number">24</span>ms=<span class="number">1</span> <span class="number">25</span>ms=<span class="number">1</span> <span class="number">26</span>ms=<span class="number">1</span> <span class="number">27</span>ms=<span class="number">0</span> <span class="number">28</span>ms=<span class="number">0</span> <span class="number">29</span>ms=<span class="number">2</span> <span class="number">30</span>ms=<span class="number">0</span> <span class="number">31</span>ms=<span class="number">0</span> <span class="number">32</span>ms=<span class="number">0</span> <span class="number">34</span>ms=<span class="number">0</span> <span class="number">36</span>ms=<span class="number">0</span> <span class="number">38</span>ms=<span class="number">0</span> <span class="number">40</span>ms=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="案例五：Software-Layer-动态更新-View-内容"><a href="#案例五：Software-Layer-动态更新-View-内容" class="headerlink" title="案例五：Software Layer + 动态更新 View 内容"></a>案例五：Software Layer + 动态更新 View 内容</h2><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">objectAnimator1.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        animationText.setLayerType(View.LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        animationText.setLayerType(View.LAYER_TYPE_NONE,<span class="keyword">null</span>);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objectAnimator1.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">        animationText.setText(String.format(<span class="string">"%s%d"</span>, animationText.getText().toString(), i));</span><br><span class="line">        i ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Systrace-现象-4"><a href="#Systrace-现象-4" class="headerlink" title="Systrace 现象"></a>Systrace 现象</h3><p>由于每一帧都在更新内容，所以每次 buildDrawingCache 生成的 Bitmap 都会被销毁和重建，此时的瓶颈都在主线程中，由于 buildDrawingCache 每一帧都执行，导致 Animation 和 Draw 的执行时间都很长<a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/Software_Layer_UpdateView.html" target="_blank" rel="noopener">Systrace 下载</a><br><img src="/images//15642088391947.jpg" alt=""></p><h3 id="gfxInfo-数据-4"><a href="#gfxInfo-数据-4" class="headerlink" title="gfxInfo 数据"></a>gfxInfo 数据</h3><p>可以看到 Janky Frames 比例为 41%，99th percentile: 32ms ，说明性能比较差，同时 Number High input latency = 18 说明主线程的负载是比较高的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Total frames rendered: <span class="number">29</span></span><br><span class="line">Janky frames: <span class="number">12</span> (<span class="number">41.38</span>%)</span><br><span class="line"><span class="number">50</span>th percentile: <span class="number">14</span>ms</span><br><span class="line"><span class="number">90</span>th percentile: <span class="number">30</span>ms</span><br><span class="line"><span class="number">95</span>th percentile: <span class="number">31</span>ms</span><br><span class="line"><span class="number">99</span>th percentile: <span class="number">32</span>ms</span><br><span class="line">Number Missed Vsync: <span class="number">0</span></span><br><span class="line">Number High input latency: <span class="number">18</span></span><br><span class="line">Number Slow UI thread: <span class="number">4</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">0</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">0</span></span><br><span class="line">Number Frame deadline missed: <span class="number">4</span></span><br><span class="line">HISTOGRAM: <span class="number">5</span>ms=<span class="number">0</span> <span class="number">6</span>ms=<span class="number">1</span> <span class="number">7</span>ms=<span class="number">0</span> <span class="number">8</span>ms=<span class="number">0</span> <span class="number">9</span>ms=<span class="number">0</span> <span class="number">10</span>ms=<span class="number">1</span> <span class="number">11</span>ms=<span class="number">6</span> <span class="number">12</span>ms=<span class="number">3</span> <span class="number">13</span>ms=<span class="number">2</span> <span class="number">14</span>ms=<span class="number">3</span> <span class="number">15</span>ms=<span class="number">0</span> <span class="number">16</span>ms=<span class="number">1</span> <span class="number">17</span>ms=<span class="number">1</span> <span class="number">18</span>ms=<span class="number">1</span> <span class="number">19</span>ms=<span class="number">2</span> <span class="number">20</span>ms=<span class="number">0</span> <span class="number">21</span>ms=<span class="number">1</span> <span class="number">22</span>ms=<span class="number">0</span> <span class="number">23</span>ms=<span class="number">0</span> <span class="number">24</span>ms=<span class="number">2</span> <span class="number">25</span>ms=<span class="number">1</span> <span class="number">26</span>ms=<span class="number">0</span> <span class="number">27</span>ms=<span class="number">1</span> <span class="number">28</span>ms=<span class="number">0</span> <span class="number">29</span>ms=<span class="number">0</span> <span class="number">30</span>ms=<span class="number">1</span> <span class="number">31</span>ms=<span class="number">1</span> <span class="number">32</span>ms=<span class="number">1</span> <span class="number">34</span>ms=<span class="number">0</span> <span class="number">36</span>ms=<span class="number">0</span> <span class="number">38</span>ms=<span class="number">0</span> <span class="number">40</span>ms=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="案例六：Hardware-Layer-动态更新-View-内容"><a href="#案例六：Hardware-Layer-动态更新-View-内容" class="headerlink" title="案例六：Hardware Layer + 动态更新 View 内容"></a>案例六：Hardware Layer + 动态更新 View 内容</h2><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">objectAnimator1.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        animationText.setLayerType(View.LAYER_TYPE_HARDWARE,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">        animationText.setLayerType(View.LAYER_TYPE_NONE,<span class="keyword">null</span>);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objectAnimator1.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">        animationText.setText(String.format(<span class="string">"%s%d"</span>, animationText.getText().toString(), i));</span><br><span class="line">        i ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Systrace-现象-5"><a href="#Systrace-现象-5" class="headerlink" title="Systrace 现象"></a>Systrace 现象</h3><p>与 Software Layer 情况类似，由于每一帧都在更新内容，所以每次 drawLayer  生成的 Buffer 都会被销毁和重建，此时的瓶颈都在主线程 + 渲染线程中，由于每一帧内容更新和 Buffer 销毁重建，导致主线程和渲染线程执行时间都很长，性能比较差<a href="https://github.com/Gracker/Android_HardwareLayer_Example/blob/master/Systrace/HardWare_Layer_UpdateView.html" target="_blank" rel="noopener">Systrace 下载</a><br><img src="/images//15642088948719.jpg" alt=""></p><h3 id="gfxInfo-数据-5"><a href="#gfxInfo-数据-5" class="headerlink" title="gfxInfo 数据"></a>gfxInfo 数据</h3><p>可以看到 Janky Frames 比例为 46%，99th percentile: 32ms ，说明性能比较差，同时 Number High input latency = 30 说明主线程的负载是比较高的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Total frames rendered: <span class="number">30</span></span><br><span class="line">Janky frames: <span class="number">14</span> (<span class="number">46.67</span>%)</span><br><span class="line"><span class="number">50</span>th percentile: <span class="number">16</span>ms</span><br><span class="line"><span class="number">90</span>th percentile: <span class="number">29</span>ms</span><br><span class="line"><span class="number">95</span>th percentile: <span class="number">32</span>ms</span><br><span class="line"><span class="number">99</span>th percentile: <span class="number">32</span>ms</span><br><span class="line">Number Missed Vsync: <span class="number">0</span></span><br><span class="line">Number High input latency: <span class="number">30</span></span><br><span class="line">Number Slow UI thread: <span class="number">0</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">0</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">0</span></span><br><span class="line">Number Frame deadline missed: <span class="number">0</span></span><br><span class="line">HISTOGRAM: <span class="number">5</span>ms=<span class="number">0</span> <span class="number">6</span>ms=<span class="number">0</span> <span class="number">7</span>ms=<span class="number">0</span> <span class="number">8</span>ms=<span class="number">0</span> <span class="number">9</span>ms=<span class="number">0</span> <span class="number">10</span>ms=<span class="number">2</span> <span class="number">11</span>ms=<span class="number">2</span> <span class="number">12</span>ms=<span class="number">5</span> <span class="number">13</span>ms=<span class="number">1</span> <span class="number">14</span>ms=<span class="number">2</span> <span class="number">15</span>ms=<span class="number">1</span> <span class="number">16</span>ms=<span class="number">3</span> <span class="number">17</span>ms=<span class="number">2</span> <span class="number">18</span>ms=<span class="number">0</span> <span class="number">19</span>ms=<span class="number">0</span> <span class="number">20</span>ms=<span class="number">0</span> <span class="number">21</span>ms=<span class="number">1</span> <span class="number">22</span>ms=<span class="number">1</span> <span class="number">23</span>ms=<span class="number">1</span> <span class="number">24</span>ms=<span class="number">1</span> <span class="number">25</span>ms=<span class="number">2</span> <span class="number">26</span>ms=<span class="number">2</span> <span class="number">27</span>ms=<span class="number">0</span> <span class="number">28</span>ms=<span class="number">1</span> <span class="number">29</span>ms=<span class="number">1</span> <span class="number">30</span>ms=<span class="number">0</span> <span class="number">31</span>ms=<span class="number">0</span> <span class="number">32</span>ms=<span class="number">2</span> <span class="number">34</span>ms=<span class="number">0</span> <span class="number">36</span>ms=<span class="number">0</span> <span class="number">38</span>ms=<span class="number">0</span> <span class="number">40</span>ms=<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>从上面的六个案例可以看到，相同的动画，在不同的 LayerType 之下，其性能表现差别很大，这还只是简单的属性动画，如果碰到更加复杂的动画，性能差别会更大。<br>我们对上面几个案例和表现出来的性能数据做一下简单的总结：</p><ol><li>如果只是单纯的做动画，不动态修改 View 的内容，那么性能表现为 ：Hardware Layer &gt;= Software Layer &gt; Normal Layer</li><li>如果做动画同时动态修改 View 的内容，那么性能表现为 ：Normal Layer &gt; Software Layer = Hardware Layer</li><li>Hardware Layer 对动画性能确实有很大的提升，但是如果你用不好，那么还不如不用</li><li>如果通过 Systrace 发现你做动画的时候每一帧都在 buildDrawingCache/SW(主线程) 或者 buildLayer(渲染线程)，那么请查看你的代码的逻辑</li><li>有些情况下是由于系统的原因，比如图片比 Cache 大，invalidate 逻辑问题，可以联系手机厂商进行一起修改</li></ol><p>既然读完了,如果有什么想法可以留言沟通,也可以扫文章下面的微信二维码加好友一起讨论;如有疏漏或者错误的地方,辛苦大家告知一下,我尽早更新以免误导他人;如果觉得有用,也请把这篇文章分享给其他人.</p><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/75458539" target="_blank" rel="noopener">知乎 - Android 中的 Hardware Layer 详解</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 -- 分析 Systrace 预备知识</title>
      <link href="/2019/07/23/Android-Systrace-Pre/"/>
      <url>/2019/07/23/Android-Systrace-Pre/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第二篇，主要是讲解一些分析 Systrace 的预备知识, 有了这些预备知识, 分析 Systrace 才会事半功倍, 更快也更有效率地找到问题点.</p><p>本文介绍了如何查看 Systrace 中的线程状态 , 如何对进程的唤醒信息进行分析, 如何解读信息区的数据, 以及介绍了常用的快捷键. 通过本篇文章的学习, 相信你可以掌握进程和线程相关的一些信息, 也知道如何查看复杂的 Systrace 中包含的关键信息</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="线程状态查看"><a href="#线程状态查看" class="headerlink" title="线程状态查看"></a>线程状态查看</h2><p>Systrace 会用不同的颜色来标识不同的线程状态,  在每个方法上面都会有对应的线程状态来标识目前线程所处的状态.<br>通过查看线程状态我们可以知道目前的瓶颈是什么, 是  CPU 执行慢还是因为 Binder 调用, 又或是进行 IO 操作, 又或是拿不到 CPU 时间片 </p><p>线程状态主要有下面几个</p><h3 id="绿色-运行中"><a href="#绿色-运行中" class="headerlink" title="绿色 : 运行中"></a>绿色 : 运行中</h3><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。</p><p>作用：我们经常会查看 Running 状态的线程，查看其运行的时间，与竞品做对比，分析快或者慢的原因：</p><ol><li>是否频率不够？</li><li>是否跑在了小核上？</li><li>是否频繁在 Running 和 Runnable 之间切换？为什么？</li><li>是否频繁在 Running 和 Sleep 之间切换？为什么？</li><li>是否跑在了不该跑的核上面？比如不重要的线程占用了超大核</li></ol><p><img src="/images/15638915926547-1.jpg" alt="15638915926547"></p><h3 id="蓝色-可运行"><a href="#蓝色-可运行" class="headerlink" title="蓝色 : 可运行"></a>蓝色 : 可运行</h3><p>线程可以运行但当前没有安排，在等待 cpu 调度</p><p>作用：Runnable 状态的线程状态持续时间越长，则表示 cpu 的调度越忙，没有及时处理到这个任务：</p><ol><li>是否后台有太多的任务在跑？</li><li>没有及时处理是因为频率太低？</li><li>没有及时处理是因为被限制到某个 cpuset 里面，但是 cpu 很满？</li><li>此时 Running 的任务是什么？为什么？</li></ol><p><img src="/images//15638916092620.jpg" alt=""></p><h3 id="白色-休眠中"><a href="#白色-休眠中" class="headerlink" title="白色 : 休眠中"></a>白色 : 休眠中</h3><p>线程没有工作要做，可能是因为线程在互斥锁上被阻塞。</p><p>作用 ： 这里一般是在等事件驱动<br><img src="/images//15638916218040.jpg" alt=""></p><h3 id="橘色-不可中断的睡眠态-IO-Block"><a href="#橘色-不可中断的睡眠态-IO-Block" class="headerlink" title="橘色 : 不可中断的睡眠态 IO Block"></a>橘色 : 不可中断的睡眠态 IO Block</h3><p>线程在I / O上被阻塞或等待磁盘操作完成，一般底线都会标识出此时的 callsite ：wait_on_page_locked_killable</p><p>作用：这个一般是标示 IO 操作慢，如果有大量的橘色不可中断的睡眠态出现，那么一般是由于进入了低内存状态，申请内存的时候触发 pageFault, linux 系统的 page cache 链表中有时会出现一些还没准备好的 page(即还没把磁盘中的内容完全地读出来) , 而正好此时用户在访问这个 page 时就会出现 wait_on_page_locked_killable 阻塞了. 只有系统当 io 操作很繁忙时, 每笔的 io 操作都需要等待排队时, 极其容易出现且阻塞的时间往往会比较长.</p><p><img src="/images//15638916331888.jpg" alt=""></p><h3 id="紫色-不可中断的睡眠态"><a href="#紫色-不可中断的睡眠态" class="headerlink" title="紫色 : 不可中断的睡眠态"></a>紫色 : 不可中断的睡眠态</h3><p>线程在另一个内核操作（通常是内存管理）上被阻塞。</p><p>作用：一般是陷入了内核态，有些情况下是正常的，有些情况下是不正常的，需要按照具体的情况去分析<br><img src="/images//15638916451317.jpg" alt=""></p><h2 id="进程唤醒信息分析"><a href="#进程唤醒信息分析" class="headerlink" title="进程唤醒信息分析"></a>进程唤醒信息分析</h2><p>Systrace 会标识出一个非常有用的信息，可以帮助我们进行跨进程调用相关的分析。</p><p>一个进程被唤醒的信息往往比较重要，知道他被谁唤醒，那么我们也就知道了他们之间的调用等待关系，如果出现一段比较长的 sleep 情况，然后被唤醒，那么我们就可以去看是谁唤醒了这个线程，对应的就可以查看唤醒者的信息，看看为什么唤醒者这么晚才唤醒。</p><p>一个常见的情况是：应用进程使用 Binder 与 SystemServer 的 AMS 线程进行通信，但是恰好 AMS 的这个函数正在等待锁释放（或者这个函数本身执行时间很长），那么应用进程就需要等待比较长的时间，如果恰好是应用进程的主线程在进行等待，那么就会出现性能问题，比如响应慢或者卡顿，这就是为什么后台有大量的进程在运行，或者跑完 Monkey 之后，整机性能会下降的一个主要原因。</p><p>Systrace 可以标示出这个的一个原因是，一个任务在进入 Running 状态之前，会先进入 Runnable 状态进行等待，而 Systrace 会把这个状态也标示在 Systrace 上（非常短，需要放大进行看）</p><p><img src="/images//15638916556947.jpg" alt=""></p><p>拉到最上面查看对应的 cpu 上的 taks 信息，会标识这个 task 在被唤醒之前的状态：<br><img src="/images//15638916674736.jpg" alt=""></p><p>顺便贴一下 Linux 常见的进程状态</p><ol><li>D 无法中断的休眠状态（通常 IO 的进程）；</li><li>R 正在可运行队列中等待被调度的；</li><li>S 处于休眠状态；</li><li>T 停止或被追踪；</li><li>W 进入内存交换  （从内核2.6开始无效）；</li><li>X 死掉的进程   （基本很少見）；</li><li>Z 僵尸进程；</li><li>&lt; 优先级高的进程</li><li>N 优先级较低的进程</li><li>L 有些页被锁进内存；</li><li>s 进程的领导者（在它之下有子进程）；</li><li>l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）；</li><li><ul><li>位于后台的进程组；</li></ul></li></ol><h2 id="信息区数据解析"><a href="#信息区数据解析" class="headerlink" title="信息区数据解析"></a>信息区数据解析</h2><h3 id="进程状态信息解析"><a href="#进程状态信息解析" class="headerlink" title="进程状态信息解析"></a>进程状态信息解析</h3><p><img src="/images//15638916860044.jpg" alt=""></p><h3 id="函数-Slice-信息解析"><a href="#函数-Slice-信息解析" class="headerlink" title="函数 Slice 信息解析"></a>函数 Slice 信息解析</h3><p><img src="/images//15638916944506.jpg" alt=""></p><h3 id="Counter-Sample-信息解析"><a href="#Counter-Sample-信息解析" class="headerlink" title="Counter Sample 信息解析"></a>Counter Sample 信息解析</h3><p><img src="/images//15638917076247.jpg" alt=""></p><h3 id="Async-Slice-信息解析"><a href="#Async-Slice-信息解析" class="headerlink" title="Async Slice 信息解析"></a>Async Slice 信息解析</h3><p><img src="/images//15638917151530.jpg" alt=""></p><h3 id="CPU-Slice-信息解析"><a href="#CPU-Slice-信息解析" class="headerlink" title="CPU Slice 信息解析"></a>CPU Slice 信息解析</h3><p><img src="/images//15638917222302.jpg" alt=""></p><h3 id="User-Expectation-信息解析"><a href="#User-Expectation-信息解析" class="headerlink" title="User Expectation 信息解析"></a>User Expectation 信息解析</h3><p>位于整个 Systrace 最上面的部分,标识了 Rendering Response 和  Input Response<br><img src="/images//15638917348214.jpg" alt=""></p><h2 id="快捷键使用"><a href="#快捷键使用" class="headerlink" title="快捷键使用"></a>快捷键使用</h2><p>快捷键的使用可以加快查看 Systrace 的速度,下面是一些常用的快捷键</p><p>W : 放大 Systrace , 放大可以更好地看清局部细节<br>S : 缩小 Systrace, 缩小以查看整体<br>A : 左移<br>D : 右移<br>M : 高亮选中当前鼠标点击的段(这个比较常用,可以快速标识出这个方法的左右边界和执行时间,方便上下查看)</p><p>鼠标模式快捷切换 : 主要是针对鼠标的工作模式进行切换 , 默认是 1 ,也就是选择模式,查看 Systrace 的时候,需要经常在各个模式之间切换 , 所以点击切换模式效率比较低,直接用快捷键切换效率要高很多</p><p><strong>数字键1</strong> : 切换到 Selection 模式 , 这个模式下鼠标可以点击某一个段查看其详细信息, 一般打开 Systrace 默认就是这个模式 , 也是最常用的一个模式  , 配合 M 和 ASDW 可以做基本的操作<br><strong>数字键2</strong> : 切换到 Pan 模式 , 这个模式下长按鼠标可以左右拖动, 有时候会用到<br><strong>数字键3</strong> : 切换到 Zoom 模式 , 这个模式下长按鼠标可以放大和缩小, 有时候会用到<br><strong>数字键4</strong> : 切换到 Timing 模式 , 这个模式下主要是用来衡量时间的,比如选择一个起点, 选择一个终点, 查看起点和终点这中间的操作所花费的时间.</p><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/82522750" target="_blank" rel="noopener">知乎 - Systrace 基础知识 – 分析 Systrace 预备知识</a><br><a href="https://juejin.im/post/5dc18576f265da4d307f1878" target="_blank" rel="noopener">掘金 - Systrace 基础知识 – 分析 Systrace 预备知识</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 - SystemServer 解读</title>
      <link href="/2019/06/29/Android-Systrace-SystemServer/"/>
      <url>/2019/06/29/Android-Systrace-SystemServer/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第四篇，主要是对 SystemServer 进行简单介绍，介绍了 SystemServer 中几个比较重要的线程，由于 Input 和 Binder 比较重要，所以单独拿出来讲，在这里就没有再涉及到。</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="窗口动画"><a href="#窗口动画" class="headerlink" title="窗口动画"></a>窗口动画</h2><p>Systrace 中的 SystemServer 一个比较重要的地方就是窗口动画，由于窗口归 SystemServer 来管，那么窗口动画也就是由 SystemServer 来进行统一的处理，其中涉及到两个比较重要的线程，Android.Anim 和 Android.Anim.if 这两个线程，这两个线程的基本知识在下面有讲。</p><p>这里我们以<strong>应用启动</strong>为例，查看窗口时如何在两个线程之间进行切换(Android P 里面，应用的启动动画由 Launcher 和应用自己的第一帧组成，之前是在 SystemServer 里面的，现在多任务的动画为了性能部分移到了 Launcher 去实现)</p><p>首先我们点击图标启动应用的时候，由于 App 还在启动，Launcher 首先启动一个 StartingWindow，等 App 的第一帧绘制好了之后，再切换到 App 的窗口动画</p><p>Launcher 动画<br><img src="/images/15811380751710.jpg" alt="-w1019"></p><p>此时对应的，App 正在启动<br><img src="/images/15811380510520.jpg" alt="-w1025"></p><p>从上图可以看到，应用第一帧已经准备好了，接下来看对应的 SystemServer ，可以看到应用启动第一帧绘制完成后，动画切换到 App 的 Window 动画</p><p><img src="/images/15811383348116.jpg" alt="-w1236"></p><h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h2><p>AMS 和 WMS 算是 SystemServer 中最繁忙的两个 Service 了，与 AMS 相关的 Trace 一般会用 TRACE_TAG_ACTIVITY_MANAGER 这个 TAG，在 Systrace 中的名字是 ActivityManager</p><p>下面是启动一个新的进程的时候，AMS 的输出<br><img src="/images/15808922537197.jpg" alt="-w826"></p><p>在进程和四大组件的各种场景一般都会有对应的 Trace 点来记录，比如大家熟悉的 ActivityStart、ActivityResume、activityStop  等，这些 Trace 点有一些在应用进程，有一些在 SystemServer 进程，所以大家在看 Activity 相关的代码逻辑的时候，需要不断在这两个进程之间进行切换，这样才能从一个整体的角度来看应用的状态变化和 SystemServer 在其中起到的作用。<br><img src="/images/15808919921881.jpg" alt="-w660"></p><h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><p>与 WMS 相关的 Trace 一般会用 TRACE_TAG_WINDOW_MANAGER 这个 TAG，在 Systrace 中 WindowManagerService 在 SystemServer 中多在对应的 Binder 中出现，比如下面应用启动的时候，relayoutWindow 的 Trace 输出</p><p><img src="/images/15808923853151.jpg" alt="-w957"></p><p>在 Window 的各种场景一般都会有对应的 Trace 点来记录，比如大家熟悉的 relayoutWIndow、performLayout、prepareToDisplay 等<br><img src="/images/15808918520410.jpg" alt="-w659"></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Input 是 SystemServer 线程里面非常重要的一部分，主要是由 InputReader 和 InputDispatcher 这两个 Native 线程组成，关于这一部分在 <a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a> 里面已经详细讲过，这里就不再详细讲了</p><p><img src="/images/15808245020456.jpg" alt="-w725"></p><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>SystemServer 由于提供大量的基础服务，所以进程间的通信非常繁忙，且大部分通信都是通过 Binder ，所以 Binder 在 SystemServer 中的作用非常关键，很多时候当后台有大量的 App 存在的时候，SystemServer 就会由于 Binder 通信和锁竞争，导致系统或者 App 卡顿。关于这一部分在 <a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Binder 和锁竞争解读</a> 里面已经详细讲过，这里就不再详细讲了</p><p><img src="/images/15808245356047.jpg" alt="-w1028"></p><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><h3 id="BackgroundThread"><a href="#BackgroundThread" class="headerlink" title="BackgroundThread"></a>BackgroundThread</h3><p>com/android/internal/os/BackgroundThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">BackgroundThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"android.bg"</span>, android.os.Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Systrace 中的 BackgroundThread<br><img src="/images/15808252037825.jpg" alt="-w1082"></p><p>BackgroundThread 在系统中使用比较多，许多对性能没有要求的任务，一般都会放到 BackgroundThread 中去执行</p><p><img src="/images/15808271946061.jpg" alt="-w654"></p><h2 id="ServiceThread"><a href="#ServiceThread" class="headerlink" title="ServiceThread"></a>ServiceThread</h2><p>ServiceThread 继承自 HandlerThread ，下面介绍的几个工作线程都是继承自 ServiceThread ，分别实现不同的功能，根据线程功能不同，其线程优先级也不同：UIThread、IoThread、DisplayThread、AnimationThread、FgThread、SurfaceAnimationThread</p><p>每个 Thread 都有自己的 Looper 、Thread 和 MessageQueue，互相不会影响。Android 系统根据功能，会使用不同的 Thread 来完成。</p><h3 id="UiThread"><a href="#UiThread" class="headerlink" title="UiThread"></a>UiThread</h3><p>com/android/server/UiThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">UiThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"android.ui"</span>, Process.THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Systrace 中的 UiThread<br><img src="/images/15808252975757.jpg" alt="-w1049"></p><p>UiThread 被使用的地方如下，具体的功能可以自己去源码里面查看，关键字是 UiThread.get()<br><img src="/images/15808258949148.jpg" alt="-w650"></p><h3 id="IoThread"><a href="#IoThread" class="headerlink" title="IoThread"></a>IoThread</h3><p>com/android/server/IoThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">IoThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"android.io"</span>, android.os.Process.THREAD_PRIORITY_DEFAULT, <span class="keyword">true</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IoThread 被使用的地方如下，具体的功能可以自己去源码里面查看，关键字是 IoThread.get()<br><img src="/images/15808257964346.jpg" alt="-w654"></p><h3 id="DisplayThread"><a href="#DisplayThread" class="headerlink" title="DisplayThread"></a>DisplayThread</h3><p>com/android/server/DisplayThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DisplayThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DisplayThread runs important stuff, but these are not as important as things running in</span></span><br><span class="line">    <span class="comment">// AnimationThread. Thus, set the priority to one lower.</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"android.display"</span>, Process.THREAD_PRIORITY_DISPLAY + <span class="number">1</span>, <span class="keyword">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Systrace 中的 DisplayThread<br><img src="/images/15808251210767.jpg" alt="-w1108"></p><p><img src="/images/15808259701453.jpg" alt="-w656"></p><h3 id="AnimationThread"><a href="#AnimationThread" class="headerlink" title="AnimationThread"></a>AnimationThread</h3><p>com/android/server/AnimationThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AnimationThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"android.anim"</span>, THREAD_PRIORITY_DISPLAY, <span class="keyword">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Systrace 中的 AnimationThread<br><img src="/images/15808255124784.jpg" alt="-w902"></p><p>AnimationThread 在源码中的使用，可以看到 WindowAnimator 的动画执行也是在 AnimationThread 线程中的，Android P 增加了一个 SurfaceAnimationThread 来分担 AnimationThread 的部分工作，来提高 WindowAnimation 的动画性能</p><p><img src="/images/15808260775808.jpg" alt="-w657"></p><h3 id="FgThread"><a href="#FgThread" class="headerlink" title="FgThread"></a>FgThread</h3><p>com/android/server/FgThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">FgThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"android.fg"</span>, android.os.Process.THREAD_PRIORITY_DEFAULT, <span class="keyword">true</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Systrace 中的 FgThread<br><img src="/images/15808253825450.jpg" alt="-w1018"></p><p>FgThread 在源码中的使用，可以自己搜一下，下面是具体的使用的一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FgThread.getHandler().post(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStartedUsers.get(userIdToLockF) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"User was restarted, skipping key eviction"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mInjector.getStorageManager().lockUserKey(userIdToLockF);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException re) &#123;</span><br><span class="line">        <span class="keyword">throw</span> re.rethrowAsRuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (userIdToLockF == userId) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> KeyEvictedCallback callback : keyEvictedCallbacks) &#123;</span><br><span class="line">            callback.keyEvicted(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="SurfaceAnimationThread"><a href="#SurfaceAnimationThread" class="headerlink" title="SurfaceAnimationThread"></a>SurfaceAnimationThread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com/android/server/wm/SurfaceAnimationThread.java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SurfaceAnimationThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"android.anim.lf"</span>, THREAD_PRIORITY_DISPLAY, <span class="keyword">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Systrace 中的 SurfaceAnimationThread<br><img src="/images/15808254715766.jpg" alt="-w1148"></p><p>SurfaceAnimationThread 的名字叫 android.anim.lf ， 与 android.anim 有区别，<br><img src="/images/15808262588087.jpg" alt="-w657"></p><p>这个 Thread 主要是执行窗口动画，用于分担 android.anim 线程的一部分动画工作，减少由于锁导致的窗口动画卡顿问题，具体的内容可以看这篇文章：<a href="https://zhuanlan.zhihu.com/p/44864987" target="_blank" rel="noopener">Android P——LockFreeAnimation</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SurfaceAnimationRunner(<span class="meta">@Nullable</span> AnimationFrameCallbackProvider callbackProvider,</span><br><span class="line">        AnimatorFactory animatorFactory, Transaction frameTransaction,</span><br><span class="line">        PowerManagerInternal powerManagerInternal) &#123;</span><br><span class="line">    SurfaceAnimationThread.getHandler().runWithScissors(() -&gt; mChoreographer = getSfInstance(),</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* timeout */</span>);</span><br><span class="line">    mFrameTransaction = frameTransaction;</span><br><span class="line">    mAnimationHandler = <span class="keyword">new</span> AnimationHandler();</span><br><span class="line">    mAnimationHandler.setProvider(callbackProvider != <span class="keyword">null</span></span><br><span class="line">            ? callbackProvider</span><br><span class="line">            : <span class="keyword">new</span> SfVsyncFrameCallbackProvider(mChoreographer));</span><br><span class="line">    mAnimatorFactory = animatorFactory != <span class="keyword">null</span></span><br><span class="line">            ? animatorFactory</span><br><span class="line">            : SfValueAnimator::<span class="keyword">new</span>;</span><br><span class="line">    mPowerManagerInternal = powerManagerInternal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 -- Systrace 简介</title>
      <link href="/2019/05/28/Android-Systrace-About/"/>
      <url>/2019/05/28/Android-Systrace-About/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第一篇，主要是对 Systrace 进行简单介绍，介绍其简单使用方法；如何去看 Systrace；如何结合其他工具对 Systrace 中的现象进行分析。</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li><a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Systrace 是 Android4.1 中新增的性能数据采样和分析工具。它可帮助开发者收集 Android 关键子系统（如 SurfaceFlinger/SystemServer/Kernel/Input/Display 等 Framework 部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p><p>Systrace 的功能包括跟踪系统的 I/O 操作、内核工作队列、CPU 负载以及 Android 各个子系统的运行状况等。在 Android 平台中，它主要由3部分组成：</p><ul><li><strong>内核部分</strong>：Systrace 利用了 Linux Kernel 中的 ftrace 功能。所以，如果要使用 Systrace 的话，必须开启 kernel 中和 ftrace 相关的模块。</li><li><strong>数据采集部分</strong>：Android 定义了一个 Trace 类。应用程序可利用该类把统计信息输出给ftrace。同时，Android 还有一个 atrace 程序，它可以从 ftrace 中读取统计信息然后交给数据分析工具来处理。</li><li><strong>数据分析工具</strong>：Android 提供一个 systrace.py（ python 脚本文件，位于 Android SDK目录/platform-tools/systrace 中，其内部将调用 atrace 程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集 ftrace 统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace 是对 Linux Kernel中 ftrace 的封装。应用进程需要利用 Android 提供的 Trace 类来使用 Systrace.<br>关于 Systrace 的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" target="_blank" rel="noopener" title="SysTrace官方介绍">Systrace</a></li></ul><h2 id="Systrace简单使用"><a href="#Systrace简单使用" class="headerlink" title="Systrace简单使用"></a>Systrace简单使用</h2><p>使用 Systrace 前，要先了解一下 Systrace 在各个平台上的使用方法，鉴于大家使用Eclipse 和 Android Studio 的居多，所以直接摘抄官网关于这个的使用方法，不过不管是什么工具，流程是一样的：</p><ul><li>手机准备好你要进行抓取的界面</li><li>点击开始抓取(命令行的话就是开始执行命令)</li><li>手机上开始操作(不要太长时间)</li><li>设定好的时间到了之后，会将生成 Trace.html 文件，使用 <strong>Chrome</strong> 将这个文件打开进行分析</li></ul><p>一般抓到的 Systrace 文件如下<br><img src="/images//15618018036720.jpg" alt=""></p><h2 id="使用命令行工具抓取-Systrace"><a href="#使用命令行工具抓取-Systrace" class="headerlink" title="使用命令行工具抓取 Systrace"></a>使用命令行工具抓取 Systrace</h2><p>命令行形式比较灵活，速度也比较快，一次性配置好之后，以后再使用的时候就会很快就出结果（<strong>强烈推荐</strong>）<br>Systrace 工具在 Android-SDK 目录下的 platform-tools 里面,下面是简单的使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> android-sdk/platform-tools/systrace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python systrace.py</span></span><br></pre></td></tr></table></figure><p>可以在 Bash 中配置好对应的路径和 Alias，使用起来还是很快速的。另外 User 版本所抓的 Systrce 文件所包含的信息,是比 eng 版本或者 Userdebug 版本要少的,建议使用 Userdebug 版本的机器来进行 debug,这样既保证了性能,又能有比较详细的输出结果.</p><p>抓取结束后，会生成对应的 Trace.html 文件，注意这个文件只能被 Chrome 打开。关于如何分析 Trace 文件，我们下面的章节会讲。不论使用那种工具，在抓取之前都可以选择参数，下面说一下这些参数的意思：</p><ul><li><p><strong>-h</strong>, –help Show the help message.（帮助）</p></li><li><p><strong>-o</strong>  Write the HTML trace report to the specified file.（即输出文件名，）</p></li><li><p><strong>-t</strong> N, –time=N Trace activity for N seconds. The default value is 5 seconds. （Trace抓取的时间，一般是 ： -t 8）</p></li><li><p><strong>-b</strong> N, –buf-size=N Use a trace buffer size of N kilobytes. This option lets you limit the total size of the data collected during a trace.</p></li><li><p><strong>-k</strong></p></li><li><p><strong>—ktrace</strong>= Trace the activity of specific kernel functions, specified in a comma-separated list.</p></li><li><p><strong>-l</strong>, –list-categories List the available tracing category tags. The available tags are(下面的参数不用翻译了估计大家也看得懂，贴官方的解释也会比较权威，后面分析的时候我们会看到这些参数的作业的):</p><ul><li><strong>gfx</strong> - Graphics</li><li><strong>input</strong> - Input</li><li><strong>view</strong> - View</li><li>webview - WebView</li><li><strong>wm</strong> - Window Manager</li><li><strong>am</strong> - Activity Manager</li><li>audio - Audio</li><li>video - Video</li><li>camera - Camera</li><li>hal - Hardware Modules</li><li>res - Resource Loading</li><li><strong>dalvik</strong> - Dalvik VM</li><li>rs - RenderScript</li><li><strong>sched</strong> - CPU Scheduling</li><li><strong>freq</strong> - CPU Frequency</li><li><strong>membus</strong> - Memory Bus Utilization</li><li><strong>idle</strong> - CPU Idle</li><li><strong>disk</strong> - Disk input and output</li><li><strong>load</strong> - CPU Load</li><li><strong>sync</strong> - Synchronization Manager</li><li><strong>workq</strong> - Kernel Workqueues Note: Some trace categories are not supported on all devices. Tip: If you want to see the names of tasks in the trace output, you must include the sched category in your command parameters.</li></ul></li><li><p><strong>-a</strong></p></li><li><p><strong>—app</strong>= Enable tracing for applications, specified as a comma-separated list of package names. The apps must contain tracing instrumentation calls from the Trace class. For more information, see Analyzing Display and Performance.</p></li><li><p><strong>—link-assets</strong> Link to the original CSS or JavaScript resources instead of embedding them in the HTML trace report.</p></li><li><p><strong>—from-file</strong>= Create the interactive Systrace report from a file, instead of running a live trace.</p></li><li><p><strong>—asset-dir</strong>= Specify a directory for the trace report assets. This option is useful for maintaining a single set of assets for multiple Systrace reports.</p></li><li><p><strong>-e</strong></p></li><li><p><strong>—serial</strong>= Conduct the trace on a specific connected device, identified by its device serial number.<br>上面的参数虽然比较多，但使用工具的时候不需考虑这么多，在对应的项目前打钩即可，命令行的时候才会去手动加参数：</p></li></ul><p>我们一般会把这个命令配置成Alias，配置如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias st-<span class="keyword">start</span>=<span class="string">'python /sdk/platform-tools/systrace/systrace.py'</span>  </span><br><span class="line"><span class="keyword">alias</span> st-<span class="keyword">start</span>-gfx-<span class="keyword">trace</span> = ‘st-<span class="keyword">start</span> -t <span class="number">8</span> gfx <span class="keyword">input</span> <span class="keyword">view</span> sched freq wm am hwui workq res dalvik <span class="keyword">sync</span> disk <span class="keyword">load</span> perf hal rs idle mmc’</span><br></pre></td></tr></table></figure><p>这样在使用的时候，可以直接敲 <strong>st-start</strong> 即可，当然为了区分和保持各个文件，还需要加上 <strong>-o xxx.html</strong> .上面的命令和参数不必一次就理解，只需要记住如何简单使用即可，在分析的过程中，这些东西都会慢慢熟悉的。</p><p>一般来说比较常用的是</p><ol><li>-o : 指示输出文件的路径和名字</li><li>-t : 抓取时间(最新版本可以不用指定, 按 Enter 即可结束)</li><li>-b : 指定 buffer 大小 (一般情况下,默认的 Buffer 是够用的,如果你要抓很长的 Trae , 那么建议调大 Buffer )</li><li>-a : 指定 app 包名 (如果要 Debug 自定义的 Trace 点, 记得要加这个)</li></ol><h1 id="查看支持的-TAG"><a href="#查看支持的-TAG" class="headerlink" title="查看支持的 TAG"></a>查看支持的 TAG</h1><p>Systrace 默认支持的 TAG，可以通过下面的命令来进行抓取，不同厂商的机器可能有不同的配置，在使用的时候可以根据自己的需求来进行选择和配置，TAG 选的少的话，Trace 文件的体积也会相应的变小，但是抓取的内容也会相应变少。Trace 文件大小会影响其在 Chrome 中打开后的操作性能，所以这个需要自己取舍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> adb shell atrace --list_categories</span></span><br><span class="line">         gfx - Graphics</span><br><span class="line">       input - Input</span><br><span class="line">        view - View System</span><br><span class="line">     webview - WebView</span><br><span class="line">          wm - Window Manager</span><br><span class="line">          am - Activity Manager</span><br><span class="line">          sm - Sync Manager</span><br><span class="line">       audio - Audio</span><br><span class="line">       video - Video</span><br><span class="line">      camera - Camera</span><br><span class="line">         hal - Hardware Modules</span><br><span class="line">         res - Resource Loading</span><br><span class="line">      dalvik - Dalvik VM</span><br><span class="line">          rs - RenderScript</span><br><span class="line">      bionic - Bionic C Library</span><br><span class="line">       power - Power Management</span><br><span class="line">          pm - Package Manager</span><br><span class="line">          ss - System Server</span><br><span class="line">    database - Database</span><br><span class="line">     network - Network</span><br><span class="line">         adb - ADB</span><br><span class="line">    vibrator - Vibrator</span><br><span class="line">        aidl - AIDL calls</span><br><span class="line">       nnapi - NNAPI</span><br><span class="line">         rro - Runtime Resource Overlay</span><br><span class="line">  core_services - Core services</span><br><span class="line">         pdx - PDX services</span><br><span class="line">       sched - CPU Scheduling</span><br><span class="line">        freq - CPU Frequency</span><br><span class="line">        idle - CPU Idle</span><br><span class="line">        disk - Disk I/O</span><br><span class="line">        sync - Synchronization</span><br><span class="line">  memreclaim - Kernel Memory Reclaim</span><br><span class="line">  binder_driver - Binder Kernel driver</span><br><span class="line">  binder_lock - Binder global lock trace</span><br><span class="line">      memory - Memory</span><br><span class="line">        freq - CPU Frequency and System Clock (HAL)</span><br><span class="line">         gfx - Graphics (HAL)</span><br><span class="line">         ion - ION Allocation (HAL)</span><br><span class="line">       sched - CPU Scheduling and Trustzone (HAL)</span><br></pre></td></tr></table></figure><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace 基础知识 -- Why 60 fps ？</title>
      <link href="/2019/05/27/why-60-fps/"/>
      <url>/2019/05/27/why-60-fps/</url>
      
        <content type="html"><![CDATA[<p>本文是 Systrace 系列文章的第三篇，解释一下为何大家总是强调 60 fps。60 fps 是一个软件的概念，与屏幕刷新率里面提到的 60hz 是不一样的，可以参考这篇文章：<a href="https://www.androidperformance.com/2019/05/15/90hz-on-android/" target="_blank" rel="noopener">新的流畅体验，90Hz 漫谈</a></p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 的运行，从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天来讲一下为何我们讲到流畅度，要首先说 60 帧。</p><p>我们先来理一下基本的概念：</p><ol><li>60 fps 的意思是说，画面每秒更新60次</li><li>这60次更新，是要均匀更新的，不是说一会快，一会慢，那样视觉上也会觉得不流畅</li><li>每秒60次，也就是 1/60 ~= 16.67 ms 要更新一次</li></ol><p>在理解了上面的基本概念之后，我们再回到 Android 这边，为何 Android 现在的渲染机制，是使用 60 fps 作为标准呢？这主要和屏幕的刷新率有关。</p><!--more--><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>我们前面说的 60 fps，是针对软件的</li><li>这里说的屏幕的刷新率，是针对硬件的，现在大部分手机屏幕的刷新率，都维持在60 HZ，<strong>移动设备上一般使用60HZ，是因为移动设备对于功耗的要求更高，提高手机屏幕的刷新率，对于手机来说，逻辑功耗会随着频率的增加而线性增大，同时更高的刷新率，意味着更短的TFT数据写入时间，对屏幕设计来说难度更大。</strong></li><li>屏幕刷新率 60 HZ 只能说<strong>够用</strong>，在目前的情况下是最优解，但是未来肯定是高刷新率屏幕的天下，个人觉得主要依赖下面几点的突破：<ol start="4"><li>电池技术</li><li>软件技术</li><li>硬件能力</li></ol></li></ol><p>综上，目前的情况下， Android 的渲染机制是 16.67 ms 绘制一次， 60hz 的屏幕也是 16.67 ms 刷新一次，所以大家见到的 Android 手机，基本都是这个配置，目前阶段下的最优解。</p><h2 id="效果提升"><a href="#效果提升" class="headerlink" title="效果提升"></a>效果提升</h2><p>如果要提升，那么软件和硬件需要一起提升，光提升其中一个，是基本没有效果的，比如你屏幕刷新率是 75 hz，软件是 60 fps，每秒软件渲染60次，你刷新 75 次，是没有啥效果的，除了重复帧率费电；同样，如果你屏幕刷新率是 30 hz，软件是 60 fps，那么软件每秒绘制的60次有一半是没有显示就被抛弃了的。</p><p>如果你想体验120hz 刷新率的屏幕，建议你试试 ipad pro ，用过之后你会觉得，60 hz 的屏幕确实有改善的空间。</p><p>这一篇主要是简单介绍，如果你想更深入的去了解，可以去 Google 一下，另外 Google 出过一个短视频，介绍了 Why 60 fps， 有条件翻墙的同学可以去看看 ：</p><ol><li><a href="https://www.youtube.com/watch?v=CaMTIgxCSqU" target="_blank" rel="noopener">Why 60 fps</a></li><li><a href="https://www.youtube.com/watch?v=--OKrYxOb6Y" target="_blank" rel="noopener">玩游戏为何要60帧才流畅，电影却只需24帧</a></li></ol><p>下面这张图是 Android 应用在一帧内所需要完成的任务，后续我们还会详细讲这个：</p><p><img src="/images/media/15225938262396.jpg" alt="GPU Profile 的含义"></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Systrace -- 系列文章目录</title>
      <link href="/2019/05/26/Android_Systrace_0/"/>
      <url>/2019/05/26/Android_Systrace_0/</url>
      
        <content type="html"><![CDATA[<p>随着 Systrace 的功能越来越完善，加上 Android 版本的更迭，之前写的 Systrace 系列教程已经有点过时；另外随着自己技能的完善，从 Systrace 里挖掘了更多的信息，对解决各种性能问题很有帮助。这些技能我需要记录下来，增强自己的总结和归纳的能力，如果能帮助到看文章的人，也是极好的</p><p>本系列的目的是通过 Systrace 这个工具，从另外一个角度来看待 Android 系统整体的运行，同时也从另外一个角度来对 Framework 进行学习。也许你看了很多讲 Framework 的文章，但是总是记不住代码，或者不清楚其运行的流程，也许从 Systrace 这个图形化的角度，你可以理解的更深入一些。</p><a id="more"></a><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><p>本篇文章是一个目录，之后的文章更新后，会在这里进行汇总，内容如下：</p><ol><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 - Why 60 fps ？</a></li><li><a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="(https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/)">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li>Systrace 实战 - 分析应用冷启动时间问题</li><li>Systrace 实战 - 分析应用热启动时间问题</li><li>Systrace 实战 - 分析列表卡顿问题</li><li>Systrace 实战 - 分析窗口动画卡顿问题</li><li>Systrace 实战 - 分析进程乱跑导致的性能问题</li><li>Systrace 实战 - 分析 IO 导致的性能问题</li><li>Systrace 实战 - 分析 Memory 导致的性能问题</li><li>Systrace 实战 - Systrace 与 MethodTrace 结合使用</li><li>Systrace 实战 - 分析硬件加速问题</li></ol><p>目录暂定这么多，后续如果在写作的时候，有更新或者删减，都会在这里进行更新，本篇文章也会置顶一段时间</p><h2 id="面向读者群"><a href="#面向读者群" class="headerlink" title="面向读者群"></a>面向读者群</h2><p>本系列的文章既适用于应用开发者，也适用于系统开发者，我会在写作的时候兼顾两者。作为一名系统开发者，我大概理了一下我的优势：</p><ol><li>有系统源码，可以很方便地进行调试和修改代码，并随时在手机上看到结果</li><li>对系统框架有一定的了解</li><li>对系统调优有一定的了解</li></ol><p>基于上面几点，我在写作的时候也会利用这些优势，给大家带来不太一样的：</p><ol><li>通过 Systrace 来学习 Android Framework</li><li>修改某些系统配置，让大家看看结果：比如 Buffer 个数对应用的影响</li><li>介绍一些系统厂商在做系统的时候的考虑和取舍</li><li>介绍一些应用开发时候你不会注意但是很重要的点</li></ol><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>计划是每周更新一篇，给自己一个目标 ，给自己一个交代吧。</p><ol><li>2018-03-30 目录更新：<a href="https://androidperformance.com/2018/05/03/Android_Systrace_0.html">Systrace 系列文章目录</a></li><li>2018-04-01 更新文章：<a href="https://androidperformance.com/2018/04/01/why-60-fps.html">Systrace 基础知识 -  Why 60 fps ？</a></li><li>2019-07-23 更新文章：<a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li>2019-10-22 更新问题：<a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li>2019-11-04 更新文章：<a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li>2019-11-06 更新文章：<a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li>2019-12-01 更新文章：<a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 解读</a></li><li>2019-12-06 更新文章: <a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li>2019-12-15 更新文章：<a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li>2019-12-21 更新文章：<a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li>2020-02-04 更新文章：<a href="https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer/" target="_blank" rel="noopener">Systrace 基础知识 - SystemServer 解读</a></li><li>2020-02-14 更新文章：<a href="https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">Systrace 基础知识 - SurfaceFlinger 解读</a></li><li>2021-04-24 更新文章：<a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/" target="_blank" rel="noopener">Systrace 流畅性实战 1 ：了解卡顿原理</a></li><li>2021-04-24 更新文章：<a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2/" target="_blank" rel="noopener">Systrace 流畅性实战 2 ：案例分析: MIUI 桌面滑动卡顿分析</a></li><li>2021-04-24 更新文章：<a href="https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3/" target="_blank" rel="noopener">Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问</a></li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> Tools </tag>
            
            <tag> Systrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 新的流畅体验，90Hz 漫谈</title>
      <link href="/2019/05/15/90hz-on-android/"/>
      <url>/2019/05/15/90hz-on-android/</url>
      
        <content type="html"><![CDATA[<p>PC 上高刷新率屏幕很早就出来了，但是 Android 上高刷新率屏幕出现在 Android 手机上还只是这两年的事情，尽管雷蛇去年就推出了 120Hz 屏幕的手机，但是反响平平；而个人认为今年努比亚的红魔 3 和 OnePlus 的 7 Pro 推出的 90Hz 的屏幕才是 Android 手机目前这个阶段最好的选择，也是目前能显著提升用户体验的一个点。对高刷新率屏幕没啥概念的，可以去苹果体验店体验一下 120Hz 刷新率的 iPad Pro。</p><h1 id="技术术语解释"><a href="#技术术语解释" class="headerlink" title="技术术语解释"></a>技术术语解释</h1><h2 id="什么是屏幕刷新率-？"><a href="#什么是屏幕刷新率-？" class="headerlink" title="什么是屏幕刷新率 ？"></a>什么是屏幕刷新率 ？</h2><p>首先我们需要知道什么是屏幕刷新率，简单来说，屏幕刷新率是一个<strong>硬件</strong>的概念，是说屏幕这个硬件刷新画面的频率。</p><p>举例来说，60Hz 刷新率意思是：这个屏幕在 1 秒内，会刷新显示内容 60 次；那么对应的，90Hz 是说在 1 秒内刷新显示内容 90 次。至于显示的内容是什么，屏幕这边是不关心的，他只是从规定的地方取需要显示的内容，然后显示到屏幕上。</p><h2 id="什么是-FPS-？"><a href="#什么是-FPS-？" class="headerlink" title="什么是 FPS ？"></a>什么是 FPS ？</h2><p>首先需要说明的是 FPS 是一个<strong>软件</strong>的概念，与屏幕刷新率这个<strong>硬件</strong>概念要区分开，FPS 是由软件系统决定的。</p><p>FPS 是 Frame per Second 的缩写，意思是每秒产生画面的个数。举例来说，60FPS 指的是每秒产生 60 个画面；90FPS 指的是每秒产生 90 个画面。</p><h2 id="什么是-Vsync-？"><a href="#什么是-Vsync-？" class="headerlink" title="什么是 Vsync ？"></a>什么是 Vsync ？</h2><p>VSync 是垂直同期( Vertical Synchronization )的简称。基本的思路是将你的 FPS 和显示器的刷新率同期起来。其目的是避免一种称之为”撕裂”的现象.<br>对比 60 fps :<br>60 fps 的系统 , 1s 内需要生成 60 个可供显示的 Frame , 也就是说绘制一帧需要 16.67ms ( 1/60 ) , 才会不掉帧 ( FrameMiss ).<br>90 fps 的系统 , 1s 内生成 90 个可供显示的 Frame , 也就是说绘制一帧需要 11.11ms ( 1/90 ) , 才不会掉帧 ( FrameMiss ).</p><h2 id="什么是-Input-扫描周期-？"><a href="#什么是-Input-扫描周期-？" class="headerlink" title="什么是 Input 扫描周期 ？"></a>什么是 Input 扫描周期 ？</h2><p>Input 的扫描周期在 8 ms左右, 不同的手机会有不同, 由于 Android 系统的 Display 系统是以 Vsync 为基础的, Input 事件也是在 Vsync 到来的时候才会去处理.</p><p>所以当一个 Vsync 周期为 16.67ms , Input 周期为 8ms 的时候, 可以保证一个 Vsync 周期内存在 2 个 Input 点.<br>当一个 Vsync 周期为 11.11ms , Input 周期为 8ms 的时候, 一个 Vsync 周期内可能存在 2 个 Input 点. 也可能存在 1个 Input 点. 这会带来不均匀的 Input 体验.</p><h1 id="90Hz-用户体验"><a href="#90Hz-用户体验" class="headerlink" title="90Hz 用户体验"></a>90Hz 用户体验</h1><p>当<strong>屏幕刷新率</strong>和<strong>系统fps</strong>相对应的时候，才会带来最好的效果。从目前的硬件水平来看，90Hz 屏幕 + 90Fps 系统的组合才是目前最好的选择；其他的组合比如 90Hz 屏幕跑 60 fps 的系统，则会有屏幕刷新的时候，系统内容还没有准备好，只能显示上一帧这种情况；比如 60Hz 跑 90 fps 的系统，则会出现丢帧的情况，因为系统内容准备速度要比屏幕刷新速度快，势必有的帧绘制好却没有显示就被丢弃了。</p><p>另外 120Hz 的屏幕 + 120 fps 的系统肯定是未来发展的趋势，看看 iPad Pro 就知道了，但是目前的 Android 系统架构和硬件，都不足以支持 120Hz 的屏幕 + 120 fps 的系统，就算强行上，体验也会比较差，而且也会有很多的妥协。</p><p>相信到了 2020 年，120Hz 的屏幕 + 120 fps 的 Android 手机大家就可以买到了。</p><p>对比视频我们就直接看 OnePlus 的这个视频：<a href="https://weibo.com/tv/v/HusfeiEbX?fid=1034:4372578974817409" target="_blank" rel="noopener">90Hz 和 60Hz 屏幕使用对比</a></p><h1 id="从系统角度来看-90fps-的工作原理"><a href="#从系统角度来看-90fps-的工作原理" class="headerlink" title="从系统角度来看 90fps 的工作原理"></a>从系统角度来看 90fps 的工作原理</h1><p>简单来说，Android 系统在工作的时候，由下面几个步骤：</p><ol><li>事件触发，比如说用户点击图标，或者滑动 List</li><li>系统把事件分发给对应的 App，比如在桌面点击图标启动应用–对应点击事件，或者微信朋友圈滑动 – 对应滑动事件</li><li>App 拿到事件之后，对事件进行处理，不过有的是应用本身来处理，有的是系统帮忙处理，比如滑动事件的话，则会触发列表上下滑动，加载新的 Item 之类的</li><li>一旦 App 内容有更新，则会触发 App 的 measure、layout、draw 操作，开了硬件加速的话则会使用 RenderThread 进行这一帧的绘制，绘制好之后的 Buffer 会给到 SurfaceFlinger 进行合成</li><li>SurfaceFlinger 把各个图层合成后通过服务交到屏幕这边进行显示。</li></ol><p>需要说明的是，90fps 和 60fps 在流程上基本没有差别。</p><h2 id="90fps-下-App-的渲染流程"><a href="#90fps-下-App-的渲染流程" class="headerlink" title="90fps 下 App 的渲染流程"></a>90fps 下 App 的渲染流程</h2><p><img src="/images//15586889336528.jpg" alt="90fps 下 App 的渲染流程"><br>注: Systrace 是按照时间线从左到右展示</p><h2 id="90fps-下-SurfaceFlinger-的渲染流程"><a href="#90fps-下-SurfaceFlinger-的渲染流程" class="headerlink" title="90fps 下 SurfaceFlinger 的渲染流程"></a>90fps 下 SurfaceFlinger 的渲染流程</h2><p><img src="/images//15586889505177.jpg" alt="90fps 下 SurfaceFlinger 的渲染流程"><br>注: Systrace 是按照时间线从左到右展示</p><h1 id="90fps-的优势和挑战"><a href="#90fps-的优势和挑战" class="headerlink" title="90fps 的优势和挑战"></a>90fps 的优势和挑战</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>90fps 会带来更加顺滑的用户体验, 60fps 的时候, 1s 才更新 60 张图,这 60 张图在 1s 内顺序播放从而让人的视觉认为是连续的画面在播放 , 但是人眼会比较挑剔 , 所以当看多了 90 fps 的画面, 即每秒播放 90 张画面的时候, 再回去看 60 fps 就会觉得卡顿, 不连贯.</li><li>高刷新率屏幕使用习惯了，会没法适应低刷新率的屏幕，这是一个不可逆的过程，在挑选手机的时候需要注意这一点。</li><li>另外随着用户更换手机的频率变低，买一台一步到位的手机还是比较重要的，顶级屏幕 + 大电池 + 顶级 SOC + UFS + 大内存。今年下半年会有不少这样的机器出现，目前还在观望的同志可以再等等。 </li></ol><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><ol><li>性能<ol><li>90fps 的挑战主要在于性能, App 在 60fps 的时候, 只需要 App 和 SurfaceFlinger 把每一帧处理的时间控制在 16.6 ms之内, 就可以保证不会掉帧 (当然由于 Triple Buffer 的存在, 偶尔超过也不会掉)</li><li>到了 90fps , App 和 SF 都需要将一帧的时间压榨在 11.11ms 之内, 才可以保证不掉帧. 这里的两个挑战, 一个是 App 端, 一个是 SurfaceFlinger 及其相关的进程端 (加上 crtc 和 hw service).</li><li>由于对性能要求比较高,主要是对 cpu 的性能要求比较高 (其次是 io 和 gpu ) , 所以 90fps 需要更加强劲的硬件做支撑 (高通 855 , UFS 3.0 ), 这也是为什么到现在 90hz 的屏幕 + 90 fps 的系统才得以出现并提供良好的用户体验 ( OnePlus 7 Pro). (所以 120 fps 的雷蛇,需要把一帧的时间压在 8.3 ms , 其硬件性能是不足以支撑的.)</li></ol></li><li>功耗<ol><li>90Hz 的屏幕会比 60Hz 的屏幕更加耗电，尤其在高分辨率的情况下，所以优化好使用时功耗，是后续厂商需要考虑的问题。</li><li>有些场景和 App 是不支持 90fps 的，这时候可以把系统的 fps 降低到 60</li><li>有些场景用户为了省电，可以把屏幕分辨率从 2K 调整到 1080P</li></ol></li><li>App 适配<ol><li>大部分 App 不用做什么事情，就可以在 90 fps 的系统上跑，但是是否流畅就只能各自发挥了，有些写的好或者本身就不是很复杂的 app，跑起来就很顺畅，有些 App 则在 60 fps 下表现很好，但是到了 90 fps 下就比较差。</li><li>大部分游戏都是自主控制刷新率的，要在 90 fps 的系统下跑，需要游戏厂商进行针对性的优化，使其可以跑 90fps，也可以流畅跑 90 fps。</li><li>其他场景，比如 WebView，SurfaceView 这些，则需要根据内容来做调整。</li></ol></li></ol><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/66900738" target="_blank" rel="noopener">知乎 - 新的流畅体验，90Hz 漫谈</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 流畅度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利器 - 高效工具推荐</title>
      <link href="/2019/04/07/liqi/"/>
      <url>/2019/04/07/liqi/</url>
      
        <content type="html"><![CDATA[<p>之前很久就看到过<a href="https://mp.weixin.qq.com/s?__biz=MzA3NTgzNzU2NQ==&mid=400594784&idx=1&sn=a88b34faa7522206957d448d40ea0b31&scene=21#wechat_redirect" target="_blank" rel="noopener">利器社群计划</a>，看了大家的分享，学到了很多东西，正如开头所讲 “<strong>工具和灵感，都是利器。当来自不同的领域，不同类型的创造者的工具和灵感互相碰撞的时候，才会迸发出更多的可能性</strong>”。下面是我针对利器社群计划的6个问题的简单回答，希望有能帮助到大家的部分。</p><h2 id="介绍一下你自己和所做的工作？"><a href="#介绍一下你自己和所做的工作？" class="headerlink" title="介绍一下你自己和所做的工作？"></a>介绍一下你自己和所做的工作？</h2><p>我是一名 Android 系统开发工程师，在某手机厂商的系统研发部门。工作主要是负责 Android 系统相关的工作，比如性能、功耗、稳定性、框架维护等，工作比较杂，都是打杂的工作。<br>爱好方面，打篮球、跑步、打游戏这些程序员必备技能自然是不能少；读书、养猫、喝茶这些艺术青年的爱好也不落下；业余时间喜欢刷刷 B 站和 YouTube；有空了就把之前落下的没有完成的文章补全；目前沉迷于减肥，正在与小肚子做殊死斗争。</p><h2 id="你都在使用哪些硬件？"><a href="#你都在使用哪些硬件？" class="headerlink" title="你都在使用哪些硬件？"></a>你都在使用哪些硬件？</h2><p><strong>电脑</strong>：电脑主要有三台，一台 MacBook Pro 用来码字、写自己的小 App、处理照片等；一台公司配置的台式机，Ubuntu 系统，主要用来工作，编译 Android 源码必备；一台自己配的台式机，主要是用来玩游戏、编译 AOSP 代码。</p><p><strong>手机</strong>：手机有三台，主力机器是 <strong>iPhone X</strong>，除了续航其他的都很满意；备用机器是一台 <strong>OnePlus 6</strong>，Android 旗舰，Android 工程师还是得要有一台使用的 Android 机器的；另外一台是 <strong>Pixle</strong>，主要是来跑自己编译的 AOSP 代码的，业余学习框架必备。</p><p><strong>其他硬件</strong> ：Apple 家族的 Watch、iPad Pro、AirPods；索尼大法的无线耳机 MX-1000；Kindle Voyage，看电子书专用。</p><h2 id="软件呢？"><a href="#软件呢？" class="headerlink" title="软件呢？"></a>软件呢？</h2><ul><li><strong>Things3</strong>：主要是安排每天的工作、记录要做的事情</li><li><strong>MWeb</strong>：码字专用，此文就是用 MWeb 写的</li><li><strong>Keep</strong>：健身好帮手，有些课程跟着做就可以了，主要是记录，有时候有个目标，要比没有目标更好坚持一些，尤其是跑步的时候（推荐跑步机 HIT 训练）</li><li><strong>海豚记账本</strong>：记账软件，基本的需要。</li><li><strong>Kindle &amp;&amp; 微信读书 &amp;&amp;</strong>：读书软件，两个书库可以互补，电子书还是比较方便，尤其是用 iPad Pro 去看</li><li><strong>YouTube &amp;&amp; Bilibili</strong>：学习、娱乐，基本上就靠他了</li><li><strong>ShadowSocks &amp;&amp; Wingy</strong> ，Android 和 Mac 基本上都是用 ShadowSocks，手机和 iPad 用 Wingy，方便的是有个小插件，有时候软件被杀了，小插件开关很方便。</li><li><strong>极客时间 &amp;&amp; 得到</strong>：知识付费软件，三人行，则必有我师；个人觉得听听别人在做什么，做了什么，怎么做的，对自己的提升还是蛮大的，很多弯路不用去走。</li><li><strong>Google Photos</strong>：照片基本上都在这里，真怕有一天上不了了，估计要哭死..</li><li><strong>Reeder</strong>：之前维护了一个开发者的 <a href="https://github.com/Gracker/Rss-IT" target="_blank" rel="noopener">Feed 列表</a>，我自己是用 Reeder3 来看的。</li><li><strong>Android Studio &amp;&amp; VS Code</strong>：生产力软件，一个用来看 Framework Java代码，一个用来看 C\C++ 代码。</li><li><strong>RescueTime</strong>：主要是用来记录工作时间的，每天下来可以看自己的时间都花费在了哪里，全平台支持（不过 iOS 上只能看，不能记录，Mac 就可以记录，Android 和 Ubuntu 以及 Windows 都可以记录），有时候看看自己十几个小时的工作时间，简直欲哭无泪..</li><li><strong>石墨文档</strong>：记录自己的日报、周报、研究的一些内容，全平台支持，同步非常方便，多人协作效率也高，网页端最好用。</li><li><strong>坚果云</strong>：全平台支持的云盘，资料往上一丢，就再也不怕丢了（支持 Ubuntu 简直对程序员太友善了）</li><li><strong>印象笔记</strong>：之前用来记录，现在更多是用来当收藏中心，遇到好文章一般会记录到这里，回头再整理和复习，日常工作记录都交给石墨文档了。</li></ul><h2 id="你最理想的工作环境是什么？"><a href="#你最理想的工作环境是什么？" class="headerlink" title="你最理想的工作环境是什么？"></a>你最理想的工作环境是什么？</h2><p>最理想的工作环境是 Work Life Balance ，就像最近大火的 <a href="https://996.icu/#/zh_CN" target="_blank" rel="noopener">996 项目</a>里面说的，目前自身的工作状况也差不多，所以我更希望我的工作环境是<a href="https://github.com/formulahendry/955.WLB" target="_blank" rel="noopener"> 955.WLB </a>这个项目里面描述的，work–life balance。</p><p>996 给人最大的压力是没有自己的时间，去提升自己，每天忙到晚上十点十一点，回去洗个澡就睡了，什么健身、读书、学习这些，根本没有时间。正如这篇文章<a href="https://mp.weixin.qq.com/s/9-ZIoCvJmnYpkGpZBou4Dw" target="_blank" rel="noopener">废掉一个人最隐蔽的方式，是让他忙到没时间成长</a> 所说：</p><blockquote><p>如果一个人只是从工作过程中学习，那么这种单一的学习方式，必然导致它对成长的边际贡献越来越低。<br>每天一定要让自己有时间成长，其实是让你拓展除工作外的其它成长方式，你学习的方式多元化，对成长的边际贡献就越高，你的成长就越快。<br>一个人在职场里持续上升，必须要有持续的增量成长。</p></blockquote><p>总结来说，我最理想的工作环境：<strong>有志同道合的同事、有自己热爱的工作、有自身成长的空间和时间。</strong></p><h2 id="你平时获得工作灵感的方式有哪些？"><a href="#你平时获得工作灵感的方式有哪些？" class="headerlink" title="你平时获得工作灵感的方式有哪些？"></a>你平时获得工作灵感的方式有哪些？</h2><p>一个是阅读，从别人的思考里面提取精华，看看是否可以为我所用或者改进或者发扬光大；一个是思考和记录，边思考边画流程图，记录某个思想的火花。</p><p>不过效果都不怎么好，忙起来很少有时间阅读和思考，求各位大神指教。</p><h2 id="推荐一件生活中的利器给大家？"><a href="#推荐一件生活中的利器给大家？" class="headerlink" title="推荐一件生活中的利器给大家？"></a>推荐一件生活中的利器给大家？</h2><p>我最想推荐给大家的不是某个硬件或者软件，而是一种学习方式：<strong>记录-总结-输出</strong>。这三个环节环环相扣：</p><p><strong>记录</strong>：我们总说，好记性不如烂笔头，尤其是在现在这个信息爆炸的时代，有自己的一套记录方式显得尤其重要。待办事项、偶尔冒出来的奇怪念头、遇到的问题和解决的方法、在某个网站上看到的好文章、待更新的 Blog、YouTube 上的教学视频等等，记录会让你显得井井有条。</p><p><strong>总结</strong>：总结可以把之前零散的思路或者知识汇总到一起，清晰的脉络有助于从总体去看某个时期或者某个知识，比如项目总结可以让我们在后续的项目里面避免再走这个项目里面的坑；某个知识点的总结可以让我们从点到面了解这个知识，加深对这个知识的印象。</p><p><strong>输出</strong>：输出可以是私人笔记、Blog、视频，输出这个更多的是通过向别人讲述来强化自己。为了给别人讲清楚，自己要对输出的点非常熟悉；大家对于输出的讨论也会更加强化你对这个知识点的理解；输出也有助于帮助他人，同时提升自己的名气，你很强，你得让别人也知道你很强。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最近去了趟日本，赶上了樱花季，放一张樱花结束吧。<br><img src="/images/media/performancecase/15546301230322.jpg" alt="樱花"></p><blockquote><p>本文参与了「利器社群计划」，发现更多创造者和他们的工具：<a href="http://liqi.io/community/" target="_blank" rel="noopener">http://liqi.io/community/</a></p></blockquote><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 利器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 无障碍服务导致的整机卡顿案例分析</title>
      <link href="/2019/01/21/android-performance-case-jank-accessbility/"/>
      <url>/2019/01/21/android-performance-case-jank-accessbility/</url>
      
        <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>有用户反馈，手机在滑动的时候, 列表会一抖一抖的, 滑动桌面或者设置（只要是可以滑动的），都会出现，但是这个并不是必现，而是某些用户会出现，某些用户则不会出现。</p><p>吃瓜群众可以直接拉到下面看 罪魁祸首和自检 ，对分析问题比较感兴趣的可以看一下分析的过程。</p><h1 id="Systrace-分析"><a href="#Systrace-分析" class="headerlink" title="Systrace 分析"></a>Systrace 分析</h1><p>本地测试有一台复现, 拿过来之后分析发现,手指滑动桌面或者设置,都会必现卡顿, 从 Trace 上看就是下面这样<br><img src="/images/media/performancecase/15482434530990.jpg" alt=""></p><p>红色箭头处就是掉帧的地方. 从上面的 Buffer 个数可以看到, SF没有绘制的原因是 Launcher 没有提交 Buffer 上来.</p><p>对应的 Launcher Trace如下 , 可以看到 Launcher 没有绘制的原因是没有 Input 事件传上来. 所以 Launcher 的画面没有更新, 所以才会出现掉帧.<br><img src="/images/media/performancecase/15482435308066.jpg" alt=""></p><p>没有事件上来这个本身就是有问题的 , 我们手指是连续从屏幕上划过的, 事件的上报应该是连续的才对, 我们怀疑是屏幕报点有问题, 不过 Check 硬件之前我们首先看一下 InputReader 和 InputDispatcher 线程是否正常工作</p><p><img src="/images/media/performancecase/15482435458655.jpg" alt=""></p><p>从图中可以看到 InputReader 线程是正常工作的 , 但是 InputDIspatcher 线程却有问题, 大家可以看一下正常情况下这两个线程的对应关系</p><p><img src="/images/media/performancecase/15482435564755.jpg" alt=""></p><p>再回到有问题的那个图 , 仔细看发现 InputDispatcher 线程的周期是和 Vsync 是相同的, 也就是说, InputDispatcher 的唤醒逻辑由 InputReader 唤醒变为由 Vsync 唤醒</p><p>再仔细看的话，点开 InputDIspatcher 的线程 cpu 状态可以看到， 唤醒执行任务的 InputDispatcher 线程并不是被 InputReader 线程唤醒的, 而是被 System_Server 的 UI Thread 唤醒的.</p><p>那么接下来， 就需要从代码的角度来看为什么 InputReader 没有唤醒 InputDIspatcher 。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>InputReader 唤醒 InputDispatcher 线程的逻辑如下（以本例中的 Move 手势为例。），</p><p>frameworks/native/services/inputflinger/InputDispatcher.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::notifyMotion(<span class="keyword">const</span> NotifyMotionArgs* args) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!validateMotionEvent(args-&gt;action, args-&gt;actionButton,</span><br><span class="line">                args-&gt;pointerCount, args-&gt;pointerProperties)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> policyFlags = args-&gt;policyFlags;</span><br><span class="line">    policyFlags |= POLICY_FLAG_TRUSTED;</span><br><span class="line"></span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    mPolicy-&gt;interceptMotionBeforeQueueing(args-&gt;eventTime, <span class="comment">/*byref*/</span> policyFlags);</span><br><span class="line">    <span class="keyword">if</span> (t.duration() &gt; SLOW_INTERCEPTION_THRESHOLD) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Excessive delay in interceptMotionBeforeQueueing; took %s ms"</span>,</span><br><span class="line">                <span class="built_in">std</span>::to_string(t.duration().count()).c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> needWake; <span class="comment">//是否需要唤醒</span></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldSendMotionToInputFilterLocked(args)) &#123;</span><br><span class="line">            mLock.unlock();</span><br><span class="line"></span><br><span class="line">            MotionEvent event;</span><br><span class="line">            event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, args-&gt;actionButton,</span><br><span class="line">                    args-&gt;flags, args-&gt;edgeFlags, args-&gt;metaState, args-&gt;buttonState,</span><br><span class="line">                    <span class="number">0</span>, <span class="number">0</span>, args-&gt;xPrecision, args-&gt;yPrecision,</span><br><span class="line">                    args-&gt;downTime, args-&gt;eventTime,</span><br><span class="line">                    args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords);</span><br><span class="line"></span><br><span class="line">            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line">            <span class="comment">// SystemServer 上层要对事件进行过滤</span></span><br><span class="line">            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// event was consumed by the filter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Just enqueue a new motion event.</span></span><br><span class="line">        MotionEntry* newEntry = <span class="keyword">new</span> MotionEntry(args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                args-&gt;action, args-&gt;actionButton, args-&gt;flags,</span><br><span class="line">                args-&gt;metaState, args-&gt;buttonState,</span><br><span class="line">                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,</span><br><span class="line">                args-&gt;displayId,</span><br><span class="line">                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry); </span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意这里 ，mPolicy-&gt;filterInputEvent 直接 return了，也就是说这里如果返回 false，那么就直接 return 了， 不继续执行下面的步骤。</p><p>继续看 mPolicy-&gt;filterInputEvent</p><p>frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> NativeInputManager::filterInputEvent(<span class="keyword">const</span> InputEvent* inputEvent, <span class="keyword">uint32_t</span> policyFlags) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    jobject inputEventObj;</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line">    <span class="keyword">switch</span> (inputEvent-&gt;getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> AINPUT_EVENT_TYPE_KEY:</span><br><span class="line">        inputEventObj = android_view_KeyEvent_fromNative(env,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> KeyEvent*&gt;(inputEvent));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AINPUT_EVENT_TYPE_MOTION:</span><br><span class="line">        inputEventObj = android_view_MotionEvent_obtainAsCopy(env,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> MotionEvent*&gt;(inputEvent));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// dispatch the event normally</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The callee is responsible for recycling the event.</span></span><br><span class="line">    jboolean pass = env-&gt;CallBooleanMethod(mServiceObj, gServiceClassInfo.filterInputEvent,</span><br><span class="line">            inputEventObj, policyFlags);</span><br><span class="line">    <span class="keyword">if</span> (checkAndClearExceptionFromCallback(env, <span class="string">"filterInputEvent"</span>)) &#123;</span><br><span class="line">        pass = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;DeleteLocalRef(inputEventObj);</span><br><span class="line">    <span class="keyword">return</span> pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从 jni 调回到 java 层， 也就是 InputManagerService 的 filterInputEvent 方法。</p><p>com/android/server/input/InputManagerService.java</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native callback.</span></span><br><span class="line"><span class="function">final boolean <span class="title">filterInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">    synchronized (mInputFilterLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputFilter != null) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInputFilter.filterInputEvent(event, policyFlags);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">/* ignore */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    event.recycle();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟代码流程发现, 这个 mInputFilter 是 AccessibilityInputFilter 的一个实例, 在 辅助功能里面打开开关的时候,会调用 AccessibilityManagerService 的 updateInputFilter 方法来设置 InputFilter.</p><p>android/view/InputFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filterInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">    mH.obtainMessage(MSG_INPUT_EVENT, policyFlags, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MSG_INPUT_EVENT: &#123;</span><br><span class="line">    <span class="keyword">final</span> InputEvent event = (InputEvent)msg.obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInboundInputEventConsistencyVerifier.onInputEvent(event, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        onInputEvent(event, msg.arg1);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        event.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 onInputEvent(event, msg.arg1);<br>com/android/server/accessibility/AccessibilityInputFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"mEventHandler == null for event "</span> + event);</span><br><span class="line">        <span class="keyword">super</span>.onInputEvent(event, policyFlags);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventStreamState state = getEventStreamState(event);</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onInputEvent(event, policyFlags);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> eventSource = event.getSource();</span><br><span class="line">    <span class="keyword">if</span> ((policyFlags &amp; WindowManagerPolicy.FLAG_PASS_TO_USER) == <span class="number">0</span>) &#123;</span><br><span class="line">        state.reset();</span><br><span class="line">        mEventHandler.clearEvents(eventSource);</span><br><span class="line">        <span class="keyword">super</span>.onInputEvent(event, policyFlags);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.updateDeviceId(event.getDeviceId())) &#123;</span><br><span class="line">        mEventHandler.clearEvents(eventSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state.deviceIdValid()) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onInputEvent(event, policyFlags);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> MotionEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mEnabledFeatures &amp; FEATURES_AFFECTING_MOTION_EVENTS) != <span class="number">0</span>) &#123;</span><br><span class="line">            MotionEvent motionEvent = (MotionEvent) event;</span><br><span class="line">            processMotionEvent(state, motionEvent, policyFlags);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onInputEvent(event, policyFlags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">        KeyEvent keyEvent = (KeyEvent) event;</span><br><span class="line">        processKeyEvent(state, keyEvent, policyFlags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 processMotionEvent</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void processMotionEvent(EventStreamState <span class="keyword">state</span>, MotionEvent event, int policyFlags) &#123;</span><br><span class="line">    if (!<span class="keyword">state</span>.shouldProcessScroll() &amp;&amp; event.getActionMasked() == MotionEvent.ACTION_SCROLL) &#123;</span><br><span class="line">        super.<span class="keyword">on</span>InputEvent(event, policyFlags);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!<span class="keyword">state</span>.shouldProcessMotionEvent(event)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    batchMotionEvent(event, policyFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 batchMotionEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batchMotionEvent</span><span class="params">(MotionEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Batching event: "</span> + event + <span class="string">", policyFlags: "</span> + policyFlags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mEventQueue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mEventQueue = MotionEventHolder.obtain(event, policyFlags);</span><br><span class="line">        scheduleProcessBatchedEvents();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mEventQueue.event.addBatch(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MotionEventHolder holder = MotionEventHolder.obtain(event, policyFlags);</span><br><span class="line">    holder.next = mEventQueue;</span><br><span class="line">    mEventQueue.previous = holder;</span><br><span class="line">    mEventQueue = holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 scheduleProcessBatchedEvents</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleProcessBatchedEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mChoreographer.postCallback(Choreographer.CALLBACK_INPUT,</span><br><span class="line">            mProcessBatchedEventsRunnable, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在下一个 Vsync 周期的时候执行 mProcessBatchedEventsRunnable , 也就是 Choreographer.CALLBACK_INPUT ， 熟悉 Choregrapher 的同学应该知道这里在做什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mProcessBatchedEventsRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> frameTimeNanos = mChoreographer.getFrameTimeNanos();</span><br><span class="line">        &#125;</span><br><span class="line">        processBatchedEvents(frameTimeNanos);</span><br><span class="line">        <span class="keyword">if</span> (mEventQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleProcessBatchedEvents();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么代码在这里就比较清晰了， 是因为存在 AccessibilityInputFilter 导致 InputDIspatcher 线程没有被唤醒，而是把事件处理放到了下一个 Vsync 里面去处理。<br>结论</p><p>问题就在这个 Runnable 里面, 正常情况下, 如果没有打开 AccessibilityInputFilter , 那么上层不会对 Input 事件做任何的拦截, 一旦有 AccessibilityInputFilter , 那么就会走上面的逻辑, 这时候 InputDispatcher 不会跟着 InputReader 的节奏来走 , 而是跟着 Vsync 的节奏来走, 从  Trace 上也可看到这点;</p><p><img src="/images/media/performancecase/15482437370372.jpg" alt=""></p><p>那么这个 AccessibilityInputFilter 是从哪里来的呢？答案就是 Accessibility 服务，也就是常说的无障碍服务。</p><h1 id="罪魁祸首"><a href="#罪魁祸首" class="headerlink" title="罪魁祸首"></a>罪魁祸首</h1><p>经过上面的分析我们知道问题的原因是无障碍服务 ，无障碍服务的本质是为了服务哪些盲人之类的不方便操作的用户，但是某些 App 为了实现特定的功能，也加入了自己的 Accessibility 服务， 比如各大手机市场的“一键安装”功能，用户是方便了，但是用不好，也会有负面的作用，比如这一例，导致用户手机整机卡顿，不知道的用户，我估计都要退机了。</p><p>那么罪魁祸首是谁呢？目前发现有两个，一个讯飞输入法，一个是应用宝。打开 设置-系统-无障碍服务，可以看到里面的各种软件都有参与到，不过这个默认是关闭的，很多应用会引导用户去开启，许多用户不明所以，就稀里糊涂打开了。</p><p>无障碍服务页面如下：<br><img src="/images/media/performancecase/15482437928005.jpg" alt=""></p><p>关于无障碍服务有多NB，大家可以自己看看下面的弹框，这东西可以检测你的信用卡号和密码，至于短信内容、微信聊天内容那都是小 Case。</p><p><img src="/images/media/performancecase/15482438028084.jpg" alt=""></p><p>至于在这个例子里面引起整机卡顿的，就是下面这个 监听 ”执行手势“ 这个，一旦有应用监听这个的话， InputDIspatcher 线程就会走 Vsync 的周期，导致报点处理不及时，从而让滑动的对象以为这一帧没有事件进入，所以也没有内容的变更，就不会进行页面的更新，从而导致卡顿。<br><img src="/images/media/performancecase/15482438143185.jpg" alt=""></p><h1 id="自检"><a href="#自检" class="headerlink" title="自检"></a>自检</h1><p>如果你使用的是 Android 手机，强烈建议你关掉所有的无障碍服务（如果你不需要的话），像自动安装应用这种功能，不值得你为此付出这么大的风险。这个是 Android 原生的问题，我们在 Pixle 和 其他三方手机上都有发现这个问题。</p><ol><li><p>关闭路径：设置-系统-无障碍服务 ， 进去后把你已经打开的都关上。</p></li><li><p>强烈建议 <strong>应用宝、讯飞输入法</strong> ，不要监听手势事件。</p></li></ol><h1 id="本文知乎地址"><a href="#本文知乎地址" class="headerlink" title="本文知乎地址"></a>本文知乎地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎界面<br><a href="https://zhuanlan.zhihu.com/p/55585722" target="_blank" rel="noopener">知乎 - Android 平台应用宝和讯飞输入法无障碍服务导致的全局卡顿分析</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡顿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 年度好物推荐 - 给辛勤工作的自己一点奖励</title>
      <link href="/2019/01/12/recommend-of-2018/"/>
      <url>/2019/01/12/recommend-of-2018/</url>
      
        <content type="html"><![CDATA[<p>2018 年初写了一篇<a href="https://www.androidperformance.com/2018/01/06/2017%E5%B9%B4%E5%BA%A6%E6%9C%80%E6%8E%A8%E8%8D%90/" target="_blank" rel="noopener">&lt;2017 年度最推荐-给辛勤工作的自己一点奖励&gt;</a> , 最近有人问我今年是否会有 2018 年的年度推荐，我想了想，2018 年虽然不景气，但是还是有一些好东西可以推荐给大家，于是便有了这一篇文章。</p><p>跟 2017年一样，我会把 2018 年里面我觉得体验很棒或者对工作生活很有帮助的东西推荐给大家，或许 2019 你会需要他们。推荐的内容包含了 App、硬件、书籍、博客、专栏等，希望能帮助到看到这篇文章的你</p><a id="more"></a><h1 id="最推荐-App"><a href="#最推荐-App" class="headerlink" title="最推荐 App"></a>最推荐 App</h1><h2 id="Rescuetime"><a href="#Rescuetime" class="headerlink" title="Rescuetime"></a>Rescuetime</h2><p><a href="https://www.rescuetime.com/" target="_blank" rel="noopener">Rescuetime</a> 是一款记录时间花费的软件，它可以准确记录你每一天的时间都花在了哪里（需要安装对应的客户端）</p><p>比如你是一个程序员，你想知道自己每天的工作效率，那么使用 <a href="https://www.rescuetime.com/" target="_blank" rel="noopener">Rescuetime</a> 绝对是个好的选择，你可以清晰地看到每天都花了时间在哪里。比如我，每天的大部分时间都是在 Android-Studio、VSCode、Terminator。下面是我1月15号的截图：<br><img src="/images/recomend-2018/15478860621933.jpg" alt="-w1049"></p><p><img src="/images/recomend-2018/15478860883680.jpg" alt="-w692"></p><p>编程栏的详细信息<br><img src="/images/recomend-2018/15478861440328.jpg" alt="-w974"></p><p>有了上面的数据，你就知道自己每天在电脑上的时间都去哪里了。 这个软件基本上支持所有的平台，尤其是 Linux（不过 iOS上由于系统的原因，只能查看没法记录）。</p><h2 id="石墨文档"><a href="#石墨文档" class="headerlink" title="石墨文档"></a>石墨文档</h2><p>2018 年我记录每日的工作的软件从 MWeb 换成了<a href="https://shimo.im/" target="_blank" rel="noopener">石墨文档</a>，很大的原因是<a href="https://shimo.im/" target="_blank" rel="noopener">石墨文档</a>支持多平台（Mac、iOS、Android、微信小程序），最重要的是 Web 端也非常好用。这样我就可以实时进行记录和查看，分享也非常的方便，可以设置只读和可读可写，多人协作很方便。</p><p><img src="/images/recomend-2018/15478867439552.jpg" alt="-w973"></p><p><img src="/images/recomend-2018/15478866944155.jpg" alt="-w949"></p><p>另外一个原因是 ：一个笔记网页端对程序员最大的尊重，应该是能拦截 和处理 Ctrl+S，印象笔记这个方面做的就很不好，总是出现保存网页，石墨文档则会保存内容。</p><h2 id="坚果云"><a href="#坚果云" class="headerlink" title="坚果云"></a>坚果云</h2><p>坚果云是一款提供网盘|云盘|云服务的团队协助软件,可随时随地实现共享文件夹。坚果云网盘支持移动办公,协同办公,文件同步,数据备份,智能管理,在线编辑等功能。</p><p>目前在国内支持文件同步的软件，我找来找去，最终还是用了<a href="https://www.jianguoyun.com/#/" target="_blank" rel="noopener">坚果云</a>，很大原因是坚果云支持 Linux，在 Linux 下工作的时候，很多文件直接扔到坚果云的同步文件夹里面，其他各个平台就都有了，突出一个方便。</p><p><img src="/images/recomend-2018/15478871443953.jpg" alt="-w983"><br><img src="/images/recomend-2018/15478871670996.jpg" alt="-w953"></p><h1 id="最推荐技术书籍"><a href="#最推荐技术书籍" class="headerlink" title="最推荐技术书籍"></a>最推荐技术书籍</h1><h2 id="深入理解-Android-架构（第二版）"><a href="#深入理解-Android-架构（第二版）" class="headerlink" title="深入理解 Android 架构（第二版）"></a>深入理解 Android 架构（第二版）</h2><p><img src="/images/media/15152587790243.jpg" alt="深入理解 Android 内核设计思想"></p><p>算是系统开发的经典书了，这书今年出了第二版，加了一些新的内容。不管是应用开发工程师，还是系统开发工程师，多了解 Android 系统的架构和设计，对自己知识的深度是很有帮助的。</p><p>不过 Android 的版本发展实在是太快了，阅读此书建议配合最新的 Android 源代码。梳理流程的同时，也要深度思考设计思想。</p><blockquote><p>《深入理解Android内核设计思想》适用于 Android 4.3以上的版本。全书从操作系统的基础知识入手，全面剖析进程/线程、内存管理、Binderv机制、GUIv显示系统、多媒体管理、输入系统等核心技术在 Android 中的实现原理。书中讲述的知识点大部分来源于工程项目研发，因而具有较强的实用性，希望可以让读者“知其然，更知其所以然”。全书分为编译篇、系统原理篇、应用原理篇、系统工具篇共4篇22章，基本涵盖了参与Android开发所需具备的知识，并通过大量图片与实例来引导读者学习，以求尽量在源代码分析外为读者提供更易于理解的思维方式。</p></blockquote><blockquote><p>《深入理解Android内核设计思想》既适合 Android 系统工程师，也适合于应用开发工程师来阅读提升Android开发能力。读者可以在《深入理解vAndroidv内核设计思想》潜移默化的学习过程中更深刻地理解Android系统，并将所学知识自然地应用到实际开发难题的解决中。</p></blockquote><p>豆瓣 ： <a href="https://book.douban.com/subject/25921329/" target="_blank" rel="noopener">https://book.douban.com/subject/25921329/</a></p><h2 id="Android-进阶解密"><a href="#Android-进阶解密" class="headerlink" title="Android 进阶解密"></a>Android 进阶解密</h2><p><img src="/images/recomend-2018/15478811989772.jpg" alt="Android 进阶解密"></p><p>《Android进阶解密》是一本Android进阶书籍，主要针对Android 8.0系统源码并结合应用开发相关知识进行介绍。</p><p>《Android进阶解密》共分为17章，从3个方面来组织内容。 第一方面介绍Android应用开发所需要掌握的系统源码知识，第二方面介绍JNI、ClassLoader、Java虚拟机、DVM&amp;ART虚拟机和Hook等技术，第三方面介绍热修复原理、插件化原理、绘制优化和内存优化等与应用开发相关的知识点。3个方面有所关联并形成一个知识体系，从而使Android开发者能通过阅读本书达到融会贯通的目的。</p><p>《Android进阶解密》适合有一定基础的Android应用开发工程师、Android系统开发工程师和对Android系统源码感兴趣的读者阅读。</p><p>jd : <a href="https://item.jd.com/12447229.html" target="_blank" rel="noopener">https://item.jd.com/12447229.html</a></p><h2 id="奔跑吧-Linux-内核"><a href="#奔跑吧-Linux-内核" class="headerlink" title="奔跑吧 Linux 内核"></a>奔跑吧 Linux 内核</h2><p><img src="/images/media/15152591841672.jpg" alt="奔跑吧 Linux 内核"><br>Android 系统工程师必备。</p><p>本书内容基于Linux4.x内核，主要选取了Linux内核中比较基本和常用的内存管理、进程管理、并发与同步，以及中断管理这4个内核模块进行讲述。全书共分为6章，依次介绍了ARM体系结构、Linux内存管理、进程调度管理、并发与同步、中断管理、内核调试技巧等内容。本书的每节内容都是一个Linux内核的话题或者技术点，读者可以根据每小节前的问题进行思考，进而围绕问题进行内核源代码的分析。</p><p>本书内容丰富，讲解清晰透彻，不仅适合有一定Linux相关基础的人员，包括从事与Linux相关的开发人员、操作系统的研究人员、嵌入式开发人员及Android底层开发人员等学习和使用，而且适合作为对Linux感兴趣的程序员的学习用书，也可以作为大专院校相关专业师生的学习用书和培训学校的教材。</p><p>豆瓣 ： <a href="https://book.douban.com/subject/27108677/" target="_blank" rel="noopener">https://book.douban.com/subject/27108677/</a></p><h1 id="最推荐非技术书籍"><a href="#最推荐非技术书籍" class="headerlink" title="最推荐非技术书籍"></a>最推荐非技术书籍</h1><h2 id="镖人"><a href="#镖人" class="headerlink" title="镖人"></a>镖人</h2><p><img src="/images/recomend-2018/15478820694446.jpg" alt=""></p><p>目前出到了第五卷，豆瓣评分 8.3 的国漫，微信读书 5 卷全都有，非常方便看。</p><p><a href="https://book.douban.com/subject/30163844/" target="_blank" rel="noopener">《镖人》</a>，一部重现隋唐江湖的热血漫画！</p><p>大业三年（公元607年），隋王朝在隋炀帝杨广的残暴统治下民不聊生。身手不凡的镖客刀马行走于西域大漠，在躲避朝廷追杀的途中，他接下了一个目的地为首都长安的护送任务，本以为只是一趟简单的护镖，却没想到一路危机四伏，险象环生。一场牵动天下命运的旅途就此拉开帷幕……</p><p>豆瓣：<br><a href="https://book.douban.com/subject/30163844/" target="_blank" rel="noopener">《镖人1》</a><br><a href="https://book.douban.com/subject/30218904/" target="_blank" rel="noopener">《镖人2》</a><br><a href="https://book.douban.com/subject/30247517/" target="_blank" rel="noopener">《镖人3》</a><br><a href="https://book.douban.com/subject/30331243/" target="_blank" rel="noopener">《镖人4》</a><br><a href="https://book.douban.com/subject/30394166/" target="_blank" rel="noopener">《镖人5》</a></p><h2 id="大败局2"><a href="#大败局2" class="headerlink" title="大败局2"></a>大败局2</h2><p><img src="/images/recomend-2018/15478822095577.jpg" alt=""><br>之前读过<a href="https://book.douban.com/subject/1072438/" target="_blank" rel="noopener">《大败局1》</a>，被里面的故事深深的吸引，正如豆瓣评论：“三流的文笔，一流的现实。时代的洪流中，企业家、创始人，与赌徒并无区别。野心家迷失于成功的光环，却只能在惨败后看清自己。”</p><p><a href="https://book.douban.com/subject/25908390/" target="_blank" rel="noopener">《大败局2》</a>解读九大著名企业盛极而衰的失败原因：“中国第一饮料品牌”是如何陨落的？家电业最具现代气质的公司，是怎样被肢解和蹂躏的？中国民营企业的航母，为何会彻底沉没？股市庄家如何布下资本迷局？最具想象力的汽车革命为什么会一夜流产？房地产最大的黑马失陷何处？最低调的钢铁公司如何迎来最致命的打击？中药业的领头兵因何溃不成军？资本狂人究竟是在点燃全民的热情，还是在玩火自焚？</p><p>在<a href="https://book.douban.com/subject/25908390/" target="_blank" rel="noopener">《大败局2》</a>中，我们更多地看到了一种“工程师+赌徒”的商业人格模式。他们往往有较好的专业素养，在某些领域有超人的直觉和运营天赋，同时更有着不可遏制的豪情赌性，敢于在机遇降临的那一刻，倾命一搏。这是企业家职业中最惊心动魄的一跳，成者上天堂，败者落地狱，其微妙控制完全取决于天时、地利与人和等因素。</p><h2 id="程序员的修炼–从优秀到卓越"><a href="#程序员的修炼–从优秀到卓越" class="headerlink" title="程序员的修炼–从优秀到卓越"></a>程序员的修炼–从优秀到卓越</h2><p><img src="/images/recomend-2018/15478826704343.jpg" alt=""></p><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了 Coding Horror 博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web 设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下。</p><p>Jeff Atwood 于 2004 年创办 Coding Horror 博客，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近 10 万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞。</p><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折。</p><p>我的一些读书笔记：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><h1 id="最推荐公众号"><a href="#最推荐公众号" class="headerlink" title="最推荐公众号"></a>最推荐公众号</h1><ol><li>hongyangAndroid 鸿洋</li><li>Google_Developers 谷歌开发者</li><li>guolin_blog 郭霖</li><li>googdev 张奇</li><li>LinuxDev</li><li>hencoder 扔物线</li><li>androidperf ‘Android性能优化</li><li>nanchen_android 南尘</li><li>flutter-io</li><li>腾讯 Bugly</li></ol><h1 id="软件服务"><a href="#软件服务" class="headerlink" title="软件服务"></a>软件服务</h1><h2 id="微信读书会员"><a href="#微信读书会员" class="headerlink" title="微信读书会员"></a>微信读书会员</h2><p>今年付费会员里面感觉最值的，就是微信读书的年费会员了。年费会员可以免费看所有的付费出版物，包括听书。所以今年我的大部分的书都是在微信读书里面读的，所以我觉得这个会员办的很值，如果你是一位喜欢读书的人，那么办个会员吧。 我在微信读书读完的书包括</p><ol><li>《日据时期台湾与大陆关系史》</li><li>《软技能：代码之外的生存指南》</li><li>《大败局1》 + 《大败局2》</li><li>《八卦微积分》</li><li>《刻意练习》</li><li>《镖人1、2、3、4》</li><li>《谷物大脑》</li><li>《股权战争》</li><li>《深度学习》</li><li>《无缘社会》</li><li>《三体》</li><li>《图解 HTTP》</li><li>《万里十五年》</li><li>《黑客与画家》</li><li>《海湾战争中的地面作战》</li><li>《浅谈日本 IT 行业》</li><li>《骗局》</li><li>《柏林墙》</li><li>《万万没想到》</li><li>《硅谷钢铁侠》</li><li>《逃离德黑兰》</li><li>《芳华》</li></ol><h1 id="最推荐消费品"><a href="#最推荐消费品" class="headerlink" title="最推荐消费品"></a>最推荐消费品</h1><h2 id="12-9-iPad-pro"><a href="#12-9-iPad-pro" class="headerlink" title="12.9 iPad pro"></a>12.9 iPad pro</h2><p>2018 年的新版的 <a href="https://item.jd.com/100000206154.html" target="_blank" rel="noopener">iPad Pro</a> ，不论是在外观、性能、还是配置、价格，都是一个字：NB； 基本上可以拿来当电脑用，不论是看书、看剧、做笔记、看PDF 都非常的舒服，120 HZ 的刷新率简直是一种享受。</p><p>如果你计划入手 ipad 的话，强烈建议你入手这款，我自己的 iPad Pro 10.5 那版感觉屏幕有点小了。</p><p><img src="/images/recomend-2018/15478853976136.jpg" alt=""></p><h1 id="最推荐专栏"><a href="#最推荐专栏" class="headerlink" title="最推荐专栏"></a>最推荐专栏</h1><h2 id="极客时间-Android-开发高手课"><a href="#极客时间-Android-开发高手课" class="headerlink" title="极客时间 - Android 开发高手课"></a>极客时间 - Android 开发高手课</h2><p>《Android 开发高手课》是极客时间推出的专门为 Android 开发者定制的课程，专栏内容包括奔溃、内存、卡顿、启动、IO、存储、网络、耗电、UI、安装包体积等常见的复杂问题的原理分析和借鉴方法，非常值得 Android 开发工程师学习。</p><p>微信扫描下面的二维码即可加入学习<br><img src="/images/recomend-2018/15478836427121.jpg" alt=""></p><p><img src="/images/recomend-2018/15478835714307.jpg" alt=""></p><h2 id="极客时间-Linux-性能优化实战"><a href="#极客时间-Linux-性能优化实战" class="headerlink" title="极客时间 - Linux 性能优化实战"></a>极客时间 - Linux 性能优化实战</h2><p>《Linux 性能优化实战》是极客时间推出的面向 Linux 和 Android 底层开发者的课程，作者是微软 Azure 资深工程师。专栏中他会以案例驱动的思路，从实际问题触发，带你由浅入深学习一些基本的底层原理，掌握常见的性能指标和工具，学习实际工作中的优化技巧，让你可以准确分析和优化大多数性能问题。</p><p>微信扫描下面的二维码即可加入学习<br><img src="/images/recomend-2018/15478839286830.jpg" alt=""></p><p>其目录如下：<br><img src="/images/recomend-2018/15478838836765.jpg" alt=""></p><h2 id="得到-香帅的北大金融学课"><a href="#得到-香帅的北大金融学课" class="headerlink" title="得到 - 香帅的北大金融学课"></a>得到 - 香帅的北大金融学课</h2><p>香帅，真名唐涯，北京大学光华管理学院金融系副教授、博士生导师。香帅承诺用一年的时间，让你透彻掌握金融学的核心知识、全面理解金融学的架构和本质，建立一套完整的金融学思维。内容包好近日世界观、金融机构、工具与市场、投资者决策、公司决策、监管创新与危机、科技金融、金融术与道。</p><p>听这门课，记得老老实实做笔记。</p><p>其目录如下<br><img src="/images/recomend-2018/15478843588502.jpg" alt=""></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 系统开发源码环境搭建</title>
      <link href="/2018/11/01/android-system-develop-0/"/>
      <url>/2018/11/01/android-system-develop-0/</url>
      
        <content type="html"><![CDATA[<p>不管是 Android App 开发工程师还是 Android 系统开发工程师，对 Android 系统有一定的了解是很有必要的，正好我这几天在家里搭建了个开发环境，把过程分享出来，有需要的人可以看一下。</p><p>大概的步骤包含下面几个：</p><ol><li>安装 Ubuntu 系统</li><li>配置 Ubuntu 系统</li><li>安装必备的软件</li><li>配置 VPN (可选)</li><li>下载 AOSP 代码</li><li>配置编译环境并编译 Pixel 的代码</li><li>刷机</li><li>修改和编译 Framework 、Service、Res</li></ol><p>建议准备下面的硬件，当然没有也没关系，有了更好</p><ol><li>PC 或者笔记本</li><li>512GB 的 SSD</li><li>Pixel 手机一台</li></ol><h1 id="安装-Ubuntu-系统"><a href="#安装-Ubuntu-系统" class="headerlink" title="安装 Ubuntu 系统"></a>安装 Ubuntu 系统</h1><p>Linux 这边我建议用 Ubuntu 系统，不建议用虚拟机，直接安装一个新的 Ubuntu 系统会比较好，Ubuntu 目前最新的 LTS 版本是 18.04，目前安装 Ubuntu 的步骤会比较简单：</p><ol><li>下载 Ubuntu18.04 版本:<a href="http://mirrors.opencas.cn/ubuntu-releases/18.04.1/ubuntu-18.04.1-desktop-amd64.iso" target="_blank" rel="noopener">ubuntu 18.04</a></li><li>使用 Ubuntu 推荐的工具做一个 U 盘启动盘</li><li>使用 U 盘安装 Ubuntu 系统</li></ol><p><img src="/images/android-system/mydesktop.png" alt="mydesktop"></p><h1 id="配置-Ubuntu-系统"><a href="#配置-Ubuntu-系统" class="headerlink" title="配置 Ubuntu 系统"></a>配置 Ubuntu 系统</h1><ol><li>安装搜狗输入法</li><li>安装 vim ：sudo apt install vim</li><li>安装 adb </li><li>安装 fastboot</li></ol><h1 id="安装必备的软件"><a href="#安装必备的软件" class="headerlink" title="安装必备的软件"></a>安装必备的软件</h1><ol><li>VS Code</li><li>Android Studio</li><li>Meld</li><li>Wine</li><li>WPS</li></ol><h1 id="配置-VPN-可选"><a href="#配置-VPN-可选" class="headerlink" title="配置 VPN (可选)"></a>配置 VPN (可选)</h1><ol><li>ShadowSocks</li></ol><h1 id="下载-AOSP-代码"><a href="#下载-AOSP-代码" class="headerlink" title="下载 AOSP 代码"></a>下载 AOSP 代码</h1><p>没有 v-p-n 的话，推荐使用清华的镜像站：<a href="https://mirror.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/AOSP/</a></p><h2 id="repo-下载"><a href="#repo-下载" class="headerlink" title="repo 下载   "></a>repo 下载   </h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~<span class="string">/bin</span></span><br><span class="line">PATH=~<span class="string">/bin</span>:$PATH</span><br><span class="line">curl https:<span class="string">//storage.googleapis.com/git-repo-downloads/repo</span> &gt; ~<span class="string">/bin/repo</span></span><br><span class="line">chmod a+x ~<span class="string">/bin/repo</span></span><br></pre></td></tr></table></figure><h2 id="建立工作目录"><a href="#建立工作目录" class="headerlink" title="建立工作目录"></a>建立工作目录</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> WORKING_DIRECTORY</span><br><span class="line"><span class="built_in">cd</span> WORKING_DIRECTORY</span><br></pre></td></tr></table></figure><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https:<span class="regexp">//</span>aosp.tuna.tsinghua.edu.cn<span class="regexp">/platform/m</span>anifest</span><br></pre></td></tr></table></figure><h2 id="下载代码（-c-–no-tags-能下载更少的代码）"><a href="#下载代码（-c-–no-tags-能下载更少的代码）" class="headerlink" title="下载代码（-c –no-tags 能下载更少的代码）"></a>下载代码（-c –no-tags 能下载更少的代码）</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo <span class="keyword">sync</span> -<span class="keyword">c</span> --<span class="keyword">no</span>-<span class="keyword">tags</span></span><br></pre></td></tr></table></figure><h1 id="配置编译环境并编译-Pixel-的代码"><a href="#配置编译环境并编译-Pixel-的代码" class="headerlink" title="配置编译环境并编译 Pixel 的代码"></a>配置编译环境并编译 Pixel 的代码</h1><h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install openjdk-8-jdk</span><br></pre></td></tr></table></figure><h3 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install git-core gnupg flex bison gperf build-essential zip curl zlib1g-<span class="built_in">dev</span> gcc-multilib g++-multilib libc6-<span class="built_in">dev</span>-i386 lib32ncurses5-<span class="built_in">dev</span> x11proto-core-<span class="built_in">dev</span> libx11-<span class="built_in">dev</span> lib32z-<span class="built_in">dev</span> libgl1-mesa-<span class="built_in">dev</span> libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure><h2 id="下载-Pixle-的驱动"><a href="#下载-Pixle-的驱动" class="headerlink" title="下载 Pixle 的驱动"></a>下载 Pixle 的驱动</h2><p>编译 Android Master 的代码的话，需要下载对应的手机的驱动，在这个页面找到自己需要的驱动：<br><a href="https://developers.google.cn/android/blobs-preview" target="_blank" rel="noopener">https://developers.google.cn/android/blobs-preview</a><br><a href="/images/android-system/extract-qcom-sailfish.">extract-qcom-sailfish</a></p><p>解压如下：<br><img src="media/extract-google_devices-sailfish-1.png" alt="extract-google_devices-sailfish"></p><h2 id="编译-Pixle-的系统镜像"><a href="#编译-Pixle-的系统镜像" class="headerlink" title="编译 Pixle 的系统镜像"></a>编译 Pixle 的系统镜像</h2><p>在源码根目录下执行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> build/envsetup.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>执行下面的命令选择要编译的手机型号和版本（user、userdebug、eng）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lunch</span></span><br></pre></td></tr></table></figure><p><img src="/images/android-system/lunch.png" alt="lunch"></p><p>选择好了之后，输入对应的数字或者数字后面的,执行 make 开始编译（可选择加 -j4，4带代表线程数，机器性能好的话可以8或者16，看cpu）：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> -j8</span><br></pre></td></tr></table></figure><p><img src="/images/android-system/make-j8.png" alt="make-j8"></p><h2 id="编译成功"><a href="#编译成功" class="headerlink" title="编译成功"></a>编译成功</h2><p>out 目录会生成对应的 image<br><img src="/images/android-system/out_folder.png" alt="out_folde"></p><h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><p>在源码根目录下，执行下面的命令,即可刷入对应的系统到</p><p><img src="/images/android-system/fastboot.png" alt="fastboot"></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastboot flashall</span></span><br></pre></td></tr></table></figure><p><img src="/images/android-system/fastboot-flashall.png" alt="fastboot-flashal"></p><h1 id="修改和编译-Framework-、Service、Res"><a href="#修改和编译-Framework-、Service、Res" class="headerlink" title="修改和编译 Framework 、Service、Res"></a>修改和编译 Framework 、Service、Res</h1><p>以下命令都在源码根目录下执行</p><h2 id="修改代码-IDE"><a href="#修改代码-IDE" class="headerlink" title="修改代码 IDE"></a>修改代码 IDE</h2><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><p>java 代码推荐使用 AndroidStudio 打开、编辑</p><h3 id="c-cpp代码"><a href="#c-cpp代码" class="headerlink" title="c/cpp代码"></a>c/cpp代码</h3><p>c/cpp 代码推荐使用 SourceInsight 、Eclipse、VS Code 打开、编辑</p><h2 id="编译-Framework"><a href="#编译-Framework" class="headerlink" title="编译 Framework"></a>编译 Framework</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmm framework/<span class="keyword">base</span></span><br></pre></td></tr></table></figure><h2 id="编译-Services"><a href="#编译-Services" class="headerlink" title="编译 Services"></a>编译 Services</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmm frameworks<span class="regexp">/base/</span>services</span><br></pre></td></tr></table></figure><h2 id="编译-res"><a href="#编译-res" class="headerlink" title="编译 res"></a>编译 res</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmm frameworks<span class="regexp">/base/</span>core<span class="regexp">/res</span></span><br></pre></td></tr></table></figure><h2 id="root-amp-amp-remount"><a href="#root-amp-amp-remount" class="headerlink" title="root &amp;&amp; remount"></a>root &amp;&amp; remount</h2><p><img src="/images/android-system/root--remount.png" alt="root--remount"></p><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>root &amp;&amp; remount 之后，就可以把对应的 framework、Services、Res 等 push 进去，重启 shell 即可生效,或者直接 adb sync system 即可, sync system 会把 out目录下对应机型的 system 目录和手机的 system 目录进行同步，很是方便。</p><p>例子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb root &amp;&amp; adb remount &amp;&amp; adb shell stop &amp;&amp; adb sync<span class="built_in"> system </span>&amp;&amp; adb shell start</span><br></pre></td></tr></table></figure><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Framework </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Framework </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陆奇：除了好代码，工程师怎样才算优秀？</title>
      <link href="/2018/10/25/How-do-engineers-count-well/"/>
      <url>/2018/10/25/How-do-engineers-count-well/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自：百度Family，内容为陆奇 2017 年 7 月 的百度内部分享，非常值得技术人员学习和思考</p></blockquote><p>个人非常崇拜<a href="https://zh.wikipedia.org/wiki/%E9%99%B8%E5%A5%87" target="_blank" rel="noopener">陆奇</a>,  “陆奇以精力旺盛著称，通常凌晨4点起床，先查邮件，然后在跑步机上跑4英里，边跑边听古典音乐或看新闻。早上5点至6点就办公室，利用这段时间不受别人干扰准备一天的工作，然后一直工作到晚上10点，有时也会在半夜给同事发电子邮件。LinkedIn CEO 杰夫·维纳(Jeff Weiner)曾在雅虎与陆奇共事多年，他开始以为这种日程安排无法持久，后来不得不说：“陆奇的确是我所见过最有干劲的人。”前雅虎工程师阿米特·库玛尔(Amit Kumar)也夸奖陆奇人缘好。陆奇说：“我不觉得累，我热爱每天的工作。”陆奇获有20项美国专利。”</p><p><img src="/images/media/15404360836694.jpg" alt="陆奇"></p><p>陆奇的演讲核心思想可以归纳为下面五个点，我把它贴在了书房的墙上，时刻提醒自己。</p><blockquote><ol><li>“我们一定要有一个坚定不移的深刻的理念，相信整个世界终究是为技术所驱动的。”</li><li>“有没有其他人已经解决这个问题？然后你可以把你的时间放在更好的创新上。” </li><li>“做什么事情一定要做最好，一定要是做业界最强的。”</li><li>“我把自己想象是一个软件、一个代码，今天的版本一定要比昨天版本好，明天的版本肯定会比今天好。”</li><li>“看到问题也不要去问别人，就把它 Fix。”</li></ol></blockquote><h1 id="Believe-in-技术"><a href="#Believe-in-技术" class="headerlink" title="Believe in 技术"></a>Believe in 技术</h1><p>首先要相信技术，我刚才已经讲了，整个我们工业界，特别是像百度这样的公司，对技术坚定的、不动摇的信念特别重要。</p><p>我也分享一下，盖茨提到微软公司的宗旨就是：写软件代表的是世界的将来。</p><p>为什么？未来任何一个工业都会变成软件工业。盖茨是对的，因为任何工业任何行业自动化的程度会越来越高，最后你所处理的就是信息和知识。</p><p>但现在软件的做法又往前提了一次，因为在人工智能时代，不光是写代码，你必须懂算法，懂硬件，懂数据，整个人工智能的开发过程有一个很大程度的提高，但是，技术，特别是我们这个工业所代表的技术一定是将来任何工业的前沿。</p><p>所以我们一定要有一个坚定不移的深刻的理念，<strong>相信整个世界终究是为技术所驱动的</strong>。</p><h1 id="站在巨人的肩膀上做创新"><a href="#站在巨人的肩膀上做创新" class="headerlink" title="站在巨人的肩膀上做创新"></a>站在巨人的肩膀上做创新</h1><p>我们观察一下，在美国硅谷、在中国，互联网创业公司也好，大型公司也好，大家的起点是越来越高的。为什么现在创新速度那么快？主要是起点高了。我们可以使用的代码模块，使用的服务的能力，都是大大的提升。</p><p>在内部我想强调这一点，很多大公司包括微软在内，内部的Code都重做了无数遍。</p><p>我现在的要求是，<strong>每一次你写一行新的代码，第一要做的，先想一想你这行代码值得不值得写，是不是有人已经做了同样的工作，可能做得比你还好一点。有没有其他人已经解决这个问题，然后你可以把你的时间放在更好的创新上。</strong></p><p>特别是大公司里面重复或者是几乎重复的Code实在太多，浪费太多的资源，对每个人的职业生涯都不是好事情。</p><p>我再强调，在大公司内部，你写代码之前想一想，你这行代码要不要写，是不是别人已经有了，站在别人的肩膀上去做这件事情。</p><h1 id="追求Engineering-Excellence"><a href="#追求Engineering-Excellence" class="headerlink" title="追求Engineering Excellence"></a>追求Engineering Excellence</h1><p>我要另外强调的一点就是Engineering Excellence，工程的技术的卓越性和能力。</p><p>任何市场上竞争就像打仗一样，就看你的部队体能、质量，每一个士兵他的训练的程度，和你给他使机关枪、坦克，还是什么样的武器。</p><p>所以Engineering Excellence跟这个类比，我们要建的是一支世界上最强的部队，每一个士兵，每一个领军人，每个人的能力，他的训练都是超强的，然后我们给每个人提供的工具和武器都是一流的。</p><p>所以 Engineering Excellence 是一个永无止境的、个人的、团队的，能力的追求和工具平台的创新，综合在一起可以给我们带来的长期的、核心的竞争力，为社会创造价值，最终的目的是给每个用户、每个企业、整个社会创造价值。</p><p>我另外还要在这里强调的一点就是 Relentless pursuit of excellence：<strong>永无止境的不断的持续的追求。</strong></p><p><strong>我们要么不做，要做的事情一定做最好</strong>，这是我对大家的要求。数据库也好，做大平台也好，大数据也好，我们要做什么事情，我们一定要下决心，这是我对你们每个人的要求，做什么事情一定要做最好，一定要是做业界最强的。</p><h1 id="每天学习"><a href="#每天学习" class="headerlink" title="每天学习"></a>每天学习</h1><p>每天学习，可能是对每个人都是最最重要的。</p><p>我今天分享一下，我自己怎么想我自己的。就很简单一个概念，我把自己想象是一个软件、一个代码，今天的版本一定要比昨天版本好，明天的版本肯定会比今天好，因为即使犯了错误，我里面有If statement，说如果见到这个错误，绝对不要再犯。</p><p>英语，另外有一句说法就是Life is too short, don’t live the same day twice. 同样一天不要重活两次。每天都是不一样，每天为什么不一样，因为每天都变成最好，每天都变得更好。今天的版本一定要比昨天好，每个好的、杰出的工程师，杰出的技术领袖，一定要保持自己学习的能力，特别是学习的范围。</p><p>在这上面我也稍微引申一下，做Computer science的，如果只学Computer science，不去学一些其他的行业，肯定不够。我举个例子，经济学必须要学。为什么这样讲？Computer science它有个很大的限制，他是假定你有输入以后有输出，这种解决问题的方式有它的好处，但有它的限制性。</p><p>我给大家举个例子，地图导航，如果你纯粹用这个方式去做，你只是把一个拥挤的地方移到另外一个拥挤的地方。经济学，它对问题的建模是不一样的。它起点是假定是一个整体的一个生态，每个人的输入都是另外一个人的输出，你要用经济学的方式来描述地图导航的问题，你就会去算一个Equilibrium，市场也是这样。</p><p>如果把深度学习真的要想彻底，必须把物理重学一遍，把生物学看一遍，再把进化论再看一遍。因为深度学习跟这些东西完全相关，自己肯定想不清楚，要彻底想清楚，必须学。</p><p>另外，学产品，我以前跟所有的工程师都讲，如果不懂产品，你不可能成为一个最好的工程师。真正要做世界一流的工程师不光要懂产品，还要懂整个商业，懂生态。因为你的工作的责任，是能够看到将来，把技术展望到将来的需求，把平台、把开发流程、把你的团队为将来做准备。所以学习是非常非常重要的。</p><h1 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h1><p>最后是从我做起。</p><p>我们公司有个非常大的使命，用科技让复杂的世界更简单。整个世界非常非常复杂，人其实所做的事情基本上都是Reduce entropy。</p><p>因为从热力学第二定律来讲，世界是会变得越来越乱的，我们想做的事情就是把它变的更简单，让我们生活变得更美好。</p><p>而且具体的，我们可以通过人工智能技术来做到唤醒万物，但是这一切是通过每一个人的一点一滴的行为累计起来，从我做起。还有Ownership，看到机会不需要问别人，有机会就去做，看到问题也不要去问别人，就把它Fix。</p><p>把我们的使命、把我们的公司当成我们自己每个人的事业来做，我可以坦诚的给每个人讲，如果你把公司的使命，把公司的事业，当成你自己个人的事业，Own everything，你在职业生涯一定是走得最快。从我做起，从身边的每一件事情做起。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的修炼-08-阅读之美</title>
      <link href="/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/"/>
      <url>/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/</url>
      
        <content type="html"><![CDATA[<p>本文是 &lt;程序员的修炼-从优秀到卓越&gt; 的读书笔记的第八篇，这本书的作者是 Jeff Atwood，StackOverflow 的创始人之一，Jeff 的文章涉及面很广，他是一个经验老道的程序员、管理者、创业者，这本书谈到了编程之外的很多东西，不管你是初级工程师，还是资深工程师，本书都值得一读。随着你的阅历的增加，每一次重读这本书，都会有不一样的感悟，正如书名“从优秀到卓越”，作者为你指明了道路，至于是否能成功，则要看自己的修炼了。</p><p>我会把读书过程中一些精彩的言论摘录下来，有时会加入一些自己的见解或者经历，读书笔记的大纲与书本身的大纲是一致的，这也是我从另外一个地方学到并一直在用的“如何阅读一本书”，记录下来方便自己经常查看，也方便读者查看。下面是&lt;程序员的修炼-从优秀到卓越&gt; 读书笔记系列：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><hr><h1 id="不读书，谁之过"><a href="#不读书，谁之过" class="headerlink" title="不读书，谁之过"></a>不读书，谁之过</h1><h1 id="自助者，天助之"><a href="#自助者，天助之" class="headerlink" title="自助者，天助之"></a>自助者，天助之</h1><h1 id="计算机犯罪的历史与现状"><a href="#计算机犯罪的历史与现状" class="headerlink" title="计算机犯罪的历史与现状"></a>计算机犯罪的历史与现状</h1><h1 id="如何与人交流"><a href="#如何与人交流" class="headerlink" title="如何与人交流"></a>如何与人交流</h1><h1 id="勤练基本功"><a href="#勤练基本功" class="headerlink" title="勤练基本功"></a>勤练基本功</h1><hr><blockquote><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了Coding Horror博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下—— from 豆瓣</p></blockquote><blockquote><p>Jeff Atwood于2004年创办Coding Horror博客(.codinghorror.)，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近10万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞 —— from 豆瓣</p></blockquote><blockquote><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折 —— from 豆瓣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的修炼 </tag>
            
            <tag> 阅读之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的修炼-07-游戏与编程</title>
      <link href="/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/"/>
      <url>/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/</url>
      
        <content type="html"><![CDATA[<p>本文是 &lt;程序员的修炼-从优秀到卓越&gt; 的读书笔记的第七篇，这本书的作者是 Jeff Atwood，StackOverflow 的创始人之一，Jeff 的文章涉及面很广，他是一个经验老道的程序员、管理者、创业者，这本书谈到了编程之外的很多东西，不管你是初级工程师，还是资深工程师，本书都值得一读。随着你的阅历的增加，每一次重读这本书，都会有不一样的感悟，正如书名“从优秀到卓越”，作者为你指明了道路，至于是否能成功，则要看自己的修炼了。</p><p>我会把读书过程中一些精彩的言论摘录下来，有时会加入一些自己的见解或者经历，读书笔记的大纲与书本身的大纲是一致的，这也是我从另外一个地方学到并一直在用的“如何阅读一本书”，记录下来方便自己经常查看，也方便读者查看。下面是&lt;程序员的修炼-从优秀到卓越&gt; 读书笔记系列：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><hr><h1 id="我的编程生涯是与-BASIC"><a href="#我的编程生涯是与-BASIC" class="headerlink" title="我的编程生涯是与 BASIC"></a>我的编程生涯是与 BASIC</h1><h1 id="想玩游戏就自己写"><a href="#想玩游戏就自己写" class="headerlink" title="想玩游戏就自己写"></a>想玩游戏就自己写</h1><h1 id="游戏玩家到程序员的蜕变"><a href="#游戏玩家到程序员的蜕变" class="headerlink" title="游戏玩家到程序员的蜕变"></a>游戏玩家到程序员的蜕变</h1><hr><blockquote><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了Coding Horror博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下—— from 豆瓣</p></blockquote><blockquote><p>Jeff Atwood于2004年创办Coding Horror博客(.codinghorror.)，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近10万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞 —— from 豆瓣</p></blockquote><blockquote><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折 —— from 豆瓣</p></blockquote><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的修炼 </tag>
            
            <tag> 游戏与编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的修炼-06-互联网那些事</title>
      <link href="/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/"/>
      <url>/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/</url>
      
        <content type="html"><![CDATA[<p>本文是 &lt;程序员的修炼-从优秀到卓越&gt; 的读书笔记的第六篇，这本书的作者是 Jeff Atwood，StackOverflow 的创始人之一，Jeff 的文章涉及面很广，他是一个经验老道的程序员、管理者、创业者，这本书谈到了编程之外的很多东西，不管你是初级工程师，还是资深工程师，本书都值得一读。随着你的阅历的增加，每一次重读这本书，都会有不一样的感悟，正如书名“从优秀到卓越”，作者为你指明了道路，至于是否能成功，则要看自己的修炼了。</p><p>我会把读书过程中一些精彩的言论摘录下来，有时会加入一些自己的见解或者经历，读书笔记的大纲与书本身的大纲是一致的，这也是我从另外一个地方学到并一直在用的“如何阅读一本书”，记录下来方便自己经常查看，也方便读者查看。下面是&lt;程序员的修炼-从优秀到卓越&gt; 读书笔记系列：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><hr><h1 id="保存互联网，留住所有记忆"><a href="#保存互联网，留住所有记忆" class="headerlink" title="保存互联网，留住所有记忆"></a>保存互联网，留住所有记忆</h1><h1 id="网络中立的重要性"><a href="#网络中立的重要性" class="headerlink" title="网络中立的重要性"></a>网络中立的重要性</h1><h1 id="YouTube-上的版权保护"><a href="#YouTube-上的版权保护" class="headerlink" title="YouTube 上的版权保护"></a>YouTube 上的版权保护</h1><hr><blockquote><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了Coding Horror博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下—— from 豆瓣</p></blockquote><blockquote><p>Jeff Atwood于2004年创办Coding Horror博客(.codinghorror.)，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近10万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞 —— from 豆瓣</p></blockquote><blockquote><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折 —— from 豆瓣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的修炼 </tag>
            
            <tag> 互联网那些事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的修炼-05-了解你的用户</title>
      <link href="/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/"/>
      <url>/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/</url>
      
        <content type="html"><![CDATA[<p>本文是 &lt;程序员的修炼-从优秀到卓越&gt; 的读书笔记的第五篇，这本书的作者是 Jeff Atwood，StackOverflow 的创始人之一，Jeff 的文章涉及面很广，他是一个经验老道的程序员、管理者、创业者，这本书谈到了编程之外的很多东西，不管你是初级工程师，还是资深工程师，本书都值得一读。随着你的阅历的增加，每一次重读这本书，都会有不一样的感悟，正如书名“从优秀到卓越”，作者为你指明了道路，至于是否能成功，则要看自己的修炼了。</p><p>我会把读书过程中一些精彩的言论摘录下来，有时会加入一些自己的见解或者经历，读书笔记的大纲与书本身的大纲是一致的，这也是我从另外一个地方学到并一直在用的“如何阅读一本书”，记录下来方便自己经常查看，也方便读者查看。下面是&lt;程序员的修炼-从优秀到卓越&gt; 读书笔记系列：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><hr><h1 id="逻辑人的争议"><a href="#逻辑人的争议" class="headerlink" title="逻辑人的争议"></a>逻辑人的争议</h1><p>软件开发者身上的所有的“坏毛病”中，最严重的可能是：<strong>我们自以为是典型用户。然而大部分的开发者没有意识到的是，我们其实是异类，我们绝非等闲之辈 — 我们是边缘人。</strong></p><p>作者提到了“逻辑人”和“现代智人”的概念</p><ul><li><p><strong>逻辑人</strong>：逻辑人渴望控制那些让他们感兴趣的东西，而那些让他们感兴趣的都是些复杂的确定性系统。人是复杂的，但他们不像机器，他们的行为不具有逻辑性和可预见性，最好的机器是数字的，因为这样它就能变得最为复杂、精细，病区能被程序员轻易改变。</p></li><li><p><strong>现代智人</strong>：一般的普通用户，他们只是想简单地使用，而不是去控制。</p></li></ul><p>对于逻辑人来说，控制是他们的目标，而复杂是他们愿意为之付出的代价，对于普通人来说，简单是他们的目标，失去控制权是他们愿意付出的代价。逻辑人被一种对工作原理难以抗拒的认知欲望驱使着，相比之下，现代智人渴望的是成功。</p><p>Alan Cooper 列了一些逻辑人的典型特征，你可以对号入座一下：</p><ol><li>不惜牺牲简单以换取控制</li><li>不惜失败以换取认知</li><li>不放过任何一点可能性</li><li>行为像体育特长生</li></ol><p>另外一句话软件工程师们需要谨记：任何人都能做出一个没人会用的复杂软件，这其实并不难！把软件做的简单易用才是真本事。你必须停止像逻辑人一样思考，而应该学会像现代智人那样思考。</p><h1 id="象牙塔式的开发"><a href="#象牙塔式的开发" class="headerlink" title="象牙塔式的开发"></a>象牙塔式的开发</h1><p>象牙塔式的开发指的是：开发团队常年封闭在“高塔”之中，一门心思地做着魔法一般的软件。因为缺乏强有力的证据，开发者都假设其他人都是开发者，这是很危险的。</p><p>作者建议：在整个项目周期内，请尽力将你的开发人员暴露在用户面前：参加用户会议，参与可用性测试和验收测试，与用户进行交流，分析用户的数据和行为。</p><p>Eric 提出的“互信关系”：当人们从你那里购买软件的时候，他们对眼下和将来有很多期望：</p><ol><li>他们相信，你的产品可以在他们的机器上正常工作</li><li>他们相信，如果他们碰到了问题，你会帮助他们</li><li>他们相信，你会坚持不懈地改进产品</li><li>他们相信，你会一一个公平、合理的价格为他们提供改进后的版本</li><li>他们相信，你的公司不会再短时间内破产</li></ol><h1 id="让程序员设计界面的后果"><a href="#让程序员设计界面的后果" class="headerlink" title="让程序员设计界面的后果"></a>让程序员设计界面的后果</h1><p>优秀的程序员都有自知之明，知道自己能做什么，不能做什么。他们要么直接拷贝别人的优秀设计；要么本分地只做编码，而把界面设计的工作交给其他专家。</p><p>是朋友，就别让你的朋友做出只有程序员才会使用的界面。</p><h1 id="保护“中间分子”"><a href="#保护“中间分子”" class="headerlink" title="保护“中间分子”"></a>保护“中间分子”</h1><p>专家和小白都只是一小部分人，大部分水平相当的用户都属于“中间分子”，你应该重视这些<strong>中间分子</strong>，中等水平的用户数量是如此巨大，他们如此具有主导性，以至于你可以放弃新手和专家级别的用户。</p><p>为了迎合为数不多的新手和专家，你在软件开发过程中耗费了大量的时间，最终只是让产品变得更差，结果还冷落了核心用户群。</p><h1 id="每个用户都会说谎"><a href="#每个用户都会说谎" class="headerlink" title="每个用户都会说谎"></a>每个用户都会说谎</h1><p>用户的愿望与现实几乎总是相悖的，我们提倡要观察用户的实际行为，而不是听他们叙述他们的所作所为，其原因就在于这种背离。观察是一种很强大的技能，要学会通过人民的行为来判断，而不是听他们说什么就是什么。</p><p>作者提到了“活跃用户的矛盾体”这个概念：活跃用户的矛盾体是一种自相矛盾，因为如果用户对系统多一些了解，从长远来看，是会节省时间的。但现实世界里，人们的行为模式不是那样的。因此，我们不能忍工程师针对理想化的用户开发产品，因为现实中的人是非理性的，我们必须根据用户的实际行为模式来设计产品。</p><p>每个用户都会说谎，预期询问用户是否喜欢你的软件–他们当然会说喜欢，因为当面说你的软件有多么糟糕头型是多么的无理 – 你应该效仿 Gregory House ： 去观察他们是否使用了你的软件，以及他们是怎么使用的。基于行为数据去设计你的软件，而不要靠用户说的“谎言”（不管那些谎言带有多大的善意）</p><h1 id="别把产品发布当目标"><a href="#别把产品发布当目标" class="headerlink" title="别把产品发布当目标"></a>别把产品发布当目标</h1><p>衡量程序员是否成功，有个标准是看他发布了多少代码，但是仅仅发布是不够的，<strong>有多少用户正在使用你的软件，这才是衡量成功的终极目标</strong></p><p>聪明的软件开发者知道，他们的工作远远不止编写代码和发布产品；他们的工作是开发出人民真正想要的使用的软件。这当然包括编码，但还有大量的全局性的其他的事情，比如撰写技术文档、交互设计、培养社区用户、乃至产品愿景，这些对于软件的全面成功都是至关重要的。如果连这一点都没有搞明白，那么你写了什么样的代码就无关紧要了。</p><h1 id="别问，需观察"><a href="#别问，需观察" class="headerlink" title="别问，需观察"></a>别问，需观察</h1><p>用户口述他们想做的事情，与他们实际的所作所为相比，往往天差地别。从可用性的角度来看，询问用户他们想要什么是徒劳的，原因就在这里 – 你必须观察他们正在做了些什么。在可用性方面，你不能猜测行事，你必须去观察用户如何使用你的软件，除此之外别无他法。</p><p>在做设计的时候，如果能基于用户对你的软件的实际使用方式来做决定，岂不是更合理？不管你是在“低保真的可用性测试”转几篇每个观察用户，还是收集用户行为数据、然后在无形之中观察用户，宗旨是一样的：别问，须观察。</p><h1 id="功能越多越好吗"><a href="#功能越多越好吗" class="headerlink" title="功能越多越好吗"></a>功能越多越好吗</h1><p>软件依靠新功能来推动销售，但久而久之，那些新增的功能恰恰是使得软件越变越糟的罪魁祸首 。那种正在慢慢滋生的微妙的“功能癖” — 他会摧毁人们最喜爱的软件。</p><p>一个不好的趋势是：软件公司把现有软件修复 bug 的优先级设得比较低，而把为接下来的版本开发新功能这事看的特别重要。导致的结果就是，软件的质量每况愈下。（就像 Flyme 和 MIUI）</p><p><strong>我们也许不该在盲目地把软件当成一堆功能来衡量</strong> – 人们总有“食量”限制，就像在吃自助餐时，那么多事物你吃得完么？我们应该以结果为导向，衡量软件在帮助我们完成任务时的生产力或效力。</p><h1 id="生物会为所欲为"><a href="#生物会为所欲为" class="headerlink" title="生物会为所欲为"></a>生物会为所欲为</h1><p>作者认为，社会工程充其量是一种不精确的科学，即使在网络空间原型里也是这样。有人曾经说过，“在最精心准备的实验中”，即使条件收到最严格的控制，生物也将为所欲为</p><p><strong>在构造社会性软件时，人是所有问题的根源，但解决问题最终还得靠那些人</strong></p><h1 id="为了一点绶带"><a href="#为了一点绶带" class="headerlink" title="为了一点绶带"></a>为了一点绶带</h1><p>作者总结了自己在 Stack Exchange 的工作内容：我所做的是、我最擅长的是、我最最热爱并且胜过世界上任何其他事情的是，<strong>为喜欢相互写几段文字的人们设计大型多人游戏</strong>。我吧他们的痴迷，引导到某种积极的事情上面；他们可以从中学习，还可以为整个世界创造一些可以重复利用的美妙作品 — 这依然是我所欲之事，因为我还保留有源源不断的痴迷。</p><h1 id="为反社会人群构建社交软件"><a href="#为反社会人群构建社交软件" class="headerlink" title="为反社会人群构建社交软件"></a>为反社会人群构建社交软件</h1><p>作者提出了 “10个可怕的想法”：</p><ol><li>从根本降低参与的门槛</li><li>信任用户</li><li>生活就是世界上最大型的多人在线角色扮演游戏</li><li>总有坏事发生</li><li>喜好胜过金钱</li><li>规则可以很有趣，并且具有社交性</li><li>所有的现代网站都按游戏的方式来设计</li><li>考虑周到的游戏设计促成可持续发展的社区</li><li>社区的观点不一定是对的</li><li>需要一定的调解</li></ol><p><strong>如果你想在网上学点东西，你必须好好设计你的软件，引导人们与生俱来的社会群体冲动，并使他们重新聚焦在有价值的事情上。</strong></p><hr><blockquote><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了Coding Horror博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下—— from 豆瓣</p></blockquote><blockquote><p>Jeff Atwood于2004年创办Coding Horror博客(.codinghorror.)，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近10万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞 —— from 豆瓣</p></blockquote><blockquote><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折 —— from 豆瓣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的修炼 </tag>
            
            <tag> 了解你的用户 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的修炼-04-关于测试的一些思考</title>
      <link href="/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/"/>
      <url>/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/</url>
      
        <content type="html"><![CDATA[<p>本文是 &lt;程序员的修炼-从优秀到卓越&gt; 的读书笔记的第四篇，这本书的作者是 Jeff Atwood，StackOverflow 的创始人之一，Jeff 的文章涉及面很广，他是一个经验老道的程序员、管理者、创业者，这本书谈到了编程之外的很多东西，不管你是初级工程师，还是资深工程师，本书都值得一读。随着你的阅历的增加，每一次重读这本书，都会有不一样的感悟，正如书名“从优秀到卓越”，作者为你指明了道路，至于是否能成功，则要看自己的修炼了。</p><p>我会把读书过程中一些精彩的言论摘录下来，有时会加入一些自己的见解或者经历，读书笔记的大纲与书本身的大纲是一致的，这也是我从另外一个地方学到并一直在用的“如何阅读一本书”，记录下来方便自己经常查看，也方便读者查看。下面是&lt;程序员的修炼-从优秀到卓越&gt; 读书笔记系列：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><hr><h2 id="单元测试是必要的"><a href="#单元测试是必要的" class="headerlink" title="单元测试是必要的"></a>单元测试是必要的</h2><p>单元测试真正的价值在于，它迫使你停下来，为测试思考一番。大部分开发人员都不做测试！他们只是随意输入一些数字，然后点几个按钮，如果这个过程中没有发现尚未处理的异常，他们就觉得代码已经足够好了，可以交付给测试团队了。</p><p>单元测试让你为刚刚写下的代码思考一连串艰难但又不得不思考的问题：</p><ol><li>我该怎样测试这块代码？</li><li>我该执行何种测试？</li><li>通常的情况是怎么样的？</li><li>可能碰到的异常情况有哪些？</li><li>我有多少外部依赖关系？</li><li>我可能碰到哪些系统故障？</li></ol><h2 id="有时候是硬件问题"><a href="#有时候是硬件问题" class="headerlink" title="有时候是硬件问题"></a>有时候是硬件问题</h2><p>作者这一节主要举了一个他们实际遇到的例子，由硬件引起的 bug，排查起来异常困难，但如果用对了工具，那么将事半功倍。</p><p>尽管软件是不可靠的，但我们不能总把矛头指向软件，有时候，你面对的确确实实是一个硬件问题。</p><h2 id="异常驱动的开发"><a href="#异常驱动的开发" class="headerlink" title="异常驱动的开发"></a>异常驱动的开发</h2><p>作为一个开发者，你不应该让用户来指出哪里有错误，你应该比用户更加熟悉你的系统。所以你需要建立一种异常和错误报告机制，你需要集中在一个地方去处理所有的错误，这个地方是你团队里面的所有的开发人员非常熟悉的，而且每天会接触到的。比如 Stack Overflow ，用 ELMAH</p><p>对于 “测试驱动开发” 的一个思考是时间投入回报比，<strong>如果你修复了一个真实用户永远也碰不到的 bug，那么你的修复有什么价值呢？</strong></p><p>作者建议大家使用 “异常驱动的开发”：</p><ol><li>将你的软件发布出去，让尽可能多的用户去使用它</li><li>然后一心一意地研究他们产生的错误日志，使用那些异常日志去找出问题的根源，并且专注在你的代码中有问题的区域</li><li>重新架构，重构代码，以消除最严重的3个问题</li><li>快速迭代，部署，如此周而复始</li></ol><p>这种数据驱动的反馈机制是非常有效地，几个迭代下来，你的程序将非常稳定，坚如磐石。</p><hr><blockquote><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了Coding Horror博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下—— from 豆瓣</p></blockquote><blockquote><p>Jeff Atwood于2004年创办Coding Horror博客(.codinghorror.)，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近10万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞 —— from 豆瓣</p></blockquote><blockquote><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折 —— from 豆瓣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的修炼 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的修炼-03-Web 设计原则</title>
      <link href="/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/"/>
      <url>/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/</url>
      
        <content type="html"><![CDATA[<p>本文是 &lt;程序员的修炼-从优秀到卓越&gt; 的读书笔记的第三篇，这本书的作者是 Jeff Atwood，StackOverflow 的创始人之一，Jeff 的文章涉及面很广，他是一个经验老道的程序员、管理者、创业者，这本书谈到了编程之外的很多东西，不管你是初级工程师，还是资深工程师，本书都值得一读。随着你的阅历的增加，每一次重读这本书，都会有不一样的感悟，正如书名“从优秀到卓越”，作者为你指明了道路，至于是否能成功，则要看自己的修炼了。</p><p>我会把读书过程中一些精彩的言论摘录下来，有时会加入一些自己的见解或者经历，读书笔记的大纲与书本身的大纲是一致的，这也是我从另外一个地方学到并一直在用的“如何阅读一本书”，记录下来方便自己经常查看，也方便读者查看。下面是&lt;程序员的修炼-从优秀到卓越&gt; 读书笔记系列：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><hr><h2 id="网站的评判标准"><a href="#网站的评判标准" class="headerlink" title="网站的评判标准"></a>网站的评判标准</h2><p>作者在做网站的评委的时候，每个参赛的网站只有 30s 的时间，对于此：“在 30 秒内作出评判是完全不公平的，但那也恰恰反映了现实世界中的真实情况”</p><p>作者给参赛的提了一些建议，你的网站首页需要给人一种眼前一亮的感觉：</p><ol><li>加载速度要快，尤其是移动互联网时代，超过1s 用户就会失去耐心</li><li>这到底是什么东西？不能让进来网站的用户云里雾里，让用户一进来就知道这个网页是干嘛的。</li><li>给我看一个例子</li><li>清清楚楚告诉我要做什么，并且扫除障碍</li><li>拥抱你的受众，即使这意味着要把其他受众排除在外</li></ol><p>在任何 Web 应用中，设计首页的基本草图是你应该做的第一件事情，因为他是至关重要的初始设计文稿，也是你的远景声明。</p><h2 id="追求简单"><a href="#追求简单" class="headerlink" title="追求简单"></a>追求简单</h2><p><strong>追求简单更在于把简单进行到底</strong>，从雅虎首页和 Google 首页的历年对比来看，Google 在首页做到了非常克制的简单，而雅虎的首页越来越复杂，信息越来越多，现在来看，这简直就是门户网站的“灾难”</p><p>Google 的简单，是把复杂的事情放在了背后，而不是一股脑推给用户</p><h2 id="应用会取代网站吗？"><a href="#应用会取代网站吗？" class="headerlink" title="应用会取代网站吗？"></a>应用会取代网站吗？</h2><p>我们应该从简单设计入手，必要时按比例放大，而不是一开始就把事情搞得很复杂，然后被迫收缩，这与目前 Moble First 的设计理念类似。</p><p>为什么应用比网站更好？</p><ol><li>运行速度更快</li><li>使用简单的原生 UI 控件</li><li>更好地利用了屏幕空间</li><li>更适合于移动环境，甚至离线的情况</li></ol><p>为什么网站比应用更好？</p><ol><li>网站可以运行在任何设备的浏览器上</li><li>网站不需要安装</li><li>网站不需要手动升级</li><li>网站提供了统一的用户体验</li></ol><p>从上面的对比来看，其实是各有利弊的，不过我们也可以看到后续的发展，网页和 App 会越来越接近，其开发语言、运行环境越来越一致，各种跨平台的框架让 App 和网页的开发不再差异巨大，随着移动互联网的普及，任何 App 和网页都会是以移动设备优先的角度去开发的。</p><p><strong>网页和 App 的界限会非常模糊，最后统一。</strong></p><h2 id="切记墨守成规"><a href="#切记墨守成规" class="headerlink" title="切记墨守成规"></a>切记墨守成规</h2><p>我们需要采用正确地做事方式，而不是标准的做事方式：</p><ol><li>全面了解当前的规范以及它形成的缘由（知其然知其所以然）</li><li>偏离这个规范需要有理有据</li><li>在实验过程中收集用户使用数据（AB Test）</li><li>基于数据做决定</li></ol><p><strong>做 Android 系统优化最好也遵循上面的步骤，先弄懂代码逻辑，再弄懂代码为何这么写，然后再去思考如何优化，这期间就需要找到瓶颈，作出修改，拿到用户数据，对比用户数据选择最优解。</strong></p><h2 id="诡异的单键设计"><a href="#诡异的单键设计" class="headerlink" title="诡异的单键设计"></a>诡异的单键设计</h2><p>iPhone 的单 Home 键设置一直饱受争议，因为这使得后退这个操作比较复杂，在屏幕比较小的机器上还好，可以手势操作，但是在大屏幕机器上，后退到上一页非常不方便，你不得不用另外一个手来进行操作。</p><h2 id="可用性并非阳春白雪"><a href="#可用性并非阳春白雪" class="headerlink" title="可用性并非阳春白雪"></a>可用性并非阳春白雪</h2><p>如果你的项目里面没人关心可用性，那么记得项目注定会失败。</p><ol><li>可用性测试是人们为改进网站所能做的最有效的措施之一</li><li>既然大部分组织均有财力请专人来从事常规性的测试工作，每个人都应该自己学着做可用性测试</li></ol><p>作者推荐了一本书：《用眼动追踪提升网站可用性》，感兴趣的可以买一本看看</p><h2 id="费茨定律的另一面"><a href="#费茨定律的另一面" class="headerlink" title="费茨定律的另一面"></a>费茨定律的另一面</h2><p>费茨定律: 一个东西越大，离光标越近，它就越容易被点击。</p><p>作者概括了一篇“Visualizing Fitts’s Law”  的文章的核心思想：</p><ol><li><strong>把常用的 UI 元素摆在屏幕的边缘，因为光标自动停留在屏幕的边缘，这样的话，那些 UI 元素将更加容易被点击</strong></li><li><strong>让可点击的区域尽可能大。目标越大，越容易被点击</strong> </li></ol><p>同理，如果有的必要的按钮你不希望用户点击，那么做小一点总没有错，<strong>要让不常用或者危险的 UI 元素难以被点击</strong></p><h2 id="可用性与易学性"><a href="#可用性与易学性" class="headerlink" title="可用性与易学性"></a>可用性与易学性</h2><p>网站的写作应该采用“倒金字塔”的风格：<strong>在文章的开头先把结论告诉读者，接着再写最重要的辅助信息，最后才介绍相关的背景。</strong></p><p><strong>毋庸置疑的是，你应该尽量吧最重要的信息放在顶部，不管你是做一个网页，写一段程序，写一封电子邮件，还是做一份简历，等等</strong></p><p>另外作者推荐了一本书 <a href="https://book.douban.com/review/1131988/" target="_blank" rel="noopener">写给程序员的UI设计指南</a>,感兴趣的可以看一下</p><h2 id="只是多一个"><a href="#只是多一个" class="headerlink" title="只是多一个"></a>只是多一个</h2><p><strong>如果你想再加一个什么 UI 元素，请确信，你所加的那个 UI 元素不是压倒骆驼的最后一根稻草</strong></p><h2 id="敢于说不"><a href="#敢于说不" class="headerlink" title="敢于说不"></a>敢于说不</h2><p><strong>创新并不是要接受所有的东西，而应该对除了关键性功能之外的所有东西通通说不。</strong></p><h2 id="用户界面很难做"><a href="#用户界面很难做" class="headerlink" title="用户界面很难做"></a>用户界面很难做</h2><p>这里主要说的是程序员在做用户界面的时候，总是很粗糙，不易用。不过从现在的发展来看，用户界面设计不再那么困难，各种美观的界面框架可以非常容易的套用。</p><hr><blockquote><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了Coding Horror博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下—— from 豆瓣</p></blockquote><blockquote><p>Jeff Atwood于2004年创办Coding Horror博客(.codinghorror.)，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近10万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞 —— from 豆瓣</p></blockquote><blockquote><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折 —— from 豆瓣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的修炼 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的修炼-02-编程之道</title>
      <link href="/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/"/>
      <url>/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/</url>
      
        <content type="html"><![CDATA[<p>本文是 &lt;程序员的修炼-从优秀到卓越&gt; 的读书笔记的第二篇，这本书的作者是 Jeff Atwood，StackOverflow 的创始人之一，Jeff 的文章涉及面很广，他是一个经验老道的程序员、管理者、创业者，这本书谈到了编程之外的很多东西，不管你是初级工程师，还是资深工程师，本书都值得一读。随着你的阅历的增加，每一次重读这本书，都会有不一样的感悟，正如书名“从优秀到卓越”，作者为你指明了道路，至于是否能成功，则要看自己的修炼了。</p><p>我会把读书过程中一些精彩的言论摘录下来，有时会加入一些自己的见解或者经历，读书笔记的大纲与书本身的大纲是一致的，这也是我从另外一个地方学到并一直在用的“如何阅读一本书”，记录下来方便自己经常查看，也方便读者查看。下面是&lt;程序员的修炼-从优秀到卓越&gt; 读书笔记系列：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><hr><h2 id="切记一根筋"><a href="#切记一根筋" class="headerlink" title="切记一根筋"></a>切记一根筋</h2><p>优秀的程序员擅长编程，成为更加优秀的程序员的方法是抛开编程，你必须培养对于编程周边的所有事情的热情</p><p>比尔盖茨在2005年的访谈中提到：“工作的本质不是闭门造车，最最匮乏的人才是那些既对工程技术有超强的领悟能力，有可以与核心开发人员建立良好的关系，并且可以充当与客户、市场等之间桥梁的人”</p><p>你的兴趣爱好越广泛，就越能胜任你的工作</p><h2 id="破窗理论"><a href="#破窗理论" class="headerlink" title="破窗理论"></a>破窗理论</h2><p>破窗理论：如果一栋楼的一个窗户破了，并且留在那里不去修复，这栋楼的其他窗户很快就会被破坏。一个长久没有修复的破窗户释放出来的信号是“没人管”，这会让人觉得，即使再破坏更多的窗户也不会付出什么代价</p><p>从编程的角度来看，破窗理论也存在，你需要及时采取措施：不要放任“破窗”（不良的设计、错误的决定或者糟糕的代码）不管，一但发现就要尽快修复。如果时间不够，就先把他隔离起来。你可以把这些令人不快的代码注释掉，或者显示“尚未实现”的消息，或者用虚假的数据来代替。</p><p>编程是非常注重细节的！如果你不能够掌握这些细节，你就会有一种失控的感觉，而你的项目失控也只是一个时间问题。或许，我们就应该谨小慎微。</p><h2 id="要么热爱，要么离开"><a href="#要么热爱，要么离开" class="headerlink" title="要么热爱，要么离开"></a>要么热爱，要么离开</h2><p>我所认识的最杰出的程序员，他们对所从事的事情都有着终生的热忱，他们绝不会因为一次微弱的经济波动而转行去做其他的事情</p><p>对于编程：要么热爱，要么离开</p><h2 id="简单之美"><a href="#简单之美" class="headerlink" title="简单之美"></a>简单之美</h2><p>在编程开发领域，人们很容易就陷入“越新越好”的思维模式，而忘记了“想法往往比代码更重要”。</p><p>Forth 的进化指出了 Charles 在发明和实现 Forth 语言的时候的知道原则：</p><ol><li>保持坚定</li><li>不要妄加推测</li><li>自己动手</li></ol><p>Charles 认为：简单必须被强制执行，而不是作为一个可有可无的目标。现实中，很多开发者难以保持程序的简单，因为他们没有在需要做艰难决定的时候坚持说“不”，而事事允诺，处处妥协却容易的多</p><p>很多人看不上 oppo，但是 oppo 的系统在设计上保持了简单之美，所以 oppo 的系统用起来很轻，很舒服，长时间使用也很少有卡顿的情况出现，低端机的上面的表现也比同类竞品要好很多，这也与 oppo 的开发理念契合：优先保证基础体验（即快省稳）</p><h2 id="乐于删代码"><a href="#乐于删代码" class="headerlink" title="乐于删代码"></a>乐于删代码</h2><p>如果有一段你不再需要的代码，请真正地删除它而不是把它闲置在那里，其主要的原因是为了去除噪音和不确定性，开发者面临的众多最困难的事情之一就是代码流的噪音或者不确定性，因为这会影响他们将来的工作效率。无用的代码会引发其他开发者的思考：</p><ol><li>为什么这段代码以前是这样写的？</li><li>为什么这段新代码更好？</li><li>将来我们会重新使用老代码么？</li><li>我们评判的标准是什么？</li></ol><p>在目前 Git 横行的时代，你更不应该保留那些没用的老代码，如果想看之前的写法，也就是 Git 几行命令的事情。如果你不能有一个好的不删除的理由，那么删掉它就是合理的</p><h2 id="你是程序员这块料吗"><a href="#你是程序员这块料吗" class="headerlink" title="你是程序员这块料吗"></a>你是程序员这块料吗</h2><p>这一节提到，并不是所有人都适合编程，事实上，大部分人学不会编程，其中决定因素是他们对无意义事物的态度</p><p>形式逻辑证明，进而用一种叫编程语言的形式系统来表达，通过执行某种特别的计算得出结果，这其实是完全没有意义的。为了编写一个计算机程序，你必须做出妥协，赋予程序某种意义，但不管你想要这个程序做什么，计算机都会按照这些没有意义的规则运行，并且得到一些没有意义的结果。在测试中，那些有稳定思维模型的人都体现出了在这方面的先天接受能力，他们都有能力看见规则背后的数学计算问题，而且无论怎样都能遵循那些规则。另外一个方面，那些没用稳定思维模型的人总是找不到头绪。</p><h2 id="你循规蹈矩么"><a href="#你循规蹈矩么" class="headerlink" title="你循规蹈矩么"></a>你循规蹈矩么</h2><p>这节我感觉标题不好，循规蹈矩：原指遵守规矩，不敢违反。现也指拘守旧准则，不敢稍做变动。而文中则说的是你是否遵循基本的规则。</p><p>这一节可以理解为：很多事情，包括软件开发，都是有一定的套路或者基本规则的，这些套路或者基本规则是被大家验证过的，你要做一件事的时候，最好按照这些套路或者基本规则来办，比如作者列出了一篇博客中写出更好的代码的 12 个步骤：</p><ol><li>你使用源代码管理系统么？</li><li>你能一步之内完成软件的一次构建么？</li><li>你每天都出版本么？</li><li>你有一个 bug 跟踪数据库么？</li><li>在写新代码之前，你先解决 bug 么？</li><li>你有最新的软件开发计划表么？</li><li>你有产品规范文档么?</li><li>程序员有安静的工作环境么？</li><li>你在使用最好的商业工具么？</li><li>你有测试人员么？</li><li>在面试过程中，你让应聘者写代码么？</li><li>你做可用性测试么？</li></ol><p>虽然上面都是疑问句，但答案是肯定的</p><h2 id="科里定律：坚守一个目标"><a href="#科里定律：坚守一个目标" class="headerlink" title="科里定律：坚守一个目标"></a>科里定律：坚守一个目标</h2><p>科里定律：坚守一个目标。这个定律在现代人居开发的下面几个核心原则中都有体现</p><ol><li>Don‘t Repeat Yourself （DRY，避免重复）</li><li>Once And Only Once （OAOO，唯一一次）</li><li>Single Point Of Truth （SPOT，单点真理）</li></ol><p>科里定律同时也告诉我们，要有意识地选择你的代码不做什么</p><h2 id="最牛的编码套路"><a href="#最牛的编码套路" class="headerlink" title="最牛的编码套路"></a>最牛的编码套路</h2><p>与你所相信的恰恰相反，单纯地每天埋头于工作并不能算是真正意义上的锻炼 – 参加会议并不能锻炼你的人际交往能力；回复邮件并不能提高你的打字水平。你必须定期流出时间，集中锻炼，这样才能把事情做得更好</p><p>上面这个理论也就是我比较推崇的两本书《深度学习》和 《刻意练习》里面所强调的（如果你还没有看过这两本书，那么建议你看一下）：一万小时不是一个小时重复一万次，而是每个小时都能全心全意投入学习，深入思考，总结归纳</p><p>另外作者也提到了“努力地学习”：要不断地挑战自身能力之外的东西，学习和训练的主要价值在于发现弱点，有针对性地进行提高。<strong>“努力地学习”意味着，要常常去处理那些刚好在你能力极限上的问题，也就是那些对你来说有很大可能失败的事情</strong>。如果不经历一些失败的话，你可能就不会成长。你必须不断挑战自我，超越自己的极限</p><p>作者列举了一些套路（是那些真正可以实施的套路，有些长，不过我还是把所有的条目都摘抄出来，因为我自己也要实施）：</p><ol><li>写一份自己的简历。把自己所有的相关技能都罗列出来，然后把那些在100年后还用得到的标出来。给每个技能打分，满分为10分</li><li><strong>罗列出你所景仰的程序员。尽量包括那些与你一起工作的人，因为你会在工作中从他们身上获取一些技能。记录下他们身上的1 ~ 2个闪光点，也就是你希望自己有所提高的方面</strong></li><li>查看维基百科上的“计算机科学”栏目，找到“计算机领域先驱者”这个分类，从这个列表中挑选一个人，阅读他的事迹，并且在阅读时打开任何你感兴趣的链接</li><li>花20分钟通读别人的代码。读出色的代码和读糟糕的代码都是有益的，两者都要读，轮流切换。如果你无法感觉出它们之间的区别，可以求助于一位你尊敬的程序员，让他给你展示一下什么是出色的代码、什么是糟糕的代码。把你读过的代码给别人也看看，问问他们的看法</li><li>罗列出你最喜欢的10个编程工具——那些你觉得你用得最多、非有不行的工具。随机挑选其中的一个工具，花一个小时去阅读它的文档。在这一个小时里，努力去学习这个工具的某个你不曾意识到的新功能，或者发现某种新的使用方法</li><li><strong>想一想，除了编程之外你最擅长什么事情？再想一想，你是通过怎样的锻炼才变得如此熟练和专业的？这对于你的编程工作又有什么启发呢？（怎么把这些经验应用到编程方面？）</strong></li><li>拿出一叠简历，并和一组面试官在同一个房间里待上一个小时。确保每份简历都至少被3个面试官看过，并且要给出1 ~ 3分的评分。针对那些不同面试官评判大相径庭的简历展开讨论</li><li>参与一个电话面试。事后写下你的反馈，抛出你的观点，然后与主持电话面试的人聊一聊，看看你们是否达成了一致的结论</li><li>进行一次技术面试，并且被面试的人应该是某个你不太了解的领域里的专家。让他假定听众在该领域里一无所知，因此请他从最基础的讲起。努力去理解他所说的，必要时问一些问题</li><li>有机会参与别人的技术面试。期间，你只是认真地听、认真地学。在应聘者努力解决技术问题的同时，你也要在自己脑子里尝试解决这些问题</li><li>找到一个能和你交换实际问题的人，每隔一周，相互交流编程问题。花10 ~ 15分钟来尝试解决这些问题，再用10 ~ 15分钟进行讨论（无论能否解决）</li><li><strong>当你听到任何你一时之间也无法解决的面试问题时，赶紧回到你的座位上，把这个问题用电子邮件发给自己，以留作日后的提醒。在那一周里找出点时间，用自己最喜欢的编程语言来解决它</strong></li></ol><p>另外作者也提到了 Peter Norvig 所列出的一些建议：</p><ol><li>与别的程序员交流。读别人的代码。这比任何书籍或培训课程都更重要</li><li>动手写程序！最好的学习方法就是边做边学</li><li>在本科或研究生的课程中学习编程课程</li><li>找一些项目来做，并且需要与其他程序员形成团队来合作。在项目的进行过程中，学会辨别最出色的程序员以及最糟糕的程序员</li><li>在项目中跟随别的程序员一起工作，了解如何维护那些不是你写的代码，并且学习如何写出利于他人维护的代码</li><li>学习多种不同的编程语言，特别是那些与你现在所熟悉的语言有着不同的世界观和编程模型的</li><li>了解硬件对软件的影响。知道你的电脑执行一条指令需要多少时间，从内存中取出一个字（在有缓存或没缓存的情况下）需要多少时间，在以太网（或者因特网）上传输数据需要多少时间，从磁盘中读取连续的数据或者在磁盘上跳转到另一个位置需要多少时间，等等</li></ol><p>最后作者也阐述了自己的编程套路：</p><ol><li><strong>写博客</strong>。我在2004年初创办了CodingHorror.com博客，作为我自己努力学习的一种形式。它在一开始很不起眼，到后来成为我职业生涯中做过的最重要的一件事。所以，你也应该写博客。最后“闻达于天下”的人，往往就是那些能够有效书写和沟通的人。他们的声音最响亮，是他们在制定游戏规则，并且引领世界的潮流</li><li><strong>积极参与著名的开源项目</strong>。所有的高谈阔论听起来都很好，但是，你是一个大话王还是一名实干家呢？别光说不练，这个非常重要，因为人们会用你的行动来衡量你，而不是你的言论。努力在公众面前留下些实实在在有用的东西吧，到时候你就可以说，“我在那个项目中出过力”</li></ol><p>当你能编写精彩的代码、并且能用精彩的言辞向世人解释那些代码时，到那时候，我会觉得你已经掌握了最牛的编码套路！</p><h2 id="孤独的人是可耻的"><a href="#孤独的人是可耻的" class="headerlink" title="孤独的人是可耻的"></a>孤独的人是可耻的</h2><p>我觉得这一节作者引用的 “Creating My Own Personal Hell” 中阐述独自编程的危害性非常值得深思：</p><blockquote><p>有些人宣称，“独自工作”为建立起自己的工作流程提供了极好的机会。但是，根据我的经验，在团队只有一个人的时候是没有流程可言的。没有任何东西可以帮你抵挡住如潮水般涌来的大量工作。当你的代码太急于求成时，没有人去纠正你的错误。没有人检查你的代码。没有人保证你的代码能准时提交、打好标签、进行常规的单元测试。没有人保证你遵循了某个编码标准。没有人督促你及时修复代码里的缺陷。没有人检验你是否把一个实际存在的问题标注成了“无法重现”。没有人复核你的估算，在你玩忽职守的时候把你抓回来</p></blockquote><blockquote><p>没有人在你生病时或者出差时接过你的工作。没有人在你工作繁重时帮助你，在你深陷于骚扰电话、无聊会议、还有在最后关头忽然被扔过来（但需要立即解决）的杂碎任务时，没有人能拉你一把。没有人忽然有奇思妙想，帮助你走出困境。没有人在设计、架构或技术上与你合作。你在一个真空中工作；在真空中，没有人能听到你绝望的尖叫</p></blockquote><blockquote><p>如果你读到了这些内容，请以此为鉴。如果某个公司只招你作为唯一的一位开发者，在你答应他们之前请三思。那根本就是另一种地狱。如果有机会的话，请选择那些能与其他开发者一起工作的职位，这样你至少可以在与别人一起工作的过程中得到指导，这有助于你发展自身的技能，让你在技术方面与时俱进</p></blockquote><p>如果你不能展示给别人看，再漂亮的编码技巧又有什么意义？如果你不去接触其他程序员的不同观点、不同方法以及不同的技术，你又怎么能学到更多的技艺？谁又能检查你的代码并告诉你，那个问题有更简单的解决方法？如果你对待编程的态度是认真的，你应该要求与同伴们一起工作</p><p><strong>个人的能力总是有限的，它决定了你在这个领域里只能走那么远。找一些其他的聪明程序员吧，和他们一起工作。努力让自己保持谦逊低调，然后你会很快发现，软件开发其实是一种社会活动——它的社会性比大部分人想象的要大得多。你可以从那些性格内向的同伴身上学到很多东西</strong></p><p>就像我们常说的，<strong>一个人可以走的更快，但是一群人可以走的更远</strong></p><h2 id="你要编程伙伴么"><a href="#你要编程伙伴么" class="headerlink" title="你要编程伙伴么"></a>你要编程伙伴么</h2><p>在健康的软件工程文化影响下，团队成员通过结对的方式来提高他们的工作质量和生产力，他们明白，他们花在查看同事工作上的时间，总会在别人反过来查看他们自己的交付物的时候得到回报。</p><p>作者更是给出了一份数据来说明代码 Review 的作用（有点颠覆我的认知）：</p><blockquote><p>在平均缺陷发现率方面，单元测试只能到到 25%，功能测试可以达到 35%，而集成测试也不过45%，相比之下，设计和代码审查的平均功效可以达到 55% 和 60%</p></blockquote><p>编程有很多乐趣，其中一点在于：“你不必独自一人去做。”，所以，谁是你的编程伙伴？</p><h2 id="软件学徒制"><a href="#软件学徒制" class="headerlink" title="软件学徒制"></a>软件学徒制</h2><p>很多公司会给新人配一个导师，通过这种 1V1 的指导，让新人能尽快融入到公司，这与学徒制度很类似</p><p>晚上学习理论，白天编程工作 — 这种组合方式特别有效</p><hr><blockquote><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了Coding Horror博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下—— from 豆瓣</p></blockquote><blockquote><p>Jeff Atwood于2004年创办Coding Horror博客(.codinghorror.)，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近10万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞 —— from 豆瓣</p></blockquote><blockquote><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折 —— from 豆瓣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 程序员的修炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的修炼-01-绝地反击之术</title>
      <link href="/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/"/>
      <url>/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/</url>
      
        <content type="html"><![CDATA[<p>本文是 &lt;程序员的修炼-从优秀到卓越&gt; 的读书笔记的第一篇，这本书的作者是 Jeff Atwood，StackOverflow 的创始人之一，Jeff 的文章涉及面很广，他是一个经验老道的程序员、管理者、创业者，这本书谈到了编程之外的很多东西，不管你是初级工程师，还是资深工程师，本书都值得一读。随着你的阅历的增加，每一次重读这本书，都会有不一样的感悟，正如书名“从优秀到卓越”，作者为你指明了道路，至于是否能成功，则要看自己的修炼了。</p><p>我会把读书过程中一些精彩的言论摘录下来，有时会加入一些自己的见解或者经历，读书笔记的大纲与书本身的大纲是一致的，这也是我从另外一个地方学到并一直在用的“如何阅读一本书”，记录下来方便自己经常查看，也方便读者查看。下面是&lt;程序员的修炼-从优秀到卓越&gt; 读书笔记系列：</p><ol><li><a href="https://www.androidperformance.com/2018/09/19/how-to-stop-sucking-and-be-awesome-instead-1/" target="_blank" rel="noopener">程序员的修炼-01：绝地反击之术</a></li><li><a href="https://www.androidperformance.com/2018/09/20/how-to-stop-sucking-and-be-awesome-instead-2/" target="_blank" rel="noopener">程序员的修炼-02：编程之道</a></li><li><a href="https://www.androidperformance.com/2018/09/26/how-to-stop-sucking-and-be-awesome-instead-3/" target="_blank" rel="noopener">程序员的修炼-03：Web 设计原则</a></li><li><a href="https://www.androidperformance.com/2018/09/27/how-to-stop-sucking-and-be-awesome-instead-4/" target="_blank" rel="noopener">程序员的修炼-04：关于测试的一些思考</a></li><li><a href="https://www.androidperformance.com/2018/09/28/how-to-stop-sucking-and-be-awesome-instead-5/" target="_blank" rel="noopener">程序员的修炼-05：了解你的用户</a></li><li><a href="https://www.androidperformance.com/2018/09/29/how-to-stop-sucking-and-be-awesome-instead-6/" target="_blank" rel="noopener">程序员的修炼-06：互联网那些事</a></li><li><a href="https://www.androidperformance.com/2018/09/30/how-to-stop-sucking-and-be-awesome-instead-7/" target="_blank" rel="noopener">程序员的修炼-07：游戏与编程</a></li><li><a href="https://www.androidperformance.com/2018/10/01/how-to-stop-sucking-and-be-awesome-instead-8/" target="_blank" rel="noopener">程序员的修炼-08：阅读之美</a></li></ol><hr><h2 id="待办事项不靠谱"><a href="#待办事项不靠谱" class="headerlink" title="待办事项不靠谱"></a>待办事项不靠谱</h2><p>作者吐槽说，每天都会有新的 TO-DO 应用诞生，很多人还是管不好自己的时间，TO-DO 列表正在变得吃力不讨好：</p><ol><li>列表会给你一种正在进行的错觉</li><li>列表会给你一种完成的错觉</li><li>对于那些未完成的事情，列表会让你产生罪恶感</li><li>对于那些总被延期的事情，列表会让你产生罪恶感</li><li>对于那些不想做而没做的事情，列表会让你产生罪恶感</li><li>你会根据列表错误地排出优先级</li><li>列表不够高效</li><li><strong>列表吞噬了主动做事的乐趣，让你觉得做事情成了一种义务</strong></li><li>从长远来看，列表博纳更没有让你变得有条理</li><li>列表会让你做事缺乏主动性</li></ol><p>作者的建议是，每天早上醒来的时候，如果你不能够用上帝赐予你的大脑使劲想出今天你需要做的<strong>最重要的三件事</strong>，那么你必须先把这个问题认真解决了。<strong>你必须要搞明白，什么东西对于你来说是最重要的，并且能让你充满激情。</strong></p><p>工具是浮云，而你的大脑将会伴随你的一生，信任他，训练他。</p><h2 id="今天上班可以放羊"><a href="#今天上班可以放羊" class="headerlink" title="今天上班可以放羊"></a>今天上班可以放羊</h2><p>本节主要探讨了 Google 的 20% 时间理论：在 Google，理论上你可以拿上班时间的 20% 来做任何自己想做的事情。Google 许多伟大的软件都是这 20% 的时间里成型的，比如 Gmail、Google News、Google Talk、AdSense 等。</p><p>真正能否在公司执行，需要公司的支持：</p><ol><li>公司项目计划是否足够宽松？</li><li>公司文化容得下“白日做梦”么？</li><li>可以接受失败么？</li><li>个人的实验是否能得到尊重？</li></ol><p>在工程师文化主导的公司应该会比较容易实行，“<strong>重要的创新和改进可能会在任何时候以自下而上的方式来自于公司的任何人—他们不会按照神奇的总体规划上预定的间隔自己蹦出来。</strong>”</p><h2 id="你没有说服我"><a href="#你没有说服我" class="headerlink" title="你没有说服我"></a>你没有说服我</h2><p>本节以《末代独裁》里面的一个例子，来说明说服别人的重要性。如果想落实一件事情，你不能只是把自己的观点表达出来，等待别人的判断，你要说服别人认可你的观点：<strong>如果你想要影响别人，你必须有能力说服他们。</strong></p><p>对于软件工程师来说，他们所要知道的不仅仅是怎样去写出技惊四座的代码，更重要的是怎样推销他们的想法和产品。</p><p>作者做了举了一个说服他人的草根方法：</p><ol><li>从整体上来说，他的观点是相当出色的</li><li>他做事方式是自下而上的，而不是自上而下的</li><li>他总是能够带头亲自去做事，以赢得别人的信任</li><li>他拥有足够的耐心去等待机会的到来</li></ol><p><strong>如果你一味地保持沉默，总是像局外人一样冷眼旁观，你就什么也改变不了。如果你想改变你的工作和生活，你必须学会说服别人。</strong> 对于某些人来说（比如我），就常常受困于此，我总结了一下原因，也算是后续的职业生涯需要加强的部分：</p><ol><li>性格原因</li><li>不自信</li><li>准备不足</li></ol><p>当然，打铁还需自身硬，最近我面试有一句话我印象特别深刻：<strong>公认的牛人应该是</strong></p><ol><li><strong>自己得行</strong>：技术过硬</li><li><strong>别人说你行</strong>：得到大家的认可</li><li><strong>说你行的人也得行</strong>：得到业界的认可</li></ol><h2 id="真正失败的项目"><a href="#真正失败的项目" class="headerlink" title="真正失败的项目"></a>真正失败的项目</h2><p>不要害怕失败，也不要主动寻求失败，失败会自己找上门来。不管你在做什么项目，怀揣着学习和锻炼的态度去完成它，这绝对是值得的，与项目的结果相比，过程才是最大的财富。</p><p><strong>如果你没能从一个项目的过程中学到一点东西，这才是真正失败的项目。</strong> 所以真正的工作中，项目做完要及时 Review，总结经验和教训，防止下次再踩坑，就算是失败的项目，也有大量的经验在其中。</p><h2 id="激情造就天才"><a href="#激情造就天才" class="headerlink" title="激情造就天才"></a>激情造就天才</h2><p>很喜欢的一句话：“我将会把剩下的5天的课程全都用于让他们变得更加聪明，而不是让他们明白我有多聪明”，不管是做培训还是写博客，要有这样的心态，你不是在炫耀自己多厉害，而是要让看博客或者参加培训的人学到知识，获得真的的成长。</p><p>千万不要被身边很多天赋比你高的开发者吓倒，勤能补拙，激情造就天才。</p><h2 id="勿以专家自居"><a href="#勿以专家自居" class="headerlink" title="勿以专家自居"></a>勿以专家自居</h2><p>作者以维基百科为例，专家并没有更多的权限，在知识面前，人人平等。有时候反而因为你是专家，而对你的期望或者要求会更多。</p><p>古人云：<strong>三人行，则必有我师；闻道有先后，术业有专攻，如是而已；无他，唯手熟尔。</strong></p><p><strong>作为一名专家，重要的不是告诉别人你知道什么，而是要清楚你应该问什么样的问题，病区灵活运用你所掌握的知识去解决眼下的具体问题，作为专家，你的作用是提供明智的、可执行的方向。</strong></p><p>最近面试也有提到专家的问题，作者在这里也介绍了几个阶段，大家可以对号入座一下，记得摒弃自己的领域、专业知识、名声和声誉，然后按照下面的阶段来进行重塑：</p><ol><li><strong>第 0 阶段：我克服了漫不经心</strong><br>我现在明白了，我需要学点东西</li><li><strong>第 1 阶段：我克服了恐惧</strong><br>我觉得我可以学会这个科目或者技能，我会对它变得很了解，而不会惧怕比我懂得多的人。</li><li><strong>第 2 阶段：我变得有条理</strong><br>我不再觉得自己不懂装懂或者不学无术，我觉得我有能力参与讨论或者实践，我对自己说的话很有信心</li><li><strong>第 4 阶段：我超越了自身的能力</strong><br>我现在觉得对自己有了更高的要求，不再停留在“过得去”而沾沾自喜，我想冒一点风险，富有创造力，不断学习，不断推动自己进步，我想要与那些充满热情的人共事</li></ol><h2 id="行百里者半九十"><a href="#行百里者半九十" class="headerlink" title="行百里者半九十"></a>行百里者半九十</h2><p>本节主要讲的是项目管理相关的，包括个人项目管理和团队项目管理，如果你总是把 “快完成了” 挂在嘴边，那么你需要思考一下自己的项目管理是否有问题，作者建议：<strong>鼓励并强制要求程序员创建一张他们所要做的全部事情的列表，然后再为其中的每一项列出子项，并且尽可能把所有的子项都加进来</strong></p><p>下面是具体可能的措施，把他用在项目里面吧</p><ol><li>把你在一个大项目中需要做的事情全部罗列出来，包括哪些基础设施工作，比如配置源代码管理系统的分支</li><li>估计这个列表中每一项所要花费的时间，这这最初的估计可以帮助你看到真个项目大致的时间花费</li><li>看看你列表中的每一项要花费多少时间，如果有一项的时间超过一天，则把这项拆分成若干小项，这种将大任务拆分成小任务的方式是解决“只能完成 90%”问题的关键步骤</li><li>找出一种呈现任务状态的方式，以便那些感兴趣的人可以了解</li><li><strong>追踪每天的任务进度，把每个小任务的原定计划和实际完成时间放在同一张表上，这样就可以对工作进度做一个把控。</strong></li></ol><h2 id="管理中要有信任"><a href="#管理中要有信任" class="headerlink" title="管理中要有信任"></a>管理中要有信任</h2><p>信任可以解决大型软件管理的问题，但是信任无法代替管理，两者相辅相成。</p><h2 id="博伊德迭代法则"><a href="#博伊德迭代法则" class="headerlink" title="博伊德迭代法则"></a>博伊德迭代法则</h2><p>博伊德迭代法则：迭代的速度胜过迭代的质量。也就是大家常说的，天下武功唯快不破。</p><h2 id="十年磨一剑"><a href="#十年磨一剑" class="headerlink" title="十年磨一剑"></a>十年磨一剑</h2><p>Gmail 的成功之路是漫长的，很多人一开始并不看好他，但是在产品发布之后，用户的反馈反而很好。</p><p>一夜成名的传说容易让人误入歧途，并且遗毒不浅，如果你打算做一个全新的东西，要有打持久战的准备。</p><p>作者认为，<strong>成功需要付出多年的努力，你必须踏踏实实地在这件事上花费几年的时机去磨练，每天一醒来就开始工作，日复一日地坚持，不断取得反馈，每一天都比过去做的更好。即使你偶尔会不开心，甚至失去了乐趣，单这些都是为了获取成功所必须的。</strong></p><p>作者同时也举了写博客的例子，日复一日的投入，作者花了3年，才让他的博客在行业有了一席之地。在目前这个浮躁的环境下，能静下心来，持续做知识输出的人，我相信一定会有好的结果，只要你相信：<strong>你正在做的事情是真正值得去做的</strong>。</p><hr><blockquote><p>《程序员的修炼——从优秀到卓越》是《高效能程序员的修炼》的姊妹篇，包含了Coding Horror博客中的精华文章。全书分为8章，涵盖了时间管理、编程方法、Web设计、测试、用户需求、互联网、游戏编程以及技术阅读等方面的话题。作者选取的话题，无一不是程序员职业生涯中的痛点。很多文章在博客和网络上的点击率和回帖率居高不下—— from 豆瓣</p></blockquote><blockquote><p>Jeff Atwood于2004年创办Coding Horror博客(.codinghorror.)，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近10万人次的访问量，读者纷纷参与评论，各种观点与智慧在那里不断激情碰撞 —— from 豆瓣</p></blockquote><blockquote><p>《程序员的修炼——从优秀到卓越》的写作风格风趣幽默，且充满理解和关怀；适合从新手到老手的各个阶段的程序员阅读，也适合即将成为程序员的计算机和相关专业的学生阅读。《程序员的修炼——从优秀到卓越》能够帮助读者更多地关注技术工作的人性和人文因素，从而实现程序员职业生涯的成功转折 —— from 豆瓣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 程序员的修炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 系统不释放内存吗？</title>
      <link href="/2018/09/13/android-memory/"/>
      <url>/2018/09/13/android-memory/</url>
      
        <content type="html"><![CDATA[<p>除了 CPU，很多用户在选购手机的时候通常也会考虑内存大小，不同版本内存的手机价格也不一样，买多大内存的合适呢？Android 系统是怎么管理内存的呢？普通用户对 Android 手机的内存使用总是一头雾水，这个应用到底占了多少内存？系统到底占了多少内存？内存对我手机的使用体验有什么影响？到底怎么才能用好 Android 手机？换新手机换多大内存的会比较合适呢？</p><p>知乎上有一个问题，一个用户问 <a href="https://www.zhihu.com/question/24976909/answer/49711238" target="_blank" rel="noopener">“Android 系统不释放内存吗？</a>”，用户并不是不知道系统会释放内存，而是想知道其中的细节，好优化使用的体验，下面我就从用户的几个问题入手，来简单说明一下，比较深入的细节我后续的文章会详细介绍。</p><p>同时也会对第一段中提到的几个问题提出一些个人的见解，欢迎一起来讨论，留下你的问题，提出你的见解，大家共同进步。</p><h2 id="Android系统下关闭程序后，系统内存并不释放？"><a href="#Android系统下关闭程序后，系统内存并不释放？" class="headerlink" title="Android系统下关闭程序后，系统内存并不释放？"></a>Android系统下关闭程序后，系统内存并不释放？</h2><p>这个是不准确的,只能说对了一半. 你所描述的”android系统下关闭程序”,指的是怎么个关闭法呢?目前阶段有好几种关闭程序的方法:</p><h3 id="点击Back键退出"><a href="#点击Back键退出" class="headerlink" title="点击Back键退出."></a>点击Back键退出.</h3><p>这种退出的方法, 进程是否被杀掉,取决于这个应用程序的实现. 举个栗子,如果你创建一个空的应用, 这时候查看系统内存信息(包名为com.exmaple.gaojianwu.myapplication,pid为5708,内存为13910kb):<br><img src="/images/media/15368461581041.jpg" alt=""></p><p>可以看到,这个应用程序的pid为5708 , 其优先级为Foreground,即前台程序.</p><p>这时候我们点击Back键退出,然后再查看系统的内存信息(adb shell dumpsys meminfo)<br><img src="/images/media/15368462124980.jpg" alt=""></p><p>我们看到,这个程序在 Back 键之后,其进程 5708 依旧是存在的.只是其进程优先级变成了Cache.其占用内存变成了 12337kb,和之前的 13910kb 相比是变小了一些. 但是大部分内存是没有被释放掉的.</p><h3 id="在任务管理器中杀掉应用"><a href="#在任务管理器中杀掉应用" class="headerlink" title="在任务管理器中杀掉应用"></a>在任务管理器中杀掉应用</h3><p>在任务管理器中杀掉应用,这个结果是不一致的,其取决于这个OS的任务管理器的实现,大部分国内的厂家都会对任务管理器进行定制,以达到更有效的杀掉应用的效果.一般来说厂家定制的任务管理器都会比较暴力,除了少数白名单,其他的应用一概直接将进程杀掉</p><p>我们以上面的那个测试程序为例,打开这个程序之后, 其进程优先级为Foreground,这时候我们直接调用任务管理器杀掉改程序(以魅族MX4 Pro为栗子):<br><img src="/images/media/15368463131512.jpg" alt=""></p><p>可以看到用任务管理器杀掉之后, 整个应用程序的进程都被杀掉了.</p><h3 id="通过命令行或者开发者工具杀掉应用"><a href="#通过命令行或者开发者工具杀掉应用" class="headerlink" title="通过命令行或者开发者工具杀掉应用"></a>通过命令行或者开发者工具杀掉应用</h3><p>我们可以通过 adb shell am force-stop 包名来杀掉这个程序，其结果也是进程直接被杀掉，IDE(比如Android Studio)选择一个进程后,点击图中的按钮</p><p><img src="/images/media/15368463452505.jpg" alt=""></p><p>也是可以干掉这个进程的. 这时候进程是被直接杀掉的。</p><h2 id="即使关掉后台进程，内存也增加不多？"><a href="#即使关掉后台进程，内存也增加不多？" class="headerlink" title="即使关掉后台进程，内存也增加不多？"></a>即使关掉后台进程，内存也增加不多？</h2><p>这个不对，一个进程被杀死后，其内存会被释放掉的，不管是虚拟机内存还是 Native 内存还是图像所申请的内存，都会被系统回收，放到可用内存中。</p><p>我们以知乎 App Android客户端为栗子，打开这个程序之前,系统剩余内存 1.8G:</p><p><img src="/images/media/15368465468675.jpg" alt="打开知乎之前，系统剩余内存"></p><p>打开知乎这个程序之后,系统剩余内存:</p><p><img src="/images/media/15368465916092.jpg" alt="打开知乎之后，系统剩余内存"></p><p>知乎占用的内存:</p><p><img src="/images/media/15368466486814.jpg" alt="知乎内存占用"></p><p>使用任务管理器杀掉知乎(直接杀掉进程),系统剩余内存:</p><p><img src="/images/media/15368466879470.jpg" alt="杀掉知乎知乎系统剩余内存"></p><p>可以看到，杀掉进程之后，系统可用内存是会增加的。</p><h2 id="据说即使前台关掉进程，其实该进程在后台还在运行？"><a href="#据说即使前台关掉进程，其实该进程在后台还在运行？" class="headerlink" title="据说即使前台关掉进程，其实该进程在后台还在运行？"></a>据说即使前台关掉进程，其实该进程在后台还在运行？</h2><p>这个和第一条一样，取决于你关掉进程的方法：</p><ol><li>如果是按 Back 键，那么该进程还是会在后台。<strong>是否在运行，则要取决于这个应用的行为，有的应用 Back 到后台之后，其优先级会降到 Cache，系统内存不足或者触发 Cache  进程的数量限制，都会被系统直接杀掉，回收内存；有的应用 Back 到后台之后，会触发一些后台任务，起个 Service 之类的，还是会继续运行，比如导航软件和听歌软件</strong></li><li>如果是按 Home 键，那么该进程依然会在后台，其大部分资源都没有释放，包括 Activity、Service 等。是否在运行，与 Back 到后台的行为一样，取决于应用的行为。</li><li>如果是被任务管理器或者命令行(Force Stop)杀掉，那么除非自启动（很多国内的应用被杀之后都会走自启动模式，同样很多国内的手机厂商，都会禁止应用被杀后走自启动模式，或者被其他进程唤醒，一般有名单进行控制，名单内的可以自启动，其他的自己想办法），应用是不会在后台运行的。</li></ol><p>从上面的三个逻辑来看，用户最佳的使用方法应该遵循下面的建议：</p><ol><li>如果是正在使用的应用，临时切出去干个别的事情，一会还要切回来，那么使用 Home 键把当前应用退到后台最佳</li><li>如果是不想看了，想退出应用了，那么使用 Back 键把当前应用退到后台最佳</li><li>如果不希望这个应用退到后台之后还有可能运行，或者想释放内存，那么用任务管理器把这个应用直接杀掉最好（推荐一键全杀，国内的 Rom 基本都有）</li></ol><p>上面也讲到，<strong>国内的手机厂商，都会禁止应用被杀后走自启动模式，或者被其他进程唤醒，一般有名单进行控制</strong>，这样做是为什么呢？厂商这么做无非是为了限制应用对资源的占用，一个应用退到后台之后，系统肯定是希望其占用最少的资源，能不占资源最好（cpu、gpu、io、memory），但是国内的部分应用却没那么安分守己，大家肯定听说过全家桶和相互唤醒，应用被杀了没问题，我另外一个应用偷偷把你拉起来就可以了，这拉起来的过程就占用了系统的资源，可能会导致前台应用出现卡顿，或者导致整机内存不足，所以厂商对应用的限制是无可厚非的。</p><p><img src="/images/media/15368493914981.jpg" alt="百度全家桶"></p><p>那么应用为什么要抱团取暖，相互唤醒呢？第四个问题就是说这个的。</p><h2 id="智能手机无需将程序彻底关掉，可以减少再启动的时间。是这样吗？"><a href="#智能手机无需将程序彻底关掉，可以减少再启动的时间。是这样吗？" class="headerlink" title="智能手机无需将程序彻底关掉，可以减少再启动的时间。是这样吗？"></a>智能手机无需将程序彻底关掉，可以减少再启动的时间。是这样吗？</h2><p>这句话没毛病，但是是有前提的，前提就是，如果这个应用在后台可以安分守己，至于现实嘛..不说大家也知道，参考<a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%BA%A6%E5%85%A8%E5%AE%B6%E6%A1%B6" target="_blank" rel="noopener">百度全家桶</a></p><p>Android设计的时候,确实是想让大家不去关心内存问题,Android会有一套自己的内存管理机制,在内存不足的时候通过优先级干掉一些应用。每个应用在接收到内存不足的信号，需要根据内存不足的程度,来释放掉一部分内存.以保持自己的进程不被杀死,这样下次启动的时候就不用去fork zygote，这样的话，下一次启动的时间确实会少很多，也就是大家常说的冷启动和热启动的差距。</p><p>但是……………..凡是总有个但是，理想是丰满的，现实是很残酷的。严格按照Google想的那一套去做的应用不多，国内开发者对内存的敏感程度很低，导致很多应用程序跑起来分分钟就100-200MB 了，墨迹天气这样的应用，400m 妥妥的(不好意思又黑了墨迹天气) 。所以手机低内存的情况非常常见，所以低内存的情况会很频繁。这时候你再起一个应用，申请内存的时候发现内存不够，就开始杀应用了。</p><p>所以经常会出现你在看电子书，突然这时候微信来了个消息，你切过去回了个消息，打开相机拍了个照，然后发给朋友，又发了条微博，再回来看书的时候发现电子书已经挂了，正在重新加载程序….WLGQ…</p><p>这时候你就发现限制后台进程的重要性了，把不重要的进程直接干掉，限制应用的自启动和相互唤醒，保证重要的进程不会被系统杀掉，也就保证了用户的基本使用体验。</p><p>所以说不重要的程序是需要在使用结束后直接干掉的.一劳永逸,麻麻再也不用担心这货偷跑流量/后台安装程序/占内存/占 CPU 了….</p><p>再说后半句: 可以减少启动的时间. 这个是对的, 如果一个应用程序的进程没有被杀死,那么下一次启动这个应用程序的时候,就不需要去创建这个进程了(fork zygote,这个耗时还是蛮多的), 而是直接在这个进程中创建对应的组件即可(Android四大组件)，速度比冷启动要快很多。</p><p>以汽车发动为例:</p><ol><li>冷启动相当于 上车 -&gt; 拧钥匙 -&gt; 等发动机启动 -&gt; 踩刹车换挡 -&gt; 放手刹 -&gt; Go</li><li>热启动相当于 上车 -&gt; 踩刹车换挡 -&gt; 放手刹 -&gt; Go</li></ol><p><img src="/images/media/15368489339779.jpg" alt=""></p><h2 id="关于-Android-内存的其他一些问题"><a href="#关于-Android-内存的其他一些问题" class="headerlink" title="关于 Android 内存的其他一些问题"></a>关于 Android 内存的其他一些问题</h2><p>这里来简单解答一下第一段中提到的那些问题</p><ol start="2"><li>Android 系统是怎么管理内存的呢？ – 这个嘛，后续再详细讲</li><li>应用到底占了多少内存？ – 这个嘛，后续再详细讲</li><li>系统到底占了多少内存？ – 这个嘛，后续再详细讲</li><li>内存对我手机的使用体验有什么影响？– 低内存会影响整机的流畅性和响应速度，也会导致杀应用变得很频繁，用户体验差。</li><li>到底怎么才能用好 Android 手机？– 买 Android 旗舰，多用任务管理器的全杀功能，尽量禁止应用后台运行（Flyme 用户可以在手机关机里面设置）</li><li>换新手机换多大内存的会比较合适呢？ – 越大越好，6G 起步，8G 最佳。</li></ol><p><img src="/images/media/15368490914358.jpg" alt=""></p><h2 id="内存相关的文章参考"><a href="#内存相关的文章参考" class="headerlink" title="内存相关的文章参考"></a>内存相关的文章参考</h2><ol><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Java/" target="_blank" rel="noopener">Android代码内存优化建议-Java官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource/" target="_blank" rel="noopener">Android代码内存优化建议-Android资源篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Google/" target="_blank" rel="noopener">Android代码内存优化建议-Android官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory/" target="_blank" rel="noopener">Android代码内存优化建议-OnTrimMemory优化</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-2/" target="_blank" rel="noopener">Android性能优化典范之Understanding Overdraw</a></li><li><a href="https://www.androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/" target="_blank" rel="noopener">Android性能优化之过渡绘制(一)</a></li><li><a href="https://www.androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/" target="_blank" rel="noopener">Android性能优化之过渡绘制(二)</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/" target="_blank" rel="noopener">Android内存优化之一：MAT使用入门</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/" target="_blank" rel="noopener">Android内存优化之二：MAT使用进阶</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/" target="_blank" rel="noopener">Android内存优化之三：打开MAT中的Bitmap原图</a></li><li><a href="https://www.androidperformance.com/2018/08/13/Some-Thoughts-on-the-Fluency-of-Android/" target="_blank" rel="noopener">关于 Android 系统流畅性的一些思考</a></li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Memory </tag>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Android 系统流畅性的一些思考</title>
      <link href="/2018/08/13/Some-Thoughts-on-the-Fluency-of-Android/"/>
      <url>/2018/08/13/Some-Thoughts-on-the-Fluency-of-Android/</url>
      
        <content type="html"><![CDATA[<p>最近一直想写一些关于 Android 系统流畅度的东西，因为流畅度这个东西，是消费者最直接能体验到的，再加上 Android 一直为人诟病的越用越卡顿，使得大家在提到安卓机的时候，都会有一丝阴影。这也是大部分人买手机首先会考虑 iPhone 的一个原因。</p><p>由于 Google 对 Android 持开放态度，各个手机厂商生产不同产品定位的机器，以及各个 Android 应用的质量良莠不齐，导致影响 Android 流畅度的因素非常非常多，并非大家简单的以为是系统没有优化好，很多时候你会发现，不同 SOC 但是相同的系统，体验完全就是两种。</p><p>所以我想和大家聊聊影响 Android 系统流畅性的一些原因，后续大家遇到卡顿的问题，也不会单纯把锅甩给系统，或许你卸载一个 App 就解决了呢.</p><p>我想从下面几个方面展开聊这个话题:</p><blockquote><ol><li>硬件层面</li><li>系统层面</li><li>应用层面</li><li>流畅度优化闭环</li></ol></blockquote><p>准备好了，那就开始吧，欢迎你加入讨论</p><h2 id="1-硬件层面"><a href="#1-硬件层面" class="headerlink" title="1. 硬件层面"></a>1. 硬件层面</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>cpu 是手机硬件里面最核心的一个器件，这也是把 cpu 作为第一个来说的主要原因，cpu 之所以重要，是因为 Android 系统的运行过程中，大部分是跟 cpu 打交道，cpu 的能力强弱，直接决定了这款手机的档次。</p><p>手机 cpu 目前主要有高通、华为、三星、联发科四家在做，每家都有高中低档，高端 cpu 的排名大概是 高通&gt;华为&gt;三星&gt;联发科, 具体的排名可以去这里看(仅供参考)：<a href="http://www.mydrivers.com/zhuanti/tianti/01/" target="_blank" rel="noopener">http://www.mydrivers.com/zhuanti/tianti/01/</a></p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>各个厂商提供的 SOC 里面，通常包含了 cpu 和 gpu ，所以大部分情况下，只要一说 cpu，其 gpu 也是对应确定的，比如高通骁龙845 SOC 带的 gpu 就是 Adreno 630。</p><p>gpu 的能力强弱更多的影响的是 gpu 强相关的应用和游戏，比如绝地求生-刺激战场 、 崩坏3 、极品飞车、狂野飙车等。反而王者荣耀这样的游戏更多的是吃 cpu 而不是 gpu。</p><h3 id="Ram"><a href="#Ram" class="headerlink" title="Ram"></a>Ram</h3><p>随着 Android 版本的更新，以及硬件的更新换代，Android 系统对内存的需求越来越强，目前4G内存的手机基本上已经成了标配，旗舰机器没个 6G 或者 8G 你都不好意思说自己是旗舰。</p><p>内存主要影响系统行为，内存越大，系统就越可以以空间换时间：后台可以缓存更多的进程，杀进程不再那么激进；可以根据用户习惯预加载一些文件或者进程；各种虚拟机、hwui、进程的参数可以往宽松里调。反馈到用户那里，就是快。</p><p>当然如果后台进程多了又没有管住在后台跑，那么又会很耗电，有点得不偿失，这也是为什么国内的系统都会对进程管理这一块进行魔改。</p><h3 id="UFS-amp-amp-EMMC"><a href="#UFS-amp-amp-EMMC" class="headerlink" title="UFS &amp;&amp; EMMC"></a>UFS &amp;&amp; EMMC</h3><p>ufs 和 emmc 都是面向移动端的 flash 标准，我们最长听说的就是 emmc5.1 和 ufs 2.1 ，具体可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/26431201" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26431201</a></p><p>对于用户来说，ufs 和 emmc 的差异主要在文件读取速度、视频加载速度、文件拷贝等方面，总之能上ufs就别考虑 emmc。</p><p>不过有时候这个也是需要 SOC 支持的，比如高通 660，就不支持 ufs，能不买就别买吧。</p><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>我们最常见的屏幕分辨率是 1080P，即 1920*1080. 对用户来说，屏幕分辨率除了会影响视觉感官外，还会在系统某些地方有差异，比如截图、录屏、合成等操作。越高的屏幕分辨率，在这里的耗时就越久，也越耗电。</p><p>这也是部分 2K 手机在某些场景下，把分辨率降低到 1080P 去运行的原因。比较失败的一个例子就是当年的魅族 MX4 Pro ，在硬件性能不足以支撑 2K 的情况下，强行上了 2K 屏幕，导致很多情况下，用户反馈又卡又耗电。</p><h3 id="电池大小"><a href="#电池大小" class="headerlink" title="电池大小"></a>电池大小</h3><p>电池大小决定着续航，也决定着手机设计，手机厂家往往需要在这两者之间找一个平衡，在电池技术没有突破的情况下，就算各家都有快充，还是建议用户在选购手机的时候，尽量选大容量电池的手机，比如 Oppo Find X 或者 Vivo NEX，或者华为 Mate 10.</p><h3 id="SoC-平台"><a href="#SoC-平台" class="headerlink" title="SoC 平台"></a>SoC 平台</h3><p>SoC的全称叫做：System-on-a-Chip，除了我们之前说的 cpu、gpu，Soc 上还有很多器件，具体可以看这篇文章：<a href="https://zhuanlan.zhihu.com/p/37634251" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37634251</a><br>，这里就不展开讲了。</p><p>SoC 是整个手机最重要的部分，是一切体验的基础。现在高通、三星、MTK 给手机厂家提供的硬件就是 Soc ，以及其配套的 Android 适配系统。手机厂商拿到这个之后，在其基础上做整机的设计，系统这边会在配套的 Android 适配系统上做移植，也就是把各家系统差异化的东西移植到新系统上。</p><p>从目前的高通、三星、MTK 三家的适配系统的质量来看，高通提供的适配系统是功能最完善的，高通在 AOSP 的基础上，加上了高通自己的非常多的优化代码，并提供了完善的参数供手机厂商去配置，总的来说开发起来是很舒服的，本身系统的问题不会太多，加上高通的文档完善，支持速度快，国内那么多手机厂商都在用高通也就不足为奇了。</p><p>至于专利费，该给的要给啊。</p><p>我们经常会说，如果魅族早点用高通的 Soc，早 TM 上市了。</p><h2 id="2-系统层面"><a href="#2-系统层面" class="headerlink" title="2. 系统层面"></a>2. 系统层面</h2><h3 id="应用的管控策略"><a href="#应用的管控策略" class="headerlink" title="应用的管控策略"></a>应用的管控策略</h3><p>大部分 Android 应用开发者对国内的手机厂商恨的咬牙切齿，最大的原因就是国内系统对应用管控这一块进行了大量的魔改，除非你是 QQ 或者微信，否则灭了屏结果都一样。</p><p>国内厂商这么做，不是没有原因的，国内应用厂商的全家桶相互唤醒，已经到了一种丧心病狂的地步，牵一发而动全身，一点都不夸张。</p><p>我们遇到的很多用户反馈的整机卡顿问题，抓 Trace 和 Log 来看，都是后台有应用在乱跑，或者后台大量的进程常驻，内存根本不够，而这些普通用户根本就不知道怎么去处理。</p><p>所以国内厂商一般会在系统里面做限制，以保障用户的基础体验：</p><ol><li>除非必须，一个应用偷偷拉起来另外一个应用的行为是不被允许的</li><li>除非必须，一个应用常驻后台是不被允许的</li><li>除非必须，一个应用在灭屏后在后台乱跑是不被允许的</li><li>除非必须，一个应用在后台长时间占用 cpu 是不被允许的</li><li>除非必须，一个应用弹窗是不被允许的</li></ol><p>另外手机厂商会有其他的逻辑清理后台的应用，尽管你是合理存在的。</p><p>对进程的严格管控，也导致了国内系统的体验有一定的影响，首当其冲的是通知，如果一个应用没有接入这个手机厂商提供的 push sdk，那么他这辈子别想发通知给用户了，如果接入了手机厂商提供的 sdk（目前大部分应用的普遍做法），由于应用不在后台，用户点击通知要等好久才可以进入到对应的界面，毫无用户体验可言。</p><h3 id="内存策略"><a href="#内存策略" class="headerlink" title="内存策略"></a>内存策略</h3><p>手机厂商常常会根据手机的内存大小来定制各种不同的策略，比如后台应用的缓存个数、LowMemoryKiller 的阈值、杀进程模块的阈值、显示模块的缓存大小阈值、用户最常用应用的个数等。</p><p>很多低端机用户反馈卡顿，我们查看发现，内存是造成卡顿的主要元凶，在低内存的机器上，由于内存不足，系统会频繁杀后台，同时也有频繁的内存-&gt;文件，文件-&gt;内存 的操作，Trace 上很多 BlockIO，很多平时执行很快的操作，现在执行要很久，再加上部分进程被杀之后马上重启，重启之后又被杀，cpu 占用很高，此时就会很卡。</p><p>随着 Android 系统和应用的更新，只会越来越吃内存，目前4G内存是标配，明年或许 6G 才是标配了，能上 8G 尽量上 8G。</p><h3 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h3><p>进程调度策略有时候也会影响用户的流畅性，当应用的渲染链路上，有哪个环节因为某些原因，没有被调度到的时候，很大可能会造成卡顿。</p><p>调度不到在 Trace 上的表现是 Runnable，常见的调度不到的情况有：</p><ol><li>同时运行的进程太多，cpu 这边的几个核处理的任务基本都是满的</li><li>进程优先级较低</li><li>调度器过于不灵敏，不能及时响应大任务</li></ol><p>另外由于 cpu 引起的卡顿情况还有：</p><ol><li>从大核心掉落到小核心上，小核心处理能力不足，会造成短暂的卡顿</li><li>触发温控或者触发低电量，此时某些系统会限制大核的使用，导致卡顿</li><li>系统锁也是造成卡顿的一大元凶，尤其是 wms 锁和 ams 锁，再加上 binder 通信，relayoutWindow 了解一下？ </li><li>核心频率不足，导致函数执行时间过长导致卡顿</li><li>大核心被占用，任务又调度不到小核，导致卡顿</li></ol><p>系统调优往往需要针对上面的情况做对应的处理，给用户一个好的用户体验。具体的调优方式，往往跟系统和 Soc 强相关，又涉及到 Kernel 和 功耗，改起来是牵一发而动全身，需要非常谨慎。</p><h3 id="渲染线程和主线程"><a href="#渲染线程和主线程" class="headerlink" title="渲染线程和主线程"></a>渲染线程和主线程</h3><p>Android 应用的渲染链路上最重要的就是主线程和渲染线程，主线程就是应用启动时创建的 MainThread，对应的也会创建一个 RenderThread（硬件加速默认开启），我们平时比较看重的 GPU Profile 那条线，基本就包含了主线程和渲染线程的各个阶段的执行时间，从 GPU Profile ，就可以很容易看到应用的瓶颈</p><p>大部分应用的卡顿都发生在主线程和渲染线程上，比如：</p><ol><li>较长时间的 input 事件处理</li><li>较长时间的动画事件处理，比如 ListView 的新 Item 的生成</li><li>复杂界面的 Measure、 Layout、Draw</li><li>较大 Bitmap 的频繁 upload </li><li>复杂渲染指令的执行</li></ol><p>很多编程的不好的实现，都可以在上面几个步骤里面体现出来，这些都可以通过 Systrace 看出来。</p><p>当前应用的渲染链路上的一切优先级都应该是最高的，后台的进程不应该对其造成影响，这也是系统优化的核心要素，不过要做到这一点也是比较难的，你很难考虑到所有的情况，比如有的用户的使用环境就是很复杂，而且都是必须的，这时候就不是很好处理。</p><h3 id="TripleBuffer"><a href="#TripleBuffer" class="headerlink" title="TripleBuffer"></a>TripleBuffer</h3><p>之前有提到 TripleBuffer，这个是 Project Butter 引进的，其中 Vsyncv 和 TripleBuffer 的引进使得 Android 的流畅度上了一个台阶，关于这个可以参考这篇文章 ： <a href="https://niorgai.github.io/2017/03/21/Android-Draw-System/" target="_blank" rel="noopener">https://niorgai.github.io/2017/03/21/Android-Draw-System/</a></p><p>对于用户来说这个是透明的，影响的是 GPU Profile 的展示，有时候如果有一条线超过 16 ms 的警戒线，它不一定代表着卡顿，这就是 TrileBuffer 的作用。</p><p>后续我会有文章专门讲这个，如何判断是真正的卡顿。</p><h3 id="虚拟机-Art-和-Dalvik"><a href="#虚拟机-Art-和-Dalvik" class="headerlink" title="虚拟机 - Art 和 Dalvik"></a>虚拟机 - Art 和 Dalvik</h3><p>对用户来说，Art 虚拟机相比 Dalvik 虚拟机，最大的提升就是解放了应用的主线程，主线程不再频繁被 GC 线程 Stop ，相应卡顿也减少了很多。</p><p>当然 Art 带来的好处不止这一点，Art 随着几个大版本的缝缝补补，已经在很多地方远远超过了 Dalvik，有兴趣的可以自己查一下。</p><h3 id="温控-amp-amp-低电量"><a href="#温控-amp-amp-低电量" class="headerlink" title="温控 &amp;&amp; 低电量"></a>温控 &amp;&amp; 低电量</h3><p>之前提到，一旦触发温控或者低电量，系统会对资源做一定的限制，防止手机无限制过热或者快速关机。这限制就包括</p><ol><li>降低 cpu、gpu 最高频率</li><li>减少可运行的 cpu 的核心数</li><li>杀掉部分后台进程</li><li>关闭部分特效</li><li>限制网络连接</li></ol><p>总之，这些限制或多或少会对用户造成影响，最大的影响就是卡顿，这就是很多人会遇到打游戏的时候突然很卡的一个原因。</p><p>所以说选购手机的时候，除了要看 Soc，还要看散热是否做的够好，电池是否做的够大。</p><h2 id="3-应用层面"><a href="#3-应用层面" class="headerlink" title="3. 应用层面"></a>3. 应用层面</h2><h3 id="复杂的布局"><a href="#复杂的布局" class="headerlink" title="复杂的布局"></a>复杂的布局</h3><p>复杂的布局往往是应用卡顿的最主要的元凶之一，复杂的布局意味着更长的 Measure、Layout、Draw ，这会拖慢主线程的执行速度</p><p>ListView、RecyclerView 的新的 Item 在初始化的时候也会有类似的问题，由于此时一般是在滑动，这时候的卡顿感会更明显，用户也更容易察觉，这个从 Trace 上也很容易看出来。</p><h3 id="过多的业务逻辑"><a href="#过多的业务逻辑" class="headerlink" title="过多的业务逻辑"></a>过多的业务逻辑</h3><p>过多业务逻辑导致的卡顿和响应慢的问题，拿淘宝来举例子最合适不过了，每次你冷启动淘宝的时候，进入主界面马上滑动，总感觉跟吃了屎一样，点按钮点不动，滑界面滑不动，虽然最近的版本有优化，不过你找个低端 Android 机，还是原来的配方。</p><p>淘宝在启动的时候，需要动态加载很多东西，导致主界面响应很慢，很多东西要动态加载完成后才可以操作，后台还有大量的 dex2oat 操作，可以说是很忙了。</p><h3 id="内存颠簸"><a href="#内存颠簸" class="headerlink" title="内存颠簸"></a>内存颠簸</h3><p>频繁申请和释放内存，会导致内存颠簸，从 AS 的内存监视器可以看到这一点，短时间内内存曲线上下跳动非常频繁，这时候你需要检查一下是否代码写的有问题。</p><h3 id="慢网络"><a href="#慢网络" class="headerlink" title="慢网络"></a>慢网络</h3><p>慢网络指的是用户请求网络耗时很久，这会导致用户在某些界面等待内容需要很久，比如知乎经常会出现这种情况，在用户看来，这就是卡了。</p><h3 id="不合理的设计"><a href="#不合理的设计" class="headerlink" title="不合理的设计"></a>不合理的设计</h3><p>设计和性能往往不可兼得，需要从两者之间做取舍，设计师的设计往往很炫酷，互相嵌套的动画往往是程序员的噩梦，为了实现这些复杂的效果，程序员往往需要复杂的代码来实现，这对应用的渲染链路的压力是非常大的，而且在不同性能的机器上表现差异很大，高端机用户觉得这个效果棒棒哒，低端机用户卡的要骂娘。</p><p>程序员需要有这方面的知识和数据，好与设计师动之以情晓之以理。</p><p>不过用户是很挑剔的，现在的用户对性能的要求越来越高，哪怕是低端机用户，所以合适的设计应该考虑到这部分用户、或者针对低端机用户做区分。</p><h3 id="代码实现错误"><a href="#代码实现错误" class="headerlink" title="代码实现错误"></a>代码实现错误</h3><p>俗称 bug ，很多程序员不喜欢解决性能问题，因为这个东西解决起来，性价比很低，拿我司的程序员来说，解一个性能问题的时间，可以解决十几个界面显示的问题，还未必能真的解决。</p><p>不过由于代码实现错误引起的性能问题，必须要最高优先级解决。</p><h2 id="4-流畅度优化闭环"><a href="#4-流畅度优化闭环" class="headerlink" title="4. 流畅度优化闭环"></a>4. 流畅度优化闭环</h2><h3 id="实验室监控-amp-amp-模拟用户"><a href="#实验室监控-amp-amp-模拟用户" class="headerlink" title="实验室监控 &amp;&amp; 模拟用户"></a>实验室监控 &amp;&amp; 模拟用户</h3><p>开发阶段就用各项数据来做监控和对比，尽量模拟用户的使用环境，尽早暴漏性能问题，早日解决。</p><h3 id="用户流畅度数据收集"><a href="#用户流畅度数据收集" class="headerlink" title="用户流畅度数据收集"></a>用户流畅度数据收集</h3><p>在用户使用阶段，收集性能数据，针对这些数据做分析，找出用户最多遇到的性能问题，针对性地做优化。需要注意此时不能在用户阶段手机太多的信息，否则会导致观察者效应</p><p>至于需要收集的数据，则需要根据相关度模型来做判断，卡顿发生的时候，系统的哪些指标是可能导致卡顿的原因，那么这些指标就是我们收集的数据。</p><p>另外用户的场景判断也非常重要，需要知道用户是在哪个场景出现的卡顿，一旦用户的数量到了一定的级别，这个是很容易发现问题的。</p><h3 id="针对性地优化"><a href="#针对性地优化" class="headerlink" title="针对性地优化"></a>针对性地优化</h3><p>大数据发现问题后，后续就是针对性地进行优化，把用户最常遇到性能问题的场景进行排序，对最常见的场景进行调研和优化。很多时候需要与应用开发厂商进行沟通，</p><p>然后需要把这些场景纳入到实验室监控环境里，做到 实验室监控 —&gt; 模拟用户 — &gt; 大数据收集 —&gt; 针对性优化 —&gt; 实验室监控补充. 这样一个闭环。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 流畅性 </tag>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎 救救你的 StartingWindow</title>
      <link href="/2018/05/20/zhihu-startingwindow/"/>
      <url>/2018/05/20/zhihu-startingwindow/</url>
      
        <content type="html"><![CDATA[<p>我们经常说 iOS 整机体验要比 Android 好，这里有第三方软件的功劳（iOS 版本质量要高于 Android 版本质量），当然也归功于苹果对 iOS 的封闭系统的管控。应用想上 App Store，就得先过审核，不合规就给你打回来。</p><p>今天我们要说的，就是 iOS 和 Android 系统差异化的一个重要体现：StartingWindow，通俗点说，就是应用启动页。iOS 和 Android 都有 StartingWindow，但是表现却完全不一样。iOS 开发要求应用必须要有一个 StartingWindow，且必须是一张图片（iOS 开发可以说说是否支持定制 Layout），用户点击桌面图标启动应用，不会有任何延迟，会立即显示这个图片；Android 系统的 StartingWindow 虽然也是系统提供的，但是由于开放性，Android 允许开发者自己定制 StartingWindow、disable StartingWindow、透明化 StartingWindow。</p><a id="more"></a><h2 id="StartingWindow-对用户体验的影响"><a href="#StartingWindow-对用户体验的影响" class="headerlink" title="StartingWindow 对用户体验的影响"></a>StartingWindow 对用户体验的影响</h2><p>由于 StartingWindow 对用户体验非常重要，但是应用开发者对 StartingWindow 的滥用，导致了用户启动应用的时候，会获得非常不好的体验，我举个例子你们就明白了：</p><ol><li>使用系统默认的 StartingWindow ：用户点了应用图标启动应用，马上弹出系统默认的 StartingWindow（就是做动画的那个 Window） ，等应用加载好第一帧之后，StartingWindow 消失，显示应用第一帧，无缝衔接，体验还不错，这也是通常大部分 Android 应用的场景；比如大部分 Android 系统的自带应用，即刻、汽车之家等</li><li>自己定制简单的 StartingWindow ：用户点了应用图标启动应用，弹出应用自己定制的StartingWindow，等应用加载好第一帧之后，定制的 StartingWindow 消失，显示应用主界面，由于 StartingWindow 是自己定制的，启动的时候 Decode Bitmap 或者  Inflate 自定义 Layout 会有一定的耗时，但是总的来说与系统默认的差别不大，用户体验优；这样的应用包括淘宝、京东、微博、今日头条、美团等</li><li>把 StartingWindow 禁掉或者设置透明 ：用户点了应用图标启动应用，由于 StartingWindow 被禁掉或者被设置透明，所以会出现点击图标后，除了图标黑一下之外没有任何响应，过个 1-N 秒（取决于应用第一帧的加载速度），直接显示应用主界面。这样的<strong>毒瘤</strong>应用包括：微信、微信读书、UC 浏览器、支付宝、工商银行、米家等。</li></ol><p>大家可以安装一下我上面说的那些个应用自己体验一下，我是真的没法体会为何会有那么多应用采用第三种方式，偏偏很多用户只有一台手机，不认为是应用的问题，反而觉得是系统比较慢，然后各种投诉到系统这边，还是四五星的 Bug，真的是欲哭无泪。</p><p>我建议采用了第三种方式的应用的开发者，面壁思过一下，你们的产品经理是不合格的，你们作为开发没有主动提出优化这个也是失职的。不用怀疑微信也是他们的一员，只不过微信作为超级 App，在很多系统里面不杀他而已，不信你 <strong>adb shell am force-stop com.tencent.mm</strong> 一下试试。</p><h2 id="知乎用户体验-数据展示"><a href="#知乎用户体验-数据展示" class="headerlink" title="知乎用户体验 - 数据展示"></a>知乎用户体验 - 数据展示</h2><p>不过我今天不想说微信，我想说说知乎，因为我本人是知乎的重度用户，所以最近被知乎的体验搞得心情极差，再加上 N 多用户投诉启动慢，我必须来说两句了。</p><p>最近知乎安卓版的版本（5.17.2），虽然没有采用第三种方式，采用的是第一种方式，但是用户体验极差，具体说就是：点击桌面图标启动应用 -&gt; 显示白屏（取决于你手机的性能，在1-5s 之间）-&gt; 显示知乎是广告页 -&gt; 显示知乎首页。我们之前说，白屏是大部分系统的默认 StartingWindow ，之所以会出现这样的现象是因为知乎那令人发指的应用启动速度。</p><p>我并不想从代码级别去分析他都干了啥，因为很多人对这个不感兴趣，感兴趣的可以自己抓 MethodTrace 看一下就可以了，这里我们简单从 Systrace 来看一眼就可以了，修复 Bug 的事情，让知乎的程序员去干吧。</p><ol><li><p>从 StartingWindow（白屏） 出现到应用显示第一帧（SurfaceFlinger 视角，数据来自 Mix2s）<br> <img src="/images/media/15269126222428.jpg" alt="第一帧"></p></li><li><p>从 StartingWindow（白屏） 出现到应用显示第一帧（应用进程视角，数据来自 Mix2S）<br><img src="/images/media/15269125336746.jpg" alt="知乎冷启动"></p></li><li><p>Log 视角(看 am_activity_launch_time ：2684)(数据来自 Pro7，Mix2s 是1552)</p></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">58.033</span>  <span class="number">1252</span>  <span class="number">3371</span> I am_create_activity: [<span class="number">0</span>,<span class="number">128018471</span>,<span class="number">73</span>,com.zhihu.android/.app.ui.activity.LauncherActivity,android.<span class="built_in">int</span>ent.action.MAIN,NULL,NULL,<span class="number">270532608</span>]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">58.037</span>  <span class="number">1252</span>  <span class="number">3371</span> I am_focused_activity: [<span class="number">0</span>,com.zhihu.android/.app.ui.activity.LauncherActivity,startedActivity]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">58.042</span>  <span class="number">1252</span>  <span class="number">3371</span> I sysui_action: [<span class="number">323</span>,com.zhihu.android/.app.ui.activity.LauncherActivity]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">58.092</span>  <span class="number">1252</span>  <span class="number">1293</span> I am_proc_start: [<span class="number">0</span>,<span class="number">20985</span>,<span class="number">10111</span>,com.zhihu.android,activity,com.zhihu.android/.app.ui.activity.LauncherActivity]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">58.133</span>  <span class="number">1252</span>  <span class="number">2857</span> I am_proc_bound: [<span class="number">0</span>,<span class="number">20985</span>,com.zhihu.android]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">58.140</span>  <span class="number">1252</span>  <span class="number">2857</span> I am_restart_activity: [<span class="number">0</span>,<span class="number">128018471</span>,<span class="number">73</span>,com.zhihu.android/.app.ui.activity.LauncherActivity]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">59.564</span>  <span class="number">1252</span>  <span class="number">3109</span> I am_create_activity: [<span class="number">0</span>,<span class="number">123681068</span>,<span class="number">73</span>,com.zhihu.android/.app.ui.activity.MainActivity,android.<span class="built_in">int</span>ent.action.MAIN,NULL,NULL,<span class="number">270532608</span>]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">59.566</span>  <span class="number">1252</span>  <span class="number">3109</span> I am_focused_activity: [<span class="number">0</span>,com.zhihu.android/.app.ui.activity.MainActivity,startedActivity]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">59.567</span>  <span class="number">1252</span>  <span class="number">3109</span> I am_pause_activity: [<span class="number">0</span>,<span class="number">128018471</span>,com.zhihu.android/.app.ui.activity.LauncherActivity]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">59.570</span>  <span class="number">1252</span>  <span class="number">3109</span> I sysui_action: [<span class="number">323</span>,com.zhihu.android/.app.ui.activity.LauncherActivity]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">59.571</span>  <span class="number">1252</span>  <span class="number">3126</span> I am_finish_activity: [<span class="number">0</span>,<span class="number">128018471</span>,<span class="number">73</span>,com.zhihu.android/.app.ui.activity.LauncherActivity,app-request]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">59.661</span>  <span class="number">1252</span>  <span class="number">3094</span> I am_restart_activity: [<span class="number">0</span>,<span class="number">123681068</span>,<span class="number">73</span>,com.zhihu.android/.app.ui.activity.MainActivity]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">00.222</span> <span class="number">20985</span> <span class="number">20985</span> I am_on_resume_called: [<span class="number">0</span>,com.zhihu.android.app.ui.activity.MainActivity,LAUNCH_ACTIVITY]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">00.736</span>  <span class="number">1252</span>  <span class="number">1305</span> I am_activity_launch_time: [<span class="number">0</span>,<span class="number">123681068</span>,com.zhihu.android/.app.ui.activity.MainActivity,<span class="number">1078</span>,<span class="number">2684</span>]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">01.269</span>  <span class="number">1252</span>  <span class="number">2906</span> I am_destroy_activity: [<span class="number">0</span>,<span class="number">128018471</span>,<span class="number">73</span>,com.zhihu.android/.app.ui.activity.LauncherActivity,finish-imm]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">01.859</span>  <span class="number">1252</span>  <span class="number">3072</span> I am_proc_start: [<span class="number">0</span>,<span class="number">21229</span>,<span class="number">10111</span>,com.zhihu.android:pushservice,service,com.zhihu.android/.push.getui.GetuiPushService]</span><br><span class="line"><span class="number">05</span><span class="number">-21</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">01.882</span>  <span class="number">1252</span>  <span class="number">2857</span> I am_proc_bound: [<span class="number">0</span>,<span class="number">21229</span>,com.zhihu.android:pushservice]</span><br></pre></td></tr></table></figure><p>这长达 1.9s 的时间，用户看到的都是白屏，更不用说后面还有 3s 的广告页，然后才到主界面，说好的用户体验呢。。。而且我用的机器是小米 Mix2S，高通845加持，那些低端机器就更不用说了，时间只会多不会少。</p><h2 id="知乎用户体验-用户感受"><a href="#知乎用户体验-用户感受" class="headerlink" title="知乎用户体验 - 用户感受"></a>知乎用户体验 - 用户感受</h2><p>用户看到的就是下面三个步骤（截图来自 Pro7）</p><ol><li>首先点击桌面后，显示 StartingWindow（白屏页面）<br> <img src="/images/media/S80521-222728-1.jpg" alt="S80521-222728"></li></ol><ol start="2"><li><p>2s 后，白屏页面跳转广告页面：<br> <img src="/images/media/S80521-222748-1.jpg" alt="S80521-222748"></p></li><li><p>3S 后跳转知乎主界面<br> <img src="/images/media/S80521-222753-1.jpg" alt="S80521-222753"></p></li></ol><p>我建议知乎还是采用大多数 Android 应用目前采用的第二种方法，即定制简单的 StartingWindow，用户体验好不说，也能拉近 iOS 和 Android 版本的体验差距，比如下图（截取自知乎 iOS 版本）<br><img src="/images/media/Image-1-1.jpg" alt="Image-1"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>很大程度上来说，Android 系统的用户体验取决于第三方应用，各个厂商定制的系统能提升一部分，但是一旦进入了应用的界面，体验就完全取决于应用了。</p><p>StartingWindow 是一个很小的点，但毕竟是应用的入口，入口做的都不好的话，怎么能吸引用户每次都去访问你呢？知乎只是我举的一个小例子，毕竟还有非常恶劣的采用第三种方式的应用垫底，希望通过这个例子，各位应用开发者能体验到应用启动速度对用户的直接影响，俗话说，<strong>天下武功，唯快不破</strong>，不是没有道理的。应用优化的好，系统自然也会沾光，最终受益的还是用户。</p><p>最后还是挂一下那些非常影响用户体验的应用（采用了第三种方法），也希望读者可以反馈，我会持续更新，他们是</p><ol><li>微信</li><li>微信读书</li><li>UC 浏览器</li><li>支付宝</li><li>工商银行</li><li>米家</li><li>……</li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 用户体验 </tag>
            
            <tag> 知乎 </tag>
            
            <tag> StartingWindow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「置顶」Android 性能优化必知必会</title>
      <link href="/2018/05/07/Android-performance-optimization-skills-and-tools/"/>
      <url>/2018/05/07/Android-performance-optimization-skills-and-tools/</url>
      
        <content type="html"><![CDATA[<p>做了这么久性能相关的工作,也接触了不少模块,说实话要做好性能这一块,真心不容易.为什么这么说? 是因为需要接触的知识实在是太多了, Android 是一个整体,牵一发而动全身,不是说只懂一个模块就可以做好</p><p>在学习的过程中,除了看源码,我还接触到了很多互联网上已有的知识,各位前辈们,将他们的知识和经验倾囊相授,让我少走了很多弯路. 我在自己的笔记里面存了很多很优秀的技术文章和技术文档,现在我决定将这些放到网上,让每一个想进入 Android 系统开发和优化这个领域的人,能通过阅读这篇文章,快速入门. 同时也算是我对知识的一个梳理,查漏补缺,终身学习</p><p>这篇文章记录了 Android 性能优化所必须掌握的知识,涵盖性能优化相关的方方面面(当然如果读者同学你也有很棒的私藏文章,也可以加入到这篇文章里面).部分文章可能需要特殊的技巧才能看到，希望你已经掌握了这一部分技巧。另外附送<a href="https://androidperformance.com/2020/02/03/android-development-learning-path-2020-edition/">Android 开发者学习路线(2020 版本)</a></p><p>这篇文章会持续更新，最新更新时间：2020-04-27</p><a id="more"></a><h1 id="优化心得和经验"><a href="#优化心得和经验" class="headerlink" title="优化心得和经验"></a>优化心得和经验</h1><ol><li><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="noopener">系列视频 Android Performance Patterns</a></li><li><a href="https://juejin.im/entry/5aa24187518825557207f8e2" target="_blank" rel="noopener">给 App 提速：Android 性能优化总结 </a></li><li><a href="https://tech.meituan.com/hertz.html" target="_blank" rel="noopener">移动端性能监控方案 Hertz </a></li><li><a href="https://androidperformance.com/2015/03/31/android-performance-case-study-follow-up/">Android 性能优化后续</a></li><li><a href="http://weishu.me/2016/12/23/dive-into-android-optimize-vm-heap/" target="_blank" rel="noopener">Android性能优化之虚拟机调优</a></li><li><a href="https://zhuanlan.zhihu.com/p/27065828" target="_blank" rel="noopener">Android UI 性能优化</a></li><li><a href="https://developer.android.google.cn/training/articles/perf-tips" target="_blank" rel="noopener">Performance Tips</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651747849&idx=1&sn=e6bb86aadb6b7146f3d9ecfb1469a94b&chksm=bd12af448a652652c2d9a8f38bcff5f61b44ad26d86d4d85f6187d6e13296765c1e23dd744f9&mpshare=1&scene=1&srcid=0412q53XS0opyXmxjPp2thAv%23rd" target="_blank" rel="noopener">美团外卖Android Lint代码检查实践</a></li><li><a href="https://www.youtube.com/watch?v=VC2Hlb22mZM" target="_blank" rel="noopener">Android battery and memory optimizations - Google I/O 2016</a></li><li><a href="https://www.udacity.com/course/android-performance--ud825" target="_blank" rel="noopener">Google 免费的公开课 : Android Performance</a></li><li><a href="http://imgtec.eetrend.com/blog/11583" target="_blank" rel="noopener">Android APP 性能优化的一些思考</a></li><li><a href="https://zhuanlan.zhihu.com/p/27593816" target="_blank" rel="noopener">使用Android Studio和MAT进行内存泄漏分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650403370&idx=1&sn=b4297b138eb7f73c95a6279c3458f025&chksm=83953a32b4e2b3247fc18cbee08a2682d8b09720a1c5fef0c36257ae92b1e201cb1ad3125455&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener">历时1年，上百万行代码！首次揭秘手淘全链路性能优化（上）</a></li><li><a href="https://wemp.app/posts/cb3c5a67-0502-4d0a-8afa-b0e9863d8b83?utm_source=latest-posts" target="_blank" rel="noopener">别催更啦！手淘全链路性能优化下篇</a></li><li><a href="https://time.geekbang.org/column/intro/142" target="_blank" rel="noopener">Android开发高手课</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653579716&idx=1&sn=2f65e52559ae46b42222f72219a52198&chksm=84b3bbc3b3c432d52e3d01cc7b686877100556d18610eb80906596d5efa9c0284d1d38c44078&mpshare=1&scene=1&srcid=0311Jtai5vFmqNwNp8WUgsRT#rd" target="_blank" rel="noopener">手 Q Android缓存监控与优化实践</a></li><li><a href="https://www.infoq.cn/article/weixin-reading-stuck-monitor-and-test?useSponsorshipSuggestions=true&utm_source=articles_about_architecture-design&utm_medium=link&utm_campaign=architecture-design" target="_blank" rel="noopener">微信读书（Android）阅读引擎卡顿监控测试</a></li><li><a href="http://www.caveman.work/2019/06/01/Data-science-for-mobile-OS-system-optimization/" target="_blank" rel="noopener">Data science for mobile OS system optimization</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649287054&idx=1&sn=40f1b9935c280547926fc5f799c0b9c2&chksm=8334cd0cb443441aad977bd462df6cafcb20ae55bf9d70c99a7b3045178c848a7e75b6e02aa1&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener">Matrix TraceCanary – 初恋·卡顿</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649287034&idx=1&sn=6706196ff0824578f1400fdf9906c025&chksm=8334cdf8b44344ee51bc30820756ea737d2615fc5b30122c91a88dd7f7e7694847071a7c3b9c&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener">Matrix IOCanary – I/O 质量监控</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTAzMjcxNg==&mid=2651425463&idx=1&sn=778b483ee453f0ba987e5c9edd85c3a4" target="_blank" rel="noopener">见微知著，Google Photos Web UI 完善之旅</a></li><li><a href="https://mp.weixin.qq.com/s/KtGfi5th-4YHOZsEmTOsjg" target="_blank" rel="noopener">微信 Android 终端内存优化实践</a></li><li><a href="https://juejin.im/post/5be1077d518825171140dbfa" target="_blank" rel="noopener">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></li><li><a href="https://juejin.im/post/5e5b9466518825494b3cd5aa" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%</a></li><li><a href="https://juejin.im/post/5e809cf46fb9a03c763cf348" target="_blank" rel="noopener">抖音包大小优化-资源优化</a></li><li><a href="https://mp.weixin.qq.com/s/YJJdh3220y7TvBu3hAE3dQ" target="_blank" rel="noopener">性能问题终结者”Olympic</a></li><li><a href="https://zhuanlan.zhihu.com/p/123328822" target="_blank" rel="noopener">美团 Java 线程池实现原理及其在美团业务中的实践</a></li><li><a href="https://mp.weixin.qq.com/s/tO1yxFs2qNQlQ2bJ8vGzQA" target="_blank" rel="noopener">Probe：Android线上OOM问题定位组件</a></li></ol><h1 id="响应速度"><a href="#响应速度" class="headerlink" title="响应速度"></a>响应速度</h1><ol><li><a href="https://androidperformance.com/2019/11/18/Android-App-Lunch-Optimize/">Android App 启动优化全记录</a></li><li><a href="https://source.android.com/devices/tech/perf/boot-times" target="_blank" rel="noopener">Optimizing Boot Times</a></li><li><a href="https://androidperformance.com/2015/12/31/How-to-calculation-android-app-lunch-time/">Android 中如何计算 App 的启动时间</a></li><li><a href="https://developer.android.google.cn/topic/performance/launch-time" target="_blank" rel="noopener">Google 官方文档 - Launch-time performance</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650829097&idx=2&sn=e59841d4b1ed7e12a30e29ec51072d70&chksm=80b7a5b7b7c02ca184e0c06289d90823d589e738c55712318875f51e4aeb8646294b8d426299&mpshare=1&scene=1&srcid=&sharer_sharetime=1571275213308&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">都 9102 年了，Android 冷启动优化除了老三样还有哪些新招？</a></li><li><a href="https://mp.weixin.qq.com/s/79tAFx6zi3JRG-ewoapIVQ" target="_blank" rel="noopener">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></li><li><a href="https://mp.weixin.qq.com/s/Bf41Kez_OLZTyty4EondHA?" target="_blank" rel="noopener">Redex 初探与 Interdex：Andorid 冷启动优化</a></li><li><a href="https://juejin.im/post/5c21ea325188254eaa5c45b1#heading-5" target="_blank" rel="noopener">Android 性能优化笔记（一）——启动优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9&chksm=e9d0cd4fdea7445989cf26623a16fc8ce2876bf3bda95a5532bb0e5e5b1420765653df0b94d1&mpshare=1&scene=1&srcid=&sharer_sharetime=1565403851018&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">抖音研发实践：基于二进制文件重排的解决方案 App 启动速度提升超15%</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4MTQyNDg3Mg==&mid=2247485301&idx=2&sn=bb1e9c17b705d0dce176f127e539dd97&chksm=eba821f2dcdfa8e4890696f0870a6f48306c0bdb7bffaab146f7250446494470245647a4eb09&mpshare=1&scene=1&srcid=0114JKmlCgbw5D3pMso2K2i8#rd" target="_blank" rel="noopener">爱奇艺 Android 客户端启动优化与分析</a></li><li><a href="https://juejin.im/post/5e6f18a951882549422ef333" target="_blank" rel="noopener">深入探索 Android 启动速度优化</a></li></ol><h1 id="流畅度"><a href="#流畅度" class="headerlink" title="流畅度"></a>流畅度</h1><ol><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Debug/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 方法论</a> </li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-System/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 系统篇</a></li><li><a href="https://www.androidperformance.com/2019/09/05/Android-Jank-Due-To-App/" target="_blank" rel="noopener">Android 中的卡顿丢帧原因概述 - 应用篇</a></li><li><a href="https://androidperformance.com/2019/01/21/android-performance-case-jank-accessbility/">Android 平台应用宝和讯飞输入法无障碍服务导致的全局卡顿分析</a></li><li><a href="https://source.android.com/devices/tech/debug/eval_perf" target="_blank" rel="noopener">Evaluating Performance</a></li><li><a href="https://source.android.com/devices/tech/debug/systrace" target="_blank" rel="noopener">Understanding Systrace</a></li><li><a href="https://source.android.com/devices/tech/debug/ftrace" target="_blank" rel="noopener">Using ftrace</a></li><li><a href="https://source.android.com/devices/tech/debug/jank_capacity" target="_blank" rel="noopener">Identifying Capacity-Related Jank</a></li><li><a href="https://source.android.com/devices/tech/debug/jank_jitter" target="_blank" rel="noopener">Identifying Jitter-Related Jank</a></li><li><a href="http://blog.csdn.net/tencent_bugly/article/details/51354517" target="_blank" rel="noopener">那些年我们用过的显示性能指标</a></li><li><a href="https://developer.android.google.cn/topic/performance/vitals/render" target="_blank" rel="noopener">Slow rendering</a></li><li><a href="https://juejin.im/post/5ae98d33518825670b33e5e6" target="_blank" rel="noopener">Android 流畅度检测原理简析</a></li><li><a href="https://blog.csdn.net/msf568834002/article/details/79015497" target="_blank" rel="noopener">Android JankTracker 原理解析</a></li><li><a href="https://juejin.im/entry/56dce0bb5bbb50004cce752d" target="_blank" rel="noopener">Android 界面性能调优手册</a></li><li><a href="https://juejin.im/post/5da33dc56fb9a04e35597a47" target="_blank" rel="noopener">App流畅度优化：利用字节码插桩实现一个快速排查高耗时方法的工具</a></li></ol><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ol><li><a href="https://androidperformance.com/2019/09/18/Android-Jank-Due-To-Low-Memory/">Android 中低内存对性能的影响</a></li><li><a href="https://source.android.com/devices/tech/perf/low-ram" target="_blank" rel="noopener">Low RAM Configuration</a></li><li><a href="http://www.tinylab.cn/linux-swap-and-zramfs/#zram-" target="_blank" rel="noopener">Linux Swap 与 Zram 详解</a></li><li><a href="http://www.tinylab.cn/android-loading-a-different-relationship-between-dpi-and-memory-consumption-of-resources/" target="_blank" rel="noopener">Android 加载不同 DPI 资源与内存消耗间的关系</a></li><li><a href="https://nekosc.com/technology/zram.html" target="_blank" rel="noopener">ZRAM SWAP 内存管理讲解</a></li><li><a href="https://tech.meituan.com/oom_analysis.html" target="_blank" rel="noopener">Android OOM 案例分析</a></li><li><a href="https://androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource/">Android 代码内存优化建议-Android 资源篇</a></li><li><a href="https://androidperformance.com/2015/07/20/Android-Performance-Memory-Google/">Android 代码内存优化建议-Android 官方篇</a></li><li><a href="https://androidperformance.com/2015/07/20/Android-Performance-Memory-Java/">Android 代码内存优化建议-Java 官方篇</a></li><li><a href="https://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">Android 内存优化之一：MAT 使用入门</a></li><li><a href="https://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/">Android 内存优化之二：MAT 使用进阶</a></li><li><a href="https://androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/">Android 内存优化之三：打开 MAT 中的 Bitmap 原图</a></li><li><a href="https://androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory/">Android 代码内存优化建议-OnTrimMemory 优化</a></li><li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">Android LowMemoryKiller原理分析</a></li><li><a href="https://juejin.im/post/59e818bb6fb9a044fd10de38" target="_blank" rel="noopener">Android 匿名共享内存（Ashmem）原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664286&idx=1&sn=370af253ab45e8ce6da7c7eaeae0fbd1&chksm=810f3743b678be55df8f08dd554586e7e6a4e93fe61a9c557f5b161a6242eee6cd463f68a7e9&mpshare=1&scene=1&srcid=0425PBKSCz1pnccS17NcC4GX%23rd" target="_blank" rel="noopener">郝健: Linux内存管理学习笔记-第1节课</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664286&idx=2&sn=d6f22ef91a616e8e9232217e6dea96d4&chksm=810f3743b678be559350754a23bae993303f785ab9a46e71c09dc52ac980dd53b0d8ea7d2892&mpshare=1&scene=1&srcid=0425t2vpFk5Q1h02R7jrapFy%23rd" target="_blank" rel="noopener">郝健: Linux内存管理学习笔记-第2节课</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664286&idx=3&sn=9124b05c129eedc47e6dd222779a4ea6&chksm=810f3743b678be556d267e68102911aaaa68a31299705c5714a184e97478f45c8aa69cb96472&mpshare=1&scene=1&srcid=0425yjP3kUsqYPi4WgBMNs0q%23rd" target="_blank" rel="noopener">郝健: Linux内存管理学习笔记-第3节课</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664305&idx=1&sn=4f6de1dedec10704704ece849d395525&chksm=810f376cb678be7a7a18a7a3626615e5b8ecedae737a3f18d01db6a1af59cc04529832d1f7cb&mpshare=1&scene=1&srcid=0425iqjnsJkZEnueYQGAhWkj%23rd" target="_blank" rel="noopener">郝健: Linux内存管理学习笔记-第4节课</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664329&idx=1&sn=6b7841d49a5ddff8383097a3c60490e9&chksm=810f3494b678bd82fa38e95fa07e411820499f5a4a772ac60a9ade35bde48c248a30929758a1&mpshare=1&scene=1&srcid=0425aPqzRj0bES2nCueOQMqb%23rd" target="_blank" rel="noopener">郝健: Linux内存管理学习笔记-第5节课</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664344&idx=1&sn=e5975e775e25e2ad1612c9dda5df52f4&chksm=810f3485b678bd933fa0c4a5bcad4298ae797724614018933f426a53b952d130557badd19518&mpshare=1&scene=1&srcid=04262p3N4EDsCVq23hxqLteY%23rd" target="_blank" rel="noopener">郝健: Linux内存管理学习笔记-第6节课</a></li><li><a href="https://developer.android.google.cn/topic/performance/memory" target="_blank" rel="noopener">Manage your app’s memory</a></li><li><a href="https://developer.android.google.cn/topic/performance/memory-overview" target="_blank" rel="noopener">Overview of memory management</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651481746&idx=1&sn=17ffd1a167e6cd4abb71ef84a1d78dac&chksm=bd250aed8a5283fb9a09a166b58606dc7bccf03eef3e28594470a84f94ef4db1b0c2cc5e5fb6&mpshare=1&scene=1&srcid=0916ILFD69CAZIwr7fzDjip8%23rd" target="_blank" rel="noopener">Linux 查看进程消耗内存情况总结</a></li><li><a href="https://blog.csdn.net/mychen/article/details/80001687" target="_blank" rel="noopener">一次过程 Android 平台 native heap 内存泄露的追查过程</a></li><li><a href="http://www.wowotech.net/memory_management/458.html" target="_blank" rel="noopener">浅谈 Cache Memory</a></li><li><a href="https://juejin.im/post/5bfbd5406fb9a049be5d2a20" target="_blank" rel="noopener">Bitmap 优化详谈</a></li><li><a href="https://mp.weixin.qq.com/s/EerrwaRGdTkOFPLrg8_-oQ" target="_blank" rel="noopener">探索 Android 内存优化方法</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650828463&idx=1&sn=414bdd7012ed465664d3b99ec8f55566&chksm=80b7ba31b7c03327e86c08a9be9216b51788bce46a33be3444e1f306802be3f62d9f72a3e45d&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener">看完这篇文章,解决 APP 中 90 % 的内存异常问题</a></li><li><a href="https://juejin.im/post/5b1b5e29f265da6e01174b84" target="_blank" rel="noopener">实践App内存优化：如何有序地做内存分析与优化</a></li><li><a href="https://mp.weixin.qq.com/s/dUCrkGGSvIzYwOxBNd-Ltw" target="_blank" rel="noopener">谈谈内存压缩那些事</a></li><li><a href="https://mp.weixin.qq.com/s/pwOFI-l2seDrZgik-KvIMg" target="_blank" rel="noopener">dumpsys meminfo 的原理和应用</a></li></ol><h1 id="图形栈"><a href="#图形栈" class="headerlink" title="图形栈"></a>图形栈</h1><ol><li><a href="https://mp.weixin.qq.com/s/MuPX4s46tR7Hn_ak51x95Q" target="_blank" rel="noopener">Android display pipeline本身以及进程调度</a></li><li><a href="https://androidperformance.com/2019/07/27/Android-Hardware-Layer/">Android 中的 Hardware Layer 详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/25477828" target="_blank" rel="noopener">Android 硬件加速原理与实现简介</a></li><li><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">Android 图形系统概述</a></li><li><a href="http://gityuan.com/2017/02/25/choreographer/" target="_blank" rel="noopener">Choreographer 原理</a></li><li><a href="http://gityuan.com/2017/02/11/surface_flinger/" target="_blank" rel="noopener">SurfaceFlinger 启动篇</a></li><li><a href="http://gityuan.com/2017/02/18/surface_flinger_2/" target="_blank" rel="noopener">SurfaceFlinger 绘图篇</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/45601143" target="_blank" rel="noopener">Android 应用程序 UI 硬件加速渲染技术简要介绍和学习计划</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/45769759" target="_blank" rel="noopener">Android 应用程序 UI 硬件加速渲染环境初始化过程分析</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/45831269" target="_blank" rel="noopener">Android 应用程序 UI 硬件加速渲染的预加载资源地图集服务（Asset Atlas Service）分析</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/45943255" target="_blank" rel="noopener">Android 应用程序 UI 硬件加速渲染的 Display List 构建过程分析</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/46281499" target="_blank" rel="noopener">Android 应用程序 UI 硬件加速渲染的 Display List 渲染过程分析</a></li><li><a href="http://blog.csdn.net/luoshengyang/article/details/46449677" target="_blank" rel="noopener">Android 应用程序 UI 硬件加速渲染的动画执行过程分析</a></li><li><a href="https://www.jianshu.com/p/40f660e17a73" target="_blank" rel="noopener">Android硬件加速（一）- 理解Android硬件加速原理的小白文</a></li><li><a href="https://www.jianshu.com/p/dd800800145b" target="_blank" rel="noopener">Android硬件加速（二）- RenderThread与OpenGL GPU渲染</a></li><li><a href="https://blog.csdn.net/jinzhuojun/article/details/39698317" target="_blank" rel="noopener">Android中的GraphicBuffer同步机制-Fence</a></li><li><a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">Android P 图形显示系统（一）硬件合成HWC2</a></li><li><a href="https://www.jianshu.com/p/dd0b38832346" target="_blank" rel="noopener">Android P 图像显示系统（二）GraphicBuffer和Gralloc分析</a></li><li><a href="https://www.jianshu.com/p/abfaea892611" target="_blank" rel="noopener">Android P 图像显示系统（三）Android HWUI 绘制流程</a></li><li><a href="https://www.jianshu.com/p/c4ea60bc73d2" target="_blank" rel="noopener">Android P 图形显示系统（四） Android VirtualDisplay解析</a></li><li><a href="https://www.jianshu.com/p/8e7a9a0b5726" target="_blank" rel="noopener">Android P 图形显示系统（五） 上层Client和SurfaceFlinger的交互</a></li><li><a href="https://www.jianshu.com/p/fa115146949f" target="_blank" rel="noopener">Android P 图形显示系统（六） SurfaceFlinger合成流程(一)</a></li><li><a href="https://www.jianshu.com/p/fd16dcb4dfb6" target="_blank" rel="noopener">Android P 图形显示系统（七） SurfaceFlinger合成流程(二)</a></li><li><a href="https://www.jianshu.com/p/cf4455021fd5" target="_blank" rel="noopener">Android P 图形显示系统（八） SurfaceFlinger合成流程(三)</a></li><li><a href="https://www.jianshu.com/p/b1b75ab6f17f" target="_blank" rel="noopener">Android P 图形显示系统（九） Android图形显示子系统概述</a></li><li><a href="https://www.jianshu.com/p/81e9c814f10a" target="_blank" rel="noopener">Android P 图形显示系统（十） BufferQueue（一）</a></li><li><a href="https://www.jianshu.com/p/f808813880b0" target="_blank" rel="noopener">Android P 图形显示系统（十一） BufferQueue（二）</a></li><li><a href="https://www.jianshu.com/p/6d83dea3652b" target="_blank" rel="noopener">Android P 图形显示系统（十二） BufferQueue（三）</a></li><li><a href="https://zhuanlan.zhihu.com/p/78758247" target="_blank" rel="noopener">渲染流水线中的光栅化1</a></li><li><a href="https://zhuanlan.zhihu.com/p/81974121" target="_blank" rel="noopener">渲染流水线中的光栅化2</a></li></ol><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><ol><li><a href="https://mp.weixin.qq.com/s/ayhmYTbmnIThGQ-GH5cP2A" target="_blank" rel="noopener">带你了解 Android 10 中的 art</a></li><li><a href="https://mp.weixin.qq.com/s/Vea97ljPww8QfAEmATtKGg" target="_blank" rel="noopener">带你了解 Android 10 中的 art</a></li><li><a href="https://mp.weixin.qq.com/s/rBxBoOUyXtUBcFqfYdxl_g" target="_blank" rel="noopener">带你了解 Android 10 中的 art</a></li><li><a href="https://mp.weixin.qq.com/s/K3JFUIKYfO4hrqLA-4BqfA" target="_blank" rel="noopener">带你了解 Android 10 中的 art</a></li><li><a href="https://mp.weixin.qq.com/s/06uEMSVo-nnynNj5FbXQKA" target="_blank" rel="noopener">带你了解 Android 10 中的 art</a></li><li><a href="https://source.android.com/devices/tech/dalvik/" target="_blank" rel="noopener">ART and Dalvik</a></li><li><a href="https://source.android.com/devices/tech/dalvik/improvements" target="_blank" rel="noopener">Android 8.0 ART Improvements</a></li><li><a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode" target="_blank" rel="noopener">Dalvik bytecode</a></li><li><a href="https://source.android.com/devices/tech/dalvik/dex-format" target="_blank" rel="noopener">Dalvik Executable format</a></li><li><a href="https://source.android.com/devices/tech/dalvik/instruction-formats" target="_blank" rel="noopener">Dalvik Executable instruction formats</a></li><li><a href="https://source.android.com/devices/tech/dalvik/constraints" target="_blank" rel="noopener">Constraints</a></li><li><a href="https://source.android.com/devices/tech/dalvik/configure" target="_blank" rel="noopener">Configuring ART</a></li><li><a href="https://source.android.com/devices/tech/dalvik/gc-debug" target="_blank" rel="noopener">Debugging ART Garbage Collection </a></li><li><a href="https://source.android.com/devices/tech/dalvik/jit-compiler" target="_blank" rel="noopener">Implementing ART Just-In-Time (JIT) Compiler</a></li><li><a href="https://zhuanlan.zhihu.com/p/24414378" target="_blank" rel="noopener">深入学习Android：虚拟机&amp;运行时</a></li><li><a href="https://zhuanlan.zhihu.com/p/24534940" target="_blank" rel="noopener">Android性能优化之虚拟机调优</a></li><li><a href="https://paul.pub/android-dalvik-vm/" target="_blank" rel="noopener">Android上的Dalvik虚拟机</a></li><li><a href="https://paul.pub/android-art-vm/" target="_blank" rel="noopener">Android上的ART虚拟机</a></li><li><a href="https://zhuanlan.zhihu.com/p/89536376" target="_blank" rel="noopener">Android ART 并行拷贝垃圾回收</a></li><li><a href="https://mp.weixin.qq.com/s/pmtbK8aezOcd_yBjGu4n7g" target="_blank" rel="noopener">Android ART dex2oat 浅析</a></li></ol><h1 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h1><ol><li><a href="https://source.android.com/devices/tech/perf/task-snapshots" target="_blank" rel="noopener">Task Snapshots</a></li><li><a href="https://zhuanlan.zhihu.com/p/29152319" target="_blank" rel="noopener">Android Input 子系统：Input 进程的创建，监听线程的启动</a></li><li><a href="https://zhuanlan.zhihu.com/p/29386642" target="_blank" rel="noopener">Android Input 子系统：Input 事件的产生、读取和分发，InputReader、InputDispatcher</a></li><li><a href="https://zhuanlan.zhihu.com/p/30127752" target="_blank" rel="noopener">EventHub 与设备、Input 事件的交互</a></li><li><a href="https://zhuanlan.zhihu.com/p/29929031" target="_blank" rel="noopener">Android 消息机制，从Java 层到 Native 层剖析</a></li><li><a href="https://paul.pub/android-binder-driver/" target="_blank" rel="noopener">理解 Android Binder 机制(1/3)：驱动篇</a></li><li><a href="https://paul.pub/android-binder-cpp/" target="_blank" rel="noopener">理解 Android Binder 机制(2/3)：C++ 层</a></li><li><a href="https://paul.pub/android-binder-java/" target="_blank" rel="noopener">理解 Android Binder 机制(3/3)：Java 层</a></li><li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder 设计与实现 - 设计篇</a></li><li><a href="http://gityuan.com/2017/05/19/ams-abstract/" target="_blank" rel="noopener">四大组件之综述</a></li><li><a href="http://gityuan.com/2017/06/11/activity_record/" target="_blank" rel="noopener">四大组件之 ActivityRecord</a></li><li><a href="http://gityuan.com/2017/06/04/content_provider_record/" target="_blank" rel="noopener">四大组件之 ContentProviderRecord</a></li><li><a href="http://gityuan.com/2017/06/03/broadcast_record/" target="_blank" rel="noopener">四大组件之 BroadcastRecord</a></li><li><a href="http://gityuan.com/2017/05/25/service_record/" target="_blank" rel="noopener">四大组件之 ServiceRecord</a></li><li><a href="http://gityuan.com/2017/04/16/activity-with-window/" target="_blank" rel="noopener">简述 Activity 与 Window 关系</a></li><li><a href="http://gityuan.com/2017/04/09/android_context/" target="_blank" rel="noopener">理解 Android Context</a></li><li><a href="http://gityuan.com/2017/04/02/android-application/" target="_blank" rel="noopener">理解 Application 创建过程</a></li><li><a href="http://gityuan.com/2017/01/22/start-activity-wms/" target="_blank" rel="noopener">以 Window 视角来看 startActivity</a></li><li><a href="http://gityuan.com/2017/01/15/wms_starting_window/" target="_blank" rel="noopener">WMS—启动窗口(StartingWindow) </a></li><li><a href="http://gityuan.com/2017/01/08/windowmanger/" target="_blank" rel="noopener">WMS—启动过程 </a></li><li><a href="https://zhuanlan.zhihu.com/p/35519585" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></li><li><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder 系列—开篇</a></li><li><a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder 系列1—Binder Driver初探</a></li><li><a href="http://gityuan.com/2015/11/02/binder-driver-2/" target="_blank" rel="noopener">Binder 系列2—Binder Driver再探</a></li><li><a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">Binder 系列3—启动ServiceManager</a></li><li><a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">Binder 系列4—获取ServiceManager</a></li><li><a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">Binder 系列5—注册服务(addService)</a></li><li><a href="http://gityuan.com/2015/11/15/binder-get-service/" target="_blank" rel="noopener">Binder 系列6—获取服务(getService)</a></li><li><a href="http://gityuan.com/2015/11/21/binder-framework/" target="_blank" rel="noopener">Binder 系列7—framework层分析</a></li><li><a href="http://gityuan.com/2015/11/22/binder-use/" target="_blank" rel="noopener">Binder 系列8—如何使用Binder</a></li><li><a href="http://gityuan.com/2015/11/23/binder-aidl/" target="_blank" rel="noopener">Binder 系列9—如何使用AIDL</a></li><li><a href="http://gityuan.com/2015/11/28/binder-summary/" target="_blank" rel="noopener">Binder 系列10—总结</a></li><li><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解 Android Binder 通信架构</a></li><li><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder 学习指南</a></li><li><a href="https://wetest.qq.com/lab/view/352.html" target="_blank" rel="noopener">你知道 android 的 MessageQueue.IdleHandler 吗？</a></li><li><a href="https://my.oschina.net/youranhongcha/blog/492591?p=2" target="_blank" rel="noopener">聊一聊 Android 的消息机制</a></li><li><a href="https://mp.weixin.qq.com/s/69ndd2NCx27JWxJGEqTQBg" target="_blank" rel="noopener">聊聊 APK (一) ——直接运行 Dex 文件的黑魔法</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&mid=2649872639&idx=1&sn=94bd74f4fe5d18c839c14e2cb8c2856b&chksm=8faead3fb8d924293764698889f419bdde71c9b523acf98edba313f3ec6b75b7d8332f43c9c6&mpshare=1&scene=1&srcid=&sharer_sharetime=1565860096242&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">聊聊 APK（二）——Dex 热修复与 Classpath</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNDE1NjQ2Mw==&mid=2649872646&idx=1&sn=61f3f4bf96a9244292f264de3a60bc34&chksm=8faeacc6b8d925d0aaa93141e3232e5c125307fe2e731dd63a4a0740eb71c54275739daf0ab1&mpshare=1&scene=1&srcid=&sharer_sharetime=1565860101974&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">聊聊 APK（三）—— Android 资源编译的秘密</a></li><li><a href="https://juejin.im/post/5e9728c5e51d4547185f919e?utm_source=gold_browser_extension" target="_blank" rel="noopener">卢半山 - 反思｜Android 事件拦截机制的设计与实现</a></li><li><a href="https://juejin.im/post/5e85aa5e6fb9a03c341d9737" target="_blank" rel="noopener">卢半山 - Binder 内存拷贝的本质和变迁</a></li><li><a href="https://juejin.im/post/5e8caa97518825738a5ace08" target="_blank" rel="noopener">卢半山 - AIDL 中 inout 的本质</a></li><li><a href="https://juejin.im/post/5e993b87e51d4546d962075c" target="_blank" rel="noopener">卢半山 - Binder 的异常机制</a></li><li><a href="https://juejin.im/post/5daaf2b1e51d4524b601bb0b" target="_blank" rel="noopener">卢半山 - Binder 世界中的代理机制（上）</a></li><li><a href="https://juejin.im/post/5d9fea976fb9a04de237a5af" target="_blank" rel="noopener">卢半山 - Binder 概述</a></li><li><a href="https://sharrychoo.github.io/blog/android-source/graphic-choreographer" target="_blank" rel="noopener">Android 系统架构 —— Choreographer 的工作机制 </a></li><li><a href="https://mp.weixin.qq.com/s/IHQDWKYJY6lbEGZZxPT8lw" target="_blank" rel="noopener">Looper的wake机制升级</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469018&idx=1&sn=b6a21164fffda38bf1fe423a8bba4a57&chksm=bd12e6f18a656fe7c59b3b1af47b436bd2472b51e2b12477ab9e87175688299e58c59a2582c5&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(一)Binder、HwBinder、VndBinder概要</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469152&idx=1&sn=ca5f0873cccd3413af1b822ea9fdcaae&chksm=bd12e64b8a656f5d44b8199ce8e16af0a72742071f44a34d68d790a1f93dd9bc9344d57162a4&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(二)-Binder入门篇</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469154&idx=1&sn=ddab595f47b4f9ae228d174b447a2fd2&chksm=bd12e6498a656f5fadb1ad10c7e92d4b5d50bc0f08387fa7069aeb0be96264dc05891b8787ef&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(三)-ServiceManager篇</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469156&idx=1&sn=7793b15df568f2d28e270bf1092ee37d&chksm=bd12e64f8a656f59a0596e00de96db582556cca78b38b334164aad64c804731cedb579b396e4&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(四)-Native-C\C++实例分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469158&idx=1&sn=20e56da97c531da01f96515da9777159&chksm=bd12e64d8a656f5bc34a3b5017517016661b289d0b1b08493da574f8da942586f17fa1478637&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(五)-Binder驱动分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469160&idx=1&sn=c799a8dea63903e8d2293d352c958a51&chksm=bd12e6438a656f5593941640f5f29937066a96a3038b2c51e5f7f912d987f3f13a7c19ac42e0&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(六)-Binder数据如何完成定向打击</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469166&idx=1&sn=79603ed6eabd767320be1374da82be3a&chksm=bd12e6458a656f53d37f4108fd4ba576a2c5722773bca293544cd4a18739a6a775e3d4ae4536&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(七)-Framework binder示例</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469168&idx=1&sn=6360b7fd3c4b93e426ec232e7dfe23d4&chksm=bd12e65b8a656f4de0ec426d381dba2b8dd969b03c83e18e6f002a55bf7af7c4616139567d3b&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(八)-Framework层分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469170&idx=1&sn=c9c4ff24bec544d8435b55fe87274b7e&chksm=bd12e6598a656f4f9daa31544126182d6ac86f7efe8f4031359867b7651247eea00ef486c0c5&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(九)-AIDL Binder示例</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NDk5ODQwNA==&mid=2652469171&idx=1&sn=6b8498ad20051d343d6f4808d021aa52&chksm=bd12e6588a656f4eb5ec89dff303b8525091696e56e529dd22ffb9512f02b67b5b1546cb2f93&scene=21#wechat_redirect" target="_blank" rel="noopener">Android10.0 Binder 通信原理(十)-AIDL原理分析-Proxy-Stub设计模式</a></li></ol><h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><ol><li><a href="http://gityuan.com/2019/04/06/android-anr/" target="_blank" rel="noopener">彻底理解安卓应用无响应机制</a></li><li><a href="https://www.jianshu.com/p/18f16aba79dd" target="_blank" rel="noopener">应用与系统稳定性第一篇—ANR 问题分析的一般套路</a></li><li><a href="https://www.jianshu.com/p/ac545e10e39e" target="_blank" rel="noopener">应用与系统稳定性第二篇—ANR 的监测与信息采集</a></li><li><a href="https://www.jianshu.com/p/1f9cff12b84f" target="_blank" rel="noopener">应用与系统稳定性第三篇—FD 泄露问题漫谈</a></li><li><a href="https://www.jianshu.com/p/3017487b881f" target="_blank" rel="noopener">应用与系统稳定性第四篇—单线程导致的空指针问题分析</a></li><li><a href="https://www.jianshu.com/p/f2713f371589" target="_blank" rel="noopener">应用与系统稳定性第五篇—Watchdog 原理和问题分析</a></li><li><a href="https://www.jianshu.com/p/e398e450c597" target="_blank" rel="noopener">应用与系统稳定性第六篇—JVM 垃圾回收之 finalize 执行时引起 timed out 闪退分析</a></li><li><a href="https://www.jianshu.com/p/2addc08cb84b" target="_blank" rel="noopener">应用与系统稳定性第七篇— 用 Asan 提前解决NDK疑难crash</a></li></ol><h1 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h1><ol><li><a href="https://mp.weixin.qq.com/s/ATppCpaKh1GcJCdts_EsyA" target="_blank" rel="noopener">能感知功耗的 Linux 调度器(EAS)</a></li><li><a href="https://paul.pub/android-power" target="_blank" rel="noopener">Android 功耗改进</a></li></ol><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><ol><li><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt" target="_blank" rel="noopener">cpuset</a></li><li><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt" target="_blank" rel="noopener">cgroup</a></li><li><a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="noopener">Android 进程调度之 adj 算法</a></li><li><a href="http://gityuan.com/2017/07/30/linux-process/" target="_blank" rel="noopener">Linux 进程管理(一) </a></li><li><a href="http://gityuan.com/2017/08/05/linux-process-fork/" target="_blank" rel="noopener">Linux 进程管理(二)–fork</a></li><li><a href="http://gityuan.com/2017/08/06/linux_process_pid/" target="_blank" rel="noopener">Linux 进程 pid 分配法</a></li><li><a href="http://edu.csdn.net/course/detail/5995" target="_blank" rel="noopener">收费培训视频 打通 Linux 脉络系列：进程、线程和调度 </a></li><li><a href="https://paul.pub/android-process-creation/" target="_blank" rel="noopener">Android 系统中的进程管理：进程的创建</a></li><li><a href="https://paul.pub/android-process-priority/" target="_blank" rel="noopener">Android 系统中的进程管理：进程的优先级</a></li><li><a href="https://paul.pub/android-process-recycle/" target="_blank" rel="noopener">Android 系统中的进程管理：内存的回收</a></li><li><a href="https://paul.pub/android-process-schedule/" target="_blank" rel="noopener">Android系统上的进程管理：进程的调度</a></li><li><a href="https://paul.pub/android-init/" target="_blank" rel="noopener">Android 系统启动：init 进程与 init 语言</a></li><li><a href="https://segmentfault.com/a/1190000006251859" target="_blank" rel="noopener">Android 进程保活招式大全</a></li><li><a href="https://developer.android.google.cn/guide/components/processes-and-threads" target="_blank" rel="noopener">进程和线程</a></li><li><a href="https://developer.android.google.cn/topic/performance/threads" target="_blank" rel="noopener">通过线程提升性能</a></li><li><a href="http://gityuan.com/2018/05/19/android-process-adj/" target="_blank" rel="noopener">解读 Android 进程优先级 ADJ 算法</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580105&idx=1&sn=e2845d214f71ba46116b7ab5eff02f53&chksm=84b3b94eb3c43058fced637158b728ea14063d5b00234fda187620ac01df06b9be61a7828ef9&mpshare=1&scene=1&srcid=#rd" target="_blank" rel="noopener">杂谈 Android 线程优先级</a></li></ol><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><ol><li><a href="https://sharrychoo.github.io/blog/android-performance-opt/io" target="_blank" rel="noopener">Android 性能优化 —— IO 的监控与优化 </a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html" target="_blank" rel="noopener">从内核文件系统看文件读写过程</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">认真分析 mmap：是什么 为什么 怎么用</a></li></ol><h1 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/25277481" target="_blank" rel="noopener">另一个 Android 性能剖析工具——simpleperf</a></li><li><a href="https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md" target="_blank" rel="noopener">Simpleperf</a></li><li><a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/" target="_blank" rel="noopener">如何调试 Android Framework</a></li><li><a href="http://weishu.me/2017/01/14/how-to-debug-android-native-framework-source/" target="_blank" rel="noopener">如何调试 Android Native Framework</a></li><li><a href="https://catapult.gsrc.io/README.md" target="_blank" rel="noopener">Catapult 项目</a></li><li><a href="https://zhuanlan.zhihu.com/p/27331842" target="_blank" rel="noopener">手把手教你使用 Systrace（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/27535205" target="_blank" rel="noopener">手把手教你使用 Systrace（二）——锁优化</a></li><li><a href="https://zhuanlan.zhihu.com/p/27593816" target="_blank" rel="noopener">使用 Android Studio 和 MAT 进行内存泄漏分析</a></li><li><a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 简介</a></li><li><a href="https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/" target="_blank" rel="noopener">Systrace 基础知识 - Systrace 预备知识</a></li><li><a href="https://www.androidperformance.com/2019/05/27/why-60-fps/" target="_blank" rel="noopener">Systrace 基础知识 -  Why 60 fps ？</a></li><li><a href="https://androidperformance.com/2019/06/29/Android-Systrace-SystemServer/">Systrace 基础知识 - SystemServer 解读</a></li><li><a href="https://www.androidperformance.com/2019/11/04/Android-Systrace-Input/" target="_blank" rel="noopener">Systrace 基础知识 - Input 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/" target="_blank" rel="noopener">Systrace 基础知识 - Vsync 产生与工作机制解读</a></li><li><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/">Systrace 基础知识 - Vsync-App ：基于 Choreographer 的渲染机制详解</a></li><li><a href="https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread/" target="_blank" rel="noopener">Systrace 基础知识 - MainThread 和 RenderThread 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder/" target="_blank" rel="noopener">Systrace 基础知识 - Binder 和锁竞争解读</a></li><li><a href="https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer" target="_blank" rel="noopener">Systrace 基础知识 - Triple Buffer 解读</a></li><li><a href="https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU" target="_blank" rel="noopener">Systrace 基础知识 - CPU Info 解读</a></li><li><a href="https://source.android.google.cn/devices/graphics/tracing-win-transitions" target="_blank" rel="noopener">Tracing Window Transitions</a></li><li><a href="https://zhuanlan.zhihu.com/p/108260089" target="_blank" rel="noopener">Android 性能问题分析之 bugreport</a></li><li><a href="https://www.jianshu.com/p/95dfe1f41971" target="_blank" rel="noopener">腾讯 Apm 框架 Matrix 源码阅读 - gradle插件</a></li><li><a href="https://www.jianshu.com/p/768b14dc0ffe" target="_blank" rel="noopener">腾讯 Apm 框架 Matrix 源码阅读 - TracePlugin 架构解析</a></li><li><a href="https://www.jianshu.com/p/6dad2f9be403" target="_blank" rel="noopener">腾讯 Apm 框架 Matrix 源码阅读 - TracePlugin 之 AnrTracer</a></li><li><a href="https://www.jianshu.com/p/5721f5d11ae5" target="_blank" rel="noopener">腾讯 Apm 框架 Matrix 源码阅读 - TracePlugin 之 StartupTracer</a></li><li><a href="https://www.jianshu.com/p/731a5f4b4cd3" target="_blank" rel="noopener">腾讯 Apm 框架 Matrix 源码阅读 - TracePlugin 之 FrameTracer</a></li><li><a href="https://www.jianshu.com/p/d0f2164dd053" target="_blank" rel="noopener">腾讯 Apm 框架 Matrix 源码阅读 - 架构解析</a></li></ol><h1 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h1><ol><li><a href="https://source.android.com/devices/tech/perf/flash-wear" target="_blank" rel="noopener">Flash Wear Management in Android Automotive </a></li><li><a href="http://www.10tiao.com/html/431/201706/2650236929/1.html" target="_blank" rel="noopener">Cortex-A75 和 Cortex-A55</a></li><li><a href="http://www.brendangregg.com/blog/2017-05-09/cpu-utilization-is-wrong.html" target="_blank" rel="noopener">CPU Utilization is Wrong</a></li></ol><h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><ol><li><a href="https://academy.realm.io/cn/posts/360andev-jake-wharton-java-hidden-costs-android/" target="_blank" rel="noopener">探索 Java 隐藏的开销</a></li><li><a href="https://github.com/LyndonChin/kotlin-docs-zh" target="_blank" rel="noopener">Kotlin 中文文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/112082107" target="_blank" rel="noopener">Java 多态在 android 中的实现</a></li><li>Cancellation and Exceptions in Coroutines<ol><li><a href="https://medium.com/androiddevelopers/coroutines-first-things-first-e6187bf3bb21" target="_blank" rel="noopener">Coroutines: First things first</a></li><li><a href="https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629" target="_blank" rel="noopener">Cancellation in coroutines</a></li><li><a href="https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c" target="_blank" rel="noopener">Exceptions in Coroutines</a></li><li><a href="https://medium.com/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad" target="_blank" rel="noopener">Coroutines &amp; Patterns for work that shouldn’t be cancelled</a></li></ol></li><li><a href="https://zhuanlan.zhihu.com/p/24344559" target="_blank" rel="noopener">彻底理解引用在 Android 和 Java 中的工作原理</a></li></ol><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ol><li><a href="http://www.tinylab.cn/kernel-explore-regmap-framework/" target="_blank" rel="noopener">内核探索：Regmap 框架：简化慢速 I/O 接口优化性能 </a></li><li><a href="http://www.tinylab.cn/elinux-org-boot-time-optimization/" target="_blank" rel="noopener">嵌入式 Linux 启动时间优化 </a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664066&idx=1&sn=f5bcfbb40c8b1672e64625190b795598&chksm=810f379fb678be89aa169bc8b9ba0ddfdedb88fe191522f71330a5b394c5ff7869284643608c&mpshare=1&scene=1&srcid=0406LVWw9jQVgsGymk0i3gDf%23rd" target="_blank" rel="noopener">Linux 文件系统预读的情景分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652663878&idx=1&sn=0b4118e88de5eb5b38c4ebcfa242a442&chksm=810f36dbb678bfcd3314ec8f6da1fd1caeb588a513fb307880ff228ca89d7a99d962b64739ba&mpshare=1&scene=1&srcid=0316x6fEMYpnFompZLcxdIy3%23rd" target="_blank" rel="noopener">使用 blktrace 统计磁盘块 I/O 访问频率</a></li><li><a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">Linux 系统调用(syscall)原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652665068&idx=1&sn=6255885e49a552e14a89fa5f94263f4b&chksm=810f3271b678bb67f7cb02b6624e079952fda5f157cfd1079eb76315bde70f31fd25743db98f&mpshare=1&scene=1&srcid=0903PU0uqOmk4BvoBtfiK7MN%23rd" target="_blank" rel="noopener">浅墨: 聊聊 Linux IO（上）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652665073&idx=1&sn=479f6947d845ab3823bf35fd3a74d8fe&chksm=810f326cb678bb7a6f91a63134712e1951d9d93299a2fb10a7a09779599f161b9a3bac9bf7f5&mpshare=1&scene=1&srcid=0903obSJikgzRQkacWruVHxM%23rd" target="_blank" rel="noopener">浅墨: 聊聊 Linux IO(中)——Linux 内核中的 IO 栈</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652665103&idx=1&sn=ffffddab091250808ec273c0fb441c4c&chksm=810f3392b678ba8430b6e46b8b61e114dee92df997793657fa28e91944e37043edaf35e7a948&mpshare=1&scene=1&srcid=09036uYavdTQwV2xoxT415kt%23rd" target="_blank" rel="noopener">浅墨: 聊聊 Linux IO(下)</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664862&idx=1&sn=ff5b5e3ff12eff9933b02d056090bb64&chksm=810f3283b678bb95601a679fe633acbe8a8e5458ed3b0a172a8abf7e9748569fa2543576e9e1&mpshare=1&scene=1&srcid=0710GsjvDmQvomT82BnqUtc2%23rd" target="_blank" rel="noopener">郭健： deadline 调度器之（一）：原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664880&idx=1&sn=b1e97835b702359e20e0fb2c1218f55f&chksm=810f32adb678bbbbb8efea4902a42ae66187785b4483de4f743ea8daaee2d0d59eb73ea69747&mpshare=1&scene=1&srcid=07126zFuAiF9Bt8GHRRfDVQH%23rd" target="_blank" rel="noopener">郭健： Deadline 调度器之（二）：细节和使用方法</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652664678&idx=1&sn=4dd68ee13fcea183ddcd6576cf7d8245&chksm=810f35fbb678bcedc592e820663fd02a0f829c6a99173fb327b0a2016256d94f5a922c2436a8&mpshare=1&scene=1&srcid=0611Qm6agWbldRTrn8E6EdA2%23rd" target="_blank" rel="noopener">郭健： Linux 内存模型——平坦、非连续与稀疏</a></li><li><a href="https://www.cnblogs.com/tianguiyu/articles/6091378.html" target="_blank" rel="noopener">linux内核分析——CFS（完全公平调度算法）</a></li><li><a href="http://linuxperf.com/?p=42" target="_blank" rel="noopener">从几个问题开始理解 CFS 调度器</a></li><li><a href="http://www.wowotech.net/process_management/447.html" target="_blank" rel="noopener">CFS 调度器（1）-基本原理</a></li><li><a href="http://www.wowotech.net/process_management/448.html" target="_blank" rel="noopener">CFS 调度器（2）-源码解析</a></li><li><a href="http://www.wowotech.net/process_management/449.html" target="_blank" rel="noopener">CFS 调度器（3）-组调度</a></li><li><a href="http://www.wowotech.net/process_management/450.html" target="_blank" rel="noopener">CFS 调度器（4）-PELT(per entity load tracking)</a></li><li><a href="http://www.wowotech.net/process_management/451.html" target="_blank" rel="noopener">CFS 调度器（5）-带宽控制</a></li><li><a href="http://www.wowotech.net/process_management/452.html" target="_blank" rel="noopener">CFS 调度器（6）-总结</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTkwMDU1NQ==&mid=2247483748&idx=1&sn=d8308e7138decad8340900db3494e98d&chksm=fcd85680cbafdf96f9ff3be4a8b13b6b174f5372c760527fec90ca7feba1cc22f1d0f3aa28b5&mpshare=1&scene=1&srcid=&sharer_sharetime=1569745222548&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">关于线程和 I/O 模型的极简知识</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=404234343&amp;idx=1&amp;sn=b297b01ee7c656b900417f14a2a0ccae&amp;scene=1&amp;srcid=0303naEsx6F7zikbq8zK2REV#rd" target="_blank" rel="noopener">TRIM：提升磁盘性能，缓解 Android 卡顿</a></li><li><a href="https://tinylab.org/lwn-456904/?from=groupmessage&isappinstalled=0" target="_blank" rel="noopener">LWN 456904: 避免磁盘回写（writeback），抑制（throttling）缓存（page cache）写入</a></li><li><a href="https://tinylab.org/lwn-384093/?from=groupmessage&isappinstalled=0" target="_blank" rel="noopener">LWN 384093: 有关 “回写”（writeback）的问题讨论</a></li><li><a href="https://tinylab.org/lwn-211505/?from=groupmessage&isappinstalled=0" target="_blank" rel="noopener">LWN 211505: 避免和解决内存碎片化</a></li><li><a href="https://developer.android.google.cn/training/articles/smp#more" target="_blank" rel="noopener">SMP Primer for Android</a></li><li><a href="https://zhuanlan.zhihu.com/p/73468738" target="_blank" rel="noopener">内存分配1 - 空闲链表和内存池</a></li><li><a href="https://zhuanlan.zhihu.com/p/73562347" target="_blank" rel="noopener">内存分配2 - Buddy 系统的原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/105589621" target="_blank" rel="noopener">内存分配3 - Linux 中 Buddy 系统的实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/83945844" target="_blank" rel="noopener">Linux 中的内存压缩</a></li><li><a href="https://zhuanlan.zhihu.com/p/97319402" target="_blank" rel="noopener">研究 Linux 内核的乐趣</a></li><li><a href="https://mp.weixin.qq.com/s/j2fTXYX0-IDTeD-LhHecAw" target="_blank" rel="noopener">linux IO Block layer 解析</a></li><li><a href="https://mp.weixin.qq.com/s/pLAFcD23qBP4iZxvek7xlg" target="_blank" rel="noopener">CFS 任务的负载均衡（框架篇）</a></li><li><a href="https://mp.weixin.qq.com/s/c9Sg68iSvOPRJItFQgfZyg" target="_blank" rel="noopener">一张图读懂内存反碎片化</a></li><li><a href="https://mp.weixin.qq.com/s/ppKf8nfOBjKwosieEOezYA" target="_blank" rel="noopener">浅谈新型非易失存储</a></li><li><a href="https://mp.weixin.qq.com/s/4xY19jzL0tPYsf5fsoR4Bw" target="_blank" rel="noopener">Linux devfreq framework 剖析</a></li><li><a href="https://mp.weixin.qq.com/s/SuKRPYTMUbC5PRw9NnvUTg" target="_blank" rel="noopener">内存泄漏（增长）火焰图</a></li><li><a href="https://mp.weixin.qq.com/s/nkiE4CEo_zSN35I_qITAvQ" target="_blank" rel="noopener">Linux 系统性能评测基准系统配置及其原理</a></li><li><a href="https://mp.weixin.qq.com/s/38ki8Rx0LLtHUAURJgUJpw" target="_blank" rel="noopener">Cgroups 与 Systemd</a></li></ol><h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/62335468" target="_blank" rel="noopener">深入 Flutter 的高性能图形渲染</a></li><li><a href="https://juejin.im/post/5db29887e51d452a39002adb" target="_blank" rel="noopener">跨平台技术演进及 Flutter 未来</a></li><li><a href="https://mp.weixin.qq.com/s/IZ6rUfg3_-zvopc7jZZobg" target="_blank" rel="noopener">跨平台技术趋势及字节跳动 Flutter 架构实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMjg5NTI3NQ==&mid=2247484105&idx=1&sn=7cb3d5816507290caa6338ac9b593440&chksm=f9c5a80dceb2211bd5bc130158fa1f009d927548aa9b6b7b1452b4066b7e8ddab5c4b8a70cc2&mpshare=1&scene=1&srcid=&sharer_sharetime=1565751189915&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">Flutter 的性能测试和理论</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652049970&idx=2&sn=1160c3e2df1a2659e8f8a921c7978ebc&chksm=808cb277b7fb3b61c420cfd6e5b9be7acbecb57a794029665ac4baa6d7db649e6d34e0656182&mpshare=1&scene=1&srcid=&sharer_sharetime=1563846371830&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">深入理解 Flutter 多线程</a></li><li><a href="http://gityuan.com/2019/06/22/flutter_booting/" target="_blank" rel="noopener">深入理解 Flutter 引擎启动</a></li><li><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="noopener">Flutter 渲染机制— UI 线程</a></li><li><a href="http://gityuan.com/2019/06/16/flutter_gpu_draw/" target="_blank" rel="noopener">Flutter 渲染机制— GPU 线程</a></li></ol><h1 id="Fuchsia"><a href="#Fuchsia" class="headerlink" title="Fuchsia"></a>Fuchsia</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/55690708?utm_source=ZHShareTargetIDMore&utm_medium=social&utm_oi=27871238160384" target="_blank" rel="noopener">许中兴博士演讲：Fuchsia OS 简介</a></li></ol><h1 id="技术之外的思考"><a href="#技术之外的思考" class="headerlink" title="技术之外的思考"></a>技术之外的思考</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3ODAxNDcwNQ==&mid=2247484147&idx=1&sn=cd5f8fead3bcaac2d22a3dd699d2e79f&chksm=fd7a9e6dca0d177b27095d3d12720e83ba1638028799a89a8879929c1ad442529a62a46c5fe3&mpshare=1&scene=1&srcid=1027hi7FsUIG3AirEiJg198C#rd" target="_blank" rel="noopener">我到底有多么努力</a></li><li><a href="https://zhuanlan.zhihu.com/zmywly8866/20711335" target="_blank" rel="noopener">工作以来的一些感悟</a></li><li><a href="https://zhuanlan.zhihu.com/p/20708611" target="_blank" rel="noopener">如何自学 Android？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650714160&idx=1&sn=5ea68a672a3b4df567951a09a264dfd3&chksm=bec07e6389b7f7758f438618c5dfb91e193a39446e0864bca2ed00fcbf363ea4caa5f8391d99&mpshare=1&scene=1&srcid=0507RZEnGNhAlCveVh01K3db%23rd" target="_blank" rel="noopener">技术人最重要的能力是什么？</a></li><li><a href="https://blog.csdn.net/wetest_tencent/article/details/80361126" target="_blank" rel="noopener">浅谈软件工程师的代码素养</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MDMyMjkzNg==&mid=2652262721&idx=1&sn=978d9d94b5417ef4841d54d64fcf2776&chksm=84dc6ed6b3abe7c07990422648df4617458d50818968b247ef1aea5b077fa114c532adf79f85&mpshare=1&scene=1&srcid=0803qDDSrV6EIlW5aMuzUfv4%23rd" target="_blank" rel="noopener">陆奇：除了好代码，工程师怎样才算优秀？</a></li><li><a href="https://coolshell.cn/articles/20276.html" target="_blank" rel="noopener">别让自己“墙”了自己</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&mid=2649494737&idx=1&sn=8e1f94c24768deb3ddd926c4fd5df986&chksm=8eec9f2eb99b16386cbd677e0545d71f0863cc77f21dd9250dda8f7a31c4a206167b510118c0&mpshare=1&scene=1&srcid=&sharer_sharetime=1568602769162&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">100% 成功率的 offer 收割机是怎样练成的？</a></li><li><a href="https://coolshell.cn/articles/20533.html" target="_blank" rel="noopener">使用简单的逻辑方法进行独立思考</a></li></ol><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTg2MjA2OA==&mid=2649842075&idx=1&sn=668f0ddceab52c961f1ac20a77165429" target="_blank" rel="noopener">Android 2018 最新面试题</a></li><li><a href="https://zhuanlan.zhihu.com/p/34878265" target="_blank" rel="noopener">如何衡量一个 Android 应用开发人员的能力</a></li><li><a href="https://juejin.im/post/5b97ab465188255c865e030a" target="_blank" rel="noopener">2018 Android 面试总结</a></li><li><a href="https://www.jianshu.com/p/8608b172b103" target="_blank" rel="noopener">Android 2017-2018 最新面试题（3-5年经验个人面试经历）</a></li><li><a href="https://www.diycode.cc/wiki/androidinterview" target="_blank" rel="noopener">Android 开发工程师面试指南</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NzMxODEyMQ==&mid=2666454354&idx=2&sn=b08cfa0ba5d403c92bce5e7fb57f233f&chksm=8449afd4b33e26c2b04adad207e9bf93fa7af46be75cfb860aeba30bed5bc93340ca8965d2bc&mpshare=1&scene=1&srcid=0815726HCm2RAyWr0mKdKiHL%23rd" target="_blank" rel="noopener">阿里电话面试面试题总结，附答案！</a></li><li><a href="https://github.com/francistao/LearningNotes/blob/master/Part6/InterviewExperience/Alibaba.md" target="_blank" rel="noopener">阿里巴巴面试题</a></li><li><a href="https://github.com/francistao/LearningNotes/blob/master/Part6/InterviewExperience/%E7%BE%8E%E5%9B%A2.md" target="_blank" rel="noopener">美团面试题</a></li><li><a href="https://github.com/francistao/LearningNotes/blob/master/Part6/InterviewExperience/%E8%B1%8C%E8%B1%86%E8%8D%9A.md" target="_blank" rel="noopener">豌豆荚三面试题</a></li><li><a href="https://github.com/francistao/LearningNotes/blob/master/Part6/InterviewExperience/%E8%9C%BB%E8%9C%93FM.md" target="_blank" rel="noopener">蜻蜓FM面试题</a></li><li><a href="https://github.com/francistao/LearningNotes/blob/master/Part6/InterviewExperience/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A.md" target="_blank" rel="noopener">新浪微博面试题</a></li><li><a href="https://github.com/francistao/LearningNotes/blob/master/Part6/InterviewExperience/%E7%BD%91%E6%98%93%E6%9D%AD%E7%A0%94.md" target="_blank" rel="noopener">网易杭研面试题</a></li><li><a href="https://mp.weixin.qq.com/s/A2RzPsdkfHNGlsnFsJbe-g?" target="_blank" rel="noopener">为什么想来我们公司工作？- 面试常见问题解析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMjUyMDQ5Mw==&mid=2247484057&idx=1&sn=ca225ba9b647206d391624f9f7f9300a&chksm=fab349dbcdc4c0cd0ede64a8dc956e6fe1b6a7cd370a638010792185826c55264d3db1bcdac5&mpshare=1&scene=1&srcid=0918xJfW9762pd5y9E56E4Bh%23rd" target="_blank" rel="noopener">今日头条大佬十年面试了 2000 人，总结了这 5 点</a></li><li><a href="https://mp.weixin.qq.com/s/4qA_FrPKUQrgDu_ITVYt-A" target="_blank" rel="noopener">2019 年美团点评高级 Android 开发寒冬跳槽涨薪经验掏心分享</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247492338&idx=1&sn=1b261f2eda75163e0878d3b5e4373834&chksm=e92adffdde5d56eb4720f9ee0b3b81795ee31bedb2ebe6a3112e0e1b538242e69076ff5aa715&mpshare=1&scene=1&srcid=&sharer_sharetime=1574306357287&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">如何回答性能优化的问题，才能打动阿里面试官？</a></li><li><a href="https://juejin.im/post/5d4e40a5f265da03ef7a02a1" target="_blank" rel="noopener">2019.07 Android 面试真题集锦</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE1NDcyNQ==&mid=2247485232&idx=1&sn=b7abd39999034bed76a8b849b968faa3&chksm=eb6bd9fadc1c50ec24d8dccf80d94d8cc745d2e2c69b7add3b36a12aafd5b87b2f5e7480317f&mpshare=1&scene=1&srcid=&sharer_sharetime=1570589981034&sharer_shareid=60bd7acea7881a97fbf9a6126d3e88d3#rd" target="_blank" rel="noopener">技术面试中面试官怎么考察候选人？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3Mzc4ODQ3Mw==&mid=2247484333&idx=1&sn=03271692d0f713272baa16270f11b8d0&chksm=eb1cb8fbdc6b31edbffb8a7c01fb886e3689f5e0204f71b75908cfdfadef92333bb3c91df281&mpshare=1&scene=1&srcid=11297lZR9ijR5xUFAyStvw65#rd" target="_blank" rel="noopener">给扔物线 HenCoder Plus 学员的一次分享文字版</a></li><li><a href="https://juejin.im/post/5e9102f9e51d4546d6357fde" target="_blank" rel="noopener">快手，字节跳动，百度，美团Offer之旅</a></li><li><a href="https://zhuanlan.zhihu.com/p/31209029" target="_blank" rel="noopener">美帝面试二三事</a></li></ol><h1 id="本文其他地址"><a href="#本文其他地址" class="headerlink" title="本文其他地址"></a>本文其他地址</h1><p>由于博客留言交流不方便，点赞或者交流，可以移步本文的知乎或者掘金页面<br><a href="https://zhuanlan.zhihu.com/p/30691789" target="_blank" rel="noopener">知乎 - Android 性能优化必知必会</a><br><a href="https://juejin.im/post/5ebf4f21f265da7bad355036" target="_blank" rel="noopener">掘金 - Android 性能优化必知必会</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017 年度好物推荐 - 给辛勤工作的自己一点奖励</title>
      <link href="/2018/01/06/2017%E5%B9%B4%E5%BA%A6%E6%9C%80%E6%8E%A8%E8%8D%90/"/>
      <url>/2018/01/06/2017%E5%B9%B4%E5%BA%A6%E6%9C%80%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>2017 不知不觉已经走过，博客已经许久没有更新了，一个原因是越来越觉得自己的学识浅薄，怕写了技术误了大家，另一个原因是自己太懒了。鉴于上面两个原因，我决定此博客的更新，不再非要更新技术文章，一些我觉得有意义的事情、思考等，也会更新上来。一方面自己做个记录，如果能顺带给读者带来一点帮助，那自然是最好的(虽然没几个读者…)</p><p>2017 既然才刚刚过去，我觉得有必要把 2017 年里面我觉得体验很棒或者对工作生活很有帮助的东西推荐给大家，或许 2018 你会需要他们。推荐的内容包含了 App、硬件、书籍、器材等，需要说明的是，这些东西是我觉得 2017 年给我带来很大帮助的，适合我不一定适合你。话不多说，直接上内容吧！</p><a id="more"></a><h1 id="2017-年度最推荐-iOS-App"><a href="#2017-年度最推荐-iOS-App" class="headerlink" title="2017 年度最推荐 iOS App"></a>2017 年度最推荐 iOS App</h1><p><strong>关键词 ：减肥 学习 见识</strong></p><h2 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h2><p><img src="/images/media/15152276589894.jpg" alt="Keep"></p><p>如果你是一个健身爱好者、计划减肥者，想找一款能记录运动的 App，那么我推荐 Keep 给你。Keep 那句很出名的 slogan 不知道大家有没有听说过：<strong>自律给我自由!</strong>，我同样喜欢另外一句：<strong>不要让工作毁掉你的生活，总有比你更忙的人在运动</strong>。</p><p>软件只是一个辅助，最重要的是要自律，生活需要自律，运动需要自律，饮食需要自律。自律并不意味着生活会失去乐趣，相反，自律给我自由和自信，人总是向往完美的自己，Keep It！</p><p>2017 在 Keep 的帮助下，我的体重从最重时候的 78 kg 到了现在的 70 kg，可能数值上没有什么大不了的，但是回过头来看照片对比，现在真的要自信很多。</p><h2 id="得到"><a href="#得到" class="headerlink" title="得到"></a>得到</h2><p><img src="/images/media/1_9Z-KgmC_qnkI3YqbLbrjuQ.png" alt="得到"></p><p>正如我们家领导所说，有些人你知道他很厉害，仅此而已。</p><p>得到这个 App 确给了我们一个途径，近距离地接近那些很厉害的人，知道他们的学习方式、思考方式。你会发现，比你聪明的人比你还要努力，你还有什么理由去偷懒呢？</p><p>2017 我听了吴军的《硅谷来信》，听了薛兆丰的《北大经济学课》，听了万维钢老师的《精英日课》，听老罗唠叨了一年的《逻辑思维》，听了许多书。</p><p>从长见识和思考两个方面来说，我获得的就已经远远超出这些专栏的订阅价了。</p><h2 id="微信读书"><a href="#微信读书" class="headerlink" title="微信读书"></a>微信读书</h2><p><img src="/images/media/15152618857230.jpg" alt="微信读书"></p><p>读书的平台很多，选中一个坚持下去是最重要的，微信读书、多看阅读、Kindle 三个平台我都有读书，没有谁好谁坏，重要的是真正获取到了知识。</p><p>现在的低头族被大家吐槽，与其在地铁上刷微博、知乎、即刻，不如打开一本书，静下心来好好阅读。</p><h1 id="2017-年度最推荐-Mac-App"><a href="#2017-年度最推荐-Mac-App" class="headerlink" title="2017 年度最推荐 Mac App"></a>2017 年度最推荐 Mac App</h1><p><strong>关键词 ：工作安排 工作记录</strong></p><h2 id="Things-3"><a href="#Things-3" class="headerlink" title="Things 3"></a>Things 3</h2><p><img src="/images/media/appicon-ios.png" alt="Things 3"></p><p>这东西价格是贵了一些，但是是真的好用，各种功能都很齐全，各个平台版本（iPhone、iPad、Mac）数据也都是互通的.</p><p>Things 主要完成我工作三环中的第一环：任务安排。 很多时候会有很多任务，有时候会忘记做一些重要的事情，现在我会把所有要做的事情都记录在 Things 里面，每天早上会根据优先级，筛选出今天要做的事情。如果有其他突发的事情，也会记录下来，这样不会顾此失彼。</p><p>另外 Things 的重复任务、任务优先级、任务时间等都比较好用，之前用网页端 Tower 的我果断吧数据都迁移到 Things 了。</p><h2 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h2><p><img src="/images/media/512-1.png" alt="MWeb"></p><p>Mweb 是一款 MarkDown 软件，我也是换了好几个才换到这个，功能齐全，界面美观，MarkDown 写起来很舒服，对图片的支持也很很。</p><p>MWeb 主要完成我工作三环中的第二环：任务记录，包括每日的任务完成情况记录。Things 用来安排任务，但是任务完成后要做记录和总结，这就是每日任务记录，Things 记录的是流水，而 MWeb 则记录的是思想。</p><p>另外我还使用 MWeb 来写 Blog、公司文档、总结等，言而总之，就是一款好用的 MarkDown 软件。</p><h2 id="Evernote"><a href="#Evernote" class="headerlink" title="Evernote"></a>Evernote</h2><p><img src="/images/media/15152276977516.jpg" alt="EverNote"></p><p>印象笔记就不用多介绍了，其强大的浏览器剪切插件，帮助我存储了不少非常好的技术文章；团队共享功能，帮助我在团队中分享笔记。</p><p>印象笔记 主要完成我工作三环中的第三环：存档。不管是技术文章，还是会议纪要，还是项目规划，还是 PDF，如果要找一个长期存放的地方，那么印象笔记是一个相当可靠的软件；有时候开会不做 PPT，直接用印象笔记的演示功能也可以胜任。</p><h1 id="2017-年度最推荐-Android-App"><a href="#2017-年度最推荐-Android-App" class="headerlink" title="2017 年度最推荐 Android App"></a>2017 年度最推荐 Android App</h1><p><strong>关键词 ：墙</strong></p><h2 id="影梭"><a href="#影梭" class="headerlink" title="影梭"></a>影梭</h2><p><img src="/images/media/15152275725397.jpg" alt="影梭"></p><p>作为一个资深的 Google 全家桶爱好者，影梭是 Android 完整体验的强有力的一个保证；作为一个 Android 开发者，我没法想象如果没了影梭，我会失去多少获取知识的渠道。</p><p>爬梯需谨慎，感谢国家还没有赶尽杀绝，大家别问我是怎么搞的，低调才能生存。</p><h2 id="绿色守护"><a href="#绿色守护" class="headerlink" title="绿色守护"></a>绿色守护</h2><p><img src="/images/media/15152613218534.jpg" alt="绿色守护"></p><p>国内的 Android App 的流氓程度大家是有目共睹的，尤其是 BAT 全家桶，管不好这些应用，Android 的体验会大打折扣，尽管现在很多厂商都针对流氓软件做了限制，绿色守护仍然是你拿到新机后必须要安装的一个软件。</p><p>我有幸跟绿色守护作者冯老师在微信群里讨论过问题，冯老师对技术的深度和热情，我等实在是望尘莫及。我们都欠冯老师一个捐赠版。</p><blockquote><p>再也不用嫉妒朋友的iPhone手机，即使安装大量应用，也不会变得迟缓和耗电。有了『绿色守护』，你的Android设备也能永葆第一天拥有它时的爽滑持久！</p></blockquote><blockquote><p>『知乎』上用户认同度最高的Android省电软件：<a href="http://www.zhihu.com/question/21007772" target="_blank" rel="noopener">http://www.zhihu.com/question/21007772</a></p></blockquote><blockquote><p>『绿色守护』帮助你甄别那些对系统全局性能和耗电量有不良影响的应用程序，并通过独特的『绿色化』技术，阻止它们消耗您的电池电量，占用您的宝贵内存。经过『绿色化』工艺处理的应用，在您没有主动启动它们的时候，无法『偷偷』运行，而在您正常启动它们时仍然拥有完整的功能和体验，正如iPhone应用那样！</p></blockquote><h1 id="2017-年度最推荐非技术书"><a href="#2017-年度最推荐非技术书" class="headerlink" title="2017 年度最推荐非技术书"></a>2017 年度最推荐非技术书</h1><p><strong>关键词 ：自我提升提升</strong></p><h2 id="深度工作"><a href="#深度工作" class="headerlink" title="深度工作"></a>深度工作</h2><p><img src="/images/media/15152579958065.jpg" alt="深度工作"></p><p>强烈推荐此书，尤其是需要终生学习的程序员们，可能每个人读完后的感想都会不一样，但是我绝对是受到了里面一些做事方法的启发，结合自身的能力和工作，针对性地进行提高，而且得到了较好的效果。个人认为是我 2017 年读的最好的书。在这个碎片化严重的互联网时代，快知识的消费和满足，让自己产生了惰性，认为自己知道的东西很多，其实没有经过深加工，吸收的那些知识只是碎片而已，随着时间就消逝了。</p><blockquote><p>随时随地收发电子邮件、一个接一个地参加大小会议、在即时通讯软件的尖叫中手忙脚乱、在繁杂的多线程工作中不断地切换注意力……你看起来非常忙碌，甚至在不自觉地享受这种忙碌，但你的忙碌真的能转化为生产能力吗？</p></blockquote><blockquote><p>本书作者、麻省理工学院计算机博士卡尔·纽波特，尖锐地道破了信息经济时代的惊人真相——知识工作者60%以上的工作时间都花费在处理此类浮浅事务上，而这些工作不仅产出的价值有限，还会永久性地损害人们深度工作的能力！</p></blockquote><blockquote><p>作者创立的“深度工作”概念，其含义为在无干扰的状态下进行专注的职业活动，使个人的认知能力达到极限。而正因为当前社会深度工作能力的日益稀缺，其与经济成功的关系也变得日渐紧密起来。本书的所有讨论也围绕 “深度工作”而展开，全书共分为两部分：在第一部分中，作者从神经科学、心理学、哲学等角度，客观地分析了在新经济形势下实现深度工作的重要性。第二部分则系统地传授了在日常生活中践行深度工作的具体策略，如将深度工作纳入日常工作进程、提高大脑的深度思维能力、远离社交网络等。</p></blockquote><blockquote><p>作者还强调，深度工作不是一项过时的技能，而是将人们从技术垄断导致的精神异化状态中解救出来的良药。在当前这个以网络为中心的浮浅信息时代，倡导深度工作无异于呼唤一种匠人精神的回归。</p></blockquote><p>豆瓣：<a href="https://book.douban.com/subject/27056409/" target="_blank" rel="noopener">https://book.douban.com/subject/27056409/</a></p><h2 id="刻意练习-如何从新手到大师"><a href="#刻意练习-如何从新手到大师" class="headerlink" title="刻意练习-如何从新手到大师"></a>刻意练习-如何从新手到大师</h2><p><img src="/images/media/15152576721372.jpg" alt="刻意练习"></p><p>这本书，也算是声名在外。其实这本书告诉我们一个很简单的道理，想要成为任何一个行业的专家，你都需要进行大量的刻意练习，而不是单纯的堆积时间。</p><blockquote><p>对于在任何行业或领域中希望提升自己的每个人，刻意练习是黄金标准，是迄今为止发现的最强大的学习方法。</p></blockquote><p>豆瓣：<a href="https://book.douban.com/subject/26895993/" target="_blank" rel="noopener">https://book.douban.com/subject/26895993/</a></p><h1 id="2017-年度最推荐技术书"><a href="#2017-年度最推荐技术书" class="headerlink" title="2017 年度最推荐技术书"></a>2017 年度最推荐技术书</h1><p><strong>关键词 ：</strong><br>说来惭愧，2017年没有认认真真读完一本技术书，但从我阅读过的那么多技术书中，还是有两本可以推荐给大家，不过我阅读的技术书，跟我自己的工作相关的比较多，不一定适合你。</p><h2 id="深入理解Android内核设计思想（第二版）"><a href="#深入理解Android内核设计思想（第二版）" class="headerlink" title="深入理解Android内核设计思想（第二版）"></a>深入理解Android内核设计思想（第二版）</h2><p><img src="/images/media/15152587790243.jpg" alt="深入理解Android内核设计思想"></p><p>算是系统开发的经典书了，这书今年出了第二版，加了一些新的内容。不管是应用开发工程师，还是系统开发工程师，多了解 Android 系统的架构和设计，对自己知识的深度是很有帮助的。</p><p>不过 Android 的版本发展实在是太快了，阅读此书建议配合最新的 Android 源代码。梳理流程的同时，也要深度思考设计思想。</p><blockquote><p>《深入理解Android内核设计思想》适用于 Android 4.3以上的版本。全书从操作系统的基础知识入手，全面剖析进程/线程、内存管理、Binderv机制、GUIv显示系统、多媒体管理、输入系统等核心技术在 Android 中的实现原理。书中讲述的知识点大部分来源于工程项目研发，因而具有较强的实用性，希望可以让读者“知其然，更知其所以然”。全书分为编译篇、系统原理篇、应用原理篇、系统工具篇共4篇22章，基本涵盖了参与Android开发所需具备的知识，并通过大量图片与实例来引导读者学习，以求尽量在源代码分析外为读者提供更易于理解的思维方式。</p></blockquote><blockquote><p>《深入理解Android内核设计思想》既适合 Android 系统工程师，也适合于应用开发工程师来阅读提升Android开发能力。读者可以在《深入理解vAndroidv内核设计思想》潜移默化的学习过程中更深刻地理解Android系统，并将所学知识自然地应用到实际开发难题的解决中。</p></blockquote><p>豆瓣 ： <a href="https://book.douban.com/subject/25921329/" target="_blank" rel="noopener">https://book.douban.com/subject/25921329/</a></p><h2 id="奔跑吧-Linux内核"><a href="#奔跑吧-Linux内核" class="headerlink" title="奔跑吧 Linux内核"></a>奔跑吧 Linux内核</h2><p><img src="/images/media/15152591841672.jpg" alt="奔跑吧 Linux内核"></p><p>这本书我还在读，由于缺乏相关的知识，所以进度有点慢。Android 系统工程师必备。</p><blockquote><p>本书内容基于Linux4.x内核，主要选取了Linux内核中比较基本和常用的内存管理、进程管理、并发与同步，以及中断管理这4个内核模块进行讲述。全书共分为6章，依次介绍了ARM体系结构、Linux内存管理、进程调度管理、并发与同步、中断管理、内核调试技巧等内容。本书的每节内容都是一个Linux内核的话题或者技术点，读者可以根据每小节前的问题进行思考，进而围绕问题进行内核源代码的分析。</p></blockquote><blockquote><p>本书内容丰富，讲解清晰透彻，不仅适合有一定Linux相关基础的人员，包括从事与Linux相关的开发人员、操作系统的研究人员、嵌入式开发人员及Android底层开发人员等学习和使用，而且适合作为对Linux感兴趣的程序员的学习用书，也可以作为大专院校相关专业师生的学习用书和培训学校的教材。</p></blockquote><p>豆瓣 ： <a href="https://book.douban.com/subject/27108677/" target="_blank" rel="noopener">https://book.douban.com/subject/27108677/</a></p><h1 id="2017-年度最推荐手机-–-Meizu-Pro7-Plus"><a href="#2017-年度最推荐手机-–-Meizu-Pro7-Plus" class="headerlink" title="2017 年度最推荐手机 – Meizu Pro7 Plus"></a>2017 年度最推荐手机 – Meizu Pro7 Plus</h1><p><strong>关键词 ：旗舰</strong></p><p><img src="/images/media/15152597921570.jpg" alt="Meizu Pro7 Plus"></p><p>并不是我不想推荐 iPhone X，是因为买不起……</p><p>尽管魅族的 Pro7 Plus 被网友各种吐槽，但你不能否认这是一款非常优秀的旗舰机，舒心的 flyme 系统加上不错的硬件搭配，创新的小窗逼格满满，配不配得上 Pro + Plus 的称号，仁者见仁智者见智吧。</p><h1 id="2017-年度最推荐路由器-–-小米路由器-Pro"><a href="#2017-年度最推荐路由器-–-小米路由器-Pro" class="headerlink" title="2017 年度最推荐路由器 – 小米路由器 Pro"></a>2017 年度最推荐路由器 – 小米路由器 Pro</h1><p><strong>关键词 ：美剧</strong></p><p><img src="/images/media/15152601645070.jpg" alt="小米路由器"></p><p>小米路由器+小米家庭影院，最大的好处是方便。现在有很多美剧网站，资源下载都会有个<strong>下载到小米路由器</strong>的链接，点击就可以下载到自家的路由器上，回家就可以看，突出一个方便。</p><h1 id="2017-年度最推荐平板-–-iPad-Pro"><a href="#2017-年度最推荐平板-–-iPad-Pro" class="headerlink" title="2017 年度最推荐平板 – iPad Pro"></a>2017 年度最推荐平板 – iPad Pro</h1><p><strong>关键词 ：完美</strong></p><p><img src="/images/media/verge-10.0.jpg" alt="iPad Pro"></p><p>在我眼里，iPad Pro 既具有 iPhone 的优点，又具有 Mac 的优点。从使用场景来看，开会、收发邮件、看电子书、看技术文档、看 PDF等，都可以胜任。</p><p>iPad Pro 搭配键盘（别买笔，没用），完全就是一个缩小版本的 Mac，除了写代码，其他的都可以满足我的需求，有了这货之后，我那用了好几年快退役的 Mac 使用率更低了。</p><p>前面我提到的那些软件：Keep、得到、微信读书、Things、MWeb、Evernote 都有 iPad 版本，提要要比 iOS 版本好太多。</p><p>苹果出品，必出精品，两个字送给 iPad Pro ：完美！</p><h1 id="2017-年度最推荐穿戴设备-–-iWatch"><a href="#2017-年度最推荐穿戴设备-–-iWatch" class="headerlink" title="2017 年度最推荐穿戴设备 – iWatch"></a>2017 年度最推荐穿戴设备 – iWatch</h1><p><strong>关键词 ：记录</strong></p><p><img src="/images/media/il_570xN.1294603892_67xk.jpg" alt="iWatch"></p><p>iWatch 是苹果四件套里面存在感最弱的，个人认为最大的问题是续航，一代一天一冲，二代两天一冲，实在是有点无力吐槽。主力机从 iOS 切换到 Android 后，电话短信闹钟提醒这几个功能完全没用了，不过这货解决了一个我的痛点：运动记录。</p><p>跑步机 + iWatch，简直是减肥利器，事无巨细的运动记录也 push 我不要偷懒，言而总之，iWatch 是我生活中不可或缺的。</p><h1 id="2017-年度最推荐耳机-–-MDR-1000X"><a href="#2017-年度最推荐耳机-–-MDR-1000X" class="headerlink" title="2017 年度最推荐耳机 – MDR-1000X"></a>2017 年度最推荐耳机 – MDR-1000X</h1><p><strong>关键词 ：降噪</strong></p><p><img src="/images/media/Sony_MDR1000X_Photo_Main.jpg" alt="Sony_MDR1000X"></p><p>在嘈杂的办公室，拥有一个带降噪的无线耳机真的是非常重要。降噪能给你一个安静的环境，不管是思考还是写代码还是看书，不受外界打扰的感觉真的很棒；无线带来简洁，没了线的束缚会方便很多，也会少了凳子绕线的苦恼。</p><p>MDR-1000X 我用了这么久，降噪、易用性、音质这三个方面都很满意。据说戴耳机会降低 50% 的被打扰率，推荐你也入手一个降噪耳机。</p><h1 id="2017-年度最推荐减肥伴侣-–-跑步机"><a href="#2017-年度最推荐减肥伴侣-–-跑步机" class="headerlink" title="2017 年度最推荐减肥伴侣 – 跑步机"></a>2017 年度最推荐减肥伴侣 – 跑步机</h1><p><strong>关键词 ：坚持</strong></p><p>人总是会有惰性，大家都知道跑步减肥，但是就是坚持不下来，而且外出跑步受环境的影响太大，太冷太热下雨下雪。</p><p>我在本来就拥挤的家里强行放了一台跑步机，跑步机的好处是，随时都可以跑，而且对跑步的抗拒心理没那么严重。每天下班后，打开 Keep，开跑，每天五公里并不难，重要的是要坚持。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>当然还有一些能显著提高幸福感的东西，就不一一列举了，我想起来就会更新到下面</p><ol><li>肉麒麟家的牛肉酱，选<strong>三观正的牛</strong>这个，包你会爱上</li><li>洗碗机，谁用谁知道，再也不会抵制在家里做饭了</li><li>扫地机器人，谁不想每天回去家里的地上很干净呢？尤其是在家里有一个长毛怪和两只猫的情况下</li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017</title>
      <link href="/2017/04/23/About-work/"/>
      <url>/2017/04/23/About-work/</url>
      
        <content type="html"><![CDATA[<p>一转眼就 2017 年了，算起来自己已经工作了快四年了，09年到威海上学，12年去上海实习，13年毕业后还是去了上海，14年进了珠海魅族，直到现在。</p><p>这博客从我毕业开始写东西，写写删删，也算是记录了一些东西，自己的工作内容也从 App 开发换到了系统 App 开发，在换到系统开发，也算是走了一圈，一些路程，记录下来，几年后再看看，怀念一下也是不错的。</p><p>这篇文章我记录了自己的博客、自己的工作、自己的工作内容、自己的工作习惯、还有对 2017 年的期望，有迷茫，也有奋斗。</p><p>17年已经过了 30% 了，希望还不算晚。</p><a id="more"></a><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>看到上一篇博客文章的更新时间，已经是去年的这个月了，想想还真是惭愧，每次想动笔重新开始写一些东西的时候，总是由于这样或者那样的原因，没有动手去写。</p><p>记得刚毕业的时候，我是很喜欢写东西的，学习笔记也有，工具教程也有，什么都敢写，什么都敢往博客上面放，后来随着工作的深入，懂的东西变多之后，写东西反而不是很多了，我想一个原因是，随着技术水平的慢慢提高，我意识到自己的技术深度还远远不够，很多东西自己都知其然不知其所以然，这样的状态，写出来的东西，会不会误导人呢？</p><p>不过，现在技术有了一点点沉淀之后，我觉得有必要把自己总结的一些经验和技巧分享给大家，另外一方面也算是一个记录。很多思路和想法，如果不去记录下来，很容易就会忘记，</p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>从 HTC 的实习，到火花乐蛙的短暂停留，再到魅族，算起来工作了也好几年了，这几年一直在做 Android 相关的开发，从 App 开发到系统开发，一路下来，越发觉得，做软件开发是一件很有趣的事，尤其是当你做的功能，被几百万几千万的用户在使用的时候，那份激动和责任，总会驱动我们要做得更好，我推测未来五年之内， Android 在手机界的统治地位，暂时没有其他的系统可以撼动，所以值得花时间在这上面。</p><p>当然除了具体的 Android 技术点，学习 Android 的设计思想，软件架构，培养自己解决通用问题的能力，是更重要的事情，这正是我现阶段需要去努力的方向。</p><p>关于具体的技术田，我暂时还没有想好具体要深入哪一块，目前对 Android 和 Linux 的进程管理和 CPU 调度比较感兴趣，性能方面则偏重于流畅度、响应速度的分析和调优，不得不说这几块就够我钻研好久了。</p><p>前几天去总部，看到 2016 年我司出了 15 台手机，每一台手机在做的时候，我们都会对其做性能调优，那一大堆性能 Feature ，和每个机型都莫名其妙的性能问题，搞得团队根本没有时间去做一些更有深度的事情，有点故步自封的感觉，2017 年希望能改变这一点，起码自己要先做改变。</p><h2 id="关于工作内容"><a href="#关于工作内容" class="headerlink" title="关于工作内容"></a>关于工作内容</h2><p>工作内容主要是系统层面的一些优化工作，涉及到的点比较多，自己则是全而不精，今年要寻找一个点深挖：</p><ol><li>负责 Android 系统级别的性能优化，主要是 Framework 层以及 App 层的优化</li><li>负责优化内容包括 响应速度、流畅度、内存、启动速度、过度绘制、HWUI、SurfaceFlinger 等</li><li>参与制定性能部分测试项和测试标准</li><li>负责寻找和挖掘性能优化点，并负责实施和推广</li><li>负责系统关键项目的开发，比如智能系统调频器、进程优先级优化等</li><li>负责老机型与新机型的性能问题分析与解决</li><li>负责新员工性能方面的培训，以及内部技术分享</li><li>竞品分析，挖掘竞品的优点</li><li>负责性能部分文档编写与总结</li></ol><h2 id="关于习惯"><a href="#关于习惯" class="headerlink" title="关于习惯"></a>关于习惯</h2><p>2016 年起，我养成了一套自己的工作习惯，不过有的时候都没有严格去执行，2017 年则需要严格去执行这些，</p><h3 id="工作安排"><a href="#工作安排" class="headerlink" title="工作安排"></a>工作安排</h3><p>每天早上起来后，会安排一下今天一天的工作，安排的依据是昨天的工作记录情况和邮件记录，主要包含下面几点</p><ul><li>优先级：确定每个任务的优先级，重要的事情放在前面，优先做</li><li>预估时间：确定每个任务的预估时间，精确到半个小时</li></ul><p>当然会预留一定的时间，去应付突发的事情，比如有人来找我分析很重要的问题，就会打乱我的计划，所以工作安排也是一门技术，以我的经验和公司的情况，我一般会如下安排时间：</p><ul><li>一般来说，上午的时候，来找的人比较少，可以安排做一些重要 Feature 的开发，或者重要技术的预言</li><li>下午的时候可以安排处理 Bug ，处理邮件，处理非重要的 Feature 等</li><li>晚上的时候可以安排做一些技术的研究</li></ul><p>当然理想是丰满的，现实是骨干的，鉴于软件开发的不确定性，上面的安排也经常会失效，有人建议用桌子上放一个番茄钟的方式来避免别人的干扰，我个人的经验是，戴个耳机！</p><p>我安排自己工作的软件是 Tower ， Tower 本来是一个团队软件，不过我们团队不是很适应这个软件，所以在我安利了一段时间后，他们就放弃了，所以我还是自己一个人用， 优先级和时间都会以标签的方式显示在每个任务之前：</p><p><img src="/images/media/14929591578368.jpg" alt=""></p><h3 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h3><p>每日回家之后，会把每天的工作记录下来，Tower 适合安排工作，但是不太适合记录工作，一是不太方便每日查看，二是自己的一些思路和想法，记录到 Tower 上很容易找不到。</p><p>所以我记录工作的软件是 MWeb ，会记录每天所完成的各个项，不论大小，比较重要的工作项，解题思路和想法都会记录在后面，每周的总结也会记录，来源包括 Redmine、邮件、Tower 等，这样不会漏掉一些重要的事情和数据</p><h3 id="文章记录"><a href="#文章记录" class="headerlink" title="文章记录"></a>文章记录</h3><p>文章记录主要的印象笔记，遇到好文章或者比较重要的事情，我都会记录到印象笔记中，定时去整理和查看</p><h2 id="关于-2017"><a href="#关于-2017" class="headerlink" title="关于 2017"></a>关于 2017</h2><p>今年公司比较动荡，身边好几个小伙伴都走人了，公司也在转型，阵痛期。自己也比较犹豫，不过目前没有花太多的时间去想这事，做好目前手上每一件事，该做的去做，机会总是青睐有准备的人。</p><p>作为一个软件工程师，Coding 能力永远是要放在第一位的，这一点需要向我偶像百万学习（下图，一周Coding 的时间是51个小时）！<br><img src="/images/media/14929935518939.jpg" alt="百万"></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Bottom navigation 规范二：样式、行为与规格</title>
      <link href="/2016/04/05/android-bottom-bar-2/"/>
      <url>/2016/04/05/android-bottom-bar-2/</url>
      
        <content type="html"><![CDATA[<p>Android 官方在三月的某一天更新了一个新的设计规范，所谓设计规范就是告诉开发者和设计师要如何去设计和使用某一个组件。不过这次 Bottom navigation 的发布，让许多人大跌眼镜，毕竟 Bottom navigation 这样的组件，在之前的 MD 设计语言中可是只字未提，Android 开发者与 iOS 开发中最大的不同也是由于 Bottom navigation 是 iOS 应用的必备，而遵循 MD 设计规范的 Android 应用，则对 Bottom navigation 敬而远之。</p><p>本文是 Android Bottom navigation 的第二篇文章，主要介绍样式、行为与规格。</p><a id="more"></a><h1 id="1-样式-Style"><a href="#1-样式-Style" class="headerlink" title="1. 样式-Style"></a>1. 样式-Style</h1><h2 id="1-1-图标和文字-Icons-and-text"><a href="#1-1-图标和文字-Icons-and-text" class="headerlink" title="1.1 图标和文字-Icons and text"></a>1.1 图标和文字-Icons and text</h2><p>Because bottom navigation actions are presented as icons, they should be used for content that can be suitably communicated with icons.<br>由于底部导航操作显示为图标，它应该使用与其内容相符合的图标。根据以下条件来为每个操作设定样式：</p><ul><li>当 Item 是 focus 状态的时候，显示这个 Item View 的图标和文字。</li><li>当 bottom navigation 只有三个 Item 的时候，他们的图标和文字都应该被显示。</li><li>当 bottom navigation 有四个或者五个 Item 的时候，在非激活状态的时候只显示他们的图标即可。</li></ul><h2 id="1-2颜色"><a href="#1-2颜色" class="headerlink" title="1.2颜色"></a>1.2颜色</h2><p>Tint the current bottom navigation action (including the icon and any text label present) with the app’s primary color<br>用应用的主色调给底部导航操作（包括图标与当前标签文字）上色。</p><p><img src="/images/bottombar2/1.png" alt="Do. Use the app’s primary color to indicate the view in focus."></p><p><img src="/images/bottombar2/2.png" alt="Don&#39;t. Avoid using different colored  icons and text labels."><br>如果底部导航条已着色，将底部导航操作图标和文字设置为白色或黑色。</p><p><img src="/images/bottombar2/3.png" alt="Do. Use black or white iconography if the bottom navigation bar is colored."></p><p><img src="/images/bottombar2/4.png" alt="Don&#39;t. Avoid pairing colored icons with a colored bottom navigation bar."></p><h2 id="1-3文本标签"><a href="#1-3文本标签" class="headerlink" title="1.3文本标签"></a>1.3文本标签</h2><p>文本标签为导航图标提供简明的定义。应避免使用较长的文本而造成文本被裁截或遮挡。<br><img src="/images/bottombar2/5.png" alt="Do. Use short labels"></p><p><img src="/images/bottombar2/6.png" alt="Don&#39;t. Avoid labels with wrapping text"></p><p><img src="/images/bottombar2/7.png" alt="Don&#39;t. Avoid truncating text labels as doing so may prevent comprehension."></p><p><img src="/images/bottombar2/8.png" alt="Don&#39;t. Avoid shrinking text labels to fit on a single line."></p><h1 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h1><p>点击底部导航图标将直接跳转至相关的界面或刷新当前的界面。</p><p>每一个底部导航图标都必须指向一个目的，不应打开主菜单或跳转至其他窗口。</p><p>每一个底部导航图标都会随着界面的滚动而动态的显示或隐藏。</p><ul><li>界面向下滚动时隐藏底部导航栏</li><li>界面向上滚动时显示底部导航栏</li></ul><p>在内容区域使用滑动手势不能进行界面的跳转。<br>在当前界面与未激活界面的跳转过程中使用淡入淡出的动画效果。</p><h1 id="3-空间"><a href="#3-空间" class="headerlink" title="3.空间"></a>3.空间</h1><h2 id="3-1确定底部导航栏"><a href="#3-1确定底部导航栏" class="headerlink" title="3.1确定底部导航栏"></a>3.1确定底部导航栏</h2><p>用底部导航栏的总长度除以图标的个数，计算出每个图标的宽度。也就是说，要使得每个底部导航图标占有最充足的空间。<br><img src="/images/bottombar2/9.png" alt="Fixed bottom navigation bar on mobile"><br>宽度的最大及最小值（这些数据包含边距）：</p><ul><li>最大值：168dp</li><li>最小值：较大界面为 120dp，较小界面为 104dp</li></ul><p>高度：<br>56dp</p><p>图标：<br>24*24dp</p><p><img src="/images/bottombar2/11.png" alt="168dp max width"><br>内容对齐：<br>文本与图标需居中且水平。</p><p>边距：</p><ul><li>距图标 6dp（当前界面），距图标 8dp（未被激活界面）</li><li>距文本 10dp</li><li>距文本左右各 12dp</li></ul><p>文本标签：</p><ul><li>常规 Roboto字体： 14sp（当前界面）</li><li>常规 Roboto字体：12sp（未激活界面）</li></ul><p><img src="/images/bottombar2/12.png" alt="12dp left and right of text"></p><p><img src="/images/bottombar2/13.png" alt="12dp left and right of text"></p><p><img src="/images/bottombar2/14.png" alt="Fixed bottom navigation bar on landscape mobile"></p><p><img src="/images/bottombar2/15.png" alt="Fixed bottom navigation bar on tablet"></p><h2 id="3-2切换底部导航栏"><a href="#3-2切换底部导航栏" class="headerlink" title="3.2切换底部导航栏"></a>3.2切换底部导航栏</h2><p>用底部导航栏的总长度除以图标的个数，计算出每个图标的宽度。</p><p><img src="/images/bottombar2/16.png" alt="Shifting bottom navigation bar on mobile"></p><p>宽度的最大及最小值（这些数据包含边距）：<br>当前界面</p><ul><li>最大值：168 dp</li><li>最小值：96 dp</li></ul><p>未激活界面</p><ul><li>最大值：96 dp</li><li>最小值：64 dp</li></ul><p><img src="/images/bottombar2/17.png" alt="Active view: 96dp min width"></p><p><img src="/images/bottombar2/18.png" alt="Active view: 168dp max width"></p><p><img src="/images/bottombar2/19.png" alt="Inactive view: 64dp min width"></p><p><img src="/images/bottombar2/20.png" alt="Inactive view: 96dp max width"><br>高度：<br>56dp</p><p>图标：<br>24*24 dp</p><p>内容对齐：<br>文本与图标需居中且水平。</p><p>边距：</p><ul><li>距图标上 6dp（当前界面），距图标上下各 16dp（未被激活界面）</li><li>距文本下 10dp</li></ul><p>文本标签：<br>常规 Roboto 字体： 14sp（当前界面）</p><p><img src="/images/bottombar2/21.png" alt="Shifting bottom navigation bar on landscape mobile"></p><p><img src="/images/bottombar2/22.png" alt="Shifting bottom navigation bar on tablet"></p><h1 id="4-层级"><a href="#4-层级" class="headerlink" title="4. 层级"></a>4. 层级</h1><p>由于 snackbars  的层级高度(elevation) 为6dp，而 navigation bar 的层级高度为 8dp，所以 snackbars 显示在 navigation bar 的后面。而 Bottom sheets, navigation drawers 和 keyboards 都显示在 navigation bar 的前面，完全覆盖 navigation bar 。</p><p><img src="/images/bottombar2/23.png" alt="Snackbars appear behind the bottom navigation bar."></p><p><img src="/images/bottombar2/24.png" alt="Orthographic view of app structure"></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 设计规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Bottom navigation 规范一：使用方法</title>
      <link href="/2016/04/05/android-bottom-bar-1/"/>
      <url>/2016/04/05/android-bottom-bar-1/</url>
      
        <content type="html"><![CDATA[<p>Android 官方在三月的某一天更新了一个新的设计规范，所谓设计规范就是告诉开发者和设计师要如何去设计和使用某一个组件。不过这次 Bottom navigation 的发布，让许多人大跌眼镜，毕竟 Bottom navigation 这样的组件，在之前的 MD 设计语言中可是只字未提，Android 开发者与 iOS 开发中最大的不同也是由于 Bottom navigation 是 iOS 应用的必备，而遵循 MD 设计规范的 Android 应用，则对 Bottom navigation 敬而远之。</p><p>本文是 Android Bottom navigation 的第一篇文章，主要介绍 Bottom navigation 的使用，以及  Bottom navigation 小变迁。</p><a id="more"></a><h2 id="1-Android-之前的关于底栏的设计规范"><a href="#1-Android-之前的关于底栏的设计规范" class="headerlink" title="1 Android 之前的关于底栏的设计规范"></a>1 Android 之前的关于底栏的设计规范</h2><p><img src="/images/bottombar1/14598674457055.jpg" alt="Google 之前对于底栏的设计规范"></p><h2 id="2-微信的改版"><a href="#2-微信的改版" class="headerlink" title="2. 微信的改版"></a>2. 微信的改版</h2><p>上上一次 Bottom navigation 在 Android 圈引起轩然大波还是微信的改版（5.2版本），在试错之后迅速换回了 Bottom navigation 。</p><p><img src="/images/bottombar1/14598674884766.jpg" alt="测试改版的微信"></p><p><img src="/images/bottombar1/14598675383016.jpg" alt="改版后的微信"></p><h2 id="3-Google-的改版"><a href="#3-Google-的改版" class="headerlink" title="3 Google + 的改版"></a>3 Google + 的改版</h2><p>而上一次 Bottom navigation 在 Android 圈引起轩然大波的就是 Google Plus 的改版：</p><p><img src="/images/bottombar1/14598675580793.jpg" alt="Google + 的改版"></p><p>反正打脸啪啪啪，不过规则是用来遵守的，你看微信没有遵守，活的比 Google + 好几百倍了。</p><h2 id="4-Bottom-navigation-设计规范"><a href="#4-Bottom-navigation-设计规范" class="headerlink" title="4. Bottom navigation 设计规范"></a>4. Bottom navigation 设计规范</h2><p>闲话说完了我们就来看看官方发布的  <a href="https://www.google.com/design/spec/components/bottom-navigation.html#" target="_blank" rel="noopener">Bottom navigation 的设计规范</a>，毕竟对于我们广大程序员来说，设计方面的能力还是没有专业的设计师强的，有一些规范我们做出来的东西不至于太难看。</p><h3 id="4-1-Bottom-navigation-使用"><a href="#4-1-Bottom-navigation-使用" class="headerlink" title="4.1 Bottom navigation 使用"></a>4.1 Bottom navigation 使用</h3><p>Bottom navigation 主要为手机应用设计，它提供了应用内顶层视图的快速导航功能。一些大的显示设备，比如桌面设备，可以使用侧面导航达到类似的效果。</p><p><img src="/images/bottombar1/14598675822179.jpg" alt="The bottom navigation bar on mobile"><br><img src="/images/bottombar1/14598676008074.jpg" alt="Left navigation on a larger display, such as tablet or desktop"></p><h4 id="4-1-1-使用时机"><a href="#4-1-1-使用时机" class="headerlink" title="4.1.1 使用时机"></a>4.1.1 使用时机</h4><p>Bottom navigation 的使用时机：</p><ul><li>三到五个同样重要的顶级功能界面</li><li>需要从应用程序的任意位置访问的功能界面</li></ul><h5 id="Do-and-Don’t-1-当底栏的-Item-太少的时候，不要使用-Bottom-navigation-，用-Tab-来替代。（毕竟只有两个-Item-的时候，还是蛮奇怪的看上去。"><a href="#Do-and-Don’t-1-当底栏的-Item-太少的时候，不要使用-Bottom-navigation-，用-Tab-来替代。（毕竟只有两个-Item-的时候，还是蛮奇怪的看上去。" class="headerlink" title="[Do and Don’t] 1. 当底栏的 Item 太少的时候，不要使用 Bottom navigation ，用  Tab 来替代。（毕竟只有两个 Item 的时候，还是蛮奇怪的看上去。"></a>[Do and Don’t] 1. 当底栏的 Item 太少的时候，不要使用 Bottom navigation ，用  Tab 来替代。（毕竟只有两个 Item 的时候，还是蛮奇怪的看上去。</h5><p><img src="/images/bottombar1/14598676393637.jpg" alt="Do.The bottom navigation bar exposes the three to five top-level destinations of an app."></p><p><img src="/images/bottombar1/14598676746527.jpg" alt="Don&#39;t. If there are fewer than three destinations, consider using tabs instead."></p><h5 id="Do-and-Don’t-2-如果你的底栏-Item-多于6个，可以在-Navigation-drawer-中提供访问入口，不要将底栏做成可以滑动的。"><a href="#Do-and-Don’t-2-如果你的底栏-Item-多于6个，可以在-Navigation-drawer-中提供访问入口，不要将底栏做成可以滑动的。" class="headerlink" title="[Do and Don’t] 2. 如果你的底栏 Item 多于6个，可以在 Navigation drawer 中提供访问入口，不要将底栏做成可以滑动的。"></a>[Do and Don’t] 2. 如果你的底栏 Item 多于6个，可以在 Navigation drawer 中提供访问入口，不要将底栏做成可以滑动的。</h5><p><img src="/images/bottombar1/14598676965667.jpg" alt="Do. Views are fixed in a bottom navigation bar."></p><p><img src="/images/bottombar1/14598677161097.jpg" alt="Don&#39;t.Avoid scrollable content in the bottom navigation bar."></p><h5 id="Do-and-Don’t-3-最好提供3-5个底栏-Item-，当底栏-Item-超过五个的时候，会显得每个-Item-过于紧凑，影响美观"><a href="#Do-and-Don’t-3-最好提供3-5个底栏-Item-，当底栏-Item-超过五个的时候，会显得每个-Item-过于紧凑，影响美观" class="headerlink" title="[Do and Don’t] 3. 最好提供3-5个底栏 Item ，当底栏 Item 超过五个的时候，会显得每个 Item 过于紧凑，影响美观"></a>[Do and Don’t] 3. 最好提供3-5个底栏 Item ，当底栏 Item 超过五个的时候，会显得每个 Item 过于紧凑，影响美观</h5><p><img src="/images/bottombar1/14598677362029.jpg" alt="Do. Use up to five top-level destinations in a bottom navigation bar."></p><p><img src="/images/bottombar1/14598677540938.jpg" alt="Don&#39;t. Avoid using more than five destinations in bottom navigation as tap targets will be situated too close to one another."></p><h2 id="5-Bottom-navigation-与-tabs"><a href="#5-Bottom-navigation-与-tabs" class="headerlink" title="5. Bottom navigation 与 tabs"></a>5. Bottom navigation 与 tabs</h2><p>当 Bottom navigation 与 tabs 混合使用的时候，可能会造成使用上的混乱。 举个栗子，点击 tab 和点击 Bottom navigation 可以显示不同的内容组合，这些功能的组合会给用户带来使用上的混乱。<br>另外 Tabs 在体验上和 Bottom navigation 也有很大的不同，Tabs 更依赖手势操作带来的便利，而 Bottom navigation 则由于位置比较靠近手指，使得点击更加方便。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 设计规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中如何计算 App 的启动时间？</title>
      <link href="/2015/12/31/How-to-calculation-android-app-lunch-time/"/>
      <url>/2015/12/31/How-to-calculation-android-app-lunch-time/</url>
      
        <content type="html"><![CDATA[<p>之前有人在知乎提问：<a href="https://www.zhihu.com/question/35487841/answer/63011462" target="_blank" rel="noopener">“怎么计算apk的启动时间？”</a> :</p><blockquote><p>利用python或者直接用adb命令怎么计算apk的启动时间呢？就是计算从点击图标到apk完全启动所花费的时间。比如，对游戏来说就是点击游戏图标到进入到登录界面的这段时间。<br>已知的两种方法貌似可以获取，但是感觉结果不准确：一种是，adb shell am start -w packagename/activity,这个可以得到两个值，ThisTime和TotalTime，不知道两个有什么区别，而且与实际启动时间不匹配，两者相加都可能比实际启动时间小（测试游戏的时候差别更大）；另外一种是通过adb logcat的方式，感觉获取的结果也与实际有差别。</p></blockquote><p>我和另外一个同事<a href="https://www.zhihu.com/people/guo-qi-fa" target="_blank" rel="noopener">郭启发</a> 针对两个方面进行了回答，不过毕竟知乎上看的人会比较少，所以我在征得他的同意之后，将这两个答案整理了一下，记录到博客中，一来算是一个小的总结，之后自己看得时候比较方便，二来给需要的同学一个更加方便的途径。</p><a id="more"></a><h1 id="1-应用启动场景"><a href="#1-应用启动场景" class="headerlink" title="1 应用启动场景"></a>1 应用启动场景</h1><p>事实上 Android 中一个 App 的启动时间可以准确计算的.但是要分场景.也就是说要分开游戏和应用. 大家都知道,在Android中,游戏开发和应用开发是两码事.所以我们需要分开来说.</p><h2 id="1-1-应用启动"><a href="#1-1-应用启动" class="headerlink" title="1.1 应用启动"></a>1.1 应用启动</h2><p>我们平时在写应用的时候,一般会指定一个 mainActivity ,用户在桌面上点击这个 Activity 的时候,系统会直接起这个 Activity. 我们知道 Activity 在启动的时候会走 onCreate/onStart/onResume .这几个回调函数.</p><p>许多书里讲过,当执行完 onResume 函数之后,应用就显示出来了…其实这是一种不准确的说法,因为从系统层面来看,一个 Activity 走完 onCreate/onStart/onResume 这几个生命周期之后,只是完成了应用自身的一些配置,比如 window 的一些属性的设置/ View 树的建立(只是建立,并没有显示,也就是说只是调用了 inflate 而已) . 后面 ViewRootImpl 还会调用两次performTraversals ,初始化 Egl 以及 measure/layout/draw. 等.<br>所以我们定义一个 Android 应用的启动时间, 肯定不能在 Activity 的回调函数上下手.而是以用户在手机屏幕上看到你在 onCreate 的 setContentView 中设置的 layout 完全显示为准,也就是我们常说的应用第一帧.</p><p>上面扯得有点远,不感兴趣的话可以不看,下面直接说方法.<br>题主说的 adb shell am start -w packagename/activity,是可以完全应用的启动时间的.不过也要分场景.</p><h2 id="1-2-应用第一次启动"><a href="#1-2-应用第一次启动" class="headerlink" title="1.2 应用第一次启动"></a>1.2 应用第一次启动</h2><p>也就是我们常说的冷启动,这时候你的应用程序的进程是没有创建的. 这也是大部分应用的使用场景.用户在桌面上点击你应用的 icon 之后,首先要创建进程,然后才启动 MainActivity.<br>这时候adb shell am start -w packagename/MainActivity 返回的结果,就是标准的应用程序的启动时间（注意 Android 5.0 之前的手机是没有 WaitTime 这个值的）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ adb shell am start -W com.media.painter/com.media.painter.PainterMainActivity</span><br><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.media.painter/.PainterMainActivity &#125;</span><br><span class="line">Status: ok</span><br><span class="line">Activity: com.media.painter/.PainterMainActivity</span><br><span class="line">ThisTime: 355</span><br><span class="line">TotalTime: 355</span><br><span class="line">WaitTime: 365</span><br><span class="line">Complete</span><br></pre></td></tr></table></figure><p>总共返回了三个结果,我们以 WaitTime 为准. </p><p>关于ThisTime/TotalTime/WaitTime的区别,下面是其解释：</p><p>“adb shell am start -W ”的实现在 frameworks\base\cmds\am\src\com\android\commands\am\Am.java 文件中。其实就是跨Binder调用ActivityManagerService.startActivityAndWait() 接口（后面将ActivityManagerService简称为AMS），这个接口返回的结果包含上面打印的ThisTime、TotalTime时间.</p><p><img src="/images/applunch3/1.png" alt="ThisTime/TotalTime"></p><ul><li>startTime记录的刚准备调用startActivityAndWait()的时间点</li><li>endTime记录的是startActivityAndWait()函数调用返回的时间点</li><li>WaitTime = startActivityAndWait()调用耗时。    </li></ul><p>ThisTime、TotalTime 的计算在 frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java 文件的 reportLaunchTimeLocked() 函数中。</p><p><img src="/images/applunch3/2.png" alt="curTime/displayStartTime/mLaunchStartTime"></p><p>我们来解释下代码里curTime、displayStartTime、mLaunchStartTime三个时间变量.</p><ul><li>curTime表示该函数调用的时间点.</li><li>displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点.</li><li>mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点. </li></ul><p>正常情况下点击桌面图标只启动一个有界面的 Activity，此时 displayStartTime 与mLaunchStartTime 便指向同一时间点，此时 ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的 Activity 做逻辑处理，接着又启动一个有界面的Activity，在这种启动一连串 Activity 的情况下（知乎的启动就是属于这种情况），displayStartTime 便指向最后一个 Activity 的开始启动时间点，mLaunchStartTime 指向第一个无界面Activity的开始启动时间点，此时 ThisTime！=TotalTime。这两种情况如下图：</p><p><img src="/images/applunch3/3.png" alt="curTime/displayStartTime/mLaunchStartTime"></p><p>在上面的图中，我用①②③分别标注了三个时间段，在这三个时间段内分别干了什么事呢？           </p><ul><li>在第①个时间段内，AMS 创建 ActivityRecord 记录块和选择合理的 Task、将当前Resume 的 Activity 进行 pause</li><li>在第②个时间段内，启动进程、调用无界面 Activity 的 onCreate() 等、 pause/finish 无界面的 Activity</li><li>在第③个时间段内，调用有界面 Activity 的 onCreate、onResume</li></ul><p>看到这里应该清楚 ThisTime、TotalTime、WaitTime 三个时间的关系了吧：</p><ul><li>WaitTime 就是总的耗时，包括前一个应用 Activity pause 的时间和新应用启动的时间；</li><li>ThisTime 表示一连串启动 Activity 的最后一个 Activity 的启动耗时；</li><li>TotalTime 表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，但不包括前</li></ul><p>一个应用 Activity pause 的耗时。也就是说，开发者一般只要关心 TotalTime 即可，这个时间才是自己应用真正启动的耗时。    </p><p>Event log中 TAG=am_activity_launch_time 中的两个值分表表示 ThisTime、TotalTime，跟通过 “adb shell am start -W ” 得到的值是一致的。    </p><p>最后再说下系统根据什么来判断应用启动结束。我们知道应用启动包括进程启动、走 Activity生命周期 onCreate/onResume 等。在第一次 onResume 时添加窗口到WMS中，然后measure/layout/draw，窗口绘制完成后通知 WMS，WMS 在合适的时机控制界面开始显示(夹杂了界面切换动画逻辑)。记住是窗口界面显示出来后，WMS 才调用reportLaunchTimeLocked() 通知 AMS Activity 启动完成。    </p><p><strong><em>最后总结一下，如果只关心某个应用自身启动耗时，参考TotalTime；如果关心系统启动应用耗时，参考WaitTime；如果关心应用有界面Activity启动耗时，参考ThisTime。</em></strong></p><h2 id="1-2-应用非第一次启动"><a href="#1-2-应用非第一次启动" class="headerlink" title="1.2 应用非第一次启动"></a>1.2 应用非第一次启动</h2><p>如果是你按Back键，并没有将应用进程杀掉的话，那么执行上述命令就会快一些，因为不用创建进程了，只需要启动一个Activity即可。这也就是我们说的应用热启动。</p><h1 id="2-游戏启动场景"><a href="#2-游戏启动场景" class="headerlink" title="2 游戏启动场景"></a>2 游戏启动场景</h1><p>游戏启动的话，就不适用用命令行的方法来启动了，因为从用户点击桌面图标到登录界面，既有系统的部分也有游戏自己的部分。</p><h2 id="2-1-系统部分"><a href="#2-1-系统部分" class="headerlink" title="2.1 系统部分"></a>2.1 系统部分</h2><p>游戏也有一个 Activity，所以启动的时候还是会去启动这个 Activity，所以系统启动部分也就是用户点击桌面桌面响应到这个Activity启动。</p><h2 id="2-2-游戏部分"><a href="#2-2-游戏部分" class="headerlink" title="2.2 游戏部分"></a>2.2 游戏部分</h2><p>一般游戏的主 Activity 启动后，还会做一些比较耗时的事情，这时候你看到的界面是不能操作的，比如：加载游戏数据、联网更新数据、读取和更新配置文件、游戏引擎初始化等操作。从游戏开发的角度来看，到了真正用户能操作的界面才算是一个游戏真正加载完成的时间。<br>那么这个时间，就得使用 Log 来记录了，因为加载游戏数据、联网更新数据、读取和更新配置文件、游戏引擎初始化这些操作，都是游戏自己的逻辑，与系统无关，所以得由游戏自己定义加载完成的点。</p><p>对于游戏的启动时间，我们更倾向于计算从<strong>点击桌面图标</strong>到<strong>用户可以与游戏进行交互</strong>这个时间段作为一个游戏的启动时间。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>计算机最让人着迷的一点就是其准确性，1+1 永远等于 2，启动耗时多久就是多久，每一次可能不一样，但每一次的时间都是这一次的准确时间。</p><p>不过每个公司由于对应用的定位不同，所以对应用启动的要求也不一样。比如有的做 ROM 的公司，其内置应用的启动时间一定是要非常快的，这样给用户的第一感觉就是快、流畅；互联网公司的 App 则不是很关心启动速度，大部分互联网公司的应用都有一个启动页，用来展示广告或者功能介绍之类的，然后才会进入到主界面。需求不一样，这么做也无可厚非，不过从消费者的角度来看，越早见到主界面当然越好。</p><p>所以在做一个 Android App 的时候，一定要记得将应用的启动时间作为一个性能指标，毕竟：</p><blockquote><p>天下武功，唯快不破！</p></blockquote><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 启动优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 应用启动优化:一种 DelayLoad 的实现和原理(下篇)</title>
      <link href="/2015/12/29/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E4%B8%80%E7%A7%8DDelayLoad%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86-%E4%B8%8B%E7%AF%87/"/>
      <url>/2015/12/29/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E4%B8%80%E7%A7%8DDelayLoad%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86-%E4%B8%8B%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load/" target="_blank" rel="noopener">上一篇文章</a>我们使用第三种方法来实现延迟加载。不过上一篇写的比较简单，只是讲解了如何去实现，这一篇就来讲一下为何要这么做，以及这么做后面的原理。<br>其中会涉及到一些 Android 中的比较重要的类，以及 Activity 生命周期中比较重要的几个函数。<br>其实这个其中的原理比较简单，不过要弄清楚其实现的过程，还是一件蛮好玩的事情，其中会用到一些工具，自己加调试代码等，一步一步下来，自己对 Activity 的启动的理解又深了一层，希望大家读完之后也会对大家有一定的帮助。</p><a id="more"></a><p>上一篇中我们最终使用的 DelayLoad 的核心方法是在 Activity 的 onCreate 函数中加入下面的方法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myHandler.post(mLoadingRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们一一来看涉及到的类和方法</p><h2 id="1-Activity-getWindow-及-PhoneWindow-的初始化时机"><a href="#1-Activity-getWindow-及-PhoneWindow-的初始化时机" class="headerlink" title="1. Activity.getWindow 及 PhoneWindow 的初始化时机"></a>1. Activity.getWindow 及 PhoneWindow 的初始化时机</h2><p>Activity 的 getWindow 方法获取到的是一个 PhoneWindow 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个 mWindow 就是一个 PhoneWindow 对象，其初始化的时机为这个 Activity attach 的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">          Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">          Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">          CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">          NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">          Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span> </span>&#123;</span><br><span class="line">      attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">      mFragments.attachActivity(<span class="keyword">this</span>, mContainer, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      mWindow = PolicyManager.makeNewWindow(<span class="keyword">this</span>);</span><br><span class="line">      mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">      mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">      mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">      ........</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PolicyManager.makeNewWindow(this) 最终会调用 Policy 的 makeNewWindow 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意 Activity 的 attach 方法很早就会调用的，是要早于 Activity 的 onCreate 方法的。 </p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>PhoneWindow 与 Activity 是一对一的关系，通过上面的初始化过程你应该更加清楚这个概念</li><li>Android 中对 PhoneWindow 的注释是 ：Android-specific Window ，可见其重要性</li><li>PhoneWindow 中有很多大家比较熟悉的方法，比如 setContentView / addContentView 等 ； 也有几个重要的内部类，比如：DecorView ;</li></ul><h2 id="2-PhoneWindow-getDecorView-及-DecorView-的初始化时机"><a href="#2-PhoneWindow-getDecorView-及-DecorView-的初始化时机" class="headerlink" title="2. PhoneWindow.getDecorView 及 DecorView 的初始化时机"></a>2. PhoneWindow.getDecorView 及 DecorView 的初始化时机</h2><p>上面我们说到 DecorView是 PhoneWindow 的一个内部类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">RootViewSurfaceTaker</span></span></span><br></pre></td></tr></table></figure><p>那么 DecorView 是什么时候初始化的呢？DecorView 是在 Activity 的父类的 onCreate 方法中被初始化的，比如我例子中的 MainActivity 是继承自 android.support.v7.app.AppCompatActivity ，当我们调用 MainActivity 的 super.onCreate(savedInstanceState); 的时候，就会调用下面的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    getDelegate().installViewFactory();</span><br><span class="line">    getDelegate().onCreate(savedInstanceState);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们导入的是 support.v7 包里面的AppCompatActivity， getDelegate() 得到的就是AppCompatDelegateImplV7 ，其 onCreate 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    mWindowDecor = (ViewGroup) mWindow.getDecorView();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这里的 mWindow.getDecorView() ，对 DecorView 进行了实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次调用 getDecorView 的时候，会进入 installDecor 方法，这个方法对 DecorView 进行了一系列的初始化 ，其中比较重要的几个方法有：generateDecor / generateLayout 等，generateLayout 会从当前的 Activity 的 Theme 提取相关的属性，设置给 Window，同时还会初始化一个 startingView，添加到 DecorView上，也就是我们所说的 startingWindow。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Decor 有装饰的意思，DecorView 官方注释为 “This is the top-level view of the window, containing the window decor” , 我们可以理解为 DecorView 是我们当前 Activity 的最下面的布局。所以我们打开 DDMS 查看 Tree Overview 的时候，可以发现最根部的那个 View 就是 DecorView：<br>  <img src="/images/applunch2/1.png" alt="DelayLoad"></li><li>应用从桌面启动的时候，在主 Activity 还没有显示的时候，如果主题没有设置窗口的背景，那么我们就会看到白色（这个和手机的Rom也有关系），如果应用启动很慢，那么用户得看好一会白色。如果要避免这个，则可以在 Application 或者 Activity 的 Theme 中设置 WindowBackground , 这样就可以避免白色（当然现在各种大厂都是SplashActivity+广告我也是可以理解的）</li></ul><h2 id="3-Post"><a href="#3-Post" class="headerlink" title="3. Post"></a>3. Post</h2><p>当我们调用 DecorView 的 Post 的时候，其实最终会调用 View 的 Post ，因为 DecorView 最终是继承 View 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Assume that post will succeed later</span></span><br><span class="line">    ViewRootImpl.getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的 mAttachInfo ，我们调用 post 是在 Activity 的 onCreate 中调用的，那么此时 mAttachInfo 是否为空呢？答案是 mAttachInfo 此时为空。</p><p>这里有一个点就是 Activity 的各个回调函数都是干嘛的？是不是平时自己写应用的时候，貌似在 onCreate 里面搞定一切就OK了， onResume ？ onStart？没怎么涉及到嘛，其实不然。<br>onCreate 顾名思义就是 Create ，我们在前面看到，Activity 的 onCreate 函数做了很多初始化的操作，包括 PhoneWindow/DecorView/StartingView/setContentView等，但是 onCreate 只是初始化了这些对象.<br>真正要设置为显示则在 Resume 的时候，不过这些对开发者是透明了，具体可以看 ActivityThread 的 handleResumeActivity 函数，handleResumeActivity 中除了调用 Activity 的 onResume 回调之外，还初始化了几个比较重要的类：ViewRootImpl / ThreadedRenderer。</p><p>ActivityThread.handleResumeActivity:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">    r.window = r.activity.getWindow();</span><br><span class="line">    View decor = r.window.getDecorView();</span><br><span class="line">    decor.setVisibility(View.INVISIBLE);</span><br><span class="line">    ViewManager wm = a.getWindowManager();</span><br><span class="line">    WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">    a.mDecor = decor;</span><br><span class="line">    l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">    l.softInputMode |= forwardBit;</span><br><span class="line">    <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">        a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要是 wm.addView(decor, l); 这句，将 decorView 与 WindowManagerImpl联系起来，这句最终会调用到 WindowManagerGlobal 的 addView 函数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 ViewRootImpl 是 View 系统的一个核心类，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span></span></span><br></pre></td></tr></table></figure><p>ViewRootImpl 初始化的时候会对 AttachInfo 进行初始化，这就是为什么之前的在 onCreate 的时候 attachInfo 为空。ViewRootImpl 里面有很多我们比较熟悉也非常重要的方法，比如 performTraversals / performLayout / performMeasure / performDraw / draw 等。<br>我们继续 addView 中的root.setView(view, wparams, panelParentView); 传入的 view 为 decorView，root 为 ViewRootImpl ，这个函数中将 ViewRootImpl 的mView 变量 设置为传入的view，也就是 decorView。<br>这样来看，ViewRootImpl 与 DecorView 的关系我们也清楚了。</p><p>扯了一圈，我们再回到大标题的 Post 函数上，前面有说这个 Post 走的是 View 的Post 函数，由于 在 onCreate 的时候 attachInfo 为空，所以会走下面的分支：ViewRootImpl.getRunQueue().post(action);<br>注意这里的 getRunQueue 得到的并不是 Looper 里面的那个 MessageQueue，而是由 ViewRootImpl 维持的一个 RunQueue 对象，其核心为一个 ArrayList ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;HandlerAction&gt; mActions = <span class="keyword">new</span> ArrayList&lt;HandlerAction&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">            postDelayed(action, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">            HandlerAction handlerAction = <span class="keyword">new</span> HandlerAction();</span><br><span class="line">            handlerAction.action = action;</span><br><span class="line">            handlerAction.delay = delayMillis;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (mActions) &#123;</span><br><span class="line">                mActions.add(handlerAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">executeActions</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mActions) &#123;</span><br><span class="line">                <span class="keyword">final</span> ArrayList&lt;HandlerAction&gt; actions = mActions;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = actions.size();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> HandlerAction handlerAction = actions.get(i);</span><br><span class="line">                    handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                actions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>当我们执行了 Post 之后 ，其实只是把 Runnable 封装成一个 HandlerAction 对象存入到 ArrayList 中，当执行到 executeActions 方法的时候，将存在这里的 HandlerAction 再通过 executeActions 方法传入的 Handler 对象重新进行 Post。<br>那么 executeActions 方法是什么时候执行的呢？传入的 Handler 又是哪个 Handler 呢？</p><h2 id="4-PerformTraversals"><a href="#4-PerformTraversals" class="headerlink" title="4. PerformTraversals"></a>4. PerformTraversals</h2><p>我们之前讲过，ViewRootImpl 的 performTraversals 方法是一个很核心的方法，每一帧绘制都会走一遍，调用各种 measure / layout / draw 等 ，最终将要显示的数据交给 hwui 去进行绘制。<br>我们上一节讲到的 executeActions ，就是在 performTraversals 中执行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute enqueued actions on every traversal in case a detached view enqueued an action</span></span><br><span class="line">getRunQueue().executeActions(mAttachInfo.mHandler);</span><br></pre></td></tr></table></figure><p>可以看到这里传入的 Handler 是 mAttachInfo.mHandler ，上一节讲到 mAttachInfo 是在 ViewRootImpl 初始化的时候一起初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这里的 mHandler 是一个 ViewRootHandler 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br></pre></td></tr></table></figure><p>我们注意到 ViewRootHandler 在创建的时候并没有传入一个 Looper 对象，这意味着此 ViewRootHandler 的 Looper 就是 mainLooper。</p><p><strong><em>这下我们就清楚了，我们在 onCreate 中 Post 的 runnable 对象，最终还是在第一个 performTraversals 方法执行的时候，加入到了 MainLooper 的 MessageQueue 里面了。</em></strong></p><p>绕了一圈终于我们终于把文章最前面的那句话解释清楚了，当然中间还有很多的废话，不过我估计能耐着性子看到这里的人会很少，所以如果你看到了这里，可以在底下的评论里面将 index ++ ；这里 index = 0 ；就是看看几个人是真正认真看了这篇文章的。</p><h2 id="5-UpdateText"><a href="#5-UpdateText" class="headerlink" title="5. UpdateText"></a>5. UpdateText</h2><p>接着 performTraversals 我们继续说，话说在<a href="https://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load/" target="_blank" rel="noopener">第一篇文章</a> 我们有讲到，Activity 在启动时，会在第二次执行 performTraversals 才会去真正的绘制，原因在于第一次执行 performTraversals 的时候，会走到 Egl 初始化的逻辑，然后会重新执行一次 performTraversals 。<br>所以前一篇文章的评论区有人问为何在 run 方法里面还要 post 一次，如果在 run 方法里面直接执行 updateText 方法 ，那么 updateText 就会在第一个 performTraversals 之后就执行，而不是在第一帧绘制完成后才去执行，所以我们又 Post 了一次 。所以大概的处理步骤如下：</p><blockquote><p>第一步：Activity.onCreate –&gt; Activity.onStart –&gt; Activity.onResume</p></blockquote><blockquote><p>第二步：ViewRootImpl.performTraversals –&gt;Runnable</p></blockquote><blockquote><p>第三步：Runnable –&gt; ViewRootImpl.performTraversals</p></blockquote><blockquote><p>第四步：ViewRootImpl.performTraversals –&gt; UpdateText</p></blockquote><blockquote><p>第五步：UpdateText</p></blockquote><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>其实一路跟下来发现其实原理很简单，其实 DelayLoad 其实只是一个很小的点，关键是教大家如何去跟踪一个自己不认识的知识点或者优化，这里面主要用到了两个工具：Systrace 和 Method Trace， 以及源码编译和调试。<br>关于 Systrace 和 Method Trace 的使用，之后会有详细的文章去介绍，这两个工具非常有助于理解源码和一些技术的实现。</p><h3 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h3><p><img src="/images/applunch2/2.png" alt="Systrace"></p><h3 id="Method-Trace"><a href="#Method-Trace" class="headerlink" title="Method Trace"></a>Method Trace</h3><p><img src="/images/applunch2/3.png" alt="Method Trace"></p><h3 id="源码编译与调试"><a href="#源码编译与调试" class="headerlink" title="源码编译与调试"></a>源码编译与调试</h3><p><img src="/images/applunch2/4.png" alt="源码编译与调试"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>本文章所所涉及到的代码我放到了Github上：<br><a href="https://github.com/Gracker/DelayLoadSample" target="_blank" rel="noopener">https://github.com/Gracker/DelayLoadSample</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 启动优化 </tag>
            
            <tag> DelayLoad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 应用启动优化 - 一种 DelayLoad 的实现和原理(上篇)</title>
      <link href="/2015/11/18/Android-app-lunch-optimize-delay-load/"/>
      <url>/2015/11/18/Android-app-lunch-optimize-delay-load/</url>
      
        <content type="html"><![CDATA[<p>在 Android 开发中,应用启动速度是一个非常重要的点,应用启动优化也是一个非常重要的过程.对于应用启动优化,其实核心思想就是在启动过程中少做事情,具体实践的时候无非就是下面几种:</p><ol><li>异步加载</li><li>延时加载</li><li>懒加载</li></ol><p>不用一一去解释,做过启动优化的估计都使用过,本篇文章将详细讲解一下一种延时加载的实现以及其原理.<br>其实这种加载的实现是非常简单的,但是其中的原理可能比较复杂,还涉及到Looper/Handler/MessageQueue/VSYNC等.以及其中碰到的一些问题,还会有一些我自己额外的思考.</p><a id="more"></a><h1 id="1-优化后的DelayLoad的实现"><a href="#1-优化后的DelayLoad的实现" class="headerlink" title="1. 优化后的DelayLoad的实现"></a>1. 优化后的DelayLoad的实现</h1><p>一提到DelayLoad,大家可能第一时间想到的就是在 onCreate 里面调用 Handler.postDelayed方法, 将需要 Delay 加载的东西放到这里面去初始化, 这个也是一个比较方便的方法. Delay一段时间再去执行,这时候应用已经加载完成,界面已经显示出来了, 不过这个方法有一个致命的问题: 延迟多久?<br>大家都知道,在 Android 的高端机型上,应用的启动是非常快的 , 这时候只需要 Delay 很短的时间就可以了, 但是在低端机型上,应用的启动就没有那么快了,而且现在应用为了兼容旧的机型,往往需要 Delay 较长的时间,这样带来体验上的差异是很明显的.</p><p>这里先说优化方案:</p><ol><li><p>首先 , 创建 Handler 和 Runnable 对象, 其中 Runnable 对象的 run方法里面去更新 UI 线程.</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler myHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"><span class="keyword">private</span> Runnable mLoadingRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    updateText(); <span class="comment">//更新UI线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在主 Activity 的 onCreate 中加入下面的代码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myHandler.post(mLoadingRunnable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>其实实现的话非常简单,我们来对比一下三种方案的效果.</p><h1 id="2-三种写法的差异对比"><a href="#2-三种写法的差异对比" class="headerlink" title="2. 三种写法的差异对比"></a>2. 三种写法的差异对比</h1><p>为了验证我们优化的 DelayLoad的效果,我们写了一个简单的app , 这个 App 中包含三张不同大小的图片,每张图片下面都会有一个 TextView , 来标记图片的显示高度和宽度. MainActivity的代码如下:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> MainActivity extends AppCompatActivity &#123;</span><br><span class="line">  <span class="keyword">private</span> static final <span class="built_in">int</span> DEALY_TIME = <span class="number">300</span> ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ImageView imageView1;</span><br><span class="line">  <span class="keyword">private</span> ImageView imageView2;</span><br><span class="line">  <span class="keyword">private</span> ImageView imageView3;</span><br><span class="line">  <span class="keyword">private</span> TextView textView1;</span><br><span class="line">  <span class="keyword">private</span> TextView textView2;</span><br><span class="line">  <span class="keyword">private</span> TextView textView3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Handler myHandler = <span class="keyword">new</span> <span class="constructor">Handler()</span>;</span><br><span class="line">  <span class="keyword">private</span> Runnable mLoadingRunnable = <span class="keyword">new</span> <span class="constructor">Runnable()</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run<span class="literal">()</span> &#123;</span><br><span class="line">      update<span class="constructor">Text()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;</span><br><span class="line">    super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;</span><br><span class="line">    set<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">activity_main</span>)</span>;</span><br><span class="line"></span><br><span class="line">    imageView1 = (ImageView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">image1</span>)</span>;</span><br><span class="line">    imageView2 = (ImageView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">image2</span>)</span>;</span><br><span class="line">    imageView3 = (ImageView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">image3</span>)</span>;</span><br><span class="line"></span><br><span class="line">    textView1 = (TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">text1</span>)</span>;</span><br><span class="line">    textView2 = (TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">text2</span>)</span>;</span><br><span class="line">    textView3 = (TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">text3</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第一种写法:直接Post</span></span><br><span class="line">    myHandler.post(mLoadingRunnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第二种写法:直接PostDelay 300ms.</span></span><br><span class="line"><span class="comment">//  myHandler.postDelayed(mLoadingRunnable, DEALY_TIME);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第三种写法:优化的DelayLoad</span></span><br><span class="line"><span class="comment">//  getWindow().getDecorView().post(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void run() &#123;</span></span><br><span class="line"><span class="comment">//      myHandler.post(mLoadingRunnable);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dump当前的MessageQueue信息.</span></span><br><span class="line">    get<span class="constructor">MainLooper()</span>.dump(<span class="keyword">new</span> <span class="constructor">Printer()</span> &#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void println(String x) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>i(<span class="string">"Gracker"</span>,x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">"onCreate"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void update<span class="constructor">Text()</span> &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">TraceCompat</span>.</span></span><span class="keyword">begin</span><span class="constructor">Section(<span class="string">"updateText"</span>)</span>;</span><br><span class="line">    textView1.set<span class="constructor">Text(<span class="string">"image1 : w="</span> + <span class="params">imageView1</span>.<span class="params">getWidth</span>()</span> +</span><br><span class="line">      <span class="string">" h ="</span> + imageView1.get<span class="constructor">Height()</span>);</span><br><span class="line">    textView2.set<span class="constructor">Text(<span class="string">"image2 : w="</span> + <span class="params">imageView2</span>.<span class="params">getWidth</span>()</span> +</span><br><span class="line">      <span class="string">" h ="</span> + imageView2.get<span class="constructor">Height()</span>);</span><br><span class="line">    textView3.set<span class="constructor">Text(<span class="string">"image3 : w="</span> + <span class="params">imageView3</span>.<span class="params">getWidth</span>()</span> +</span><br><span class="line">      <span class="string">" h ="</span> + imageView3.get<span class="constructor">Height()</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">TraceCompat</span>.</span></span><span class="keyword">end</span><span class="constructor">Section()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要关注两个点:</p><ul><li>updateText 这个函数是什么时候被执行的?</li><li>App 启动后,三个图片的长宽是否可以被正确地显示出来?</li><li>是否有 Delay Load 的效果?</li></ul><h2 id="2-1-第一种写法"><a href="#2-1-第一种写法" class="headerlink" title="2.1 第一种写法"></a>2.1 第一种写法</h2><ol><li><p>updateText执行的时机?<br>下面是第一种写法的Trace图:<br><img src="/images/app-lunch/1.png" alt="第一种写法"><br>可以看到 updateText 是在 Activity 的 onCreate/onStart/onResume三个回调执行完成后才去执行的.</p></li><li><p>图片的宽高是否正确显示?<br><img src="/images/app-lunch/2.png" alt="第一种写法"></p><p>从图片看一看到,宽高并没有显示. 这是为什么呢? 这个问题就要从Activity 的 onCreate/onStart/onResume三个回调说起了. 其实Activity 的 onCreate/onStart/onResume三个回调中,并没有执行Measure和Layout操作, 这个是在后面的performTraversals中才执行的. 所以在这之前宽高都是0.</p></li><li><p>是否有 Delay Load 的效果?<br>并没有. 因为我们知道, 应用启动的时候,要等两次 performTraversals 都执行完成之后才会显示第一帧, 而 updateText 这个方法在第一个 performTraversals 执行之前就执行了. 所以 updateText 方法的执行时间是算在应用启动的时间里面的.</p></li></ol><h2 id="2-2-第二种写法"><a href="#2-2-第二种写法" class="headerlink" title="2.2 第二种写法"></a>2.2 第二种写法</h2><p>第二种写法我们Delay了300ms .我们来看一下表现.</p><ol><li><p>updateText执行的时机?<br><img src="/images/app-lunch/3.png" alt="第二种写法"></p><p>可以看到,这种写法的话,updateText是在两个performTraversals 执行完成之后(这时候 APP 的第一帧才显示出来)才去执行的, 执行完成之后又调用了一次 performTraversals 将 TextView 的内容进行更新.</p></li><li><p>图片的宽高是否正确显示?<br><img src="/images/app-lunch/4.png" alt="第二种写法"></p><p>从上图可以看到,图片的宽高是正确显示了出来. 原因上面已经说了,measure/layout执行完成后,宽高的数据就可以获取了.</p></li><li><p>是否有 Delay Load 的效果?<br>不一定,取决于 Delay的时长.<br>从前面的 Trace 图上我们可以看到 , updateText 方法由于 Delay 了300ms, 所以在应用第一帧显示出来170ms之后, 图片的文字信息才进行了更新. 这个是有 Delay Load 的效果的.<br>但是这里只是一个简单的TextView的更新, 如果是较大模块的加载 , 用户视觉上会有很明显的 “ 空白-&gt;内容填充” 这个过程, 或者会附加”闪一下”特效…这显然是我们不想看到的.</p><p>有人会说:可以把Delay的时间减小一点嘛,这样就不会闪了. 话是这么说,但是由于 Android 机器的多元性(其实就是有很多高端机器,也有很多低端机器) , 在这个机子上300ms的延迟算是快,在另外一个机子上300ms算是很慢.</p><p>我们将Delay时间调整为50ms, 其Trace图如下:</p><p><img src="/images/app-lunch/5.png" alt="第二种写法:Delay 50ms"></p><p>可以看到,updateText 方法在第一个 performTraversals 之后就执行了,所以也没有 Delay Load 的效果(虽然宽高是正确显示了,因为在第一个 performTraversals 方法中就执行了layout和measure).</p></li></ol><h2 id="2-3-第三种写法"><a href="#2-3-第三种写法" class="headerlink" title="2.3 第三种写法"></a>2.3 第三种写法</h2><p>经过前两个方法 , 我们就会想, 如果能不使用Delay方法, updateText 方法能在 第二个performTraversals 方法执行完成后(即APP第一帧在屏幕上显示),马上就去执行,那么即起到了 Delay Load的作用,又可以正确显示图片的宽高.<br>第三种写法就是这个效果:</p><ol><li><p>updateText执行的时机?</p><p><img src="/images/app-lunch/6.png" alt="第三种写法"></p><p>可以看到这种写法. updateText 在第二个 performTraversals 方法执行完成后马上就执行了, 然后下一个 VSYNC 信号来了之后, TextView就更新了.</p></li><li><p>图片的宽高是否正确显示?<br>当然是正确显示的.如图:<br><img src="/images/app-lunch/7.png" alt="第三种写法"></p></li><li><p>是否有 Delay Load 的效果?<br>从 Trace 图上看, 是有 Delay Load的效果的, 而且可以在应用第一帧显示后马上进行数据 Load , 不用考虑 Delay时间的长短.</p></li></ol><h1 id="3-一些思考"><a href="#3-一些思考" class="headerlink" title="3. 一些思考"></a>3. 一些思考</h1><p>关于优化的 Delay Load 的实现,从代码层面来看其实是非常简单的.其带来的效果也是很赞的.<br>但是实现之后我们还需要思考一下,为何这么做就可以实现这种功能呢?很显然要回答这个问题,我们需要知道更底层的一些东西.这个还涉及到 Handler/Message/MessageQueue/Looper/VSYNC/ViewRootImpl等知识. 往大里说应该还涉及到AMS/WMS等.由于涉及到的东西比较多,我就不在这一篇里面阐述了, 下一篇文章将会从从原理上讲解一下为何优化的 Delay Load 会起作用.</p><h1 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h1><p>本文章所所涉及到的代码我放到了Github上：<br><a href="https://github.com/Gracker/DelayLoadSample" target="_blank" rel="noopener">https://github.com/Gracker/DelayLoadSample</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 启动优化 </tag>
            
            <tag> DelayLoad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android hwui 中 RenderThread 工作流程</title>
      <link href="/2015/08/12/AndroidL-hwui-RenderThread-workflow/"/>
      <url>/2015/08/12/AndroidL-hwui-RenderThread-workflow/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章是自己的一个学习笔记，记录了 Android 5.0 中 hwui 中的 RenderThread 的简单工作流程。由于是学习笔记，所以其中一些细节不会太详细，我只是将大概的流程走一遍，将其工作流标注出来，下次遇到问题的时候就可以知道去哪里查。</p><p>下图是我用 Systrace 抓取的一个应用启动的时候 RenderThread 的第一次 Draw 的 Trace 图，从这里面的顺序来看 RenderThread 的流程。熟悉应用启动流程的话应该知道，只有当第一次 DrawFrame 完成之后，整个应用的界面才会显示在手机上，在这之前，用户看到的是应用的 StartingWindow 的界面。</p><a id="more"></a><p><img src="/images/hwui/renderthread/1.png" alt="RenderThread Draw first frame"></p><h2 id="从Java层说起"><a href="#从Java层说起" class="headerlink" title="从Java层说起"></a>从Java层说起</h2><p>应用程序的每一帧是从接收到 VSYNC 信号开始进行计算和绘制的,这要从 Choreographer 这个类说起了，不过由于篇幅原因，我们直接看一帧的绘制调用关系链即可：</p><p><img src="/images/hwui/renderthread/2.png" alt="绘制关系链"></p><p>Choreographer 的 drawFrame 会调用到 ViewRootImpl 的 performTraversals 方法，而 performTraversals 方法最终会调用到performDraw() 方法， performDraw 又会调用到 draw(boolean fullRedrawNeeded) 方法，这个 draw 方法是 ViewRootImpl 的私有方法，和我们熟知的那个draw并不是同一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">                mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> invalidateRoot = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123;</span><br><span class="line">                    mHardwareYOffset = yOffset;</span><br><span class="line">                    mHardwareXOffset = xOffset;</span><br><span class="line">                    mAttachInfo.mHardwareRenderer.invalidateRoot();</span><br><span class="line">                &#125;</span><br><span class="line">                mResizeAlpha = resizeAlpha;</span><br><span class="line"></span><br><span class="line">                dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">                mBlockResizeBuffer = <span class="keyword">false</span>;</span><br><span class="line">                mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是走硬件绘制路线的话，则会走这一条先，之后就会调用 mHardwareRenderer 的 draw 方法,这里的 mHardwareRenderer 指的是 ThreadedRenderer ，其 Draw 函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> frameTimeNanos = mChoreographer.getFrameTimeNanos();</span><br><span class="line">    attachInfo.mDrawingTime = frameTimeNanos / TimeUtils.NANOS_PER_MS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> recordDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mProfilingEnabled) &#123;</span><br><span class="line">        recordDuration = System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProfilingEnabled) &#123;</span><br><span class="line">        recordDuration = System.nanoTime() - recordDuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register animating rendernodes which started animating prior to renderer</span></span><br><span class="line">    <span class="comment">// creation, which is typical for animators started prior to first draw</span></span><br><span class="line">    <span class="keyword">if</span> (attachInfo.mPendingAnimatingRenderNodes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = attachInfo.mPendingAnimatingRenderNodes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            registerAnimatingRenderNode(</span><br><span class="line">                    attachInfo.mPendingAnimatingRenderNodes.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes.clear();</span><br><span class="line">        <span class="comment">// We don't need this anymore as subsequent calls to</span></span><br><span class="line">        <span class="comment">// ViewRootImpl#attachRenderNodeAnimator will go directly to us.</span></span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameTimeNanos,</span><br><span class="line">            recordDuration, view.getResources().getDisplayMetrics().density);</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_INVALIDATE_REQUIRED) != <span class="number">0</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数里面的 updateRootDisplayList(view, callbacks) ;即 getDisplayList 操作。接下来就是比较重要的一个操作：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int syncResult = nSyncAndDrawFrame(<span class="name">mNativeProxy</span>, frameTimeNanos,</span><br><span class="line">        recordDuration, view.getResources().getDisplayMetrics().density)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>可以看出这是一个阻塞操作，等Native层完成后，拿到返回值后才会进行下一步的操作。</p><h2 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h2><p>其Native代码在android_view_ThreadedRenderer.cpp中，对应的实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong proxyPtr, jlong frameTimeNanos, jlong recordDuration, jfloat density)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    <span class="keyword">return</span> proxy-&gt;syncAndDrawFrame(frameTimeNanos, recordDuration, density);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderProxy的路径位于frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> RenderProxy::syncAndDrawFrame(<span class="keyword">nsecs_t</span> frameTimeNanos, <span class="keyword">nsecs_t</span> recordDurationNanos,</span><br><span class="line">        <span class="keyword">float</span> density) &#123;</span><br><span class="line">    mDrawFrameTask.setDensity(density);</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame(frameTimeNanos, recordDurationNanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mDrawFrameTask 是一个 DrawFrameTask 对象，其路径位于frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp，其中drawFrame代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> DrawFrameTask::draw<span class="constructor">Frame(<span class="params">nsecs_t</span> <span class="params">frameTimeNanos</span>, <span class="params">nsecs_t</span> <span class="params">recordDurationNanos</span>)</span> &#123;</span><br><span class="line">    mSyncResult = kSync_OK;</span><br><span class="line">    mFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    mRecordDurationNanos = recordDurationNanos;</span><br><span class="line">    post<span class="constructor">AndWait()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the single-frame data</span></span><br><span class="line">    mFrameTimeNanos = <span class="number">0</span>;</span><br><span class="line">    mRecordDurationNanos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    return mSyncResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 postAndWait() 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DrawFrameTask::postAndWait() &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>(<span class="keyword">this</span>);</span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是将一个 DrawFrameTask 放入到了 mRenderThread 中,其中 queue 方法实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RenderThread::<span class="built_in">queue</span>(RenderTask* task) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mQueue.<span class="built_in">queue</span>(task);</span><br><span class="line">    <span class="keyword">if</span> (mNextWakeup &amp;&amp; task-&gt;mRunAt &lt; mNextWakeup) &#123;</span><br><span class="line">        mNextWakeup = <span class="number">0</span>;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mQueue 是一个 TaskQueue 对象，其</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TaskQueue::queue(RenderTask* <span class="keyword">task</span>) &#123;</span><br><span class="line">    <span class="comment">// Since the RenderTask itself forms the linked list it is not allowed</span></span><br><span class="line">    <span class="comment">// to have the same task queued twice</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(<span class="keyword">task</span>-&gt;mNext || mTail == <span class="keyword">task</span>, <span class="string">"Task is already in the queue!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mTail) &#123;</span><br><span class="line">        <span class="comment">// Fast path if we can just append</span></span><br><span class="line">        <span class="keyword">if</span> (mTail-&gt;mRunAt &lt;= <span class="keyword">task</span>-&gt;mRunAt) &#123;</span><br><span class="line">            mTail-&gt;mNext = <span class="keyword">task</span>;</span><br><span class="line">            mTail = <span class="keyword">task</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Need to find the proper insertion point</span></span><br><span class="line">            RenderTask* <span class="keyword">previous</span> = <span class="number">0</span>;</span><br><span class="line">            RenderTask* <span class="keyword">next</span> = mHead;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">next</span> &amp;&amp; <span class="keyword">next</span>-&gt;mRunAt &lt;= <span class="keyword">task</span>-&gt;mRunAt) &#123;</span><br><span class="line">                <span class="keyword">previous</span> = <span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">next</span> = <span class="keyword">next</span>-&gt;mNext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">previous</span>) &#123;</span><br><span class="line">                <span class="keyword">task</span>-&gt;mNext = mHead;</span><br><span class="line">                mHead = <span class="keyword">task</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">previous</span>-&gt;mNext = <span class="keyword">task</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">next</span>) &#123;</span><br><span class="line">                    <span class="keyword">task</span>-&gt;mNext = <span class="keyword">next</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTail = <span class="keyword">task</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mTail = mHead = <span class="keyword">task</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看 RenderThread 之前的 queue 方法，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wake 函数则更为简单，仅仅向管道的写端写入一个字符“W”，这样管道的读端就会因为有数据可读而从等待状态中醒来。</p><h2 id="HWUI-RenderThread"><a href="#HWUI-RenderThread" class="headerlink" title="HWUI-RenderThread"></a>HWUI-RenderThread</h2><p>接下来会到哪里去，我们首先要熟悉一下RenderThread，RenderThread是继承自Thread的，这个Thread是utils/Thread.h,RenderThread的初始化函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RenderThread::<span class="constructor">RenderThread()</span> : <span class="constructor">Thread(<span class="params">true</span>)</span>, Singleton&lt;RenderThread&gt;<span class="literal">()</span></span><br><span class="line">        , m<span class="constructor">NextWakeup(LLONG_MAX)</span></span><br><span class="line">        , m<span class="constructor">DisplayEventReceiver(0)</span></span><br><span class="line">        , m<span class="constructor">VsyncRequested(<span class="params">false</span>)</span></span><br><span class="line">        , m<span class="constructor">FrameCallbackTaskPending(<span class="params">false</span>)</span></span><br><span class="line">        , m<span class="constructor">FrameCallbackTask(0)</span></span><br><span class="line">        , m<span class="constructor">RenderState(NULL)</span></span><br><span class="line">        , m<span class="constructor">EglManager(NULL)</span> &#123;</span><br><span class="line">    mFrameCallbackTask = <span class="keyword">new</span> <span class="constructor">DispatchFrameCallbacks(<span class="params">this</span>)</span>;</span><br><span class="line">    mLooper = <span class="keyword">new</span> <span class="constructor">Looper(<span class="params">false</span>)</span>;</span><br><span class="line">    run(<span class="string">"RenderThread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 run 方法在 Thread 中有说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the thread in threadLoop() which needs to be implemented.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t    <span class="title">run</span><span class="params">(    <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int32_t</span> priority = PRIORITY_DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">size_t</span> <span class="built_in">stack</span> = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>即启动 threadLoop 函数，我们来看 RenderThread 的 threadLoop 函数，这个函数比较重要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RenderThread::threadLoop() &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PTHREADS)</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_DISPLAY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(result == Looper::POLL_ERROR,</span><br><span class="line">                <span class="string">"RenderThread Looper POLL_ERROR!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">nsecs_t</span> nextWakeup;</span><br><span class="line">        <span class="comment">// Process our queue, if we have anything</span></span><br><span class="line">        <span class="keyword">while</span> (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</span><br><span class="line">            task-&gt;run();</span><br><span class="line">            <span class="comment">// task may have deleted itself, do not reference it again</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextWakeup == LLONG_MAX) &#123;</span><br><span class="line">            timeoutMillis = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">nsecs_t</span> timeoutNanos = nextWakeup - systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            timeoutMillis = nanoseconds_to_milliseconds(timeoutNanos);</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                timeoutMillis = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue(<span class="literal">true</span>);</span><br><span class="line">            mFrameCallbacks.insert(</span><br><span class="line">                    mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，一个 for 循环是一个无限循环，而其中 pollOnce 是一个阻塞函数，直到我们上面调用了 mLooper-&gt;wake() 之后，会继续往下走，走到 while 循环中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</span><br><span class="line">            task-&gt;run();</span><br><span class="line">            <span class="comment">// task may have deleted itself, do not reference it again</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>会将 RenderTask 取出来执行其 run 方法，经过前面的流程我们知道这个 RenderTask 是一个 DrawFrameTask ，其run方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DrawFrameTask::run() &#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"DrawFrame"</span>);</span><br><span class="line"></span><br><span class="line">    mContext-&gt;profiler().setDensity(mDensity);</span><br><span class="line">    mContext-&gt;profiler().startFrame(mRecordDurationNanos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> canUnblockUiThread;</span><br><span class="line">    <span class="keyword">bool</span> canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, mRenderThread-&gt;renderState())</span></span>;</span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From this point on anything in "this" is *UNSAFE TO ACCESS*</span></span><br><span class="line">    <span class="keyword">if</span> (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RenderThread-DrawFrame"><a href="#RenderThread-DrawFrame" class="headerlink" title="RenderThread.DrawFrame"></a>RenderThread.DrawFrame</h2><p>上面说到了 DrawFrameTask 的 run 方法，这里 run 方法中的执行的方法即我们在最前面那张图中所示的部分（即文章最前面那张图），下面的流程就是那张图中的函数调用，我们结合代码和图，一部分一部分来走整个 DrawFrame 的流程：</p><h3 id="1-syncFrameState"><a href="#1-syncFrameState" class="headerlink" title="1. syncFrameState"></a>1. syncFrameState</h3><p>第一个比较重要的函数是 syncFrameState ，从函数名就可以知道， syncFrameState 的作用就是同步 frame 信息，将 Java 层维护的 frame 信息同步到 RenderThread中。</p><blockquote><p>Main Thread 和Render Thread 都各自维护了一份应用程序窗口视图信息。各自维护了一份应用程序窗口视图信息的目的，就是为了可以互不干扰，进而实现最大程度的并行。其中，Render Thread维护的应用程序窗口视图信息是来自于 Main Thread 的。因此，当Main Thread 维护的应用程序窗口信息发生了变化时，就需要同步到 Render Thread 去。</p></blockquote><p>所以查看代码就可以知道有两个 RenderNode，一个在 hwui 中，一个在 View 中。简单来说，同步信息就是将 Java 层的 RenderNode 中的信息同步到 hwui 中的 RenderNode 中。 注意syncFrameState的返回值赋给了 canUnblockUiThread ，从名字可以看出这个 canUnblockUiThread 的作用是判断是否唤醒 Main Thread ，也就是说如果返回为 true 的话，会提前唤醒主线程来执行其他的事情，而不用等到 draw 完成后再去唤醒 Main Thread。 这也是 Android 5.0 和 Android 4.x 最大的区别了。</p><p><img src="/images/hwui/renderthread/3.png" alt="syncFrameState"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> DrawFrameTask::sync<span class="constructor">FrameState(TreeInfo&amp; <span class="params">info</span>)</span> &#123;</span><br><span class="line">    mRenderThread-&gt;time<span class="constructor">Lord()</span>.vsync<span class="constructor">Received(<span class="params">mFrameTimeNanos</span>)</span>;</span><br><span class="line">    mContext-&gt;make<span class="constructor">Current()</span>;</span><br><span class="line">    Caches::get<span class="constructor">Instance()</span>.textureCache.reset<span class="constructor">MarkInUse()</span>;</span><br><span class="line"></span><br><span class="line">    for (size_t i = <span class="number">0</span>; i &lt; mLayers.size<span class="literal">()</span>; i++) &#123;</span><br><span class="line">        mContext-&gt;process<span class="constructor">LayerUpdate(<span class="params">mLayers</span>[<span class="params">i</span>].<span class="params">get</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear<span class="literal">()</span>;</span><br><span class="line">    mContext-&gt;prepare<span class="constructor">Tree(<span class="params">info</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult <span class="pattern-match">|= k<span class="constructor">Sync_UIRedrawRequired</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> <span class="constructor">If</span> prepare<span class="constructor">Textures</span> is <span class="literal">false</span>, we ran out <span class="keyword">of</span> texture cache space</span></span><br><span class="line"><span class="pattern-match">    return info.prepare<span class="constructor">Textures</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>首先是makeCurrent，这里的mContext是一个CanvasContext对象，其makeCurrent实现如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void CanvasContext::make<span class="constructor">Current()</span> &#123;</span><br><span class="line">    <span class="comment">// In the meantime this matches the behavior of GLRenderer, so it is not a regression</span></span><br><span class="line">    mHaveNewSurface <span class="pattern-match">|= m<span class="constructor">EglManager</span>.make<span class="constructor">Current(<span class="params">mEglSurface</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>mEglManager是一个EglManager对象，其实现为：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> EglManager::<span class="built_in">makeCurrent</span>(EGLSurface <span class="built_in">surface</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isCurrent</span>(<span class="built_in">surface</span>)) <span class="keyword">return</span> false;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (surface == EGL_NO_SURFACE) &#123;</span><br><span class="line">        <span class="comment">// If we are setting EGL_NO_SURFACE we don't care about any of the potential</span></span><br><span class="line">        <span class="comment">// return errors, which would only happen if mEglDisplay had already been</span></span><br><span class="line">        <span class="comment">// destroyed in which case the current context is already NO_CONTEXT</span></span><br><span class="line">        <span class="built_in">TIME_LOG</span>(<span class="string">"eglMakeCurrent"</span>, <span class="built_in">eglMakeCurrent</span>(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        EGLBoolean success;</span><br><span class="line">        <span class="built_in">TIME_LOG</span>(<span class="string">"eglMakeCurrent"</span>, success = <span class="built_in">eglMakeCurrent</span>(mEglDisplay, <span class="built_in">surface</span>, <span class="built_in">surface</span>, mEglContext));</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">"Failed to make current on surface %p, error=%s"</span>,</span><br><span class="line">                (void*)<span class="built_in">surface</span>, <span class="built_in">egl_error_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentSurface = <span class="built_in">surface</span>;</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会判断mCurrentSurface == surface，如果成立，则不用再初始化操作，如果是另外一个surface。，则会执行eglMakeCurrent，来重新创建上下文。</p><p>makeCurrent之后，会调用mContext-&gt;prepareTree(info)，其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CanvasContext::prepareTree(TreeInfo&amp; info) &#123;</span><br><span class="line">    mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    info.damageAccumulator = &amp;mDamageAccumulator;</span><br><span class="line">    info.renderer = mCanvas;</span><br><span class="line">    <span class="keyword">if</span> (mPrefetechedLayers.size() &amp;&amp; info.mode == TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        info.canvasContext = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimationContext-&gt;startFrame(info.mode);</span><br><span class="line">    mRootRenderNode-&gt;prepareTree(info);</span><br><span class="line">    mAnimationContext-&gt;runRemainingAnimations(info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.canvasContext) &#123;</span><br><span class="line">        freePrefetechedLayers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> runningBehind = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> This query is moderately expensive, investigate adding some sort</span></span><br><span class="line">    <span class="comment">// of fast-path based off when we last called eglSwapBuffers() as well as</span></span><br><span class="line">    <span class="comment">// last vsync time. Or something.</span></span><br><span class="line">    TIME_LOG(<span class="string">"nativeWindowQuery"</span>, mNativeWindow-&gt;query(mNativeWindow.get(),</span><br><span class="line">            NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND, &amp;runningBehind));</span><br><span class="line">    info.out.canDrawThisFrame = !runningBehind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations || !info.out.canDrawThisFrame) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!info.out.requiresUiRedraw) &#123;</span><br><span class="line">            <span class="comment">// If animationsNeedsRedraw is set don't bother posting for an RT anim</span></span><br><span class="line">            <span class="comment">// as we will just end up fighting the UI thread.</span></span><br><span class="line">            mRenderThread.postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mRootRenderNode-&gt;prepareTree(info) 又是最重要的。回到Java层，我们知道 ThreadedRenderer 在初始化时，初始化了一个指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</span><br></pre></td></tr></table></figure><p>这个RootRenderNode也就是一个根Node，</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mRootNode</span> = RenderNode.adopt(rootNodePtr)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后会创建一个 mNativeProxy 指针，在 Native 层初始化一个 RenderProxy 对象，将 rootNodePtr 传给 RenderProxy 对象，这样在 RenderProxy 我们就可以得到这个对象的指针了。其中 CanvasContext 也是在 RenderProxy 对象初始化的时候被初始化的，初始化的时候将 rootNodePtr 传给了 CanvasContext 对象。</p><p>我们之前提到 ThreadedRenderer 的 draw 方法中首先会调用updateRootDisplayList，即我们熟悉的 getDisplayList 。这个方法中，其实也分为两个步骤，第一个步骤是 updateViewTreeDisplayList，第二个步骤是将根 Node 加入到 DrawOp 中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.insert<span class="constructor">ReorderBarrier()</span>;</span><br><span class="line">canvas.draw<span class="constructor">RenderNode(<span class="params">view</span>.<span class="params">getDisplayList</span>()</span>);</span><br><span class="line">canvas.insert<span class="constructor">InorderBarrier()</span>;</span><br></pre></td></tr></table></figure><p>其最终实现在</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayListRenderer::draw<span class="constructor">RenderNode(RenderNode<span class="operator">*</span> <span class="params">renderNode</span>, Rect&amp; <span class="params">dirty</span>, <span class="params">int32_t</span> <span class="params">flags</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">LOG_ALWAYS_FATAL_IF(!<span class="params">renderNode</span>, <span class="string">"missing rendernode"</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty is an out parameter and should not be recorded,</span></span><br><span class="line">    <span class="comment">// it matters only when replaying the display list</span></span><br><span class="line">    DrawRenderNodeOp* op = <span class="keyword">new</span> (alloc<span class="literal">()</span>) <span class="constructor">DrawRenderNodeOp(<span class="params">renderNode</span>, <span class="params">flags</span>, <span class="operator">*</span><span class="params">currentTransform</span>()</span>);</span><br><span class="line">    add<span class="constructor">RenderNodeOp(<span class="params">op</span>)</span>;</span><br><span class="line"></span><br><span class="line">    return DrawGlInfo::kStatusDone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到我们之前的 CanvasContext.prepareTree 中提到的 mRootRenderNode-&gt;prepareTree(info)，这时候这里的 mRootRenderNode 就是 CanvasContext 初始化是传进来的。</p><p>其实现在 RenderNode.cpp 中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void RenderNode::prepare<span class="constructor">Tree(TreeInfo&amp; <span class="params">info</span>)</span> &#123;</span><br><span class="line">    prepare<span class="constructor">TreeImpl(<span class="params">info</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RenderNode::prepare<span class="constructor">TreeImpl(TreeInfo&amp; <span class="params">info</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">TT_START_MARK(<span class="params">getName</span>()</span>);</span><br><span class="line">    info.damageAccumulator-&gt;push<span class="constructor">Transform(<span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.mode<span class="operator"> == </span>TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        push<span class="constructor">StagingPropertiesChanges(<span class="params">info</span>)</span>; <span class="comment">//同步当前正在处理的Render Node的Property</span></span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t animatorDirtyMask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">CC_LIKELY(<span class="params">info</span>.<span class="params">runAnimations</span>)</span>) &#123;</span><br><span class="line">        animatorDirtyMask = mAnimatorManager.animate(info);<span class="comment">//执行动画相关的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    prepare<span class="constructor">Layer(<span class="params">info</span>, <span class="params">animatorDirtyMask</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (info.mode<span class="operator"> == </span>TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        push<span class="constructor">StagingDisplayListChanges(<span class="params">info</span>)</span>;  <span class="comment">//同步当前正在处理的Render Node的Display List</span></span><br><span class="line">    &#125;</span><br><span class="line">    prepare<span class="constructor">SubTree(<span class="params">info</span>, <span class="params">mDisplayListData</span>)</span>; <span class="comment">//同步当前正在处理的Render Node的Display List引用的Bitmap，以及当前正在处理的Render Node的子Render Node的Display List等信息</span></span><br><span class="line">    push<span class="constructor">LayerUpdate(<span class="params">info</span>)</span>; <span class="comment">//检查当前正在处理的Render Node是否设置了Layer。如果设置了的话，就对这些Layer进行处理</span></span><br><span class="line"></span><br><span class="line">    info.damageAccumulator-&gt;pop<span class="constructor">Transform()</span>;</span><br><span class="line">    <span class="constructor">TT_END_MARK()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所涉及到的进一步的具体操作大家可以自行去看代码。</p><h2 id="2-draw"><a href="#2-draw" class="headerlink" title="2. draw"></a>2. draw</h2><p><img src="/images/hwui/renderthread/4.png" alt="Draw"></p><p>执行完syncFrameState之后，接下来就是执行draw</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span> <span class="params">(CC_LIKELY(canDrawThisFrame)</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="title">context</span>-&gt;</span>draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CanvasContext的draw函数是一个核心函数，其位置在 frameworks/base/libs/hwui/OpenGLRenderer.cpp ，其实现如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void CanvasContext::draw() &#123;</span><br><span class="line">    profiler().markPlaybackStart();</span><br><span class="line"></span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulator.finish(&amp;dirty);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    status_t status;</span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty()) &#123;</span><br><span class="line">        <span class="function"><span class="title">status</span> = mCanvas-&gt;</span>prepareDirty(dirty.fLeft, dirty.fTop,</span><br><span class="line">                dirty.fRight, dirty.fBottom, mOpaque);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">status</span> = mCanvas-&gt;</span>prepare(mOpaque);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rect outBounds;</span><br><span class="line">    <span class="function"><span class="title">status</span> |= mCanvas-&gt;</span>drawRenderNode(mRootRenderNode.get(), outBounds);</span><br><span class="line"></span><br><span class="line">    profiler().draw(mCanvas);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">mCanvas</span>-&gt;</span>finish();</span><br><span class="line"></span><br><span class="line">    profiler().markPlaybackEnd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status &amp; DrawGlInfo::kStatusDrew) &#123;</span><br><span class="line">        swapBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    profiler().finishFrame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// M: enable to get overdraw count</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(g_HWUI_debug_overdraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDebugOverdrawLayer) &#123;</span><br><span class="line">            mDebugOverdrawLayer = LayerRenderer::createRenderLayer(mRenderThread.renderState(),</span><br><span class="line">                <span class="function"><span class="title">mCanvas</span>-&gt;</span><span class="function"><span class="title">getWidth</span>(), mCanvas-&gt;</span>getHeight());</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (mDebugOverdrawLayer-&gt;</span><span class="function"><span class="title">layer</span>.getWidth() != mCanvas-&gt;</span>getWidth() ||</span><br><span class="line">                   <span class="function"><span class="title">mDebugOverdrawLayer</span>-&gt;</span><span class="function"><span class="title">layer</span>.getHeight() != mCanvas-&gt;</span>getHeight()) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!LayerRenderer::resizeLayer(mDebugOverdrawLayer, mCanvas-&gt;</span><span class="function"><span class="title">getWidth</span>(), mCanvas-&gt;</span>getHeight())) &#123;</span><br><span class="line">                LayerRenderer::destroyLayer(mDebugOverdrawLayer);</span><br><span class="line">                mDebugOverdrawLayer = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-eglBeginFrame"><a href="#2-1-eglBeginFrame" class="headerlink" title="2.1 eglBeginFrame"></a>2.1 eglBeginFrame</h4><p>首先来看eglBeginFrame的实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void EglManager::<span class="keyword">begin</span><span class="constructor">Frame(EGLSurface <span class="params">surface</span>, EGLint<span class="operator">*</span> <span class="params">width</span>, EGLint<span class="operator">*</span> <span class="params">height</span>)</span> &#123;</span><br><span class="line">    make<span class="constructor">Current(<span class="params">surface</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (width) &#123;</span><br><span class="line">        egl<span class="constructor">QuerySurface(<span class="params">mEglDisplay</span>, <span class="params">surface</span>, EGL_WIDTH, <span class="params">width</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (height) &#123;</span><br><span class="line">        egl<span class="constructor">QuerySurface(<span class="params">mEglDisplay</span>, <span class="params">surface</span>, EGL_HEIGHT, <span class="params">height</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    egl<span class="constructor">BeginFrame(<span class="params">mEglDisplay</span>, <span class="params">surface</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeCurrent是用来管理上下文，eglBeginFrame主要是校验参数的合法性。</p><h4 id="2-2-prepareDirty"><a href="#2-2-prepareDirty" class="headerlink" title="2.2 prepareDirty"></a>2.2 prepareDirty</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status_t status;</span><br><span class="line">if (!<span class="keyword">dirty.isEmpty()) </span>&#123;</span><br><span class="line">    status = mCanvas-&gt;prepareDirty(<span class="keyword">dirty.fLeft, </span><span class="keyword">dirty.fTop,</span></span><br><span class="line"><span class="keyword"> </span>           <span class="keyword">dirty.fRight, </span><span class="keyword">dirty.fBottom, </span>mOpaque);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    status = mCanvas-&gt;prepare(mOpaque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mCanvas是一个OpenGLRenderer对象，其prepareDirty实现</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span>增加函数功能描述</span></span><br><span class="line">status_t OpenGLRenderer::prepareDirty(<span class="keyword">float</span> left, <span class="keyword">float</span> top,</span><br><span class="line">        <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">bool</span> opaque) &#123;</span><br><span class="line">    setupFrameState(left, top, right, bottom, opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer renderers will start the frame immediately</span></span><br><span class="line">    <span class="comment">// The framebuffer renderer will first defer the display list</span></span><br><span class="line">    <span class="comment">// for each layer and wait until the first drawing command</span></span><br><span class="line">    <span class="comment">// to start the frame</span></span><br><span class="line">    <span class="keyword">if</span> (currentSnapshot()-&gt;fbo == <span class="number">0</span>) &#123;</span><br><span class="line">        syncState();</span><br><span class="line">        updateLayers();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DrawGlInfo::kStatusDone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-drawRenderNode"><a href="#2-3-drawRenderNode" class="headerlink" title="2.3 drawRenderNode"></a>2.3 drawRenderNode</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rect outBounds;</span><br><span class="line">status <span class="pattern-match">|= m<span class="constructor">Canvas</span>-&gt;draw<span class="constructor">RenderNode(<span class="params">mRootRenderNode</span>.<span class="params">get</span>()</span>, out<span class="constructor">Bounds</span>);</span></span><br></pre></td></tr></table></figure><p>接下来就是调用OpenGLRenderer的drawRenderNode方法进行绘制</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">status_t OpenGLRenderer::draw<span class="constructor">RenderNode(RenderNode<span class="operator">*</span> <span class="params">renderNode</span>, Rect&amp; <span class="params">dirty</span>, <span class="params">int32_t</span> <span class="params">replayFlags</span>)</span> &#123;</span><br><span class="line">    status_t status;</span><br><span class="line">    <span class="comment">// All the usual checks and setup operations (quickReject, setupDraw, etc.)</span></span><br><span class="line">    <span class="comment">// will be performed by the display list itself</span></span><br><span class="line">    <span class="keyword">if</span> (renderNode<span class="operator"> &amp;&amp; </span>renderNode-&gt;is<span class="constructor">Renderable()</span>) &#123;</span><br><span class="line">        <span class="comment">// compute 3d ordering</span></span><br><span class="line">        renderNode-&gt;compute<span class="constructor">Ordering()</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">CC_UNLIKELY(<span class="params">mCaches</span>.<span class="params">drawDeferDisabled</span>)</span>) &#123; <span class="comment">//判断是否不重排序</span></span><br><span class="line">            status = start<span class="constructor">Frame()</span>;</span><br><span class="line">            ReplayStateStruct replay<span class="constructor">Struct(<span class="operator">*</span><span class="params">this</span>, <span class="params">dirty</span>, <span class="params">replayFlags</span>)</span>;</span><br><span class="line">            renderNode-&gt;replay(replayStruct, <span class="number">0</span>);</span><br><span class="line">            return status <span class="pattern-match">| replay<span class="constructor">Struct</span>.m<span class="constructor">DrawGlStatus</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> 需要重新排序</span></span><br><span class="line"><span class="pattern-match">        <span class="built_in">bool</span> avoid<span class="constructor">Overdraw</span> = !m<span class="constructor">Caches</span>.debug<span class="constructor">Overdraw</span> <span class="operator">&amp;&amp;</span> !m<span class="constructor">CountOverdraw</span>; <span class="operator">/</span><span class="operator">/</span> shh, don't tell devs!</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">DeferredDisplayList</span> deferred<span class="constructor">List(<span class="operator">*</span><span class="params">currentClipRect</span>()</span>, avoid<span class="constructor">Overdraw</span>);</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">DeferStateStruct</span> defer<span class="constructor">Struct(<span class="params">deferredList</span>, <span class="operator">*</span><span class="params">this</span>, <span class="params">replayFlags</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        render<span class="constructor">Node</span>-&gt;defer(defer<span class="constructor">Struct</span>, 0); <span class="operator">/</span><span class="operator">/</span>递归进行重排操作</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">        flush<span class="constructor">Layers()</span>; <span class="operator">/</span><span class="operator">/</span> 首先执行设置了 <span class="constructor">Layer</span> 的子 <span class="constructor">Render</span> <span class="constructor">Node</span> 的绘制命令，以便得到一个对应的<span class="constructor">FBO</span></span></span><br><span class="line"><span class="pattern-match">        status = start<span class="constructor">Frame()</span>; <span class="operator">/</span><span class="operator">/</span>执行一些诸如清理颜色绘冲区等基本操作</span></span><br><span class="line"><span class="pattern-match">        status = deferred<span class="constructor">List</span>.flush(<span class="operator">*</span>this, dirty) | status;</span></span><br><span class="line"><span class="pattern-match">        return status;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> <span class="constructor">Even</span> <span class="keyword">if</span> there is no drawing command(<span class="constructor">Ex</span>: invisible),</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> it still needs start<span class="constructor">Frame</span> <span class="keyword">to</span> clear buffer <span class="keyword">and</span> start tiling.</span></span><br><span class="line"><span class="pattern-match">    return start<span class="constructor">Frame()</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>这里的 renderNode 是一个 Root Render Node，</p><p>可以看到，到了这里虽然只是开始，但是其实已经结束了，这个函数里面最重要的几步:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renderNode-&gt;defer(deferStruct, <span class="number">0</span>); <span class="comment">//进行重排序</span></span><br><span class="line"></span><br><span class="line">flushLayers(); 首先执行设置了 Layer 的子 Render Node 的绘制命令，以便得到一个对应的FBO</span><br><span class="line"></span><br><span class="line">status = deferredList.flush(*<span class="keyword">this</span>, dirty) | status;   <span class="comment">//对deferredList中的绘制命令进行真正的绘制操作</span></span><br></pre></td></tr></table></figure><p>这几个是渲染部分真正的核心部分，其中的代码细节需要自己去研究。老罗在这部分讲的很细，有空可以去看看他的文章<a href="http://blog.csdn.net/Luoshengyang/article/details/46281499" target="_blank" rel="noopener"><a href="http://blog.csdn.net/luoshengyang/article/details/46281499" target="_blank" rel="noopener">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></a>.</p><h4 id="2-4-swapBuffers"><a href="#2-4-swapBuffers" class="headerlink" title="2.4 swapBuffers"></a>2.4 swapBuffers</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (status &amp; <span class="attribute">DrawGlInfo</span>::kStatusDrew) &#123;</span><br><span class="line">    <span class="selector-tag">swapBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其核心就是调用EGL的 eglSwapBuffers(mEglDisplay, surface), duration)函数。</p><h4 id="2-5-FinishFrame"><a href="#2-5-FinishFrame" class="headerlink" title="2.5  FinishFrame"></a>2.5  FinishFrame</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">profiler</span>()<span class="selector-class">.finishFrame</span>();</span><br></pre></td></tr></table></figure><p>主要是记录时间信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>鉴于我比较懒，而且总结能力不如老罗，就直接把他的总结贴过来了。<br>RenderThread的总的流程如下：</p><blockquote><ol><li>将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。</li></ol></blockquote><blockquote><ol start="2"><li>如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。</li></ol></blockquote><blockquote><ol start="3"><li>Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。</li></ol></blockquote><blockquote><p>第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。</p></blockquote><p>注意最后一段，在 Android 4.x 时代，没有RenderThread的时代，只有 Main Thread ，也就是说 必须要等到 Draw 完成后，才会去准备下一帧的数据，如下图：</p><p><img src="/images/hwui/renderthread/5.png" alt="Paste_Image.png"></p><p>Android5.0 之后，如老罗所说，有两种情况，</p><p><img src="/images/hwui/renderthread/6.png" alt="Main Thread 和 Render Thread"></p><p><img src="/images/hwui/renderthread/7.png" alt="Render Thread 提前唤醒了 Main Thread"></p><p>可以看到第二张图中，Render Thread 并没有绘制完成，但是由于其提前唤醒了 Main Thread ，所以 Main Thread 在下一个Vsync信号到来的时候，响应了Vsync事件，开始准备下一帧。<br>此时虽然由于第一帧绘制时间过长，导致掉了一帧，但是第二帧没有收到任何影响。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> hwui </tag>
            
            <tag> RenderThread </tag>
            
            <tag> Menory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java7 HashMap 源码分析</title>
      <link href="/2015/08/05/HashMap/"/>
      <url>/2015/08/05/HashMap/</url>
      
        <content type="html"><![CDATA[<p>链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）.</p><p>HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><a id="more"></a><h3 id="1-HashMap的数据结构："><a href="#1-HashMap的数据结构：" class="headerlink" title="1. HashMap的数据结构："></a>1. HashMap的数据结构：</h3><p>HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</p><p><img src="/images/hashMapSourceAnalysis/hs.20150729.01.jpg" alt="enter image description here"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>Entry是HashMap中的一个内部静态类，包级私有，实现了Map中的接口Entey&lt;K,V&gt;。可以看出来它内部含有一个指向下一个元素的指针。</p><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h3><p>HashMap的构造函数有四个：</p><ol><li>HashMap() — 构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。 </li><li>HashMap(int initialCapacity)  — 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。 </li><li>HashMap(int initialCapacity, float loadFactor) — 构造一个带指定初始容量和加载因子的空 HashMap。 </li><li>HashMap(Map&lt;? extends K,? extends V&gt; m) — 构造一个映射关系与指定 Map 相同的新 HashMap</li></ol><p>实际上就两种，一个是指定初始容量和加载因子，一个是用一个给定的映射关系生成一个新的HashMap。说一下第一种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap &lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and load factor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">    *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float. isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">       <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">           capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       useAltHashing = sun.misc.VM. isBooted() &amp;&amp;</span><br><span class="line">               (capacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>参数很简单，初始容量，和加载因子。初始容量定义了初识数组的大小，加载因子和初始容量的乘积确定了一个阈值。阈值最大是(1&lt;&lt;30) + 1。初始容量一定是2的N次方，而且刚刚比要设置的值大。默认初始容量是16，默认加载因子是0.75。当表中的元素数量大于等于阈值时，数组的容量会翻倍，并重新插入元素到新的数组中，所以HashMap不保证顺序恒久不变。</p><p>当输入的加载因子小于零或者不是浮点数时会抛出异常（IllegalArgumentException）。</p><h3 id="3-put操作"><a href="#3-put操作" class="headerlink" title="3.put操作"></a>3.put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">    * value is replaced.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key &lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null &lt;/tt&gt; if there was no mapping for &lt;tt&gt; key&lt;/tt&gt; .</span></span><br><span class="line"><span class="comment">    *         (A &lt;tt&gt;null &lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">    *         previously associated &lt;tt&gt;null &lt;/tt&gt; with &lt;tt&gt; key&lt;/tt&gt; .)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table .length );</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e. value;</span><br><span class="line">               e. value = value;</span><br><span class="line">               e.recordAccess( <span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由于HashMap只是key值为null，所以首先要判断key值是不是为null，是则进行特殊处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Offloaded version of put for null keys</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e. key == <span class="keyword">null</span>) &#123;</span><br><span class="line">               V oldValue = e. value;</span><br><span class="line">               e. value = value;</span><br><span class="line">               e.recordAccess( <span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看出key值为null则会插入到数组的第一个位置。如果第一个位置存在，则替代，不存在则添加一个新的。稍后会看到addEntry函数。</p><p>** PS：考虑一个问题，key值为null会插入到table[0]，那为什么还要遍历整个链表呢？**</p><p>回到put函数中。在判断key不为null后，会求key的hash值，并通过indexFor函数找出这个key应该存在table中的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span> <span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>indexFor函数很简短，但是却实现的很巧妙。一般来说我们把一个数映射到一个固定的长度会用取余（%）运算，也就是h % length，但里巧妙地运用了table.length的特性。还记得前面说了数组的容量都是很特殊的数，是2的N次方。用二进制表示也就是一个1后面N个0，（length-1）就是N个1了。这里直接用与运算，运算速度快，效率高。但是这是是利用了length的特殊性，如果length不是2的N次方的话可能会增加冲突。</p><p>前面的问题在这里就有答案了。因为indexFor函数返回值的范围是0到（length-1），所以可能会有key值不是null的Entry存到table[0]中，所以前面还是需要遍历链表的。</p><p>得到key值对应在table中的位置，就可以对链表进行遍历，如果存在该key则，替换value，并把旧的value返回，modCount++代表操作数加1。这个属性用于Fail-Fast机制，后面讲到。如果遍历链表后发现key不存在，则要插入一个新的Entry到链表中。这时就会调用addEntry函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment"> * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment"> * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span> <span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; ( <span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table. length);</span><br><span class="line">        hash = ( <span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有四个参数，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置，也就是indexFor(hash(key), table.length-1)。首先会判断size（当前表中的元素个数）是不是大于或等于阈值。并且判断数组这个位置是不是空。如果条件满足则要resize(2 * table. length)，等下我们来看这个操作。超过阈值要resize是为了减少冲突，提高访问效率。判断当前位置不是空时才resize是为了尽可能减少resize次数，因为这个位置是空，放一个元素在这也没有冲突，所以不影响效率，就先不进行resize了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment"> * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment"> * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment"> * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment"> *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment"> *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment"> *        is irrelevant).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable. length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer. MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">    useAltHashing |= sun.misc.VM. isBooted() &amp;&amp;</span><br><span class="line">            (newCapacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor , MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resize操作先要判断当前table的长度是不是已经等于最大容量（1&lt;&lt;30）了，如果是则把阈值调到整数的最大值（(1&lt;&lt;31) - 1），就没有再拓展table的必要了。如果没有到达最大容量，就要生成一个新的空数组，长度是原来的两倍。这时候可能要问了，如果oldTable. length不等于MAXIMUM_CAPACITY，但是（2 * oldTable. length）也就是newCapacity大于MAXIMUM_CAPACITY怎么办？这个是不可能的，因为数组长度是2的N次方，而MAXIMUM_CAPACITY = 1&lt;&lt;30。<br>生成新的数组后要执行transfer函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable. length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e. next;</span><br><span class="line">            <span class="keyword">if</span> ( rehash) &#123;</span><br><span class="line">                e. hash = <span class="keyword">null</span> == e. key ? <span class="number">0</span> : hash(e. key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e. next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数要做的就是把原来table中的值挨个拿出来插到新数组中，由于数组长度发生了改变，所以元素的位置肯定发生变化，所以HashMap不能保证该顺序恒久不变。回到resize函数，这时新的数组已经生成了，只需要替换原来数组就好了。并且要更新一下阈值。可以看出来resize是个比较消耗资源的函数，所以能减少resize的次数就尽量减少。</p><p>回到函数addEntry 中，判断完是不是需要resize后就需要创建一个新的Entry了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like addEntry except that this version is used when creating entries</span></span><br><span class="line"><span class="comment"> * as part of Map construction or "pseudo -construction" (cloning,</span></span><br><span class="line"><span class="comment"> * deserialization).  This version needn't worry about resizing the table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of HashMap(Map),</span></span><br><span class="line"><span class="comment"> * clone, and readObject.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">( <span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用createEntry函数，参数跟addEntry一样，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置。这里的操作与Entry的构造函数有关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates new entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Entry (<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中传入一个Entry对象，并把它当做这个新生成的Entry的next。所以createEntry函数中的操作相当于把table[bucketIndex]上的链表拿下来，放在新的Entry后面，然后再把新的Entry放到table[bucketIndex]上。</p><p><img src="/images/hashMapSourceAnalysis/hs.20150729.02.jpg" alt="enter image description here"></p><p>到这里整个put函数算是结束了。如果新插入的K，V则会返回null。</p><h3 id="4-get操作"><a href="#4-get操作" class="headerlink" title="4.get操作"></a>4.get操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily &lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是先判断key是不是null，做特殊处理。直接上代码，不赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Offloaded version of get() to look up null keys.  Null keys map</span></span><br><span class="line"><span class="comment"> * to index 0.  This null case is split out into separate methods</span></span><br><span class="line"><span class="comment"> * for the sake of performance in the two most commonly used</span></span><br><span class="line"><span class="comment"> * operations (get and put), but incorporated with conditionals in</span></span><br><span class="line"><span class="comment"> * others.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e. key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e. value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key不是null则会调用getEntry函数，并返回一个Entry对象，如果不是null，就返回entry的value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the entry associated with the specified key in the</span></span><br><span class="line"><span class="comment"> * HashMap.  Returns null if the HashMap contains no mapping</span></span><br><span class="line"><span class="comment"> * for the key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[ indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e. next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e. hash == hash &amp;&amp;</span><br><span class="line">            ((k = e. key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接求key值hash值，然后求table中的位置，遍历链表。有返回entry对象，没有返回null。</p><h3 id="5-Fail-Fast机制"><a href="#5-Fail-Fast机制" class="headerlink" title="5. Fail-Fast机制"></a>5. Fail-Fast机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail -fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p><p>这一策略在源码中的实现是通过modCount域，保证线程之间修改的可见性。，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p><p><strong>注意</strong>，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《Core JAVA》</li><li>《JAVA API》</li></ul><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 代码内存优化建议 - OnTrimMemory 优化</title>
      <link href="/2015/07/20/Android-Performance-Memory-onTrimMemory/"/>
      <url>/2015/07/20/Android-Performance-Memory-onTrimMemory/</url>
      
        <content type="html"><![CDATA[<p>Android 内存优化系列文章：</p><ol><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Google/" target="_blank" rel="noopener">Android代码内存优化建议-Android官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Java/" target="_blank" rel="noopener">Android代码内存优化建议-Java官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource/" target="_blank" rel="noopener">Android代码内存优化建议-Android资源篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory/" target="_blank" rel="noopener">Android代码内存优化建议-OnTrimMemory优化</a></li></ol><hr><p>OnTrimMemory 回调是 Android 4.0 之后提供的一个API，这个 API 是提供给开发者的，它的主要作用是提示开发者在系统内存不足的时候，通过处理部分资源来释放内存，从而避免被 Android 系统杀死。这样应用在下一次启动的时候，速度就会比较快。</p><p>本文通过问答的方式，从各个方面来讲解 OnTrimMemory 回调的使用过程和效果。想要开发高性能且用户体验良好的 Android 应用，那么这篇文章你不应该错过。</p><a id="more"></a><h2 id="0-OnTrimMemory回调的作用？"><a href="#0-OnTrimMemory回调的作用？" class="headerlink" title="0. OnTrimMemory回调的作用？"></a>0. OnTrimMemory回调的作用？</h2><p>OnTrimMemory是Android在4.0之后加入的一个回调，任何实现了ComponentCallbacks2接口的类都可以重写实现这个回调方法．OnTrimMemory的主要作用就是<strong>指导应用程序在不同的情况下进行自身的内存释放，以避免被系统直接杀掉，提高应用程序的用户体验.</strong></p><p>Android系统会根据不同等级的内存使用情况，调用这个函数，并传入对应的等级：</p><ul><li>TRIM_MEMORY_UI_HIDDEN 表示应用程序的<strong>所有UI界面</strong>被隐藏了，即用户点击了Home键或者Back键导致应用的UI界面不可见．这时候应该释放一些资源．<br>TRIM_MEMORY_UI_HIDDEN这个等级比较常用，和下面六个的关系不是很强，所以单独说．</li></ul><p>下面三个等级是当我们的应用程序真正运行时的回调：</p><ul><li>TRIM_MEMORY_RUNNING_MODERATE    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。</li><li>TRIM_MEMORY_RUNNING_LOW    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。</li><li>TRIM_MEMORY_RUNNING_CRITICAL    表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</li></ul><p>当应用程序是缓存的，则会收到以下几种类型的回调：</p><ul><li>TRIM_MEMORY_BACKGROUND    表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。</li><li>TRIM_MEMORY_MODERATE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。</li><li>TRIM_MEMORY_COMPLETE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。</li></ul><h2 id="1-哪些组件可以实现OnTrimMemory回调？"><a href="#1-哪些组件可以实现OnTrimMemory回调？" class="headerlink" title="1. 哪些组件可以实现OnTrimMemory回调？"></a>1. 哪些组件可以实现OnTrimMemory回调？</h2><ul><li>Application.onTrimMemory()</li><li>Activity.onTrimMemory()</li><li>Fragment.OnTrimMemory()</li><li>Service.onTrimMemory()</li><li>ContentProvider.OnTrimMemory()</li></ul><h2 id="2-OnTrimMemory回调中可以释放哪些资源？"><a href="#2-OnTrimMemory回调中可以释放哪些资源？" class="headerlink" title="2. OnTrimMemory回调中可以释放哪些资源？"></a>2. OnTrimMemory回调中可以释放哪些资源？</h2><p>通常在架构阶段就要考虑清楚，我们有哪些东西是要常驻内存的，有哪些是伴随界面存在的．一般情况下，有下面几种资源需要进行释放：</p><ul><li>缓存  缓存包括一些文件缓存，图片缓存等，在用户正常使用的时候这些缓存很有作用，但当你的应用程序UI不可见的时候，这些缓存就可以被清除以减少内存的使用．比如第三方图片库的缓存．</li><li>一些动态生成动态添加的View．　这些动态生成和添加的View且少数情况下才使用到的View，这时候可以被释放，下次使用的时候再进行动态生成即可．比如原生桌面中，会在OnTrimMemory的TRIM_MEMORY_MODERATE等级中，释放所有AppsCustomizePagedView的资源，来保证在低内存的时候，桌面不会轻易被杀掉．</li></ul><h4 id="2-1-例子：释放不常用到的View．"><a href="#2-1-例子：释放不常用到的View．" class="headerlink" title="2.1 例子：释放不常用到的View．"></a>2.1 例子：释放不常用到的View．</h4><p>代码出处：Launcher</p><p>Launcher.java:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onTrimMemory(level);</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) &#123;</span><br><span class="line">        mAppsCustomizeTabHost.onTrimMemory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppsCustomizeTabHost.java:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mContent.setVisibility(GONE);</span><br><span class="line">    <span class="comment">// Clear the widget pages of all their subviews - this will trigger the widget previews</span></span><br><span class="line">    <span class="comment">// to delete their bitmaps</span></span><br><span class="line">    mPagedView.clearAllWidgetPages();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppsCustomizePagedView.java:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void clear<span class="constructor">AllWidgetPages()</span> &#123;</span><br><span class="line">    cancel<span class="constructor">AllTasks()</span>;</span><br><span class="line">    <span class="built_in">int</span> count = get<span class="constructor">ChildCount()</span>;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View v = get<span class="constructor">PageAt(<span class="params">i</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (v instanceof PagedViewGridLayout) &#123;</span><br><span class="line">            ((PagedViewGridLayout) v).remove<span class="constructor">AllViewsOnPage()</span>;</span><br><span class="line">            mDirtyPageContent.set(i, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PagedViewGridLayout.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">removeAllViewsOnPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeAllViews();</span><br><span class="line">    mOnLayoutListener = <span class="keyword">null</span>;</span><br><span class="line">    setLayerType(LAYER_TYPE_NONE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-例子-清除缓存"><a href="#2-2-例子-清除缓存" class="headerlink" title="2.2 例子: 清除缓存"></a>2.2 例子: 清除缓存</h4><p>代码出处：Contact</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) &#123;</span><br><span class="line">        <span class="comment">// Clear the caches.  Note all pending requests will be removed too.</span></span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mPendingRequests.<span class="built_in">clear</span>();</span><br><span class="line">    mBitmapHolderCache.evictAll();</span><br><span class="line">    mBitmapCache.evictAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-OnTrimMemory和onStop的关系？"><a href="#3-OnTrimMemory和onStop的关系？" class="headerlink" title="3. OnTrimMemory和onStop的关系？"></a>3. OnTrimMemory和onStop的关系？</h2><p>onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。</p><p>因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p><p>需要注意的是，onTrimMemory的TRIM_MEMORY_UI_HIDDEN 等级是在onStop方法之前调用的．</p><h2 id="4-OnTrimMemory和OnLowMemory的关系？"><a href="#4-OnTrimMemory和OnLowMemory的关系？" class="headerlink" title="4. OnTrimMemory和OnLowMemory的关系？"></a>4. OnTrimMemory和OnLowMemory的关系？</h2><p>在引入OnTrimMemory之前都是使用OnLowMemory回调，需要知道的是，OnLowMemory大概和OnTrimMemory中的TRIM_MEMORY_COMPLETE级别相同，如果你想兼容api&lt;14的机器，那么可以用OnLowMemory来实现，否则你可以忽略OnLowMemory，直接使用OnTrimMemory即可．</p><h2 id="5-为什么要调用OnTrimMemory？"><a href="#5-为什么要调用OnTrimMemory？" class="headerlink" title="5. 为什么要调用OnTrimMemory？"></a>5. 为什么要调用OnTrimMemory？</h2><p>尽管系统在内存不足的时候杀进程的顺序是按照LRU Cache中从低到高来的，但是它同时也会考虑杀掉那些占用内存较高的应用来让系统更快地获得更多的内存。</p><p>所以如果你的应用占用内存较小，就可以增加不被杀掉的几率，从而快速地恢复（如果不被杀掉，启动的时候就是热启动，否则就是冷启动，其速度差在2~3倍）。</p><p>所以说在几个不同的OnTrimMemory回调中释放自己的UI资源，可以有效地提高用户体验。</p><h2 id="6-有哪些典型的使用场景？"><a href="#6-有哪些典型的使用场景？" class="headerlink" title="6. 有哪些典型的使用场景？"></a>6. 有哪些典型的使用场景？</h2><h3 id="6-1-常驻内存的应用"><a href="#6-1-常驻内存的应用" class="headerlink" title="6.1 常驻内存的应用"></a>6.1 常驻内存的应用</h3><p>一些常驻内存的应用，比如Launcher、安全中心、电话等，在用户使用过要退出的时候，需要调用OnTrimMemory来及时释放用户使用的时候所产生的多余的内存资源：比如动态生成的View、图片缓存、Fragment等。</p><h3 id="6-2-有后台Service运行的应用"><a href="#6-2-有后台Service运行的应用" class="headerlink" title="6.2 有后台Service运行的应用"></a>6.2 有后台Service运行的应用</h3><p>这些应用不是常驻内存的，意味着可以被任务管理器杀掉，但是在某些场景下用户不会去杀。<br>这类应用包括：音乐、下载等。用户退出UI界面后，音乐还在继续播放，下载程序还在运行。这时候音乐应该释放部分UI资源和Cache。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Memory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 代码内存优化建议 - Android 资源篇</title>
      <link href="/2015/07/20/Android-Performance-Memory-AndroidResource/"/>
      <url>/2015/07/20/Android-Performance-Memory-AndroidResource/</url>
      
        <content type="html"><![CDATA[<p>Android 内存优化系列文章：</p><ol><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Google/" target="_blank" rel="noopener">Android代码内存优化建议-Android官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Java/" target="_blank" rel="noopener">Android代码内存优化建议-Java官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource/" target="_blank" rel="noopener">Android代码内存优化建议-Android资源篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory/" target="_blank" rel="noopener">Android代码内存优化建议-OnTrimMemory优化</a></li></ol><hr><p>这篇文章主要介绍在实际Android应用程序的开发中，容易导致内存泄露的一些情况。开发人员如果在进行代码编写之前就有内存泄露方面的基础知识，那么写出来的代码会强壮许多，写这篇文章也是这个初衷。本文从Android开发中的资源使用情况入手，介绍了如何在Bitmap、数据库查询、9-patch、过渡绘制等方面优化内存的使用。</p><a id="more"></a><h1 id="Android资源优化"><a href="#Android资源优化" class="headerlink" title="Android资源优化"></a>Android资源优化</h1><h2 id="1-Bitmap优化"><a href="#1-Bitmap优化" class="headerlink" title="1. Bitmap优化"></a>1. Bitmap优化</h2><p>Android中的大部分内存问题归根结底都是Bitmap的问题，如果打开MAT(Memory analyzer tool)来看，实际占用内存大的都是一些Bitmap(以byte数组的形式存储)。所以Bitmap的优化应该是我们着重去解决的。Google在其官方有针对Bitmap的使用专门写了一个专题 : <a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="noopener">Displaying Bitmaps Efficiently</a>, 对应的中文翻译在 ：<a href="https://github.com/kesenhoo/android-training-course-in-chinese/tree/master/graphics/displaying-bitmaps" target="_blank" rel="noopener">displaying-bitmaps</a> , 在优化Bitmap资源之前，请先看看这个系列的文档，以确保自己正确地使用了Bitmap。</p><p>Bitmap如果没有被释放，那么一般只有两个问题：</p><ul><li>用户在使用完这个Bitmap之后，没有主动去释放Bitmap资源。</li><li>这个Bitmap资源被引用所以无法被释放 。</li></ul><h3 id="1-1-主动释放Bitmap资源"><a href="#1-1-主动释放Bitmap资源" class="headerlink" title="1.1 主动释放Bitmap资源"></a>1.1 主动释放Bitmap资源</h3><p>当你确定这个Bitmap资源不会再被使用的时候(当然这个Bitmap不释放可能会让程序下一次启动或者resume快一些，但是其占用的内存资源太大，可能导致程序在后台的时候被杀掉，反而得不偿失)，我们建议手动调用recycle()方法，释放其Native内存：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="keyword">bitmap </span>!= null &amp;&amp; !<span class="keyword">bitmap.isRecycled())&#123; </span> </span><br><span class="line">    <span class="keyword">bitmap.recycle(); </span></span><br><span class="line">    <span class="keyword">bitmap </span>= null<span class="comment">; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以看一下Bitmap.java中recycle()方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Free the native object associated with this bitmap, and clear the</span></span><br><span class="line"><span class="comment">     * reference to the pixel data. This will not free the pixel data synchronously;</span></span><br><span class="line"><span class="comment">     * it simply allows it to be garbage collected if there are no other references.</span></span><br><span class="line"><span class="comment">     * The bitmap is marked as "dead", meaning it will throw an exception if</span></span><br><span class="line"><span class="comment">     * getPixels() or setPixels() is called, and will draw nothing. This operation</span></span><br><span class="line"><span class="comment">     * cannot be reversed, so it should only be called if you are sure there are no</span></span><br><span class="line"><span class="comment">     * further uses for the bitmap. This is an advanced call, and normally need</span></span><br><span class="line"><span class="comment">     * not be called, since the normal GC process will free up this memory when</span></span><br><span class="line"><span class="comment">     * there are no more references to this bitmap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRecycled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nativeRecycle(mNativeBitmap)) &#123;</span><br><span class="line">                <span class="comment">// return value indicates whether native pixel object was actually recycled.</span></span><br><span class="line">                <span class="comment">// false indicates that it is still in use at the native level and these</span></span><br><span class="line">                <span class="comment">// objects should not be collected now. They will be collected later when the</span></span><br><span class="line">                <span class="comment">// Bitmap itself is collected.</span></span><br><span class="line">                mBuffer = <span class="keyword">null</span>;</span><br><span class="line">                mNinePatchChunk = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRecycled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果使用过程中抛出异常的判断</span></span><br><span class="line"><span class="keyword">if</span> (bitmap.isRecycled()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Canvas: trying to use a recycled bitmap "</span> + bitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用bitmap.recycle之后，这个Bitmap如果没有被引用到，那么就会被垃圾回收器回收。如果不主动调用这个方法，垃圾回收器也会进行回收工作，只不过垃圾回收器的不确定性太大，依赖其自动回收不靠谱(比如垃圾回收器一次性要回收好多Bitmap，那么需要的时间就会很多，导致回收的时候会卡顿)。所以我们需要主动调用recycle。</p><h3 id="1-2-主动释放ImageView的图片资源"><a href="#1-2-主动释放ImageView的图片资源" class="headerlink" title="1.2 主动释放ImageView的图片资源"></a>1.2 主动释放ImageView的图片资源</h3><p>由于我们在实际开发中，很多情况是在xml布局文件中设置ImageView的src或者在代码中调用ImageView.setImageResource/setImageURI/setImageDrawable等方法设置图像，下面代码可以回收这个ImageView所对应的资源：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">private</span> static void recycleImageViewBitMap(ImageView imageView) &#123;</span><br><span class="line">    <span class="meta">if</span> (imageView != null) &#123;</span><br><span class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>imageView.getDrawable()<span class="comment">;</span></span><br><span class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">private</span> static void rceycleBitmapDrawable(<span class="keyword">BitmapDrawable </span><span class="keyword">bitmapDrawable) </span>&#123;</span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bitmapDrawable </span>!= null) &#123;</span><br><span class="line">        <span class="keyword">Bitmap </span><span class="keyword">bitmap </span>= <span class="keyword">bitmapDrawable.getBitmap();</span></span><br><span class="line"><span class="keyword"> </span>       rceycleBitmap(<span class="keyword">bitmap);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    <span class="keyword">bitmapDrawable </span>= null<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">private</span> static void rceycleBitmap(<span class="keyword">Bitmap </span><span class="keyword">bitmap) </span>&#123;</span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bitmap </span>!= null &amp;&amp; !<span class="keyword">bitmap.isRecycled()) </span>&#123;</span><br><span class="line">        <span class="keyword">bitmap.recycle();</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">bitmap </span>= null<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-主动释放ImageView的背景资源"><a href="#1-3-主动释放ImageView的背景资源" class="headerlink" title="1.3 主动释放ImageView的背景资源"></a>1.3 主动释放ImageView的背景资源</h3><p>如果你的ImageView是有Background，那么下面的代码可以释放他：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> static void recycleBackgroundBitMap(ImageView view) &#123;</span><br><span class="line">    <span class="meta">if</span> (view != null) &#123;</span><br><span class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>view.getBackground()<span class="comment">;</span></span><br><span class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">public</span> static void recycleImageViewBitMap(ImageView imageView) &#123;</span><br><span class="line">    <span class="meta">if</span> (imageView != null) &#123;</span><br><span class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>imageView.getDrawable()<span class="comment">;</span></span><br><span class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">private</span> static void rceycleBitmapDrawable(<span class="keyword">BitmapDrawable </span><span class="keyword">bitmapDrawable) </span>&#123;</span><br><span class="line">    <span class="meta">if</span> (<span class="keyword">bitmapDrawable </span>!= null) &#123;</span><br><span class="line">        <span class="keyword">Bitmap </span><span class="keyword">bitmap </span>= <span class="keyword">bitmapDrawable.getBitmap();</span></span><br><span class="line"><span class="keyword"> </span>       rceycleBitmap(<span class="keyword">bitmap);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    <span class="keyword">bitmapDrawable </span>= null<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-尽量少用Png图，多用NinePatch的图"><a href="#1-4-尽量少用Png图，多用NinePatch的图" class="headerlink" title="1.4 尽量少用Png图，多用NinePatch的图"></a>1.4 尽量少用Png图，多用NinePatch的图</h3><p>现在手机的分辨率越来越高，图片资源在被加载后所占用的内存也越来越大，所以要尽量避免使用大的PNG图，在产品设计的时候就要尽量避免用一张大图来进行展示，尽量多用NinePatch资源。</p><p>Android中的NinePatch指的是一种拉伸后不会变形的特殊png图，NinePatch的拉伸区域可以自己定义。这种图的优点是体积小，拉伸不变形，可以适配多机型。Android SDK中有自带NinePatch资源制作工具，Android-Studio中在普通png图片点击右键可以将其转换为NinePatch资源，使用起来非常方便。</p><p><img src="/images/Memory_AndroidSoruce/1.png" alt="左边是原图，右边是拉伸后的效果"></p><h3 id="1-5-使用大图之前，尽量先对其进行压缩"><a href="#1-5-使用大图之前，尽量先对其进行压缩" class="headerlink" title="1.5 使用大图之前，尽量先对其进行压缩"></a>1.5 使用大图之前，尽量先对其进行压缩</h3><p>图片有不同的形状与大小。在大多数情况下它们的实际大小都比需要呈现出来的要大很多。例如，系统的Gallery程序会显示那些你使用设备camera拍摄的图片，但是那些图片的分辨率通常都比你的设备屏幕分辨率要高很多。</p><p>考虑到程序是在有限的内存下工作，理想情况是你只需要在内存中加载一个低分辨率的版本即可。这个低分辨率的版本应该是与你的UI大小所匹配的，这样才便于显示。一个高分辨率的图片不会提供任何可见的好处，却会占用宝贵的(precious)的内存资源，并且会在快速滑动图片时导致(incurs)附加的效率问题。</p><p>Google官网的Training中，有一篇文章专门介绍如何有效地加载大图，里面提到了两个比较重要的技术：</p><ul><li>在图片加载前获取其宽高和类型</li><li>加载一个按比例缩小的版本到内存中</li></ul><p>原文地址：<a href="http://developer.android.com/training/displaying-bitmaps/load-bitmap.html#read-bitmap" target="_blank" rel="noopener">Loading Large Bitmaps Efficiently</a>,中文翻译地址：<a href="https://github.com/kesenhoo/android-training-course-in-chinese/blob/master/graphics/displaying-bitmaps/load-bitmap.md" target="_blank" rel="noopener">有效地加载大尺寸位图</a>，强烈建议每一位Android开发者都去看一下，并在自己的实际项目中使用到。</p><p>更多关于Bitmap的使用和优化，可以参考Android官方Training专题的<a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="noopener">displaying-bitmaps</a></p><h2 id="2-查询数据库没有关闭游标"><a href="#2-查询数据库没有关闭游标" class="headerlink" title="2 查询数据库没有关闭游标"></a>2 查询数据库没有关闭游标</h2><p>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。<br>示例代码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = getContentResolver<span class="params">()</span><span class="string">.query</span><span class="params">(uri ...)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(cursor.moveToNext()</span>) &#123;</span><br><span class="line"> <span class="string">...</span> <span class="string">...</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修正示例代码:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cursor <span class="built_in">cursor</span> = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">cursor</span> = getContentResolver().query(uri ...);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">cursor</span>.moveToNext()) &#123;</span><br><span class="line">... ... </span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="built_in">cursor</span>.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//ignore this</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`</p><h2 id="3-构造Adapter时，没有使用缓存的convertView"><a href="#3-构造Adapter时，没有使用缓存的convertView" class="headerlink" title="3 构造Adapter时，没有使用缓存的convertView"></a>3 构造Adapter时，没有使用缓存的convertView</h2><p>以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public View get<span class="constructor">View(<span class="params">int</span> <span class="params">position</span>, View <span class="params">convertView</span>, ViewGroup <span class="params">parent</span>)</span></span><br></pre></td></tr></table></figure><p>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。ListView回收list item的view对象的过程可以查看:android.widget.AbsListView.java –&gt; void addScrapView(View scrap) 方法。</p><p><img src="/images/Memory_AndroidSoruce/2.png" alt="ListView的getView"></p><p>示例代码：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">View</span> getView(int position, <span class="keyword">View</span> convertView, ViewGroup parent) &#123;</span><br><span class="line"> <span class="keyword">View</span> <span class="keyword">view</span> = <span class="keyword">new</span> Xxx(...)<span class="comment">;</span></span><br><span class="line"> ... ...</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">view</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`<br>示例修正代码：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="meta">View</span> getView(int position, <span class="meta">View</span> convertView, ViewGroup parent) &#123;</span><br><span class="line"> <span class="meta">View</span> <span class="meta">view</span> = <span class="meta">null</span>;</span><br><span class="line"> <span class="meta">if</span> (convertView != <span class="meta">null</span>) &#123;</span><br><span class="line"> <span class="meta">view</span> = convertView;</span><br><span class="line"> populate(<span class="meta">view</span>, getItem(position));</span><br><span class="line"> ...</span><br><span class="line"> &#125; <span class="meta">else</span> &#123;</span><br><span class="line"> <span class="meta">view</span> = new Xxx(...);</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">return</span> <span class="meta">view</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ListView的使用和优化，可以参考这两篇文章：</p><ul><li><a href="http://www.vogella.com/tutorials/AndroidListView/article.html" target="_blank" rel="noopener">Using lists in Android (ListView) - Tutorial  </a></li><li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="noopener">Making ListView Scrolling Smooth</a></li></ul><h2 id="4-释放对象的引用"><a href="#4-释放对象的引用" class="headerlink" title="4 释放对象的引用"></a>4 释放对象的引用</h2><p>前面有说过，一个对象的内存没有被释放是因为他被其他的对象所引用，系统不回去释放这些有GC Root的对象。</p><p>示例A：<br>假设有如下操作</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">private</span> <span class="type">Handler</span> mHandler = ...</span><br><span class="line"><span class="keyword">private</span> <span class="type">Object</span> obj;</span><br><span class="line">public void operation() &#123;</span><br><span class="line"> obj = initObj();</span><br><span class="line"> ...</span><br><span class="line"> [<span class="type">Mark</span>]</span><br><span class="line"> mHandler.post(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">         useObj(obj);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个成员变量 obj，在operation()中我们希望能够将处理obj实例的操作post到某个线程的MessageQueue中。在以上的代码中，即便是mHandler所在的线程使用完了obj所引用的对象，但这个对象仍然不会被垃圾回收掉，因为DemoActivity.obj还保有这个对象的引用。所以如果在DemoActivity中不再使用这个对象了，可以在[Mark]的位置释放对象的引用，而代码可以修改为：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">obj = initObj();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> Object o = obj;</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useObj(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例B：<br>假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。  </p><p>但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_ui进程挂掉。</p><p>总之当一个生命周期较短的对象A，被一个生命周期较长的对象B保有其引用的情况下，在A的生命周期结束时，要在B中清除掉对A的引用。</p><p>使用MAT可以很方便地查看对象之间的引用，</p><h2 id="5-在Activity的生命周期中释放资源"><a href="#5-在Activity的生命周期中释放资源" class="headerlink" title="5 在Activity的生命周期中释放资源"></a>5 在Activity的生命周期中释放资源</h2><p>Android应用程序中最典型的需要注意释放资源的情况是在Activity的生命周期中，在onPause()、onStop()、onDestroy()方法中需要适当的释放资源的情况。由于此情况很基础，在此不详细说明，具体可以查看官方文档对Activity生命周期的介绍，以明确何时应该释放哪些资源。</p><h2 id="6-消除过渡绘制"><a href="#6-消除过渡绘制" class="headerlink" title="6 消除过渡绘制"></a>6 消除过渡绘制</h2><p>过渡绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p><p>过渡绘制的原因:</p><ol><li>同一层级的View叠加</li><li>复杂的层级叠加</li></ol><p>减少过渡绘制能去掉一些无用的View，能有效减少GPU的负载，也可以减轻一部分内存压力。关于过渡绘制我专门写了一篇文章来介绍：<a href="https://www.androidperformance.com/android-performance-optimization-overdraw-1.html" target="_blank" rel="noopener">过渡绘制及其优化</a></p><h2 id="7-使用Android系统自带的资源"><a href="#7-使用Android系统自带的资源" class="headerlink" title="7 使用Android系统自带的资源"></a>7 使用Android系统自带的资源</h2><p>在Android应用开发过程中，屏幕上控件的布局代码和程序的逻辑代码通常是分开的。界面的布局代码是放在一个独立的xml文件中的，这个文件里面是树型组织的，控制着页面的布局。通常，在这个页面中会用到很多控件，控件会用到很多的资源。Android系统本身有很多的资源，包括各种各样的字符串、图片、动画、样式和布局等等，这些都可以在应用程序中直接使用。这样做的好处很多，既可以减少内存的使用，又可以减少部分工作量，也可以缩减程序安装包的大小。</p><p>比如下面的代码就是使用系统的ListView：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView </span><br><span class="line">    android:<span class="attribute">id</span>=<span class="string">"@android:id/list"</span></span><br><span class="line">    android:<span class="attribute">layout_width</span>=<span class="string">"fill_parent"</span></span><br><span class="line">    android:<span class="attribute">layout_height</span>=<span class="string">"fill_parent"</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="8-使用内存相关工具检测"><a href="#8-使用内存相关工具检测" class="headerlink" title="8 使用内存相关工具检测"></a>8 使用内存相关工具检测</h2><p>在开发中，不可能保证一次就开发出一个内存管理非常棒的应用，所以在开发的每一个阶段，都要有意识地去针对内存进行专门的检查。目前Android提供了许多布局、内存相关的工具，比如Lint、MAT等。学会这些工具的使用是一个Android开发者必不可少的技能。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 代码内存优化建议 - Android 官方篇</title>
      <link href="/2015/07/20/Android-Performance-Memory-Google/"/>
      <url>/2015/07/20/Android-Performance-Memory-Google/</url>
      
        <content type="html"><![CDATA[<p>Android 内存优化系列文章：</p><ol><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Google/" target="_blank" rel="noopener">Android代码内存优化建议-Android官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Java/" target="_blank" rel="noopener">Android代码内存优化建议-Java官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource/" target="_blank" rel="noopener">Android代码内存优化建议-Android资源篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory/" target="_blank" rel="noopener">Android代码内存优化建议-OnTrimMemory优化</a></li></ol><hr><p>为了使垃圾回收器可以正常释放程序所占用的内存，在编写代码的时候就一定要注意尽量避免出现内存泄漏的情况（通常都是由于全局成员变量持有对象引用所导致的），并且在适当的时候去释放对象引用。对于大多数的应用程序而言，后面其它的事情就可以都交给垃圾回收器去完成了，如果一个对象的引用不再被其它对象所持有，那么系统就会将这个对象所分配的内存进行回收。</p><p>我们在开发软件的时候应当自始至终都把内存的问题充分考虑进去，这样的话才能开发出更加高性能的软件。而内存问题也并不是无规律可行的，Android系统给我们提出了很多内存优化的建议技巧，只要按照这些技巧来编写程序，就可以让我们的程序在内存性能发面表现得相当不错。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文原文来自Android开发者官网<a href="http://developer.android.com/training/articles/memory.html" target="_blank" rel="noopener">Managing Your App’s Memory</a>章节中的<br><a href="http://developer.android.com/training/articles/memory.html#YourApp" target="_blank" rel="noopener">How Your App Should Manage Memory</a>部分。是Android官方帮助应用开发者更好地管理应用的内存而写的。作为一个应用程序开发者，你需要在你开发应用程序的时时刻刻都考虑内存问题。</p><h3 id="1-节制地使用Service"><a href="#1-节制地使用Service" class="headerlink" title="1. 节制地使用Service"></a>1. 节制地使用Service</h3><p>如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。</p><p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p><p>为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用<a href="http://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="noopener"><strong>IntentService</strong></a>，这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。</p><p>让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。所以Android官方极度建议开发人员们不要过于贪婪，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载</p><h3 id="2-当界面不可见时释放内存"><a href="#2-当界面不可见时释放内存" class="headerlink" title="2. 当界面不可见时释放内存"></a>2. 当界面不可见时释放内存</h3><p>当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。<br>那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> onTrimMemory(<span class="keyword">int</span> level) &#123;  </span><br><span class="line">    <span class="keyword">super</span>.onTrimMemory(level);  </span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="string">TRIM_MEMORY_UI_HIDDEN:</span>  </span><br><span class="line">        <span class="comment">// 进行资源释放操作  </span></span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p><h3 id="3-当内存紧张时释放内存"><a href="#3-当内存紧张时释放内存" class="headerlink" title="3.当内存紧张时释放内存"></a>3.当内存紧张时释放内存</h3><p>除了刚才讲的<strong>TRIM_MEMORY_UI_HIDDEN</strong>这个回调，onTrimMemory()方法还有很多种其它类型的回调，可以在手机内存降低的时候及时通知我们。我们应该根据回调中传入的级别来去决定如何释放应用程序的资源：</p><h4 id="3-1-应用程序正在运行时"><a href="#3-1-应用程序正在运行时" class="headerlink" title="3.1 应用程序正在运行时"></a>3.1 应用程序正在运行时</h4><p><strong>TRIM_MEMORY_RUNNING_MODERATE</strong> 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。<br><strong>TRIM_MEMORY_RUNNING_LOW</strong> 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。<br><strong>TRIM_MEMORY_RUNNING_CRITICAL</strong> 表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</p><h4 id="3-2-应用程序被缓存"><a href="#3-2-应用程序被缓存" class="headerlink" title="3.2 应用程序被缓存"></a>3.2 应用程序被缓存</h4><p><strong>TRIM_MEMORY_BACKGROUND</strong> 表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。<br><strong>TRIM_MEMORY_MODERATE</strong> 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。<br><strong>TRIM_MEMORY_COMPLETE</strong> 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。</p><p>因为onTrimMemory()是在API14才加进来的，所以如果要支持API14之前的话，则可以考虑 <a href="http://developer.android.com/reference/android/content/ComponentCallbacks.html#onLowMemory()" target="_blank" rel="noopener">onLowMemory()</a>这个方法，它粗略的相等于onTrimMemory()回调的TRIM_MEMORY_COMPLETE事件。</p><blockquote><p>注意：当系统安装LRU cache杀进程的时候，尽管大部分时间是从下往上按顺序杀，有时候系统也会将占用内存比较大的进程纳入被杀范围，以尽快得到足够的内存。所以你的应用在LRU list中占用的内存越少，你就越能避免被杀掉，当你恢复的时候也会更快。</p></blockquote><h3 id="4-检查你应该使用多少的内存"><a href="#4-检查你应该使用多少的内存" class="headerlink" title="4. 检查你应该使用多少的内存"></a>4. 检查你应该使用多少的内存</h3><p>正如前面提到的，每一个Android设备都会有不同的RAM总大小与可用空间，因此不同设备为app提供了不同大小的heap限制。你可以通过调用<a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass()" target="_blank" rel="noopener">getMemoryClass()</a>来获取你的app的可用heap大小。如果你的app尝试申请更多的内存，会出现OutOfMemory的错误。</p><p>在一些特殊的情景下，你可以通过在manifest的application标签下添加largeHeap=true的属性来声明一个更大的heap空间。如果你这样做，你可以通过<a href="http://developer.android.com/reference/android/app/ActivityManager.html#getLargeMemoryClass()" target="_blank" rel="noopener">getLargeMemoryClass()</a>来获取到一个更大的heap size。</p><p>然而，能够获取更大heap的设计本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。<strong>不要轻易的因为你需要使用大量的内存而去请求一个大的heap size。</strong>只有当你清楚的知道哪里会使用大量的内存并且为什么这些内存必须被保留时才去使用large heap. 因此请尽量少使用large heap。使用额外的内存会影响系统整体的用户体验，并且会使得GC的每次运行时间更长。在任务切换时，系统的性能会变得大打折扣。</p><p>另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。</p><h3 id="5-避免在Bitmap上浪费内存"><a href="#5-避免在Bitmap上浪费内存" class="headerlink" title="5. 避免在Bitmap上浪费内存"></a>5. 避免在Bitmap上浪费内存</h3><p>当我们读取一个Bitmap图片的时候，有一点一定要注意，就是千万不要去加载不需要的分辨率。在一个很小的ImageView上显示一张高分辨率的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存。需要仅记的一点是，将一张图片解析成一个Bitmap对象时所占用的内存并不是这个图片在硬盘中的大小，可能一张图片只有100k你觉得它并不大，但是读取到内存当中是按照像素点来算的，比如这张图片是1500<em>1000像素，使用的ARGB_8888颜色类型，那么每个像素点就会占用4个字节，总内存就是1500</em>1000*4字节，也就是5.7M，这个数据看起来就比较恐怖了。</p><h3 id="6-使用优化过的数据集合"><a href="#6-使用优化过的数据集合" class="headerlink" title="6. 使用优化过的数据集合"></a>6. 使用优化过的数据集合</h3><p>利用Android Framework里面优化过的容器类，例如<a href="http://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="noopener">SparseArray</a>, <a href="http://developer.android.com/reference/android/util/SparseBooleanArray.html" target="_blank" rel="noopener">SparseBooleanArray</a>, 与 <a href="http://developer.android.com/reference/android/support/v4/util/LongSparseArray.html" target="_blank" rel="noopener">LongSparseArray</a>。 通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。</p><h3 id="7-知晓内存的开支情况"><a href="#7-知晓内存的开支情况" class="headerlink" title="7. 知晓内存的开支情况"></a>7. 知晓内存的开支情况</h3><p>我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：</p><ul><li>使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。</li><li>任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。</li><li>任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。</li><li>在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。</li></ul><h3 id="8-谨慎使用抽象编程"><a href="#8-谨慎使用抽象编程" class="headerlink" title="8. 谨慎使用抽象编程"></a>8. 谨慎使用抽象编程</h3><p>许多程序员都喜欢各种使用抽象来编程，认为这是一种很好的编程习惯。当然，这一点不可否认，因为的抽象的编程方法更加面向对象，而且在代码的维护和可扩展性方面都会有所提高。但是，在Android上使用抽象会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是却也要映射到内存当中，不仅占用了更多的内存，在执行效率方面也会有所降低。当然这里我并不是提倡大家完全不使用抽象编程，而是谨慎使用抽象编程，不要认为这是一种很酷的编程方式而去肆意使用它，只在你认为有必要的情况下才去使用。</p><h3 id="9-为序列化的数据使用nano-protobufs"><a href="#9-为序列化的数据使用nano-protobufs" class="headerlink" title="9. 为序列化的数据使用nano protobufs"></a>9. 为序列化的数据使用nano protobufs</h3><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protocol buffers</a>是由Google为序列化结构数据而设计的，一种语言无关，平台无关，具有良好扩展性的协议。类似XML，却比XML更加轻量，快速，简单。如果你需要为你的数据实现协议化，你应该在客户端的代码中总是使用nano protobufs。通常的协议化操作会生成大量繁琐的代码，这容易给你的app带来许多问题：增加RAM的使用量，显著增加APK的大小，更慢的执行速度，更容易达到DEX的字符限制。</p><p>关于更多细节，请参考<a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt" target="_blank" rel="noopener">protobuf readme</a>的”Nano version”章节。</p><h3 id="10-尽量避免使用依赖注入框架"><a href="#10-尽量避免使用依赖注入框架" class="headerlink" title="10. 尽量避免使用依赖注入框架"></a>10. 尽量避免使用依赖注入框架</h3><p>现在有很多人都喜欢在Android工程当中使用依赖注入框架，比如说像Guice或者RoboGuice等，因为它们可以简化一些复杂的编码操作，比如可以将下面的一段代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AndroidWay extends Activity &#123;   </span><br><span class="line">    TextView name;   </span><br><span class="line">    ImageView thumbnail;   </span><br><span class="line">    LocationManager loc;   </span><br><span class="line">    Drawable icon;   </span><br><span class="line">    String myName;   </span><br><span class="line">  </span><br><span class="line">    public void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;   </span><br><span class="line">        super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;   </span><br><span class="line">        set<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">main</span>)</span>;  </span><br><span class="line">        name      = (TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">name</span>)</span>;   </span><br><span class="line">        thumbnail = (ImageView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">thumbnail</span>)</span>;   </span><br><span class="line">        loc       = (LocationManager) get<span class="constructor">SystemService(Activity.LOCATION_SERVICE)</span>;   </span><br><span class="line">        icon      = get<span class="constructor">Resources()</span>.get<span class="constructor">Drawable(R.<span class="params">drawable</span>.<span class="params">icon</span>)</span>;   </span><br><span class="line">        myName    = get<span class="constructor">String(R.<span class="params">string</span>.<span class="params">app_name</span>)</span>;   </span><br><span class="line">        name.set<span class="constructor">Text( <span class="string">"Hello, "</span> + <span class="params">myName</span> )</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化成这样的一种写法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">main</span>)</span>  </span><br><span class="line"><span class="keyword">class</span> RoboWay extends RoboActivity &#123;   </span><br><span class="line">    @<span class="constructor">InjectView(R.<span class="params">id</span>.<span class="params">name</span>)</span>             TextView name;   </span><br><span class="line">    @<span class="constructor">InjectView(R.<span class="params">id</span>.<span class="params">thumbnail</span>)</span>        ImageView thumbnail;   </span><br><span class="line">    @<span class="constructor">InjectResource(R.<span class="params">drawable</span>.<span class="params">icon</span>)</span>   Drawable icon;   </span><br><span class="line">    @<span class="constructor">InjectResource(R.<span class="params">string</span>.<span class="params">app_name</span>)</span> String myName;   </span><br><span class="line">    @Inject                            LocationManager loc;   </span><br><span class="line">  </span><br><span class="line">    public void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;   </span><br><span class="line">        super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;   </span><br><span class="line">        name.set<span class="constructor">Text( <span class="string">"Hello, "</span> + <span class="params">myName</span> )</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去确实十分诱人，我们甚至可以将findViewById()这一类的繁琐操作全部省去了。但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且还可能将一些你用不到的对象也一并加载到内存当中。这些用不到的对象会一直占用着内存空间，可能要过很久之后才会得到释放，相较之下，也许多敲几行看似繁琐的代码才是更好的选择。</p><h3 id="11-谨慎使用external-libraries"><a href="#11-谨慎使用external-libraries" class="headerlink" title="11. 谨慎使用external libraries"></a>11. 谨慎使用external libraries</h3><p>很多External library的代码都不是为移动网络环境而编写的，在移动客户端则显示的效率不高。至少，当你决定使用一个external library的时候，你应该针对移动网络做繁琐的porting与maintenance的工作。</p><p>即使是针对Android而设计的library，也可能是很危险的，因为每一个library所做的事情都是不一样的。例如，其中一个lib使用的是nano protobufs, 而另外一个使用的是micro protobufs。那么这样，在你的app里面就有2种protobuf的实现方式。这样的冲突同样可能发生在输出日志，加载图片，缓存等等模块里面。</p><p>同样不要陷入为了1个或者2个功能而导入整个library的陷阱。如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案。</p><h3 id="12-优化整体性能"><a href="#12-优化整体性能" class="headerlink" title="12. 优化整体性能"></a>12. 优化整体性能</h3><p>官方有列出许多优化整个app性能的文章：<a href="http://developer.android.com/training/best-performance.html" target="_blank" rel="noopener">Best Practices for Performance</a>. 这篇文章就是其中之一。有些文章是讲解如何优化app的CPU使用效率，有些是如何优化app的内存使用效率。</p><p>你还应该阅读<a href="http://developer.android.com/tools/debugging/debugging-ui.html" target="_blank" rel="noopener">optimizing your UI</a>来为layout进行优化。同样还应该关注lint工具所提出的建议，进行优化。</p><h3 id="13-使用ProGuard来剔除不需要的代码"><a href="#13-使用ProGuard来剔除不需要的代码" class="headerlink" title="13. 使用ProGuard来剔除不需要的代码"></a>13. 使用ProGuard来剔除不需要的代码</h3><p><a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="noopener">ProGuard</a>能够通过移除不需要的代码，重命名类，域与方法等方对代码进行压缩，优化与混淆。使用ProGuard可以是的你的代码更加紧凑，这样能够使用更少mapped代码所需要的RAM。</p><h3 id="14-对最终的APK使用zipalign"><a href="#14-对最终的APK使用zipalign" class="headerlink" title="14. 对最终的APK使用zipalign"></a>14. 对最终的APK使用zipalign</h3><p>在编写完所有代码，并通过编译系统生成APK之后，你需要使用<a href="http://developer.android.com/tools/help/zipalign.html" target="_blank" rel="noopener">zipalign</a>对APK进行重新校准。如果你不做这个步骤，会导致你的APK需要更多的RAM，因为一些类似图片资源的东西不能被mapped。</p><p><strong>Notes::</strong>Google Play不接受没有经过zipalign的APK。</p><h3 id="15-分析你的RAM使用情况"><a href="#15-分析你的RAM使用情况" class="headerlink" title="15. 分析你的RAM使用情况"></a>15. 分析你的RAM使用情况</h3><p>一旦你获取到一个相对稳定的版本后，需要分析你的app整个生命周期内使用的内存情况，并进行优化，更多细节请参考<a href="http://developer.android.com/tools/debugging/debugging-memory.html" target="_blank" rel="noopener">Investigating Your RAM Usage</a>.</p><h3 id="16-使用多进程"><a href="#16-使用多进程" class="headerlink" title="16. 使用多进程"></a>16. 使用多进程</h3><p>如果合适的话，有一个更高级的技术可以帮助你的app管理内存使用：通过把你的app组件切分成多个组件，运行在不同的进程中。这个技术必须谨慎使用，大多数app都不应该运行在多个进程中。因为如果使用不当，它会显著增加内存的使用，而不是减少。当你的app需要在后台运行与前台一样的大量的任务的时候，可以考虑使用这个技术。</p><p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个app运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的app可以切分成2个进程：一个用来操作UI，另外一个用来后台的Service.</p><p>你可以通过在manifest文件中声明’android:process’属性来实现某个组件运行在另外一个进程的操作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".PlaybackService"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">":background"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>更多关于使用这个技术的细节，请参考原文，链接如下。<br><a href="http://developer.android.com/training/articles/memory.html" target="_blank" rel="noopener">http://developer.android.com/training/articles/memory.html</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 代码内存优化建议 - Java 官方篇</title>
      <link href="/2015/07/20/Android-Performance-Memory-Java/"/>
      <url>/2015/07/20/Android-Performance-Memory-Java/</url>
      
        <content type="html"><![CDATA[<p>Android 内存优化系列文章：</p><ol><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Google/" target="_blank" rel="noopener">Android代码内存优化建议-Android官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-Java/" target="_blank" rel="noopener">Android代码内存优化建议-Java官方篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource/" target="_blank" rel="noopener">Android代码内存优化建议-Android资源篇</a></li><li><a href="https://www.androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory/" target="_blank" rel="noopener">Android代码内存优化建议-OnTrimMemory优化</a></li></ol><hr><p>这篇文章主要是介绍了一些小细节的优化技巧，当这些小技巧综合使用起来的时候，对于整个App的性能提升还是有作用的，只是不能较大幅度的提升性能而已。选择合适的算法与数据结构才应该是你首要考虑的因素，在这篇文章中不会涉及这方面。你应该使用这篇文章中的小技巧作为平时写代码的习惯，这样能够提升代码的效率。</p><p>本文的原文为Google官方Training的性能优化部分，这一章节主要讲解的是高性能Android代码优化建议,建议所有Android应用开发者都仔细阅读这份文档，并将所提到的编码思想运用到实际的Android开发中。</p><a id="more"></a><blockquote><p>原文地址：<a href="http://developer.android.com/training/articles/perf-tips.html" target="_blank" rel="noopener">http://developer.android.com/training/articles/perf-tips.html</a></p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>通常来说，高效的代码需要满足下面两个规则：</p><ul><li>不要做冗余的动作</li><li>如果能避免，尽量不要分配内存</li></ul><p>你会面临最棘手的一个问题是当你优化一个肯定会在多种类型的硬件上运行的应用程序。不同版本的VM在不同的处理器上运行速度不同。它甚至不是你可以简单地说“设备X因为F原因比设备Y快/慢”那么简单,而且也不能简单地从一个设备拓展到另一个设备。特别提醒的是模拟器在性能方面和其他的设备没有可比性。通常有JIT优化和没有JIT优化的设备之间存在巨大差异:经过JIT代码优化的设备并不一定比没有经过JIT代码优化的设备好。</p><p>代码的执行效果会受到设备CPU,设备内存,系统版本等诸多因素的影响。为了确保代码能够在不同设备上都运行良好，需要最大化代码的效率。</p><h2 id="1-避免创建不必要的对象"><a href="#1-避免创建不必要的对象" class="headerlink" title="1)避免创建不必要的对象"></a>1)避免创建不必要的对象</h2><p>虽然GC可以回收不用的对象，可是为这些对象分配内存，并回收它们同样是需要耗费资源的。<br>因此请尽量避免创建不必要的对象，有下面一些例子来说明这个问题：</p><ul><li>如果你需要返回一个String对象，并且你知道它最终会需要连接到一个StringBuffer，请修改你的实现方式，避免直接进行连接操作，应该采用创建一个临时对象来做这个操作.</li><li>当从输入的数据集中抽取出Strings的时候，尝试返回原数据的substring对象，而不是创建一个重复的对象。</li></ul><p>一个稍微激进点的做法是把所有多维的数据分解成1维的数组:</p><ul><li>一组int数据要比一组Integer对象要好很多。可以得知，两组1维数组要比一个2维数组更加的有效率。同样的，这个道理可以推广至其他原始数据类型。</li><li>如果你需要实现一个数组用来存放(Foo,Bar)的对象，尝试分解为Foo[]与Bar[]要比(Foo,Bar)好很多。(当然，为了某些好的API的设计，可以适当做一些妥协。但是在自己的代码内部，你应该多多使用分解后的容易。</li></ul><p>通常来说，需要避免创建更多的对象。更少的对象意味者更少的GC动作，GC会对用户体验有比较直接的影响。</p><h2 id="2-选择Static而不是Virtual"><a href="#2-选择Static而不是Virtual" class="headerlink" title="2)选择Static而不是Virtual"></a>2)选择Static而不是Virtual</h2><p>如果你不需要访问一个对象的值域,请保证这个方法是static类型的,这样方法调用将快15%-20%。这是一个好的习惯，因为你可以从方法声明中得知调用无法改变这个对象的状态。</p><h2 id="3-常量声明为Static-Final"><a href="#3-常量声明为Static-Final" class="headerlink" title="3)常量声明为Static Final"></a>3)常量声明为Static Final</h2><p>先看下面这种声明的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">static</span> String strVal = <span class="string">"Hello, world!"</span>;</span><br></pre></td></tr></table></figure><p>编译器会在类首次被使用到的时候，使用初始化<code>&lt;clinit&gt;</code>方法来初始化上面的值，之后访问的时候会需要先到它那里查找，然后才返回数据。我们可以使用static final来提升性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String strVal = <span class="string">"Hello, world!"</span>;</span><br></pre></td></tr></table></figure><p>这时再也不需要上面的那个方法来做多余的查找动作了。<br>** 所以，请尽可能的为常量声明为static final类型的。**</p><h2 id="4-避免内部的Getters-Setters"><a href="#4-避免内部的Getters-Setters" class="headerlink" title="4)避免内部的Getters/Setters"></a>4)避免内部的Getters/Setters</h2><p>像C++等native language,通常使用getters(i = getCount())而不是直接访问变量(i = mCount).这是编写C++的一种优秀习惯，而且通常也被其他面向对象的语言所采用，例如C#与Java，因为编译器通常会做inline访问，而且你需要限制或者调试变量，你可以在任何时候在getter/setter里面添加代码。<br><strong>然而，在Android上，这是一个糟糕的写法</strong>。Virtual method的调用比起直接访问变量要耗费更多。那么合理的做法是：<strong>在面向对象的设计当中应该使用getter/setter，但是在类的内部你应该直接访问变量。</strong><br>没有<code>JIT(Just In Time Compiler)</code>时，直接访问变量的速度是调用getter的3倍。有JIT时,直接访问变量的速度是通过getter访问的7倍。<br>请注意，如果你使用<a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="noopener">ProGuard</a>, 你可以获得同样的效果，因为ProGuard可以为你inline accessors.</p><h2 id="5-使用增强的For循环写法"><a href="#5-使用增强的For循环写法" class="headerlink" title="5)使用增强的For循环写法"></a>5)使用增强的For循环写法</h2><p>请比较下面三种循环的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mSplat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo[] mArray = ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; ++i) &#123;</span><br><span class="line">        sum += mArray[i].mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Foo[] localArray = mArray;</span><br><span class="line">    <span class="keyword">int</span> len = localArray.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        sum += localArray[i].mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Foo a : mArray) &#123;</span><br><span class="line">        sum += a.mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>zero()是最慢的，因为JIT没有办法对它进行优化。</li><li>one()稍微快些。</li><li>two() 在没有做JIT时是最快的，可是如果经过JIT之后，与方法one()是差不多一样快的。它使用了增强的循环方法for-each。</li></ul><p>所以请尽量使用for-each的方法，但是对于ArrayList，请使用方法one()。</p><h2 id="6-使用包级访问而不是内部类的私有访问"><a href="#6-使用包级访问而不是内部类的私有访问" class="headerlink" title="6)使用包级访问而不是内部类的私有访问"></a>6)使用包级访问而不是内部类的私有访问</h2><p>参考下面一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Foo.<span class="keyword">this</span>.doStuff(Foo.<span class="keyword">this</span>.mValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        mValue = <span class="number">27</span>;</span><br><span class="line">        in.stuff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重要的是，我们定义了一个私有的内部类（Foo$Inner），它直接访问了外部类中的私有方法以及私有成员对象。这是合法的，这段代码也会如同预期一样打印出”Value is 27”。</p><p>问题是，VM因为Foo和Foo$Inner是不同的类，会认为在Foo$Inner中直接访问Foo类的私有成员是不合法的。即使Java语言允许内部类访问外部类的私有成员。为了去除这种差异，编译器会产生一些仿造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">int</span> Foo.access$<span class="number">100</span>(Foo foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo.mValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">void</span> Foo.access$<span class="number">200</span>(Foo foo, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    foo.doStuff(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当内部类需要访问外部类中的mValue成员或需要调用doStuff()函数时，它都会调用这些静态方法。这意味着，上面的代码可以归结为，通过accessor函数来访问成员变量。早些时候我们说过，通过accessor会比直接访问域要慢。所以，这是一个特定语言用法造成性能降低的例子。</p><p>如果你正在性能热区（hotspot:高频率、重复执行的代码段）使用像这样的代码，你可以把内部类需要访问的域和方法声明为包级访问，而不是私有访问权限。不幸的是，这意味着在相同包中的其他类也可以直接访问这些域，所以在公开的API中你不能这样做。</p><h2 id="7-避免使用float类型"><a href="#7-避免使用float类型" class="headerlink" title="7)避免使用float类型"></a>7)避免使用float类型</h2><p>Android系统中float类型的数据存取速度是int类型的一半，尽量优先采用int类型。</p><h2 id="8-使用库函数"><a href="#8-使用库函数" class="headerlink" title="8)使用库函数"></a>8)使用库函数</h2><p>尽量使用System.arraycopy()等一些封装好的库函数，它的效率是手动编写copy实现的9倍多。</p><p>** Tip: Also see Josh Bloch’s Effective Java, item 47. **</p><h2 id="9-谨慎使用native函数"><a href="#9-谨慎使用native函数" class="headerlink" title="9)谨慎使用native函数"></a>9)谨慎使用native函数</h2><p>当你需要把已经存在的native code迁移到Android，请谨慎使用JNI。如果你要使用JNI,请学习<a href="http://developer.android.com/guide/practices/jni.html" target="_blank" rel="noopener">JNI Tips</a></p><h2 id="10-关于性能的误区"><a href="#10-关于性能的误区" class="headerlink" title="10)关于性能的误区"></a>10)关于性能的误区</h2><p>在没有做JIT之前，使用一种确切的数据类型确实要比抽象的数据类型速度要更有效率。(例如，使用HashMap要比Map效率更高。) 有误传效率要高一倍，实际上只是6%左右。而且，在JIT之后，他们直接并没有大多差异。</p><h2 id="11-关于测量"><a href="#11-关于测量" class="headerlink" title="11)关于测量"></a>11)关于测量</h2><p>上面文档中出现的数据是Android的实际运行效果。我们可以用<a href="http://developer.android.com/tools/debugging/debugging-tracing.html" target="_blank" rel="noopener">Traceview</a> 来测量，但是测量的数据是没有经过JIT优化的，所以实际的效果应该是要比测量的数据稍微好些。</p><p>关于如何测量与调试，还可以参考下面两篇文章：</p><ul><li><a href="http://developer.android.com/tools/debugging/debugging-tracing.html" target="_blank" rel="noopener">Profiling with Traceview and dmtracedump</a></li><li><a href="http://developer.android.com/tools/debugging/systrace.html" target="_blank" rel="noopener">Analysing Display and Performance with Systrace</a></li></ul><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nexus6 with Android M开启多窗口模式</title>
      <link href="/2015/05/29/Nexus6-with-Android-M/"/>
      <url>/2015/05/29/Nexus6-with-Android-M/</url>
      
        <content type="html"><![CDATA[<p>昨天的Google IO之后，Google放出了Android M Preview for Nexus6. 固件大家可以去Google的官网去下，下好了刷完之后，就可以体验一下最新的Android M了。下面是设置 里面的主界面和彩蛋界面:</p><a id="more"></a><p><img src="/images/nexus6/0.png" alt="主界面"></p><p><img src="/images/nexus6/1.png" alt="彩蛋"></p><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><ol><li>Android M给人最大的不一样就是其抽屉的变化：</li></ol><p><img src="/images/nexus6/2.png" alt="抽屉"></p><p>从图中可以看出,抽屉中的APP是使用字母进行索引的.最上面一排是最常用的的APP,目前是不可以定制的.</p><ol start="2"><li><p>另外一个感觉变化比较大的地方就是动画,文件夹动画和应用启动动画都变了,这个不好描述,大家回头可以自己去感受.</p></li><li><p>设置里面可以设置主题了,不过目前也就light和dark可以选择.</p></li></ol><p><img src="/images/nexus6/3.png" alt="模式选择"></p><h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><p>Android M Preview官方固件里面默认是没有多窗口模式这个选项的.因为官方的固件是user版本的,而这个多窗口的模式是在userdebug中才能打开的. 所以必须要手动进行开启.</p><h3 id="刷入第三方Recovery"><a href="#刷入第三方Recovery" class="headerlink" title="刷入第三方Recovery"></a>刷入第三方Recovery</h3><h4 id="1-进入bootloader模式"><a href="#1-进入bootloader模式" class="headerlink" title="1. 进入bootloader模式"></a>1. 进入bootloader模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><h4 id="2-刷入twrp-img"><a href="#2-刷入twrp-img" class="headerlink" title="2. 刷入twrp.img"></a>2. 刷入twrp.img</h4><p>这个twrp是从官网下载的，下载速度略慢，我把它放到了百度网盘，方便大家去下载：<a href="http://pan.baidu.com/s/1eQ5ysE2" target="_blank" rel="noopener">twrp</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery ~/Downloads/twrp-<span class="number">2.8</span><span class="number">.6</span><span class="number">.0</span>-shamu.img</span><br></pre></td></tr></table></figure><h4 id="3-Mount-System"><a href="#3-Mount-System" class="headerlink" title="3. Mount System"></a>3. Mount System</h4><p>刷入recovery之后不用重启手机，直接进入recovery模式，进入mount，将system这一项前面的对勾选上。这一步是为了可以改system目录里面的值。</p><h4 id="4-修改-system-build-prop"><a href="#4-修改-system-build-prop" class="headerlink" title="4. 修改/system/build.prop"></a>4. 修改/system/build.prop</h4><p>第三步结束后，使用adb devices查看是否可以看到手机。如果能正常看到手机，那么先进入shell：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br></pre></td></tr></table></figure><p>然后使用vi打开system/build.prop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi system/build.prop</span><br></pre></td></tr></table></figure><p>找到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ro.build.type=user</span><br></pre></td></tr></table></figure><p>将其修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ro.build.type=userdebug</span><br></pre></td></tr></table></figure><p>保存后退出shell，这时候执行adb reboot重启机器就可以看到在开发者选项中多了一项：</p><p><img src="/images/nexus6/4.png" alt="选择开启多窗口"></p><p>开启多窗口的方法是点击多任务按钮，选择一个任务窗口上面的三个框（选一个即可）<br>，第一个是在上面窗口，第二个是在下面的窗口，第三个是全屏。</p><p><img src="/images/nexus6/5.png" alt="多窗口位置选择"></p><p>然后就可以看到效果了：</p><p><img src="/images/nexus6/6.png" alt="多窗口效果"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>说是多窗口，其实目前只支持双窗口。不过双窗口的窗口利用率其实并不高，多窗口就更加呵呵呵了。这个就看Google之后如何发挥这个了。</p><p>其实多窗口三星早就实现了。而且每个窗口还可以动态调整大小，不过这并没有什么卵用。测评中提到的也不多。可见多窗口现在其实还只是一个炫技的功能。至于使用的话，可能还得要多迭代几次才可以。</p><p>另外这篇文章的简书地址在此：<a href="http://www.jianshu.com/p/8bb7b44930e3" target="_blank" rel="noopener">Nexus6-with-Android-M开启多窗口模式</a> . 因为我写东西都是在简书上完成，然后才Copy到其他的地方，所以这里也给大家推荐一下简书吧。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Nexus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细说 Java 单例模式</title>
      <link href="/2015/05/06/Java-Singleton/"/>
      <url>/2015/05/06/Java-Singleton/</url>
      
        <content type="html"><![CDATA[<p>单例模式也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。本文就从单例模式的两种构建方式来带大家了解一下单例，最后介绍一种高级且简洁的单例模式。</p><a id="more"></a><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><blockquote><p><a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">单例模式</a>，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。</p></blockquote><p>中心原则就是：单例对象的类必须保证只有一个实例存在</p><h2 id="单例模式的构建"><a href="#单例模式的构建" class="headerlink" title="单例模式的构建"></a>单例模式的构建</h2><p>在java中主要有两种构建方式</p><ol><li>懒汉方式。指全局的单例实例在第一次被使用时构建。</li><li>饿汉方式。指全局的单例实例在类装载时构建。</li></ol><p>简单的说就是一个需要延迟初始化，一个则不需要。</p><p>比较简单的构建方式有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private constructor suppresses   </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default public constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式实现简单，实例在类装载时构建，如果想要实现一种实例在第一次被使用时构建应该怎么做？</p><p>有一种叫做 双重检查锁(double-checked locking)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private constructor suppresses </span></span><br><span class="line">    <span class="comment">// default public constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//thread safe and performance  promote </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//when more than two threads run into the first null check same time, to avoid instanced more than one time, it needs to be checked again.</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方法只能用在JDK5及以后版本(注意 INSTANCE 被声明为 volatile)，之前的版本使用“双重检查锁”会发生非预期行为.</p><h2 id="另一种单例模式"><a href="#另一种单例模式" class="headerlink" title="另一种单例模式"></a>另一种单例模式</h2><p>在第一条推荐阅读里提到了另一种实现单例的方式 lazy initialization holder class idiom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private constructor suppresses   </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。相比其他实现方案（如double-checked locking等），该技术方案的实现代码较为简洁，并且在所有版本的编译器中都是可行的。</p><p>关于 static final Singleton INSTANCE 域的访问权限为什么时包级私有可以阅读: <a href="http://ifeve.com/initialization-on-demand-holder-idiom/" target="_blank" rel="noopener">Initialization On Demand Holder idiom的实现探讨</a></p><h2 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h2><p>最后推荐实现最为简洁的一种方式: 使用枚举</p><p>代码极其简洁, 使用极其简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下前面集中单例的实现方式, 都只考虑了常规获取类对象的手段, 然而还可以通过序列化和反射机制获取对象.上面两种方式如果实现了序列化接口 Serializable 就必须重写 readResolve() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使重写了 readResolve() 方法也会涉及某系域需要关键字 transient 的修饰, 具体讨论不再展开, 总之涉及序列化挺蛋疼. </p><p>关于防止反射暂时没有深入了解, 据了解: 因为反射的某些地方绕过了java机制的限制，private只在编译时进行权限的限制，但是在运行时是不存在这种权限的限制的, 此处仅供参考.</p><p>但是使用enum实现的单例自带防序列化与防反射功能, 详细参照枚举类反编译后代码(供参考)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        Singleton asingleton[];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        Singleton asingleton1[];</span><br><span class="line">        System.arraycopy(asingleton = ENUM$VALUES, <span class="number">0</span>, asingleton1 = <span class="keyword">new</span> Singleton[i = asingleton.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> asingleton1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Singleton)Enum.valueOf(singleton/Singleton, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Singleton(String s, <span class="keyword">int</span> i, Singleton singleton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton ENUM$VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton(<span class="string">"INSTANCE"</span>, <span class="number">0</span>) ;</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> Singleton[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实现的枚举都是继承了 java.lang.Enum 可以看出来单例的实现也是通过关键字 static 修饰的静态初始化块来实现.</p><p>那么为什么enum可以防御反射呢…很简单, 因为它是一个抽象类 public abstract class Singleton extends Enum 即使是反射机制也不能实例化了.</p><p>有为什么能防御序列化呢…这个要看java源码中对于对象序列化的处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">java.io.ObjectOutputStream</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// remaining cases</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        writeString((String) obj, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">        writeArray(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">        writeEnum((Enum) obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">        writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Writes given enum constant to stream.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeEnum</span><span class="params">(Enum en, ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    bout.writeByte(TC_ENUM);</span><br><span class="line">    ObjectStreamClass sdesc = desc.getSuperDesc();</span><br><span class="line">    writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : en);</span><br><span class="line">    writeString(en.name(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出enum在被序列化时时经过特殊处理的, 被序列化的仅仅是枚举的名字而已.所以可以猜测一下反序列的的代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> java.io.ObjectOutputStream</span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">        <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads in and returns enum constant, or null if enum type is</span></span><br><span class="line"><span class="comment"> * unresolvable.  Sets passHandle to enum constant's assigned handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Enum <span class="title">readEnum</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            en = Enum.valueOf(cl, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">                <span class="string">"enum constant "</span> + name + <span class="string">" does not exist in "</span> +</span><br><span class="line">                cl).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!unshared) &#123;</span><br><span class="line">            handles.setObject(enumHandle, en);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> en;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化也仅仅是通过name调用了方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enum.valueOf(Class&lt;T&gt; enumType, String name)</span><br></pre></td></tr></table></figure><p>获取了一个枚举实例, 所以枚举也可以防止通过序列化产生新的单例.</p><p>友情建议: 在序列化枚举时要特别注意, 枚举的名称一定不能改变, 否则在反序列化时有可能会抛出异常!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String name)</span> </span>&#123;</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读:"></a>推荐阅读:</h2><ol><li>Effective Java 第71条 慎用延迟初始化</li><li>Core Java 第一卷 14.5.8 Volatile 域</li><li><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4" target="_blank" rel="noopener">JSL 17.4</a></li><li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">Java 理论与实践: 正确使用 Volatile 变量</a></li><li><a href="http://ifeve.com/double-checked-locking-with-delay-initialization/" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a></li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化典范 - Profile GPU Rendering</title>
      <link href="/2015/04/19/Android-Performance-Patterns-4/"/>
      <url>/2015/04/19/Android-Performance-Patterns-4/</url>
      
        <content type="html"><![CDATA[<p>系列文章目录：</p><ol><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns/" target="_blank" rel="noopener">Android性能优化典范综述</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-1/" target="_blank" rel="noopener">Android性能优化典范之Render Performance</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-2/" target="_blank" rel="noopener">Android性能优化典范之Understanding Overdraw</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-3/" target="_blank" rel="noopener">Android性能优化典范之Understanding VSYNC</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-4/" target="_blank" rel="noopener">Android性能优化典范之Profile GPU Rendering</a></li></ol><hr><blockquote><p>“If you can measure it, you can optimize it” is a common term in the computing world, and for Android’s rendering system, the same thing holds true. In order to optimize your pipeline to be more efficient for rendering, you need a tool to give you feedback on where the current perf problems lie.</p></blockquote><blockquote><p>And in this video, +Colt McAnlis walks you through an on-device tool that’s built for this exact reason. “Profile GPU Rendering” will help you understand the stages of the rendering pipeline, and also get a chance to see what portions of it might be taking too long, and what you can do about it for your application.</p></blockquote><h2 id="GPU-Profile工具"><a href="#GPU-Profile工具" class="headerlink" title="GPU Profile工具"></a>GPU Profile工具</h2><p>渲染性能问题往往是偷取你宝贵帧数的罪魁祸首,这种问题很容易产生,很容易出现,而且在一个非常方便的工具的帮助下,也非常容易去追踪. 使用Peofile GPU Rendering tool,你可以在手机上就可以看到究竟是什么导致你的应用程序出现卡顿,变慢的情况.</p><a id="more"></a><p>这个工具在设置-开发者选项-Profile GPU rendering选项,打开后选择on screen as bars:</p><p><img src="/images/performance-4/1.png" alt="Profile GPU rendering"></p><p>然后手机屏幕上就会出现三个颜色组成的小柱状图,以及一条绿线:</p><p><img src="/images/performance-4/2.png" alt="gpu工具"></p><p>这个工具会在屏幕上显示经过分析后的图形数据,最底部的图显示的是Navigation的相关信息,最上面显示的是Notification的相关信息,中间的图显示的是当前应用程序的图.</p><h2 id="使用GPU-Profile工具"><a href="#使用GPU-Profile工具" class="headerlink" title="使用GPU Profile工具"></a>使用GPU Profile工具</h2><p>当你的应用程序在运行时,你会看到一排柱状图在屏幕上,从左到右动态地显示,<strong>每一个垂直的柱状图代表一帧的渲染,越长的垂直柱状图表示这一帧需要渲染的时间越长</strong>.随着需要渲染的帧数越来越多,他们会堆积在一起,这样你就可以观察到这段时间帧率的变化.</p><h3 id="绿线"><a href="#绿线" class="headerlink" title="绿线"></a>绿线</h3><p>下图中的绿线代表16ms,要确保一秒内打到60fps,你需要确保这些帧的每一条线都在绿色的16ms标记线之下.任何时候你看到一个竖线超过了绿色的标记现,你就会看到你的动画有卡顿现象产生.</p><p><img src="/images/performance-4/3.png" alt="绿线"></p><h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><p>每一条柱状图都由三种颜色组成: 蓝-红-黄. 这些线直接和Android的渲染流水线和他实际运行帧数的时间关联:</p><p><img src="/images/performance-4/4.png" alt="柱状图"></p><ul><li><p>蓝色代表测量绘制的时间,或者说它代表需要多长时间去创建和更新你的DisplayList.在Android中,一个视图在可以实际的进行渲染之前,它必须被转换成GPU所熟悉的格式,简单来说就是几条绘图命令,复杂点的可能是你的自定义的View嵌入了自定义的Path. 一旦完成,结果会作为一个DisplayList对象被系统送入缓存,蓝色就是记录了需要花费多长时间在屏幕上更新视图(说白了就是执行每一个View的onDraw方法,创建或者更新每一个View的Display List对象).</p><p><img src="/images/performance-4/5.png" alt="Draw Phase"></p><p>当你看到蓝色的线很高的时候,<strong>有可能是因为你的一堆视图突然变得无效了(即需要重新绘制),或者你的几个自定义视图的onDraw函数过于复杂</strong>.</p><p><img src="/images/performance-4/6.png" alt="自定义视图"></p></li><li><p>红色代表执行的时间,这部分是Android进行2D渲染 Display List的时间,为了绘制到屏幕上,Android需要使用OpenGl ES的API接口来绘制Display List.这些API有效地将数据发送到GPU,最总在屏幕上显示出来.</p><p><img src="/images/performance-4/7.png" alt="红色"></p><p>记住绘制下图这样自定义的比较复杂的视图时,需要用到的OpenGl的绘制命令也会更复杂</p><p><img src="/images/performance-4/8.png" alt="自定义的复杂View"></p><p>当你看到红色的线非常高的时候,这些复杂的自定义View就是罪魁祸首:</p><p><img src="/images/performance-4/9.png" alt="Paste_Image.png"></p><p>值得一提的是,上面图中红色线较高的一种可能性是因为重新提交了视图而导致的.这些视图并不是失效的视图,但是有些时候发生了某些事,例如视图旋转,我们需要重新清理这个区域的视图,这样可能会影响这个视图下面的视图,因为这些视图都需要进行重新的绘制操作.</p></li><li><p>橙色部分表示的是处理时间,或者说是CPU告诉GPU渲染一帧的地方,这是一个阻塞调用,因为CPU会一直等待GPU发出接到命令的回复,如果柱状图很高,那就意味着你给GPU太多的工作,太多的负责视图需要OpenGL命令去绘制和处理.</p></li></ul><p>保持动画流畅的关键就在于让这些垂直的柱状条尽可能地保持在绿线下面,任何时候超过绿线,你就有可能丢失一帧的内容.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>GPU Profile工具能够很好地帮助你找到渲染相关的问题,但是要修复这些问题就不是那么简单了. 你需要结合代码来具体分析,找到性能的瓶颈,并进行优化.</p><p>有时候你可以以这个为工具,让负责设计这个产品的人修改他的设计,以获得良好的用户体验.</p><h2 id="Perf-Matters"><a href="#Perf-Matters" class="headerlink" title="Perf Matters"></a>Perf Matters</h2><blockquote><p>keep calm, profile your code, and always remember, Perf Matters</p></blockquote><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化典范 - Understanding VSYNC</title>
      <link href="/2015/04/19/Android-Performance-Patterns-3/"/>
      <url>/2015/04/19/Android-Performance-Patterns-3/</url>
      
        <content type="html"><![CDATA[<p>系列文章目录：</p><ol><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns/" target="_blank" rel="noopener">Android性能优化典范综述</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-1/" target="_blank" rel="noopener">Android性能优化典范之Render Performance</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-2/" target="_blank" rel="noopener">Android性能优化典范之Understanding Overdraw</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-3/" target="_blank" rel="noopener">Android性能优化典范之Understanding VSYNC</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-4/" target="_blank" rel="noopener">Android性能优化典范之Profile GPU Rendering</a></li></ol><hr><blockquote><p>Unbeknown to most developers, there’s a simple hardware design that defines everything about how fast your application can draw things to the screen.</p></blockquote><blockquote><p>You may have heard the term VSYNC - VSYNC stands for vertical synchronization and it’s an event that happens every time your screen starts to refresh the content it wants to show you.</p></blockquote><blockquote><p>Effectively, VSYNC is the product of two components Refresh Rate (how fast the hardware can refresh the screen), and Frames Per Second (how fast the GPU can draw images), and in this video +Colt McAnlis walks through each of these topics, and discusses where VSYNC (and the 16ms rendering barrier) comes from, and why it’s critical to understand if you want a silky smooth application.</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>想要开发一个高性能的应用程序,首先你得了解他的硬件工作原理,那么最好的办法就是去使用它,应用程序运行速度的快慢,很容易被人误解为硬件进程的控制问题,然而这最主要的根源在于渲染性能.如果你想要提高你应用程序的渲染性能,你就必须知道什么是<strong>VSYNC</strong>.</p><a id="more"></a><p>在了解<strong>VSYNC</strong>之前,我们需要了解两个概念:</p><h3 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h3><p>刷新率代表屏幕在一秒内刷新屏幕的次数,这个值用赫兹来表示,取决于硬件的固定参数. 这个值一般是60Hz,即每16.66ms刷新一次屏幕.</p><p><img src="/images/performance-3/1.png" alt="刷新率"></p><h3 id="帧速率"><a href="#帧速率" class="headerlink" title="帧速率"></a>帧速率</h3><p>帧速率代表了GPU在一秒内绘制操作的帧数,比如30fps/60fps.在这种情况下,高点的帧速率总是好的.</p><p><img src="/images/performance-3/2.png" alt="帧速率"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>刷新率和帧速率需要协同工作,才能让你的应用程序的内容显示到屏幕上,GPU会获取图像数据进行绘制,然后硬件负责把内容呈现到屏幕上,这将在你的应用程序的生命周期中周而复始地发生.下面的图中每一个竖行代表了一帧的绘制和呈现工作.</p><p><img src="/images/performance-3/3.png" alt="协同工作"></p><p>不幸的是,刷新率和帧速率并不是总能够保持相同的节奏:</p><ul><li><p>如果帧速率实际上比刷新率快,那么就会出现一些视觉上的问题,下面的图中可以看到,当帧速率在100fps而刷新率只有75Hz的时候,GPU所渲染的图像并非全都被显示出来.</p><p><img src="/images/performance-3/4.png" alt="帧速率比刷新率快的情况"></p><p>举个例子, 你拍了一张照片,然后旋转5度再拍一张照片, 将两种图片的中间剪开并拼接在一起:</p><p><img src="/images/performance-3/5.png" alt="拍两张照片"></p><p><img src="/images/performance-3/6.png" alt="剪贴在一起"><br>这两张图有相似之处,但是上面和下面部分有明显的区别,这就叫Tearing(撕裂),是刷新率和帧速率不一致的结果.</p><p>上面的原因是因为,当你的显卡正在使用,一个内存区正在写入帧数据(用来显示一帧的一个Buffer),从顶部开始, 新的一帧覆盖前一帧,并立刻输出一行内容. 现在,当屏幕开始刷新时,实际上并不知道缓冲区是什么状态(即不知道缓冲区中的一帧是否绘制完毕,即存在只绘制了一半的情况,另一半还是之前的那帧),因此它从GPU中抓住的帧肯可能并不是完全完整的.</p><p><img src="/images/performance-3/7.png" alt="图像撕裂"></p><p>目前Android的双缓冲(或者三缓冲/四缓冲), 这是非常有效的,当GPU将一帧写入一个被成为后缓冲的存储器, 而存储器中的次级区域被称为帧缓冲,当写入下一帧时,它会开始填充后缓冲,而帧缓冲保持不变,现在我们刷新屏幕,它将使用帧缓冲(事先已经绘制好),而不是正在处于绘制状态的后缓冲, 这就是VSYNC的作用.如果在屏幕刷新中,VSYNC,即垂直同步,将会在让从后缓冲到帧缓冲的拷贝过程保持同样的复制操作:</p><p><img src="/images/performance-3/8.png" alt="Vsync"></p><p>GPU的频率比屏幕刷新率高是正常的,因为你的GPU刷新会比屏幕刷新快,在这种情况下,当屏幕刷新成功,你的GPU将会等待VSYNC信号,直到下一个VSYNC信号到来时(即屏幕刷新时),这时你的帧速率就可以达到设备的刷新率上限. 当然这只是理想情况, 当fps达到60的时候,GPU需要在16.66ms内准备好一帧,这对应用程序的要求是非常高的.更不用说100fps了…</p></li><li><p>屏幕刷新率比帧速率快的情况<br>如果屏幕刷新率比帧速率快,屏幕会在两帧中显示同一个画面,当这种断断续续的情况发生时,你就遇到麻烦了.比如你的帧速率比屏幕刷新率高的时候,用户看到的是非常流畅的画面, 但是帧速率降下来的时候(GPU绘制太多东西的时候),用户将会很明显地察觉到动画卡住了或者掉帧,然后又恢复了流畅.这通常会被描述为闪屏, 跳帧,延迟.</p><p><img src="/images/performance-3/9.png" alt="屏幕刷新率比帧速率快"></p><p>你的应用程序应该避免这些帧率突降的情况.以确保GPU迅速获取数据,并在屏幕再次刷新之前写录内容.</p></li></ul><h2 id="Perf-Matters"><a href="#Perf-Matters" class="headerlink" title="Perf Matters"></a>Perf Matters</h2><blockquote><p>keep calm, profile your code, and always remember, Perf Matters</p></blockquote><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化典范之 Understanding Overdraw</title>
      <link href="/2015/04/19/Android-Performance-Patterns-2/"/>
      <url>/2015/04/19/Android-Performance-Patterns-2/</url>
      
        <content type="html"><![CDATA[<p>系列文章目录：</p><ol><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns/" target="_blank" rel="noopener">Android性能优化典范综述</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-1/" target="_blank" rel="noopener">Android性能优化典范之Render Performance</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-2/" target="_blank" rel="noopener">Android性能优化典范之Understanding Overdraw</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-3/" target="_blank" rel="noopener">Android性能优化典范之Understanding VSYNC</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-4/" target="_blank" rel="noopener">Android性能优化典范之Profile GPU Rendering</a></li></ol><hr><blockquote><p>One of the most problematic performance problems on Android is the easiest to create; thankfully, it’s also easy to fix.</p></blockquote><blockquote><p><strong>OVERDRAW</strong> is a term used to describe how many times a pixel has been re-drawn in a single frame of rendering. It’s a troublesome issue, because in most cases, pixels that are overdrawn do not end up contributing to the final rendered image. As such, it amounts to wasted work for your GPU and CPU. </p></blockquote><blockquote><p>Fixing overdraw has everything to do with using the available on-device tools, like Show GPU Overdraw, and then adjusting your view hierarchy in order to reduce areas where it may be occurring.</p></blockquote><h2 id="OverDraw概念"><a href="#OverDraw概念" class="headerlink" title="OverDraw概念"></a>OverDraw概念</h2><p>视频开头作者举了一个例子，说如果你是一个粉刷匠，你应该会知道，给墙壁粉刷是一件工作量非常大的工作，而且如果你需要重新粉刷一遍的话(比如对颜色不满意),那么第一次的粉刷就白干了. 同样的道理,如果你的应用程序中出现了过度绘制问题,那么你之前所做的事情也就白费了.如果你想兼顾高性能和完美的设计,那么你的程序可能会出现一个性能问题:<strong>OverDraw</strong>!</p><p><strong>OverDraw</strong>是一个术语, 它表示某些组件在屏幕上的一个像素点的绘制超过1次.如下面的图所示,我们有一堆重叠的卡片,被用户激活的卡片在最上面,而那些没有激活的卡片在下面,这意味着我们画大力气绘制的那些卡片,基本都是不可见的.问题就在于次,我们像素渲染的并不全是用户最后能看打的部分, 这是在浪费GPU的时间!</p><a id="more"></a><p><img src="/images/performance-2/1.png" alt="OverDraw"></p><p>目前流行的一些布局是一把双刃剑,带给我们漂亮的画面的同时,也带来了很大的麻烦.为了最大限度地提高应用程序的性能,你得减少<strong>OverDraw!</strong></p><p><img src="/images/performance-2/2.png" alt="性能和界面"></p><h2 id="追踪OverDraw"><a href="#追踪OverDraw" class="headerlink" title="追踪OverDraw"></a>追踪OverDraw</h2><p>Android手机中提供了查看OverDraw情况的工具,在设置-开发者选项中,找到打开”Show GPU OverDraw”按钮即可:</p><p><img src="/images/performance-2/3.png" alt="Show GPU OverDraw"></p><p>Android会使用不同深浅的颜色来表示OverDraw的程序,没有OverDraw的时候, 你看到的是它本来的颜色,其他颜色表示不同的过度绘制程序:</p><ul><li>蓝色: 1倍过度绘制,即一个像素点绘制了2次</li><li>绿色:2倍过度绘制,即一个像素点绘制了3次</li><li>浅红色:3倍过度绘制,即一个像素点绘制了4次</li><li>深红色:4倍过度绘制及以上,即一个像素点绘制了5次及以上</li></ul><p><img src="/images/performance-2/4.png" alt="OverDraw"></p><p>你的应用程序的目标应该是尽可能地减少过度绘制,即更多的蓝色色块而不是红色色块:</p><p><img src="/images/performance-2/5.png" alt="Good and Bad"></p><h2 id="OverDraw的根源"><a href="#OverDraw的根源" class="headerlink" title="OverDraw的根源"></a>OverDraw的根源</h2><p>虽然OverDraw很大程序上来自于你的视图互相重叠的问题,但是各位开发者更需要注意的是不必要的背景重叠.</p><p><img src="/images/performance-2/6.png" alt="Bad"></p><p>比如在一个应用程序中,你的所有的View都有背景的话,就会看起来像第一张图中那样,而在去除这些不必要的背景之后(指的是Window的默认背景,Layout的背景,文字以及图片的可能存在的背景),效果就像第二张图那样,基本没有过度绘制的情况.</p><p><img src="/images/performance-2/7.png" alt="去掉不必要的背景"></p><p>比如去除Window的默认背景:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.getWindow</span>()<span class="selector-class">.setBackgroundDrawableResource</span>(<span class="selector-tag">android</span><span class="selector-class">.R</span><span class="selector-class">.color</span><span class="selector-class">.transparent</span>);</span><br></pre></td></tr></table></figure><h2 id="Perf-Matters"><a href="#Perf-Matters" class="headerlink" title="Perf Matters"></a>Perf Matters</h2><blockquote><p>keep calm, profile your code, and always remember, Perf Matters</p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>关于过度绘制及其优化,我博客有两篇文章专门介绍:</p><ul><li><a href="https://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/">Android过度绘制优化-基础篇</a></li><li><a href="https://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/">Android过度绘制优化-实战篇</a></li></ul><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化典范 - Render Performance</title>
      <link href="/2015/04/19/Android-Performance-Patterns-1/"/>
      <url>/2015/04/19/Android-Performance-Patterns-1/</url>
      
        <content type="html"><![CDATA[<p>系列文章目录：</p><ol><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns/" target="_blank" rel="noopener">Android性能优化典范综述</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-1/" target="_blank" rel="noopener">Android性能优化典范之Render Performance</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-2/" target="_blank" rel="noopener">Android性能优化典范之Understanding Overdraw</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-3/" target="_blank" rel="noopener">Android性能优化典范之Understanding VSYNC</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-4/" target="_blank" rel="noopener">Android性能优化典范之Profile GPU Rendering</a></li></ol><hr><blockquote><p>Rendering performance is all about how fast you can draw your activity, and get it updated on the screen. Success here means your users feeling like your application is smooth and responsive, which means that you’ve got to get all your logic completed, <em>and</em> all your rendering done in 16ms or less, each and every frame. But that might be a bit more difficult than you think.</p></blockquote><blockquote><p>In this video, +Colt McAnlis takes a look at what “rendering performance” means to developers, alongside some of the most common pitfalls that are ran into; and let’s not forget the important stuff: the tools that help you track down, and fix these issues before they become large problems.</p></blockquote><h2 id="Android渲染知识"><a href="#Android渲染知识" class="headerlink" title="Android渲染知识"></a>Android渲染知识</h2><p>当你觉得自己开发了一个改变世界的应用的时候，你的用户可能并不会这么认为，他们认为你的应用又慢又卡，达不到他们所期望的那种顺滑，更谈不上改变这该死的世界了，回收站走你！等等！明明我这个应用在我的Nexus5上非常顺滑啊？你咋能说又慢又卡呢？如果你对Android的碎片化有一定了解的话，你就应该知道，很多低配置的手机并不像Nexus5那样有强大的处理器和GPU，以及没有被怎么污染的原生系统。</p><p>如果有大量的用户投诉说你的应用又卡又慢的时候，不要总是抱怨用户的低端手机，有时候问题就出在你的应用本身，也就意味着你的Android存在比较严重的渲染性能问题。只有真正了解问题发生的根源，才能有效的解决问题。所以了解Android渲染相关的知识，是一个Android开发者必不可少的知识。</p><a id="more"></a><h2 id="设计与性能"><a href="#设计与性能" class="headerlink" title="设计与性能"></a>设计与性能</h2><p>渲染问题是你建立一个应用程序是最经常碰到的问题，一方面，设计师希望展现给用户一个超自然的体验，另一方面，这些华丽的动画和视图并不能在所有的Android手机上都流畅地运行。所以这就是问题所在。</p><p><img src="/images/performance-1/1.png" alt="Design vs Performance"></p><h2 id="绘制原理"><a href="#绘制原理" class="headerlink" title="绘制原理"></a>绘制原理</h2><p>Android系统每16ms都会重新绘制一次你的Activity，也就是说，你的逻辑控制画面更新要保证最多16ms一帧才能每秒达到60帧（至于为什么是60帧，这个后面会有一个专题来讲解这个）。如下图，每一帧都在16ms内绘制完成，此时的世界是顺滑的。</p><p><img src="%5D(/images/performance-1/2.png" alt="Draw Good"></p><p>但是如果你的应用程序没有在16ms内完成这一帧的绘制，假设你花费了24ms来绘制这一帧，那么就会出现我们称之为<strong>掉帧</strong>的情况，世界变得有延迟了。如下图：</p><p><img src="%5D(%5D(/images/performance-1/3.png" alt="Draw Bad"></p><p>系统准备将新的一帧绘制到屏幕上，但是这一帧并没有准备好，所有就不会有绘制操作，画面也就不会刷新。反馈到用户身上，就是用户盯着同一张图看了32ms而不是16ms，也就是说掉帧发生了。</p><h2 id="掉帧"><a href="#掉帧" class="headerlink" title="掉帧"></a>掉帧</h2><p>掉帧是用户体验中一个非常核心的问题，用户将很容易察觉到由于掉帧而产生的卡顿感，如果此时用户正在与系统进行交互，比如滑动列表，或者正在打字，那么卡顿感是非常明显的。用户会马上对你的应用进行吐槽，下一步工作肯定是回收站走你！所以弄清楚掉帧的原因是非常重要的。</p><p>不过蛋疼的是，引起掉帧发生的原因非常多，比如：</p><ul><li><strong>你花了太多的时间重新绘制你视图中的大部分东西，这样非常浪费CPU周期</strong><br><img src="%5D(%5D(/images/performance-1/4.png" alt="Too Much View"></li><li><strong>你有太多的对象堆叠到了一起，你在绘制用户看不到的对象上花费了太多的时间</strong><br><img src="%5D(%5D(/images/performance-1/5.png" alt="Draw Hidden View"></li><li><strong>你有一大堆的动画重复了一遍又一遍，导致CPU和GPU组件的大量浪费</strong><br><img src="%5D(%5D(/images/performance-1/6.png" alt="Too Much Animations"></li></ul><h2 id="检测和解决"><a href="#检测和解决" class="headerlink" title="检测和解决"></a>检测和解决</h2><p>检测和解决这些问题很大程度上依赖于你的应用程序架构，但是幸运的是，我们有很多开发者工具来协助我们发现和解决这些问题，有些工具甚至能追踪到具体出错的代码行数或者UI控件，这些工具包括但不限于：</p><ul><li><h4 id="Hierarchy-View"><a href="#Hierarchy-View" class="headerlink" title="Hierarchy View"></a>Hierarchy View</h4><p><img src="%5D(%5D(/images/performance-1/7.png" alt="Hierarchy View"><br>你可以使用Hierarchy View 来查看你的View是否过于复杂，如果是，那么说明你有很多时间没有利用。并且浪费了许多时间进行重绘。<br>Hierarchy View 位于Android Device Monitor 中，Android Device Monitor在Eclipse和Android Studio中都有有对应的入口，依次选则Window-Open Perspective-Hierarchy View即可打开Hierarchy View视图。 Hierarchy View视图虽然比较简单，但是非常有效。花费一点了解这个工具每一个细节，对于以后排查问题来说都是事半功倍。关于Hierarchy View视图的用法，会有更详细的单独的教程来讲解。</p></li><li><h4 id="On-Device-Tools-–-Profile-GPU-Rendering-、Show-GPU-Overdraw、GPU-View-Updates"><a href="#On-Device-Tools-–-Profile-GPU-Rendering-、Show-GPU-Overdraw、GPU-View-Updates" class="headerlink" title="On-Device Tools – Profile GPU Rendering 、Show GPU Overdraw、GPU View Updates"></a>On-Device Tools – Profile GPU Rendering 、Show GPU Overdraw、GPU View Updates</h4><p><img src="%5D(%5D(/images/performance-1/8.png" alt="On-Device Tools"></p></li></ul><p>这三个选项在设置-辅助功能- 开发者选项中，默认都是关闭的。Profile GPU Rendering 和 GPU Overdraw比较重要，所以系列视频后面会有专门的专题会讲解，这里简单介绍一下GPU View Updates。GPU View Updates的作用是使用GPU进行绘图时闪烁显示窗口中的视图。随着android版本的更新，越来越多的绘制操作能使用GPU来完成，详见<a href="http://developer.android.com/guide/topics/graphics/hardware-accel.html" target="_blank" rel="noopener">http://developer.android.com/guide/topics/graphics/hardware-accel.html</a>，而这个工具打开之后，使用GPU绘制的区域会用红色来标注，而没有红色标注的区域，则是使用CPU绘制的。这个选项也可以用来查看redraw的区域大小。</p><ul><li><h4 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h4></li></ul><p><img src="%5D(%5D(/images/performance-1/9.png" alt="TraceView"></p><p>TraceView是一个很棒的检查是否掉帧的工具，视频中没有对此工具进行介绍，但是这个工具非常的重要，他可以找到你代码中花费时间的地方，精确到每一个函数，不论这个函数是你应用程序中的还是系统函数。另外在Android Studio中，TraceView得到了改进，其视图能非常直观的显示出每一帧所消耗的时间，函数像倒金字塔一般展现在面前，我们可以很容易地看出掉帧的地方以及那一帧里面所有的函数调用情况。鉴于此工具非常实用，所有会有更详细的单独的教程来讲解。</p><h2 id="Perf-Matters"><a href="#Perf-Matters" class="headerlink" title="Perf Matters"></a>Perf Matters</h2><blockquote><p>keep calm, profile your code, and always remember, Perf Matters</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是这个系列视频的第一个视频，从内容上来看，是从一个大的角度来看Render Performance，简单地讲述了一下Render Performance基本的概念，出现的原因以及排查的工具。在发现问题–定位问题–解决问题的流程上属于发现问题–定位问题，解决问题则基本没有提到。这也基本符合这一系列视频的基调：即着重于发现问题(使用工具发现问题、挖掘问题出现的原理和原因)和定位问题(使用工具定位)，如何解决问题则需要自己通过实战去进行锻炼，毕竟这种问题并没有一个通用的解决方法，每个应用都有每个应用自己的问题。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化典范综述</title>
      <link href="/2015/04/19/Android-Performance-Patterns/"/>
      <url>/2015/04/19/Android-Performance-Patterns/</url>
      
        <content type="html"><![CDATA[<p>系列文章目录：</p><ol><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns/" target="_blank" rel="noopener">Android性能优化典范综述</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-1/" target="_blank" rel="noopener">Android性能优化典范之Render Performance</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-2/" target="_blank" rel="noopener">Android性能优化典范之Understanding Overdraw</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-3/" target="_blank" rel="noopener">Android性能优化典范之Understanding VSYNC</a></li><li><a href="https://www.androidperformance.com/2015/04/19/Android-Performance-Patterns-4/" target="_blank" rel="noopener">Android性能优化典范之Profile GPU Rendering</a></li></ol><hr><p>2015年1月6日，Google官方发布了一系列关于Android性能优化的小视频，将其命名为Android Performance Patterns，这一些列视频放在<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="noopener">YouTube</a>上，观看的话需要科学地上网。</p><p><img src="/images/performance-0/1.jpg" alt="Android性能优化典范"></p><p>官方简介：</p><blockquote><p>Android Performance Patterns is a collection of videos focused entirely on helping developers write faster, more performant Android Applications. On one side, it’s about peeling back the layers of the Android System, and exposing how things are working under the hood. On the other side, it’s about teaching you how the tools work, and what to look for in order to extract the right perf out of your app.<br>But at the end of the day, Android Performance Patterns is all giving you the right resources, at the right time to help make the fastest, smoothest, most awesome experience for your users. And that’s the whole point, right?</p></blockquote><p>总之就是一系列讲解Android性能相关的视频。这些小视频的时间非常短，在3-5分钟之内，主讲人的英文语速也非常快，初期这些视频没有翻译的时候，着实考验了一把听力。好消息是现在这些视频已经都有中英文字幕了。</p><p>这些视频的时间虽然很短，但是信息量却非常大，有些他一句话带过的内容，我们却需要花费很多的时间去研究他的原理，或者研究一个调试工具如何使用。也就是说，这一系列视频并没有真正教你如何去优化你的应用，而是告诉你关于Android性能优化你需要知道的知识，这样你去优化你的Android应用的时候，<strong>知道该用什么工具，该采取什么样的步骤，需要达到什么样的目标。</strong></p><a id="more"></a><p>由于我最近也在研究Android性能优化相关的课题，这个视频第一时间出来的时候我就看了好几遍，所以一早就有将这一系列视频翻译成中文的想法。后来看了几遍之后，我发现仅仅翻译成中文其实意义不大，他所讲述的每一个知识点，都是可以写成一篇博文甚至好几篇博文的，所以就有了这一系列文章的出现。</p><p>每一篇文章中，我都会先将视频中涉及到的知识点列出来，然后一一进行讲解。有些调试工具由于篇幅原因，可能会写到单独的博文中。</p><p>另外催生我写这一系列文章的是胡凯，他的博客 <a href="http://hukai.me/android-performance-patterns" target="_blank" rel="noopener">http://hukai.me/android-performance-patterns</a> 第一时间就将这一些列视频的内容翻译成了中文，优美的排版加上过硬的翻译，让这篇博文被广泛传播，备受好评。同时他也是github上 <a href="https://github.com/kesenhoo/android-training-course-in-chinese" target="_blank" rel="noopener">android-training-course-in-chinese</a> 项目的发起人，他的Github主页：<a href="https://github.com/kesenhoo" target="_blank" rel="noopener">https://github.com/kesenhoo</a>。他对于分享的热情我非常敬佩。如果你并非是Android应用开发者或者对技术细节不感兴趣的话，直接看他的那篇Android性能优化典范即可，看完之后你会对这一些列视频有一个大概的认识。</p><p>下面是关于Android性能优化典范这一些列视频的一些资源信息：</p><ul><li>YouTube主页：<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="noopener">Android Performance Patterns</a></li><li>作者Google+主页：</li><li>Android Performance Patterns的Google+社群：</li></ul><p>OK，Let us start！！！</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Performance </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 内存优化之三 - 打开 MAT 中的 Bitmap 原图</title>
      <link href="/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/"/>
      <url>/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/</url>
      
        <content type="html"><![CDATA[<p>本文是 MAT 工具使用系列的第二篇，这个系列共三篇，详细介绍了如何使用 MAT 来分析内存问题，既可以是 Java 应用的内存问题，也可以是 Android 应用的内存问题：</p><ol><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/" target="_blank" rel="noopener">Android 内存优化之一：MAT 使用入门</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/" target="_blank" rel="noopener">Android内存优化之二：MAT使用进阶</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/" target="_blank" rel="noopener">Android内存优化之三：打开MAT中的Bitmap原图</a></li></ol><p>在使用MAT查看应用程序内存使用情况的时候,我们经常会碰到Bitmap对象以及BitmapDrawable$BitmapState对象,而且在内存使用上,Bitmap所占用的内存占大多数.在这样的情况下, Bitmap所造成的内存泄露尤其严重, 需要及时发现并且及时处理.在这样的需求下, 当我们在MAT中发现和图片相关的内存泄露的时候, 如果能知道是那一张图片,对分析问题会有很大的帮助.</p><p>本文就介绍如何将MAT中的Bitmap数组对象还原成一张图片。</p><a id="more"></a><p>Bitmap对象如图:</p><p><img src="/images/MAT_OpenBitmap/Image_1.png" alt="Bitmap对象"></p><h2 id="导出Bitmap原始数据"><a href="#导出Bitmap原始数据" class="headerlink" title="导出Bitmap原始数据"></a>导出Bitmap原始数据</h2><p>在MAT中打开Dominator Tree视图 , 选择一个Bitmap对象 , 查看此时右边的Inspector窗口,内容如下图: </p><p><img src="/images/MAT_OpenBitmap/Image_2.png" alt="image"></p><p>这个视图中,可以看到这个Bitmap的一些基本的信息: mBuffer, mHeight, mWidth , mNativeBitmap等, 宽和高的值我们一会需要用的到 . </p><p>mBuffer的定义在Bitmap.java中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backing buffer for the Bitmap.</span></span><br><span class="line"><span class="comment"> * Made public for quick access from drawing methods -- do NOT modify</span></span><br><span class="line"><span class="comment"> * from outside this class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"UnusedDeclaration"</span>) <span class="comment">// native code only</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] mBuffer;</span><br></pre></td></tr></table></figure><p>其值是保存在byte数组中的, 我们需要的就是这个byte数组中的内容. 在Inspector窗口的mBuffer这一栏或者Dominator Tree视图的Bitmap这一栏点开下一级,都可以看到这个byte数组的内容. 鼠标右键选择Copy –&gt;Save Value To File. 弹出如下对话框:</p><p><img src="/images/MAT_OpenBitmap/Image_3.png" alt="image"></p><p>选择存储路径和文件名,这里需要注意的是,<strong>文件名一定要以 .data为后缀</strong>,否则无法正常使用,切记.</p><h2 id="打开原始资源数据"><a href="#打开原始资源数据" class="headerlink" title="打开原始资源数据"></a>打开原始资源数据</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>这时需要借助Linux上强大的图片应用:GIMP,没安装的可以去安装一下. 安装好之后, 打开GIMP,选择文件-打开.选择我们上一步导出的.data文件(比如image.data),然后会出现如下图的属性框:</p><p><img src="/images/MAT_OpenBitmap/Image_4.png" alt="image"></p><p>图像类型这一栏选择RGB Alpha, 宽度和高度必填, 其值可以在MAT中查看到,第一步的时候有说到这个值的位置, 其他的选择默认即可,然后点击打开. GIMP就会把这个文件打开.</p><h3 id="Mac-amp-amp-Windows"><a href="#Mac-amp-amp-Windows" class="headerlink" title="Mac &amp;&amp; Windows"></a>Mac &amp;&amp; Windows</h3><p>Mac和Windows可以选择使用PhotoShop作为打开的工具, 和Linux唯一不同的地方在于. 保存的文件的格式需要以.raw结尾 (比如image.raw),选择深度为32位. 其余的和Linux相同.</p><p>另外GIMP也有Mac、Windows版本，建议大家在各个平台都使用GIMP，这样学习成本比较低，而且GIMP为免费软件，使用起来功能也非常多。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 内存优化之二 - MAT使用进阶</title>
      <link href="/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/"/>
      <url>/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/</url>
      
        <content type="html"><![CDATA[<p>本文是 MAT 工具使用系列的第二篇，这个系列共三篇，详细介绍了如何使用 MAT 来分析内存问题，既可以是 Java 应用的内存问题，也可以是 Android 应用的内存问题：</p><ol><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/" target="_blank" rel="noopener">Android 内存优化之一：MAT 使用入门</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/" target="_blank" rel="noopener">Android内存优化之二：MAT使用进阶</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/" target="_blank" rel="noopener">Android内存优化之三：打开MAT中的Bitmap原图</a></li></ol><h1 id="Java的内存泄露的特点"><a href="#Java的内存泄露的特点" class="headerlink" title="Java的内存泄露的特点"></a>Java的内存泄露的特点</h1><ul><li>Java中的内存泄露主要特征：可达，无用</li><li>无用指的是创建了但是不再使用之后没有释放</li><li>能重用但是却创建了新的对象进行处理</li></ul><h1 id="MAT使用技巧进阶"><a href="#MAT使用技巧进阶" class="headerlink" title="MAT使用技巧进阶"></a>MAT使用技巧进阶</h1><h2 id="使用Android-Studio-Dump内存文件"><a href="#使用Android-Studio-Dump内存文件" class="headerlink" title="使用Android Studio Dump内存文件"></a>使用Android Studio Dump内存文件</h2><p>Android Studio的最新版本可以直接获取hprof文件：</p><p><img src="/images/MAT_Pro/MAT_1.png" alt="Android-Studio"></p><a id="more"></a><p>然后选择文件，点击右键转换成标准的hprof文件，就可以在MAT中打开了。</p><blockquote><p>在使用使用Eclipse或者AndroidStudio抓内存之前，一定要手动点击 Initiate GC按钮手动触发GC，这样抓到的内存使用情况就是不包括Unreachable对象的。</p></blockquote><blockquote><p><img src="/images/MAT_Pro/MAT_2.png" alt="手动触发GC"></p></blockquote><h2 id="Unreachable对象"><a href="#Unreachable对象" class="headerlink" title="Unreachable对象"></a>Unreachable对象</h2><p>Unreachable指的是可以被垃圾回收器回收的对象，但是由于没有GC发生，所以没有释放，这时抓的内存使用中的Unreachable就是这些对象。</p><p><img src="/images/MAT_Pro/MAT_3.png" alt="Unreachable Objects"></p><p><img src="/images/MAT_Pro/MAT_4.png" alt="Unreachable Objects Histogram"></p><p>点击Calculate Retained Size之后，会出现Retained Size这一列</p><p><img src="/images/MAT_Pro/MAT_5.png" alt="Calculate Retained Size"></p><p><img src="/images/MAT_Pro/MAT_6.png" alt="Unreachable Objects Histogram"></p><p>可以看到Unreachable Object的对象其Retained Heap值都为0.这也是正常的。</p><h2 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h2><p>MAT中Histogram的主要作用是查看一个instance的数量，一般用来查看自己创建的类的实例的个数。</p><ul><li>可以很容易的找出占用内存最多的几个对象，根据Percentage（百分比）来排序。</li><li>可以分不同维度来查看对象的Dominator Tree视图，Group by class、Group by class  loader、Group by package<br>和Histogram类似，时间久了，通过多次对比也可以把溢出对象找出来。</li><li>Dominator Tree和Histogram的区别是站的角度不一样，Histogram是站在类的角度上去看，Dominator Tree是站的对象实例的角度上看，Dominator Tree可以更方便的看出其引用关系。</li></ul><p><img src="/images/MAT_Pro/MAT_7.png" alt="Histogram group by package"></p><p>通过查看Object的个数，结合代码就可以找出存在内存泄露的类（<strong>即可达但是无用的对象，或者是可以重用但是重新创建的对象</strong>）</p><p>Histogram中还可以对对象进行Group，更方便查看自己Package中的对象信息。</p><p><img src="/images/MAT_Pro/MAT_8.png" alt="Paste_Image.png"></p><h3 id="Thread信息"><a href="#Thread信息" class="headerlink" title="Thread信息"></a>Thread信息</h3><p>MAT中可以查看当前的Thread信息：</p><p><img src="/images/MAT_Pro/MAT_9.png" alt="Thread"></p><p>从图中可以得到的信息：</p><ol><li><p>可以看到可能有内存问题的Thread：</p><p><img src="/images/MAT_Pro/MAT_10.png" alt="内存异常"></p></li><li><p>可以看到数量可能有问题的Thread</p><p><img src="/images/MAT_Pro/MAT_11.png" alt="数量异常"></p></li></ol><h2 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h2><p>MAT中的各个视图中，在每一个Item中点击右键会出现很多选项，很多时候我们需要依赖这些选项来进行分析：</p><p><img src="/images/MAT_Pro/MAT_12.png" alt="右键选项"></p><p>这些选项的具体含义则可以通过右键中的Search Queries这个选项(上图中的倒数第四个选项)进行搜索和查看，非常的有用。</p><p><img src="/images/MAT_Pro/MAT_13.png" alt="帮助信息"></p><p>可以看到，所有的命令其实就是配置不同的SQL查询语句。</p><p>比如我们最常用的：</p><ul><li><strong>List objects -&gt; with incoming references</strong>：查看这个对象持有的外部对象引用</li><li><strong>List objects -&gt; with outcoming references</strong>：查看这个对象被哪些外部对象引用</li><li><strong>Path To GC Roots -&gt; exclude all phantim/weak/soft etc. references</strong>：查看这个对象的GC Root，不包含虚、弱引用、软引用，剩下的就是强引用。从GC上说，除了强引用外，其他的引用在JVM需要的情况下是都可以 被GC掉的，如果一个对象始终无法被GC，就是因为强引用的存在，从而导致在GC的过程中一直得不到回收，因此就内存溢出了。</li><li><strong>Path To GC Roots  -&gt; exclude weak/soft references</strong>：查看这个对象的GC Root，不含弱引用和软引用所有的引用.</li><li>*<em>Merge Shortest path to GC root *</em>：找到从GC根节点到一个对象或一组对象的共同路径</li></ul><h2 id="Debug-Bitmap"><a href="#Debug-Bitmap" class="headerlink" title="Debug Bitmap"></a>Debug Bitmap</h2><p>如果经常使用MAT分析内存，就会发现Bitmap所占用的内存是非常大的，这个和其实际显示面积是有关系的。在2K屏幕上，一张Bitmap能达到20MB的大小。</p><p>所以要是MAT提供了一种方法，可以将存储Bitmap的byte数组导出来，使用第三方工具打开。这个大大提高了我们分析内存泄露的效率。</p><p>关于这个方法的操作流程，可以参考这篇文章<a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/" target="_blank" rel="noopener">还原MAT中的Bitmap图像</a>.<br>I</p><h2 id="Debug-ArrayList"><a href="#Debug-ArrayList" class="headerlink" title="Debug ArrayList"></a>Debug ArrayList</h2><p>ArrayList是使用非常常用的一个数据结构，在MAT中，如果想知道ArrayList中有哪些数据，需要右键-&gt; List Objects -&gt; With outgoing references,然后可以看到下面的图：</p><p><img src="/images/MAT_Pro/MAT_14.png" alt="Outgoing"></p><p>从上图可以看到，这个ArrayList的内容在一个array数组中，即暴漏了ArrayList的内部结构，查看的时候有点不方便，所以MAT提供了另外一种查看ArrayList内数据的方式：</p><p><img src="/images/MAT_Pro/MAT_15.png" alt="Extrace List Values"></p><p>其结果非常直观：</p><p><img src="/images/MAT_Pro/MAT_16.png" alt="Extrace List Values Result"></p><h2 id="Big-Drops-In-Dominator-Tree"><a href="#Big-Drops-In-Dominator-Tree" class="headerlink" title="Big Drops In Dominator Tree"></a>Big Drops In Dominator Tree</h2><p>Big Drops In Dominator Tree选项在右键-&gt;</p><blockquote><p>Displays memory accumulation points in the dominator tree. Displayed are objects with a big difference between the retained size of the parent and the children and the first “interesting” dominator of the accumulation point. These are places where the memory of many small objects is accumulated under one object.</p></blockquote><p><img src="/images/MAT_Pro/MAT_17.png" alt="Big Drops In Dominator Tree"></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 内存优化(1) - MAT 使用入门</title>
      <link href="/2015/04/11/AndroidMemory-Usage-Of-MAT/"/>
      <url>/2015/04/11/AndroidMemory-Usage-Of-MAT/</url>
      
        <content type="html"><![CDATA[<p>本文是 MAT 工具使用系列的第一篇，这个系列共三篇，详细介绍了如何使用 MAT 来分析内存问题，既可以是 Java 应用的内存问题，也可以是 Android 应用的内存问题：</p><ol><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/" target="_blank" rel="noopener">Android 内存优化(1) - MAT 使用入门</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro/" target="_blank" rel="noopener">Android 内存优化(2) - MAT使用进阶</a></li><li><a href="https://www.androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT/" target="_blank" rel="noopener">Android 内存优化(3) - 打开MAT中的Bitmap原图</a></li></ol><h1 id="MAT简介"><a href="#MAT简介" class="headerlink" title="MAT简介"></a>MAT简介</h1><h2 id="MAT介绍"><a href="#MAT介绍" class="headerlink" title="MAT介绍"></a>MAT介绍</h2><p>MAT(Memory Analyzer Tool)，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。  </p><p><img src="/images/MAT/MAT_Intro.png" alt="image"></p><p>当然MAT也有独立的不依赖Eclipse的版本，只不过这个版本在调试Android内存的时候，需要将DDMS生成的文件进行转换，才可以在独立版本的MAT上打开。不过Android SDK中已经提供了这个Tools，所以使用起来也是很方便的。</p><a id="more"></a><h2 id="MAT工具的下载安装"><a href="#MAT工具的下载安装" class="headerlink" title="MAT工具的下载安装"></a>MAT工具的下载安装</h2><p>这里是MAT的下载地址：[<a href="https://eclipse.org/mat/downloads.php]" target="_blank" rel="noopener">https://eclipse.org/mat/downloads.php]</a>(<a href="https://eclipse.org/mat/" target="_blank" rel="noopener">https://eclipse.org/mat/</a> downloads.php)，下载时会提供三种选择的方式：</p><p><img src="/images/MAT/MAT_Download.png" alt="image"></p><ul><li>Update Site  这种方式后面会有一个网址：比如<a href="http://download.eclipse.org/mat/1.4/update-site/" target="_blank" rel="noopener">http://download.eclipse.org/mat/1.4/update-site/</a> ，安装过Eclipse插件的同学应该知道，只要把这段网址复制到对应的Eclipse的Install New Software那里，就可以进行在线下载了。</li></ul><p><img src="/images/MAT/MAT_Eclipse_Install.png" alt="image"></p><ul><li>Archived Update Site  这种方式安装的位置和上一种差不多，只不过第一种是在线下载，这一种是使用离线包进行更新，这种方式劣势是当这个插件更新后，需要重新下载离线包，而第一种方式则可以在线下载更新。</li><li>Stand-alone Eclipse RCP Applications 这种方式就是把MAT当成一个独立的工具使用，不再依附于Eclipse，适合不使用Eclipse而使用Android Studio的同学。这种方式有个麻烦的地方就是DDMS导出的文件，需要进行转换才可以在MAT中打开。</li></ul><p>下载安装好之后，就可以使用MAT进行实际的操作了。</p><h1 id="Android-Java-中常见的容易引起内存泄露的不良代码"><a href="#Android-Java-中常见的容易引起内存泄露的不良代码" class="headerlink" title="Android(Java)中常见的容易引起内存泄露的不良代码"></a>Android(Java)中常见的容易引起内存泄露的不良代码</h1><h2 id="Android内存"><a href="#Android内存" class="headerlink" title="Android内存"></a>Android内存</h2><p>使用MAT工具之前，要对Android的内存分配方式有基本的了解，对容易引起内存泄露的代码也要保持敏感，在代码级别对内存泄露的排查，有助于内存的使用。</p><p>Android主要应用在嵌入式设备当中，而嵌入式设备由于一些众所周知的条件限制，通常都不会有很高的配置，特别是内存是比较有限的。如果我们编写的代码当中有太多的对内存使用不当的地方，难免会使得我们的设备运行缓慢，甚至是死机。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。一方面，如果程序在运行过程中出现了内存泄漏的问题，仅仅会使得自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。另一方面Android为不同类型的进程分配了不同的内存使用上限，如果应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉。</p><h2 id="常见的内存使用不当的情况"><a href="#常见的内存使用不当的情况" class="headerlink" title="常见的内存使用不当的情况"></a>常见的内存使用不当的情况</h2><h3 id="查询数据库没有关闭游标"><a href="#查询数据库没有关闭游标" class="headerlink" title="查询数据库没有关闭游标"></a>查询数据库没有关闭游标</h3><p>描述：<br>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = getContentResolver().query(uri ...);</span><br><span class="line"><span class="keyword">if</span> (cursor.moveToNext()) &#123;</span><br><span class="line"> ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修正示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  cursor = getContentResolver().query(uri ...);</span><br><span class="line"><span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToNext()) &#123;</span><br><span class="line">... ... </span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">cursor.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//ignore this</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`</p><h3 id="构造Adapter时，没有使用缓存的-convertView"><a href="#构造Adapter时，没有使用缓存的-convertView" class="headerlink" title="构造Adapter时，没有使用缓存的 convertView"></a>构造Adapter时，没有使用缓存的 convertView</h3><p>描述：以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span></span></span><br></pre></td></tr></table></figure><p>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。ListView回收list item的view对象的过程可以查看:android.widget.AbsListView.java –&gt; void addScrapView(View scrap) 方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line"> View view = <span class="keyword">new</span> Xxx(...);</span><br><span class="line"> ... ...</span><br><span class="line"> <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`<br>示例修正代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line"> View view = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (convertView != <span class="keyword">null</span>) &#123;</span><br><span class="line"> view = convertView;</span><br><span class="line"> populate(view, getItem(position));</span><br><span class="line"> ...</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> view = <span class="keyword">new</span> Xxx(...);</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ListView的使用和优化，可以参考这两篇文章：</p><ul><li><a href="">Using lists in Android (ListView) - Tutorial  </a>](<a href="http://www.vogella.com/tutorials/AndroidListView/article.html" target="_blank" rel="noopener">http://www.vogella.com/tutorials/AndroidListView/article.html</a>)</li><li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="noopener">Making ListView Scrolling Smooth</a></li></ul><h3 id="Bitmap对象不在使用时调用recycle-释放内存"><a href="#Bitmap对象不在使用时调用recycle-释放内存" class="headerlink" title="Bitmap对象不在使用时调用recycle()释放内存"></a>Bitmap对象不在使用时调用recycle()释放内存</h3><p>描述：有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存。<br>另外在最新版本的Android开发时，使用下面的方法也可以释放此Bitmap所占用的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap ;</span><br><span class="line"> ...</span><br><span class="line"> bitmap初始化以及使用</span><br><span class="line"> ...</span><br><span class="line">bitmap = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="释放对象的引用"><a href="#释放对象的引用" class="headerlink" title="释放对象的引用"></a>释放对象的引用</h3><p>描述：这种情况描述起来比较麻烦，举两个例子进行说明。</p><p>示例A：<br>假设有如下操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">private</span> Handler mHandler = ...</span><br><span class="line"><span class="keyword">private</span> Object obj;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> obj = initObj();</span><br><span class="line"> ...</span><br><span class="line"> [Mark]</span><br><span class="line"> mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         useObj(obj);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个成员变量 obj，在operation()中我们希望能够将处理obj实例的操作post到某个线程的MessageQueue中。在以上的代码中，即便是mHandler所在的线程使用完了obj所引用的对象，但这个对象仍然不会被垃圾回收掉，因为DemoActivity.obj还保有这个对象的引用。所以如果在DemoActivity中不再使用这个对象了，可以在[Mark]的位置释放对象的引用，而代码可以修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">obj = initObj();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> Object o = obj;</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useObj(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例B：<br>假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。  </p><p>但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process进程挂掉。</p><p>总之当一个生命周期较短的对象A，被一个生命周期较长的对象B保有其引用的情况下，在A的生命周期结束时，要在B中清除掉对A的引用。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Android应用程序中最典型的需要注意释放资源的情况是在Activity的生命周期中，在onPause()、onStop()、onDestroy()方法中需要适当的释放资源的情况。由于此情况很基础，在此不详细说明，具体可以查看官方文档对Activity生命周期的介绍，以明确何时应该释放哪些资源。</p><p>另外一些其他的例子，将会在补充版本加入。</p><h1 id="使用MAT进行内存调试"><a href="#使用MAT进行内存调试" class="headerlink" title="使用MAT进行内存调试"></a>使用MAT进行内存调试</h1><h2 id="获取HPROF文件"><a href="#获取HPROF文件" class="headerlink" title="获取HPROF文件"></a>获取HPROF文件</h2><p>HPROF文件是MAT能识别的文件，HPROF文件存储的是特定时间点，java进程的内存快照。有不同的格式来存储这些数据，总的来说包含了快照被触发时java对象和类在heap中的情况。由于快照只是一瞬间的事情，所以heap dump中无法包含一个对象在何时、何地（哪个方法中）被分配这样的信息。<br>这个文件可以使用DDMS导出：</p><ol><li><p>DDMS中在Devices上面有一排按钮，选择一个进程后（即在Devices下面列出的列表中选择你要调试的应用程序的包名），点击Dump HPROF file 按钮：</p><p><img src="/images/MAT/MAT_DDMS_ExportFile.png" alt="image">  </p></li></ol><p>选择存储路径保存后就可以得到对应进程的HPROF文件。eclipse插件可以把上面的工作一键完成。只需要点击Dump HPROF file图标，然后MAT插件就会自动转换格式，并且在eclipse中打开分析结果。eclipse中还专门有个Memory Analysis视图  </p><ol><li>得到对应的文件后，如果安装了Eclipse插件，那么切换到Memory Analyzer视图。使用独立安装的，要使用Android SDK自带的的工具（hprof-conv 位置在sdk/platform-tools/hprof-conv）进行转换</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv xxx.xxx.xxx.hprof xxx.xxx.xxx.hprof</span><br></pre></td></tr></table></figure><p>转换过后的.hprof文件即可使用MAT工具打开了。</p><h2 id="MAT主界面介绍"><a href="#MAT主界面介绍" class="headerlink" title="MAT主界面介绍"></a>MAT主界面介绍</h2><p>这里介绍的不是MAT这个工具的主界面，而是导入一个文件之后，显示OverView的界面。</p><ul><li>打开经过转换的hprof文件：<br>  <img src="/images/MAT/MAT_OpenFile.png" alt="image"></li></ul><p>如果选择了第一个，则会生成一个报告。这个无大碍。  </p><p><img src="/images/MAT/MAT_Report.png" alt="image"></p><ul><li><p>选择OverView界面：  </p><p><img src="/images/MAT/MAT_Overview.png" alt="Image"></p></li></ul><p>我们需要关注的是下面的Actions区域</p><ul><li><p>Histogram：列出内存中的对象，对象的个数以及大小  </p><p><img src="/images/MAT/MAT_Histogram.png" alt="image"></p></li><li><p>Dominator Tree：列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）  </p><p><img src="/images/MAT/MAT_DominatorTree.png" alt="image"></p></li><li><p>Top Consumers ： 通过图形列出最大的object  </p><p><img src="/images/MAT/MAT_TopConsumers.png" alt="image"></p></li><li><p>Duplicate Class：通过MAT自动分析泄漏的原因</p></li></ul><p>一般Histogram和 Dominator Tree是最常用的。  </p><h2 id="MAT中一些概念介绍"><a href="#MAT中一些概念介绍" class="headerlink" title="MAT中一些概念介绍"></a>MAT中一些概念介绍</h2><p>要看懂MAT的列表信息，Shallow heap、Retained Heap、GC Root这几个概念一定要弄懂。</p><h3 id="3-3-1-Shallow-heap"><a href="#3-3-1-Shallow-heap" class="headerlink" title="3.3.1 Shallow heap"></a>3.3.1 Shallow heap</h3><p>Shallow size就是对象本身占用内存的大小，不包含其引用的对象。  </p><ul><li>常规对象（非数组）的Shallow size有其成员变量的数量和类型决定。</li><li>数组的shallow size有数组元素的类型（对象类型、基本类型）和数组长度决定</li></ul><p>因为不像c++的对象本身可以存放大量内存，java的对象成员都是些引用。真正的内存都在堆上，看起来是一堆原生的byte[], char[], int[]，所以我们如果只看对象本身的内存，那么数量都很小。所以我们看到Histogram图是以Shallow size进行排序的，排在第一位第二位的是byte，char 。</p><h3 id="3-3-2-Retained-Heap"><a href="#3-3-2-Retained-Heap" class="headerlink" title="3.3.2 Retained Heap"></a>3.3.2 Retained Heap</h3><p>Retained Heap的概念，它表示如果一个对象被释放掉，那会因为该对象的释放而减少引用进而被释放的所有的对象（包括被递归释放的）所占用的heap大小。于是，如果一个对象的某个成员new了一大块int数组，那这个int数组也可以计算到这个对象中。相对于shallow heap，Retained heap可以更精确的反映一个对象实际占用的大小（因为如果该对象释放，retained heap都可以被释放）。</p><p>这里要说一下的是，Retained Heap并不总是那么有效。例如我在A里new了一块内存，赋值给A的一个成员变量。此时我让B也指向这块内存。此时，因为A和B都引用到这块内存，所以A释放时，该内存不会被释放。所以这块内存不会被计算到A或者B的Retained Heap中。为了纠正这点，MAT中的Leading Object（例如A或者B）不一定只是一个对象，也可以是多个对象。此时，(A, B)这个组合的Retained Set就包含那块大内存了。对应到MAT的UI中，在Histogram中，可以选择Group By class, superclass or package来选择这个组。</p><p>为了计算Retained Memory，MAT引入了Dominator Tree。加入对象A引用B和C，B和C又都引用到D（一个菱形）。此时要计算Retained Memory，A的包括A本身和B，C，D。B和C因为共同引用D，所以他俩的Retained Memory都只是他们本身。D当然也只是自己。我觉得是为了加快计算的速度，MAT改变了对象引用图，而转换成一个对象引用树。在这里例子中，树根是A，而B，C，D是他的三个儿子。B，C，D不再有相互关系。把引用图变成引用树，计算Retained Heap就会非常方便，显示也非常方便。对应到MAT UI上，在dominator tree这个view中，显示了每个对象的shallow heap和retained heap。然后可以以该节点位树根，一步步的细化看看retained heap到底是用在什么地方了。要说一下的是，这种从图到树的转换确实方便了内存分析，但有时候会让人有些疑惑。本来对象B是对象A的一个成员，但因为B还被C引用，所以B在树中并不在A下面，而很可能是平级。</p><p>为了纠正这点，MAT中点击右键，可以List objects中选择with outgoing references和with incoming references。这是个真正的引用图的概念，</p><ul><li>outgoing references ：表示该对象的出节点（被该对象引用的对象）。</li><li>incoming references ：表示该对象的入节点（引用到该对象的对象）。</li></ul><p>为了更好地理解Retained Heap，下面引用一个例子来说明：  </p><p>把内存中的对象看成下图中的节点，并且对象和对象之间互相引用。这里有一个特殊的节点GC Roots，这就是reference chain(引用链)的起点:<br><img src="/images/MAT/MAT_Retained_objects.png" alt="image"> <img src="/images/MAT/MAT_Retained_objects_2.png" alt="image"></p><p>从obj1入手，上图中蓝色节点代表仅仅只有通过obj1才能直接或间接访问的对象。因为可以通过GC Roots访问，所以左图的obj3不是蓝色节点；而在右图却是蓝色，因为它已经被包含在retained集合内。<br>所以对于左图，obj1的retained size是obj1、obj2、obj4的shallow size总和；<br>右图的retained size是obj1、obj2、obj3、obj4的shallow size总和。<br>obj2的retained size可以通过相同的方式计算。</p><h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3><p>GC发现通过任何reference chain(引用链)无法访问某个对象的时候，该对象即被回收。名词GC Roots正是分析这一过程的起点，例如JVM自己确保了对象的可到达性(那么JVM就是GC Roots)，所以GC Roots就是这样在内存中保持对象可到达性的，一旦不可到达，即被回收。通常GC Roots是一个在current thread(当前线程)的call stack(调用栈)上的对象（例如方法参数和局部变量），或者是线程自身或者是system class loader(系统类加载器)加载的类以及native code(本地代码)保留的活动对象。所以GC Roots是分析对象为何还存活于内存中的利器。</p><h2 id="MAT中的一些有用的视图"><a href="#MAT中的一些有用的视图" class="headerlink" title="MAT中的一些有用的视图"></a>MAT中的一些有用的视图</h2><h3 id="Thread-OvewView"><a href="#Thread-OvewView" class="headerlink" title="Thread OvewView"></a>Thread OvewView</h3><p>Thread OvewView可以查看这个应用的Thread信息：<br><img src="/images/MAT/MAT_ThreadOverView.png" alt="image"></p><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p>在Histogram和Domiantor Tree界面，可以选择将结果用另一种Group的方式显示（默认是Group by Object），切换到Group by package，可以更好地查看具体是哪个包里的类占用内存大，也很容易定位到自己的应用程序。<br><img src="/images/MAT/MAT_Group.png" alt="image"></p><h3 id="Path-to-GC-Root"><a href="#Path-to-GC-Root" class="headerlink" title="Path to GC Root"></a>Path to GC Root</h3><p>在Histogram或者Domiantor Tree的某一个条目上，右键可以查看其GC Root Path：<br><img src="/images/MAT/MAT_PathToGCRoot.png" alt="image"></p><p>这里也要说明一下Java的引用规则：<br>从最强到最弱，不同的引用（可到达性）级别反映了对象的生命周期。  </p><ul><li>Strong Ref(强引用)：通常我们编写的代码都是Strong Ref，于此对应的是强可达性，只有去掉强可达，对象才被回收。</li><li>Soft Ref(软引用)：对应软可达性，只要有足够的内存，就一直保持对象，直到发现内存吃紧且没有Strong Ref时才回收对象。一般可用来实现缓存，通过java.lang.ref.SoftReference类实现。</li><li>Weak Ref(弱引用)：比Soft Ref更弱，当发现不存在Strong Ref时，立刻回收对象而不必等到内存吃紧的时候。通过java.lang.ref.WeakReference和java.util.WeakHashMap类实现。</li><li>Phantom Ref(虚引用)：根本不会在内存中保持任何对象，你只能使用Phantom Ref本身。一般用于在进入finalize()方法后进行特殊的清理过程，通过 java.lang.ref.PhantomReference实现。</li></ul><p>点击Path To GC Roots –&gt; with all references<br><img src="/images/MAT/MAT_PathToGCRoot_Detail.png" alt="image"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="http://www.yourkit.com/docs/java/help/sizes.jsp" target="_blank" rel="noopener">Shallow and retained sizes</a></li><li>MAT的wiki：<a href="http://wiki.eclipse.org/index.php/MemoryAnalyzer" target="_blank" rel="noopener">http://wiki.eclipse.org/index.php/MemoryAnalyzer</a></li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android性能优化后续</title>
      <link href="/2015/03/31/android-performance-case-study-follow-up/"/>
      <url>/2015/03/31/android-performance-case-study-follow-up/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是一篇译文，原文<a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/?utm_source=Android+Weekly&utm_campaign=0692ef161b-Android_Weekly_146&utm_medium=email&utm_term=0_4eb677ad19-0692ef161b-337850757" target="_blank" rel="noopener">Android Performance Case Study Follow-up</a>的作者是大名鼎鼎的<a href="http://www.curious-creature.com/" target="_blank" rel="noopener">Romain Guy</a>。本文讲述了Android性能优化的一些技巧、方法和工具。</p><h1 id="译文正文"><a href="#译文正文" class="headerlink" title="译文正文"></a>译文正文</h1><p>两年前，我发表了一篇名为<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study/" target="_blank" rel="noopener">Android Performance Case Study</a> 的文章，来帮助Android开发者了解需要使用什么工具和技术手段来确定、追踪和优化性能问题。</p><p>那篇文章以一个Twitter客户端 <a href="https://play.google.com/store/apps/details?id=com.jv.materialfalcon" target="_blank" rel="noopener">Falcon Pro</a>为典范，其开发人员为 Joaquim Vergès. Joaquim人不错，他允许我在我的文章中使用它的程序作为例子，并且快速处理了我发现的所有问题。一切都OK，直到Joaquim 从头开始开发Falcon Pro 3，前不久在他准备发布它的新应用的时候，他联系了我，因为他有一个和滚动相关的性能问题需要我来帮助他，这一次我依然没有源代码可以参考。</p><a id="more"></a><p>Joaquim使用了所有的工具来找出问题所在，他发现Overdraw不是问题的原因，他觉得是 <a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html" target="_blank" rel="noopener">ViewPager</a> 的用法导致了这个问题。他给我发来了下面的截图：</p><p><img src="/images/android-performance-case-study-follow-up/falconpro3.png" alt="Falcon Pro"></p><p>Joaquim使用了系统内置的GPU profiling工具来发现掉帧现象， 左边的截图是在没有ViewPager 的情况下滑动时间线，右边的截图是有ViewPager的情况下滑动（他使用的是2014年的Moto x来截的图），问题看起来很明显。</p><p>我最先想到的是查看ViewPager是不是由于滥用硬件加速导致，这个性能问题看起来像是在滑动的过程中每一帧都使用了硬件加速。系统的 <a href="http://www.curious-creature.com/2013/09/13/optimizing-hardware-layers/" target="_blank" rel="noopener">hardware layers updates debugging tool</a>没有显示什么有用的信息。我反复使用HierarchyViewer 查看布局情况，令我满意的是ViewPager的表现很正确（相反，不太可能会出问题）</p><p>之后我打开了另一个强大的工具却很少用到的工具：Tracer for OpenGL 。我之前的那篇<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study" target="_blank" rel="noopener">文章</a>解释了如何使用工具获得更多细节。你首先需要知道的是这个工具收集了所有UI界面发给GPU的绘制命令。</p><blockquote><p><strong>Android 4.3 and up</strong>: <em>Tracer</em> has unfortunately become a little more difficult to use since Android 4.3 when we introduced<a href="https://developers.google.com/events/io/sessions/325418001" target="_blank" rel="noopener">reordering and merging of drawing commands</a>. It’s an amazingly useful optimization but it prevents <em>Tracer</em> from grouping drawing commands by view. You can restore the old behavior by disabling display lists optimization using the following command (before you start your application)(意思是说Android4.3之后，这个工具不太好用了，因为有reordering and merging 机制的引进)</p></blockquote><blockquote><p><strong>Reading OpenGL traces</strong>: Commands shown in blue are GL operations that draw pixels on screen. All other commands are used to transfer data or set state and can easily be ignored. Every time you click on one of the blue commands, Tracer will update the Details tab and show you the content of the current render target right after the command you clicked is executed. You can thus reconstruct a frame by clicking on each blue command one after another. It’s pretty much how I analyze performance issues with Tracer. Seeing how a frame is rendered gives a lot of insight on what the application is doing.(意思是说只蓝色的行是真正进行绘制的命令，点击可以看到绘制的这一帧的图像，其他的命令都是一些数据的转换)</p></blockquote><p>滑动一段时间Falcon Pro应用后，我仔细查看Gl Trace收集到的数据，我很惊奇地发现很多SaveLayer/ComposeLayer阻塞命令。</p><p><img src="/images/android-performance-case-study-follow-up/glTrace.png" alt="Paste_Image.png"></p><p>这些命令表明应用在生成一个临时的Hardware Layer。这些临时的Layer被不同的 [Canvas.saveLayer()](<a href="http://developer.android.com/reference/android/graphics/Canvas.html#saveLayer" target="_blank" rel="noopener">http://developer.android.com/reference/android/graphics/Canvas.html#saveLayer</a>(float, float, float, float, android.graphics.Paint, int))所创建，这些UI控件在下面的情况下使用Canvas.saveLayer()方法去绘制 alpha &lt; 1 (see<a href="http://developer.android.com/reference/android/view/View.html#setAlpha(float)" target="_blank" rel="noopener">View.setAlpha()</a>的View(即半透明View)：</p><ul><li><a href="http://developer.android.com/reference/android/view/View.html#getAlpha(" target="_blank" rel="noopener">getAlpha()</a> returns a value &lt; 1</li><li><a href="http://developer.android.com/reference/android/view/View.html#onSetAlpha(int" target="_blank" rel="noopener">onSetAlpha()</a> returns false</li><li><a href="http://developer.android.com/reference/android/view/View.html#getLayerType(" target="_blank" rel="noopener">getLayerType()</a> returns LAYER_TYPE_NONE</li><li><a href="http://developer.android.com/reference/android/view/View.html#hasOverlappingRendering(" target="_blank" rel="noopener">hasOverlappingRendering()</a> returns true</li></ul><p>我和Chet 在很多演示中解释过为什么你应该 <a href="https://youtu.be/vQZFaec9NpA?t=29m51s" target="_blank" rel="noopener">use alpha with care</a>，每次UI控件使用一个临时的Layer，绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作,这对于使用tiling/deferred架构的GPU（ImaginationTech’s SGX, Qualcomm’s Adreno, etc）等是硬伤，直接渲染架构的GPU，比如 Nvidia，则会好一点。因为我和Joaquim 使用的是搭载高通处理器的Moto X 2014版本，所以使用多个临时硬件层是最有可能的性能问题的根源。</p><p>那么问题来了，是什么创建了这些临时的Layer呢？<em>Tracer</em>告诉我们了答案，如果你看了刚刚上面那张<a href="http://www.curious-creature.com/blog/wp-content/uploads/2015/03/Screen-Shot-2015-03-25-at-11.00.53-AM-950x552.png" target="_blank" rel="noopener">图</a>,你可以看到只有SaveLayer这个组中OpenGl命令绘制了一个小圆圈（图被工具放大了），我们来看一下应用截图：</p><p><img src="/images/android-performance-case-study-follow-up/before.png" alt="Falcon Pro 3"></p><p>你看到最上面的小圆圈了么？那是ViewPager的指示器，来显示当前的位置。Joaquim 使用了一个第三方库来绘制这些指示器，有趣的是这些库如何绘制指示器的：当前的Page用一个白色的圈指示，其他的页用类似灰色的圆圈来指示。我说类似灰色因为这个圆圈其实是半透明的白色圆圈。这个库使用 setAlpha()方法来给每个圆圈设置颜色。</p><p>有下面几种方法来解决这个问题：</p><ul><li><p>Use a customizable “inactive” color instead of setting an opacity on the View（ 使用动态的“inactive”颜色(即根据状态来设置View的颜色)而不是设置透明度。）</p></li><li><p>Return false from hasOverlappingRendering() and the framework will set the proper alpha on the Paint<br>for you（使hasOverlappingRendering()返回false，这样系统会设置适当的alpha，关于这个的用法，这篇<a href="http://imid.me/blog/2014/01/17/best-practices-for-using-alpha/" target="_blank" rel="noopener">文章</a>中有提到：同时Android提供了hasOverlappingRendering()接口，通过重写该接口可以告知系统当前View是否存在内容重叠的情况，帮助系统优化绘制流程，原理是这样的：对于有重叠内容的View，系统简单粗暴的使用 offscreen buffer来协助处理。当告知系统该View无重叠内容时，系统会分别使用合适的alpha值绘制每一层。）</p> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns whether this View has content which overlaps. This function, intended <span class="keyword">to</span> be</span><br><span class="line"> * overridden <span class="keyword">by</span> specific View types, <span class="keyword">is</span> an optimization when alpha <span class="keyword">is</span> <span class="keyword">set</span> <span class="keyword">on</span> a view. If</span><br><span class="line"> * rendering overlaps <span class="keyword">in</span> a view <span class="keyword">with</span> alpha &lt; <span class="number">1</span>, <span class="keyword">that</span> view <span class="keyword">is</span> drawn <span class="keyword">to</span> an offscreen buffer</span><br><span class="line"> * <span class="keyword">and</span> <span class="keyword">then</span> composited <span class="keyword">it</span> <span class="keyword">into</span> place, which can be expensive. If <span class="keyword">the</span> view has no overlapping</span><br><span class="line"> * rendering, <span class="keyword">the</span> view can draw each primitive <span class="keyword">with</span> <span class="keyword">the</span> appropriate alpha value directly.</span><br><span class="line"> * An example <span class="keyword">of</span> overlapping rendering <span class="keyword">is</span> a TextView <span class="keyword">with</span> a background image, such <span class="keyword">as</span> a</span><br><span class="line"> * Button. An example <span class="keyword">of</span> non-overlapping rendering <span class="keyword">is</span> a TextView <span class="keyword">with</span> no background, <span class="keyword">or</span></span><br><span class="line"> * an ImageView <span class="keyword">with</span> only <span class="keyword">the</span> foreground image. The default implementation returns <span class="literal">true</span>;</span><br><span class="line"> * subclasses should override <span class="keyword">if</span> they have cases which can be optimized.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="literal">return</span> <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> content <span class="keyword">in</span> this view might overlap, <span class="literal">false</span> otherwise.</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> hasOverlappingRendering() &#123;</span><br><span class="line"><span class="built_in">    return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Return true from onSetAlpha() and set an alpha on the Paint used to draw the “gray” circles（使onSetAlpha() 返回True并对Paint设置alpha来绘制“gray”圆圈）</p> <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paint.setAlpha((<span class="built_in">int</span>) <span class="built_in">alpha</span> * <span class="number">255</span>);</span><br><span class="line">canvas.<span class="title">draw</span>*(..., paint);</span><br></pre></td></tr></table></figure></li></ul><p>最简单的方法是使用第二种，但是他只能在API16以上使用，如果你要支持旧版本的Android，使用其他两个方法，我相信Joaquim 已经丢弃那个第三方库并使用自己的指示器了。</p><p>我希望这篇文章能让大家清楚如何从看似无辜的和无害的操作中寻找可能会出现性能问题。所以请记住:不要仅仅做出假设,要实际去验证、测量。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>更多关于Alpha的使用，可以参考这篇文章：<br><a href="http://imid.me/blog/2014/01/17/best-practices-for-using-alpha/" target="_blank" rel="noopener">Android Tips: Best Practices for Using Alpha</a></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Performance </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> MAT </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 小技巧 - 5</title>
      <link href="/2015/03/15/android-tips-round-up-5/"/>
      <url>/2015/03/15/android-tips-round-up-5/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html" target="_blank" rel="noopener">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，<a href="https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html" target="_blank" rel="noopener">DrawerLayout</a>就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的<a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper/" target="_blank" rel="noopener">优秀文章</a>。</p><p><a href="https://developer.android.com/reference/android/widget/PopupWindow.html" target="_blank" rel="noopener">PopupWindow</a>——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。</p><p><a href="https://developer.android.com/reference/android/app/ActionBar.htmlgetThemedContext%28%29" target="_blank" rel="noopener">Actionbar.getThemrContext()</a>——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。</p><p><a href="https://developer.android.com/reference/android/media/ThumbnailUtils.html" target="_blank" rel="noopener">ThumbnailUtils</a>——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。<strong>译者注：</strong>该API从V8才开始支持。</p><p><a href="https://developer.android.com/reference/android/content/Context.htmlgetExternalFilesDir%28java.lang.String%29" target="_blank" rel="noopener">Context.getExternalFilesDir()</a>———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。<strong>译者注：</strong>该API从V8才开始支持。</p><p><a href="https://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="noopener">SparseArray</a>——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。</p><p><a href="https://developer.android.com/reference/android/content/pm/PackageManager.htmlsetComponentEnabledSetting%28android.content.ComponentName,%20int,%20int%29" target="_blank" rel="noopener">PackageManager.setComponentEnabledSetting()</a>——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。</p><p><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.htmlyieldIfContendedSafely%28%29" target="_blank" rel="noopener">SQLiteDatabase.yieldIfContendedSafely()</a>——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。</p><p><a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory%28java.lang.String%29" target="_blank" rel="noopener">Environment.getExternalStoragePublicDirectory()</a>——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。</p><p><a href="https://developer.android.com/reference/android/view/View.htmlgenerateViewId%28%29" target="_blank" rel="noopener">View.generateViewId()</a>——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。</p><p><a href="https://developer.android.com/reference/android/app/ActivityManager.htmlclearApplicationUserData%28%29" target="_blank" rel="noopener">ActivityManager.clearApplicationUserData()</a>—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。</p><p><a href="http://developer.android.com/reference/android/content/Context.htmlcreateConfigurationContext%28android.%E2%80%94%E2%80%94ontent.res.Configuration%29" target="_blank" rel="noopener">Context.createConfigurationContext()</a> ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。</p><p><a href="http://developer.android.com/reference/android/app/ActivityOptions.html" target="_blank" rel="noopener">ActivityOptions</a> ——方便的定义两个Activity切换的动画。 使用<a href="http://developer.android.com/reference/android/support/v4/app/ActivityOptionsCompat.html" target="_blank" rel="noopener">ActivityOptionsCompat</a> 可以很好解决旧版本的兼容问题。</p><p><a href="http://developer.android.com/reference/android/widget/AdapterViewFlipper.htmlfyiWillBeAdvancedByHostKThx%28%29" target="_blank" rel="noopener">AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()</a>——仅仅因为很好玩，没有其他原因。在整个安卓开源项目中（AOSP the Android ——pen Source Project Android开放源代码项目）中还有其他很有意思的东西（比如<br><a href="http://developer.android.com/reference/android/hardware/SensorManager.htmlGRAVITY_DEATH_STAR_I" target="_blank" rel="noopener">GRAVITY_DEATH_STAR_I</a>）。不过，都不像这个这样，这个确实有用</p><p><a href="http://developer.android.com/reference/android/view/ViewParent.htmlrequestDisallowInterceptTouchEvent%28boolean%29" target="_blank" rel="noopener">ViewParent.requestDisallowInterceptTouchEvent()</a> ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权（顺便说一下，如果你想对Android触摸机制了解更多，<a href="https://www.youtube.com/watch?v=EZAoJU-nUyI" target="_blank" rel="noopener">这个演讲</a>会令你惊叹不已。）</p><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><ol><li><a href="https://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="noopener">Part1</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="noopener">Part2</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="noopener">Part3</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="noopener">Part4</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="noopener">Part5</a></li></ol><p>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/" target="_blank" rel="noopener">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="noopener">http://blog.danlew.net/about/</a><br>本文地址:<a href="https://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="noopener">https://www.androidperformance.com/android-tips-round-up-5.html</a> 转载请注明.</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 小技巧 - 4</title>
      <link href="/2015/03/15/android-tips-round-up-4/"/>
      <url>/2015/03/15/android-tips-round-up-4/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29" target="_blank" rel="noopener">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p><p><a href="http://developer.android.com/reference/android/content/SearchRecentSuggestionsProvider.html" target="_blank" rel="noopener">SearchRecentSuggestionsProvider</a>——可以创建最近提示效果的 provider，是一个简单快速的方法。</p><p><a href="http://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="noopener">ViewTreeObserver</a>——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。</p><p><a href="https://www.timroes.de/2013/09/12/speed-up-gradle/" target="_blank" rel="noopener">org.gradle.daemon=true</a>——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。</p><p><a href="http://developer.android.com/reference/android/database/DatabaseUtils.html" target="_blank" rel="noopener">DatabaseUtils</a>——一个包含各种数据库操作的使用工具。</p><p><a href="http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:weightSum" target="_blank" rel="noopener">android:weightSum (LinearLayout)</a>——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。</p><p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:duplicateParentState" target="_blank" rel="noopener">android:duplicateParentState (View)</a>——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。</p><p><a href="http://developer.android.com/reference/android/view/ViewGroup.html#attr_android:clipChildren" target="_blank" rel="noopener">android:clipChildren (ViewGroup)</a>——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。</p><p><a href="http://developer.android.com/reference/android/widget/ScrollView.html#attr_android:fillViewport" target="_blank" rel="noopener">android:fillViewport (ScrollView)</a>——在这片文章中有详细介绍<a href="http://www.curious-creature.org/2010/08/15/scrollviews-handy-trick/" target="_blank" rel="noopener">文章链接</a>，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。</p><p><a href="http://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap" target="_blank" rel="noopener">android:tileMode (BitmapDrawable)</a>——可以指定图片使用重复填充的模式。</p><p><a href="http://developer.android.com/reference/android/R.attr.html#exitFadeDuration" target="_blank" rel="noopener">android:enterFadeDuration/android:exitFadeDuration (Drawables)</a>——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。</p><p><a href="http://developer.android.com/reference/android/widget/ImageView.html#attr_android:scaleType" target="_blank" rel="noopener">android:scaleType (ImageView)</a>——定义在 ImageView 中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。</p><p><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html#Merge" target="_blank" rel="noopener">Merge</a>——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。</p><p><a href="http://developer.android.com/reference/android/util/AtomicFile.html" target="_blank" rel="noopener">AtomicFile</a>——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。</p><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><ol><li><a href="https://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="noopener">Part1</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="noopener">Part2</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="noopener">Part3</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="noopener">Part4</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="noopener">Part5</a></li></ol><p>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/" target="_blank" rel="noopener">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="noopener">http://blog.danlew.net/about/</a><br>本文地址:<a href="https://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="noopener">https://www.androidperformance.com/android-tips-round-up-4.html</a> 转载请注明.</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 小技巧 -3</title>
      <link href="/2015/03/15/android-tips-round-up-3/"/>
      <url>/2015/03/15/android-tips-round-up-3/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html" target="_blank" rel="noopener">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p><p><a href="http://developer.android.com/reference/android/app/Fragment.html#setArguments%28android.os.Bundle%29" target="_blank" rel="noopener">Fragment.setArguments</a>——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。</p><p><a href="http://developer.android.com/reference/android/app/DialogFragment.html#setShowsDialog%28boolean%29" target="_blank" rel="noopener">DialogFragment.setShowsDialog ()</a>—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。</p><p><a href="http://developer.android.com/reference/android/app/FragmentManager.html#enableDebugLogging%28boolean%29" target="_blank" rel="noopener">FragmentManager.enableDebugLogging ()</a>——在需要观察 Fragment 状态的时候会有帮助。</p><p><a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html" target="_blank" rel="noopener">LocalBroadcastManager</a>——这个会比全局的 broadcast 更加安全，简单，快速。像 <a href="http://square.github.io/otto/" target="_blank" rel="noopener">otto</a> 这样的 Event buses 机制对你的应用场景更加有用。</p><p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#formatNumber%28java.lang.String%29" target="_blank" rel="noopener">PhoneNumberUtils.formatNumber ()</a>——顾名思义，这是对数字进行格式化操作的时候用的。</p><p><a href="http://developer.android.com/reference/android/graphics/Region.html#op%28android.graphics.Region,%20android.graphics.Region,%20android.graphics.Region.Op%29" target="_blank" rel="noopener">Region.op()</a>——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。</p><p><a href="http://developer.android.com/reference/android/app/Application.html#registerActivityLifecycleCallbacks%28android.app.Application.ActivityLifecycleCallbacks%29" target="_blank" rel="noopener">Application.registerActivityLifecycleCallbacks</a>——虽然缺少官方文档解释，不过我想它就是注册 Activity 的生命周期的一些回调方法（顾名思义），就是一个方便的工具。</p><p><a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Build-Types" target="_blank" rel="noopener">versionNameSuffix</a>——这个 gradle 设置可以让你在基于不同构建类型的 manifest 中修改版本名这个属性，例如，如果需要在在 debug 版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是 debug 版还是 release 版。</p><p><a href="http://developer.android.com/reference/android/database/CursorJoiner.html" target="_blank" rel="noopener">CursorJoiner</a>——如果你是只使用一个数据库的话，使用 SQL 中的 join 就可以了，但是如果收到的数据是来自两个独立的 ContentProvider，那么 CursorJoiner 就很实用了。</p><p><a href="http://www.genymotion.com/" target="_blank" rel="noopener">Genymotion</a>——一个非常快的 Android 模拟器，本人一直在用。</p><p><a href="http://developer.android.com/guide/practices/screens_support.html#qualifiers" target="_blank" rel="noopener">-nodpi</a>——在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。</p><p><a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setDebugUnregister%28boolean%29" target="_blank" rel="noopener">BroadcastRecevier.setDebugUnregister ()</a>——又一个方便的调试工具。</p><p><a href="http://developer.android.com/reference/android/app/Activity.html#recreate%28%29" target="_blank" rel="noopener">Activity.recreate ()</a>——强制让 Activity 重建。</p><p><a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#checkSignatures%28java.lang.String,%20java.lang.String%29" target="_blank" rel="noopener">PackageManager.checkSignatures ()</a>——如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。</p><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><ol><li><a href="https://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="noopener">Part1</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="noopener">Part2</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="noopener">Part3</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="noopener">Part4</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="noopener">Part5</a></li></ol><p>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/" target="_blank" rel="noopener">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="noopener">http://blog.danlew.net/about/</a><br>本文地址:<a href="https://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="noopener">https://www.androidperformance.com/android-tips-round-up-3.html</a> 转载请注明.</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为 Nexus5 编译 AndroidL 固件</title>
      <link href="/2015/02/04/build-rom-for-nexus5/"/>
      <url>/2015/02/04/build-rom-for-nexus5/</url>
      
        <content type="html"><![CDATA[<p>接前一篇文章<a href="https://www.androidperformance.com/view-android-source-code-with-androidstudio.html" target="_blank" rel="noopener">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p><p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html" target="_blank" rel="noopener">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html" target="_blank" rel="noopener">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p><p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p><a id="more"></a><h3 id="1-初始化编译环境"><a href="#1-初始化编译环境" class="headerlink" title="1. 初始化编译环境"></a>1. 初始化编译环境</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">. </span>build/envsetup.sh</span><br></pre></td></tr></table></figure><h3 id="2-加载机型"><a href="#2-加载机型" class="headerlink" title="2. 加载机型"></a>2. 加载机型</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lunch</span></span><br></pre></td></tr></table></figure><h3 id="3-选择要编译的机器"><a href="#3-选择要编译的机器" class="headerlink" title="3. 选择要编译的机器"></a>3. 选择要编译的机器</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">You're</span> <span class="string">building</span> <span class="string">on</span> <span class="string">Linux</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Lunch menu... pick a combo:</span></span><br><span class="line">     <span class="number">1</span><span class="string">.</span> <span class="string">aosp_arm-eng</span></span><br><span class="line">     <span class="number">2</span><span class="string">.</span> <span class="string">aosp_arm64-eng</span></span><br><span class="line">     <span class="number">3</span><span class="string">.</span> <span class="string">aosp_mips-eng</span></span><br><span class="line">     <span class="number">4</span><span class="string">.</span> <span class="string">aosp_mips64-eng</span></span><br><span class="line">     <span class="number">5</span><span class="string">.</span> <span class="string">aosp_x86-eng</span></span><br><span class="line">     <span class="number">6</span><span class="string">.</span> <span class="string">aosp_x86_64-eng</span></span><br><span class="line">     <span class="number">7</span><span class="string">.</span> <span class="string">aosp_shamu-userdebug</span></span><br><span class="line">     <span class="number">8</span><span class="string">.</span> <span class="string">aosp_manta-userdebug</span></span><br><span class="line">     <span class="number">9</span><span class="string">.</span> <span class="string">full_fugu-userdebug</span></span><br><span class="line">     <span class="number">10</span><span class="string">.</span> <span class="string">aosp_fugu-userdebug</span></span><br><span class="line">     <span class="number">11</span><span class="string">.</span> <span class="string">aosp_grouper-userdebug</span></span><br><span class="line">     <span class="number">12</span><span class="string">.</span> <span class="string">aosp_tilapia-userdebug</span></span><br><span class="line">     <span class="number">13</span><span class="string">.</span> <span class="string">aosp_deb-userdebug</span></span><br><span class="line">     <span class="number">14</span><span class="string">.</span> <span class="string">aosp_flo-userdebug</span></span><br><span class="line">     <span class="number">15</span><span class="string">.</span> <span class="string">aosp_mako-userdebug</span></span><br><span class="line">     <span class="number">16</span><span class="string">.</span> <span class="string">aosp_hammerhead-userdebug</span></span><br><span class="line">     <span class="number">17</span><span class="string">.</span> <span class="string">aosp_flounder-userdebug</span></span><br><span class="line">     <span class="number">18</span><span class="string">.</span> <span class="string">mini_emulator_x86_64-userdebug</span></span><br><span class="line">     <span class="number">19</span><span class="string">.</span> <span class="string">mini_emulator_arm-userdebug</span></span><br><span class="line">     <span class="number">20</span><span class="string">.</span> <span class="string">mini_emulator_x86-userdebug</span></span><br><span class="line">     <span class="number">21</span><span class="string">.</span> <span class="string">mini_emulator_mips-userdebug</span></span><br><span class="line">     <span class="number">22</span><span class="string">.</span> <span class="string">mini_emulator_arm64-userdebug</span></span><br></pre></td></tr></table></figure><h4 id="3-1-机型对照表"><a href="#3-1-机型对照表" class="headerlink" title="3.1 机型对照表"></a>3.1 机型对照表</h4><table><thead><tr><th>DEVICE</th><th>CODE NAME</th><th>BUILD CONFIGURATION</th></tr></thead><tbody><tr><td>Nexus 6</td><td>shamu</td><td>aosp_shamu-userdebug</td></tr><tr><td>Nexus Player</td><td>fugu</td><td>aosp_fugu-userdebug</td></tr><tr><td>Nexus 9</td><td>volantis (flounder)</td><td>aosp_flounder-userdebug</td></tr><tr><td>Nexus 5 (GSM/LTE)</td><td>hammerhead</td><td>aosp_hammerhead-userdebug</td></tr><tr><td>Nexus 7 (Wi-Fi)</td><td>razor (flo)</td><td>aosp_flo-userdebug</td></tr><tr><td>Nexus 7 (Mobile)</td><td>razorg (deb)</td><td>aosp_deb-userdebug</td></tr><tr><td>Nexus 10</td><td>mantaray (manta)</td><td>full_manta-userdebug</td></tr><tr><td>Nexus 4</td><td>occam (mako)</td><td>full_mako-userdebug</td></tr><tr><td>Nexus 7 (Wi-Fi)</td><td>nakasi (grouper)</td><td>full_grouper-userdebug</td></tr><tr><td>Nexus 7 (Mobile)</td><td>nakasig (tilapia)</td><td>full_tilapia-userdebug</td></tr><tr><td>Galaxy Nexus (GSM/HSPA+)</td><td>yakju (maguro)</td><td>full_maguro-userdebug</td></tr><tr><td>Galaxy Nexus (Verizon)</td><td>mysid (toro)</td><td>aosp_toro-userdebug</td></tr><tr><td>Galaxy Nexus (Experimental)</td><td>mysidspr (toroplus)</td><td>aosp_toroplus-userdebug</td></tr><tr><td>PandaBoard (Archived)</td><td>panda</td><td>aosp_panda-userdebug</td></tr><tr><td>Motorola Xoom (U.S. Wi-Fi)</td><td>wingray</td><td>full_wingray-userdebug</td></tr><tr><td>Nexus S</td><td>soju (crespo)</td><td>full_crespo-userdebug</td></tr><tr><td>Nexus S 4G</td><td>sojus (crespo4g)</td><td>full_crespo4g-userdebug3.2</td></tr></tbody></table><h4 id="3-2-三个版本说明版本"><a href="#3-2-三个版本说明版本" class="headerlink" title="3.2 三个版本说明版本"></a>3.2 三个版本说明版本</h4><table><thead><tr><th>BUILDTYPE</th><th>USE</th></tr></thead><tbody><tr><td>user</td><td>limited access; suited for production</td></tr><tr><td>userdebug</td><td>like “user” but with root access and debuggability; preferred for debugging</td></tr><tr><td>eng</td><td>development configuration with additional debugging tools</td></tr></tbody></table><p>选择aosp_hammerhead-userdebug之后,会有下面的确认信息:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">============================================</span><br><span class="line">PLATFORM_VERSION_CODENAME=REL</span><br><span class="line">PLATFORM_VERSION=5.0.50.50.50.50</span><br><span class="line">TARGET_PRODUCT=aosp_hammerhead</span><br><span class="line">TARGET_BUILD_VARIANT=userdebug</span><br><span class="line">TARGET_BUILD_TYPE=release</span><br><span class="line">TARGET_BUILD_APPS=</span><br><span class="line">TARGET_ARCH=arm</span><br><span class="line">TARGET_ARCH_VARIANT=armv7-a-neon</span><br><span class="line">TARGET_CPU_VARIANT=krait</span><br><span class="line">TARGET_2ND_ARCH=</span><br><span class="line">TARGET_2ND_ARCH_VARIANT=</span><br><span class="line">TARGET_2ND_CPU_VARIANT=</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_OS_EXTRA=Linux-3.13.0-37-generic-x86_64-with-Ubuntu-14.10-utopic</span><br><span class="line">HOST_BUILD_TYPE=release</span><br><span class="line">BUILD_ID=AOSP</span><br><span class="line">OUT_DIR=out</span><br><span class="line">============================================</span><br></pre></td></tr></table></figure><h3 id="4-生成驱动目录"><a href="#4-生成驱动目录" class="headerlink" title="4. 生成驱动目录"></a>4. 生成驱动目录</h3><p>接下来需要在<a href="https://developers.google.com/android/nexus/drivers#hammerheadlrx22c" target="_blank" rel="noopener">Android官网</a>下载 Nexus5所需要的驱动:</p><table><thead><tr><th>HARDWARE COMPONENT</th><th>COMPANY</th><th>DOWNLOAD</th><th>MD5 CHECKSUM</th><th>SHA-1 CHECKSUM</th></tr></thead><tbody><tr><td>NFC, Bluetooth, Wi-Fi</td><td>Broadcom</td><td><a href="https://dl.google.com/dl/android/aosp/broadcom-hammerhead-lrx22c-964d941e.tgz" target="_blank" rel="noopener">Link</a></td><td>2c398994e37093df51b105d63f0eb611</td><td>991346159c95ae75f760014a6822b8b3e8667700</td></tr><tr><td>Camera, Sensors, Audio</td><td>LG</td><td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="noopener">Link</a></td><td>74cf8235e6bb04da28b2ff738b13eee9</td><td>175dd5bae81bb54030d072cb0f0b4ec81eb3f71f</td></tr><tr><td>Graphics, GSM, Camera, GPS, Sensors, Media, DSP, USB</td><td>Qualcomm</td><td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="noopener">Link</a></td><td>0a43395e175d3de3dc312d8abdcb4f20</td><td>007cf9d49f0409d5c703e7f2811fd153fee22353</td></tr></tbody></table><p>下载完成后,解压出来是三个.sh文件,放到Android源码目录下面,然后执行.会将相关驱动放到vender目录下面.</p><h3 id="5-执行编译命令"><a href="#5-执行编译命令" class="headerlink" title="5. 执行编译命令"></a>5. 执行编译命令</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> -j8</span><br></pre></td></tr></table></figure><p>如果没有出错的话,在经过漫长的时间之后,编译成功:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Installed file list: out/target/product/hammerhead/installed-files.txt</span><br><span class="line">Target<span class="built_in"> system </span>fs image: out/target/product/hammerhead/obj/PACKAGING/systemimage_intermediates/system.img</span><br><span class="line">Running:  mkuserimg.sh -s out/target/product/hammerhead<span class="built_in">/system </span>out/target/product/hammerhead/obj/PACKAGING/systemimage_intermediates/system.img ext4<span class="built_in"> system </span>1073741824 -L<span class="built_in"> system </span>out/target/product/hammerhead/root/file_contexts</span><br><span class="line">make_ext4fs -s -T -1 -S out/target/product/hammerhead/root/file_contexts -L<span class="built_in"> system </span>-l 1073741824 -a<span class="built_in"> system </span>out/target/product/hammerhead/obj/PACKAGING/systemimage_intermediates/system.img out/target/product/hammerhead/system</span><br><span class="line">Creating filesystem with parameters:</span><br><span class="line">    Size: 1073741824</span><br><span class="line">    Block size: 4096</span><br><span class="line">    Blocks per group: 32768</span><br><span class="line">    Inodes per group: 8192</span><br><span class="line">    Inode size: 256</span><br><span class="line">    Journal blocks: 4096</span><br><span class="line">    Label: system</span><br><span class="line">    Blocks: 262144</span><br><span class="line">    Block groups: 8</span><br><span class="line">    Reserved block<span class="built_in"> group </span>size: 63</span><br><span class="line">Created filesystem with 1445/65536 inodes <span class="keyword">and</span> 85879/262144 blocks</span><br><span class="line">Install<span class="built_in"> system </span>fs image: out/target/product/hammerhead/system.img</span><br><span class="line">out/target/product/hammerhead/system.img+out/target/product/hammerhead/obj/PACKAGING/recovery_patch_intermediates/recovery_from_boot.p <span class="attribute">maxsize</span>=1096212480 <span class="attribute">blocksize</span>=135168 <span class="attribute">total</span>=336629666 <span class="attribute">reserve</span>=11083776</span><br></pre></td></tr></table></figure><h3 id="6-刷机命令"><a href="#6-刷机命令" class="headerlink" title="6. 刷机命令"></a>6. 刷机命令</h3><p>Nexus5关机状态下,长按音量下+电源,即可进入recovery模式, 然后在源码根目录下执行下面命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastboot -w flashall</span></span><br></pre></td></tr></table></figure><p>刷机成功后会自动重启</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">~/Android-SourceCode fastboot -w flashall</span><br><span class="line">target reported <span class="built-in">max</span> download size of <span class="number">1073741824</span> bytes</span><br><span class="line">Creating filesystem with <span class="keyword">parameters</span>:</span><br><span class="line">    Size: 13725835264</span><br><span class="line">    Block <span class="comment">size: 4096</span></span><br><span class="line">    Blocks <span class="comment">per group: 32768</span></span><br><span class="line">    Inodes <span class="comment">per group: 8144</span></span><br><span class="line">    Inode <span class="comment">size: 256</span></span><br><span class="line">    Journal <span class="comment">blocks: 32768</span></span><br><span class="line">    Label: </span><br><span class="line">    Blocks: 3351034</span><br><span class="line">    Block <span class="comment">groups: 103</span></span><br><span class="line">    Reserved <span class="comment">block group size: 823</span></span><br><span class="line">Created <span class="comment">filesystem with 11</span>/<span class="number">838832</span> inodes <span class="keyword">and</span> <span class="number">93654</span>/<span class="comment">3351034 blocks</span></span><br><span class="line">Creating <span class="comment">filesystem with parameters:</span></span><br><span class="line">    Size: 734003200</span><br><span class="line">    Block <span class="comment">size: 4096</span></span><br><span class="line">    Blocks <span class="comment">per group: 32768</span></span><br><span class="line">    Inodes <span class="comment">per group: 7472</span></span><br><span class="line">    Inode <span class="comment">size: 256</span></span><br><span class="line">    Journal <span class="comment">blocks: 2800</span></span><br><span class="line">    Label: </span><br><span class="line">    Blocks: 179200</span><br><span class="line">    Block <span class="comment">groups: 6</span></span><br><span class="line">    Reserved <span class="comment">block group size: 47</span></span><br><span class="line">Created <span class="comment">filesystem with 11</span>/<span class="number">44832</span> inodes <span class="keyword">and</span> <span class="number">5813</span>/<span class="comment">179200 blocks</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">Bootloader <span class="comment">Version...: HHZ12d</span></span><br><span class="line">Baseband <span class="comment">Version.....: M8974A-2.0.50.2.22</span></span><br><span class="line">Serial <span class="comment">Number........: 08ade1a513dc087b</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">checking <span class="comment">product...</span></span><br><span class="line">OKAY <span class="comment">[  0.100s]</span></span><br><span class="line">sending <span class="comment">'boot'</span><span class="comment"> (8950 KB)...</span></span><br><span class="line">OKAY <span class="comment">[  0.500s]</span></span><br><span class="line">writing <span class="comment">'boot'</span><span class="comment">...</span></span><br><span class="line">OKAY <span class="comment">[  0.784s]</span></span><br><span class="line">sending <span class="comment">'recovery'</span><span class="comment"> (9672 KB)...</span></span><br><span class="line">OKAY <span class="comment">[  0.556s]</span></span><br><span class="line">writing <span class="comment">'recovery'</span><span class="comment">...</span></span><br><span class="line">OKAY <span class="comment">[  0.814s]</span></span><br><span class="line">erasing <span class="comment">'system'</span><span class="comment">...</span></span><br><span class="line">OKAY <span class="comment">[  1.166s]</span></span><br><span class="line">sending <span class="comment">'system'</span><span class="comment"> (328187 KB)...</span></span><br><span class="line">OKAY <span class="comment">[ 10.501s]</span></span><br><span class="line">writing <span class="comment">'system'</span><span class="comment">...</span></span><br><span class="line">OKAY <span class="comment">[ 23.623s]</span></span><br><span class="line">erasing <span class="comment">'userdata'</span><span class="comment">...</span></span><br><span class="line">OKAY <span class="comment">[ 14.657s]</span></span><br><span class="line">sending <span class="comment">'userdata'</span><span class="comment"> (137318 KB)...</span></span><br><span class="line">OKAY <span class="comment">[  4.520s]</span></span><br><span class="line">writing <span class="comment">'userdata'</span><span class="comment">...</span></span><br><span class="line">OKAY <span class="comment">[  9.776s]</span></span><br><span class="line">erasing <span class="comment">'cache'</span><span class="comment">...</span></span><br><span class="line">OKAY <span class="comment">[  0.618s]</span></span><br><span class="line">sending <span class="comment">'cache'</span><span class="comment"> (13348 KB)...</span></span><br><span class="line">OKAY <span class="comment">[  0.630s]</span></span><br><span class="line">writing <span class="comment">'cache'</span><span class="comment">...</span></span><br><span class="line">OKAY <span class="comment">[  1.070s]</span></span><br><span class="line">rebooting...</span><br><span class="line"></span><br><span class="line">finished. total <span class="comment">time: 70.095s</span></span><br></pre></td></tr></table></figure><h3 id="7-秀桌面"><a href="#7-秀桌面" class="headerlink" title="7.秀桌面"></a>7.秀桌面</h3><p><img src="/images/build-image-for-nexus-5/Nexus5.png" alt="image"></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化之 Systrace 工具介绍(一)</title>
      <link href="/2015/01/30/android-performance-tools-systrace-1/"/>
      <url>/2015/01/30/android-performance-tools-systrace-1/</url>
      
        <content type="html"><![CDATA[<p><strong>注意</strong>，本篇内容已经过时，请参考新的 <a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Systrace 系列文章</a></p><p>本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p><p>这一篇先来简单介绍一下Systrace这个工具。</p><h2 id="Systrace简单介绍"><a href="#Systrace简单介绍" class="headerlink" title="Systrace简单介绍"></a>Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p><p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p><ul><li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li><li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li><li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" target="_blank" rel="noopener" title="SysTrace官方介绍">Systrace</a></li></ul><a id="more"></a><h2 id="Systrace简单使用"><a href="#Systrace简单使用" class="headerlink" title="Systrace简单使用"></a>Systrace简单使用</h2><p>使用Systrace前，要先了解一下Systrace在各个平台上的使用方法，鉴于大家使用Eclipse和Android Studio的居多，所以直接摘抄官网关于这个的使用方法，不过不管是什么工具，流程是一样的：</p><ul><li>手机准备好你要进行抓取的界面</li><li>点击开始抓取（命令行的话就是开始执行命令）</li><li>手机上开始操作</li><li>设定好的时间到了之后，会将生成Trace文件，使用Chrome将这个文件打开进行分析</li></ul><h4 id="Using-Eclipse"><a href="#Using-Eclipse" class="headerlink" title="Using Eclipse"></a>Using <strong>Eclipse</strong></h4><ol><li><p>In Eclipse, open an Android application project.</p><ol><li>Switch to the DDMS perspective, by selecting Window &gt; Perspectives &gt; DDMS.</li><li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li><li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li><li>Set the tracing options and click OK to start the trace.</li></ol></li></ol><h4 id="Using-Android-Studio"><a href="#Using-Android-Studio" class="headerlink" title="Using ** Android Studio**"></a>Using ** Android Studio**</h4><ol><li><p>In Android Studio, open an Android application project.</p><ol><li>Open the Device Monitor by selecting Tools &gt; Android &gt; Monitor.</li><li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li><li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li><li>Set the tracing options and click OK to start the trace.</li></ol></li></ol><h4 id="Using-Device-Monitor"><a href="#Using-Device-Monitor" class="headerlink" title="Using Device Monitor"></a>Using <strong>Device Monitor</strong></h4><ol><li><p>Navigate to your SDK tools/ directory.</p><ol><li>Run the monitor program.</li><li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li><li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li><li>Set the tracing options and click OK to start the trace.</li></ol></li></ol><h4 id="Command-Line-Usage"><a href="#Command-Line-Usage" class="headerlink" title="Command Line Usage"></a>Command Line Usage</h4><p>命令行形式比较灵活，速度也比较快，一次性配置好之后，以后再使用的时候就会很快就出结果（<strong>强烈推荐</strong>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> android-sdk/platform-tools/systrace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python systrace.py --time=10 -o mynewtrace.html <span class="built_in">sched</span> gfx view wm</span></span><br></pre></td></tr></table></figure><p>从上面的命令可以看到Systrace工具的位置，只需要在Bash中配置好对应的路径和Alias，使用起来还是很快速的。另外User版本是不可以抓Trace的，只有ENG版本或者Userdebug版本才可以。</p><p>抓取结束后，会生成对应的Trace文件，注意这个文件只能被Chrome打开。关于如何分析Trace文件，我们下面的章节会讲。不论使用那种工具，在抓取之前都会让选择参数，下面说一下这些参数的意思：</p><ul><li><p>-h, –help Show the help message.（帮助）</p></li><li><p>-o  Write the HTML trace report to the specified file.（即输出文件名，）</p></li><li><p>-t N, –time=N Trace activity for N seconds. The default value is 5 seconds. （Trace抓取的时间，一般是 ： -t 8）</p></li><li><p>-b N, –buf-size=N Use a trace buffer size of N kilobytes. This option lets you limit the total size of the data collected during a trace.</p></li><li><p>-k</p></li><li><p>—ktrace= Trace the activity of specific kernel functions, specified in a comma-separated list.</p></li><li><p>-l, –list-categories List the available tracing category tags. The available tags are(下面的参数不用翻译了估计大家也看得懂，贴官方的解释也会比较权威，后面分析的时候我们会看到这些参数的作业的):</p><ul><li><strong>gfx</strong> - Graphics</li><li><strong>input</strong> - Input</li><li><strong>view</strong> - View</li><li>webview - WebView</li><li><strong>wm</strong> - Window Manager</li><li><strong>am</strong> - Activity Manager</li><li>audio - Audio</li><li>video - Video</li><li>camera - Camera</li><li>hal - Hardware Modules</li><li>res - Resource Loading</li><li><strong>dalvik</strong> - Dalvik VM</li><li>rs - RenderScript</li><li><strong>sched</strong> - CPU Scheduling</li><li><strong>freq</strong> - CPU Frequency</li><li><strong>membus</strong> - Memory Bus Utilization</li><li><strong>idle</strong> - CPU Idle</li><li><strong>disk</strong> - Disk input and output</li><li><strong>load</strong> - CPU Load</li><li><strong>sync</strong> - Synchronization Manager</li><li><strong>workq</strong> - Kernel Workqueues Note: Some trace categories are not supported on all devices. Tip: If you want to see the names of tasks in the trace output, you must include the sched category in your command parameters.</li></ul></li><li><p>-a</p></li><li><p>—app= Enable tracing for applications, specified as a comma-separated list of package names. The apps must contain tracing instrumentation calls from the Trace class. For more information, see Analyzing Display and Performance.</p></li><li><p>—link-assets Link to the original CSS or JavaScript resources instead of embedding them in the HTML trace report.</p></li><li><p>—from-file= Create the interactive Systrace report from a file, instead of running a live trace.</p></li><li><p>—asset-dir= Specify a directory for the trace report assets. This option is useful for maintaining a single set of assets for multiple Systrace reports.</p></li><li><p>-e</p></li><li><p>—serial= Conduct the trace on a specific connected device, identified by its device serial number.<br>上面的参数虽然比较多，但使用工具的时候不需考虑这么多，在对应的项目前打钩即可，命令行的时候才会去手动加参数：</p></li></ul><p>我们一般会把这个命令配置成Alias，配置如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias st-<span class="keyword">start</span>=<span class="string">'python /home/gaojianwu/Software/android-studio/sdk/platform-tools/systrace/systrace.py'</span>  </span><br><span class="line"><span class="keyword">alias</span> st-<span class="keyword">start</span>-gfx-<span class="keyword">trace</span> = ‘st-<span class="keyword">start</span> -t <span class="number">8</span> gfx <span class="keyword">input</span> <span class="keyword">view</span> sched freq wm am hwui workq res dalvik <span class="keyword">sync</span> disk <span class="keyword">load</span> perf hal rs idle mmc’</span><br></pre></td></tr></table></figure><p>这样在使用的时候，可以直接敲 <strong>st-start</strong> 即可，当然为了区分和保持各个文件，还需要加上 <strong>-o xxx.Trace</strong> .上面的命令和参数不必一次就理解，只需要记住如何简单使用即可，在分析的过程中，这些东西都会慢慢熟悉的。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Android Studio 查看 Android Lollipop 源码</title>
      <link href="/2015/01/16/view-android-source-code-with-androidstudio/"/>
      <url>/2015/01/16/view-android-source-code-with-androidstudio/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了).</p><a id="more"></a><p>关于Android Studio的好处我就不用说了,下面两点就足矣让你转投Android Studio了:</p><ul><li>Android Studio是Google官方指定的,目前官网已经去掉了ADT, 大家可以在<a href="http://developer.android.com/sdk/installing/index.html" target="_blank" rel="noopener">Android开发者官网</a> 中进行查看,目前只有Android Studio提供下载了.</li><li>Google也表示ADT不再进行维护了.<br>转投Android Studio时大势所趋,网上关于如何使用Android Studio的帖子也是满天飞,所以我就不再啰嗦夸奖Android Studio了.看一下下面的图,估计你就会很有欲望了.想查看详细的内容,可以查看<a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="noopener">Android Studio官方文档</a></li></ul><p><img src="/images/view-android-source-code-with-androidstudio/androidstudio.png" alt="Android Studio Preview"></p><h2 id="Android-5-0-Lollipop"><a href="#Android-5-0-Lollipop" class="headerlink" title="Android 5.0 : Lollipop"></a>Android 5.0 : Lollipop</h2><p>Android Lollipop是Google在今年推出的,关于Lollipop的详细介绍可以查看<a href="http://developer.android.com/about/versions/lollipop.html" target="_blank" rel="noopener">Lollipop官方介绍</a> ,我也就不多说了.作为一个开发者,我们不应该停留在表面(即Lollipop的绚丽的界面,和新奇的设计语言<a href="http://developer.android.com/about/versions/lollipop.html#Material" target="_blank" rel="noopener">Material design</a>,我们更要了解其中的原理.</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在使用Android Studio查看源码之前,你需要做下面几件事:</p><ul><li>下载Android Lollipop源码(当然不一定非要是Lollipop源码,其他的版本也是可以的)</li><li>进行过一次完整编译(不编译是无法进行源码导入工作的)<br>以上操作可以参考<a href="https://source.android.com/source/initializing.html" target="_blank" rel="noopener">Google 官方教程</a> 以确保万无一失(呵呵).上面的几个链接需要翻墙才可以访问,不过有兴趣看这篇文章的人,大部分应该都是知道VPN的.或者没有VPN不会翻墙的,速度去卖一个VPN,能花钱解决的事情,就不要花时间.</li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>进入Android 源码根目录</li><li>执行<br><code>mmm development/tools/idegen/</code><br>这行命令的意思是编译idegen这个项目,生成idegen.jar文件.生成成功后,会显示这个jar包的位置,并显示<br><code>make completed successfully (43 seconds)</code> ,如果编译失败了,后面会讲到这种情况(比较少见)</li><li>执行<br><code>sh ./development/tools/idegen/idegen.sh</code><br>这行命令的意思是生成对应的文件:android.iws, android.ipr, android.iml .如果生成失败,后面也会讲到这种情况.</li><li>生成对应的文件后,打开Android Studio,选择打开一个现有的Android Studio项目,选择Android源码的根目录,导入即可(起作用的是android.irp文件).在配置sdk版本之后就可以查看Android 源码了.</li><li>已经完成了,没有下一步了.</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>执行第一个命令的时候编译不过,出现这种情况的原因有好几种:</p><ul><li>Android 源码没有下载完全</li><li>没有进行全部编译</li><li>环境变量配置有问题解决方法依问题而定,网上对应的帖子很多,可以自己去找. 推荐这种问题还是去<a href="http://www.jianshu.com/p/www.google.com" target="_blank" rel="noopener">Google</a> 和<a href="http://www.jianshu.com/p/www.stackoverflow.com" target="_blank" rel="noopener">StackOverFlow</a> 上去问.</li></ul></li><li><p>执行第二个命令的时候,碰到下面的问题:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.io.FileNotFoundException: ./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java (Is a directory)</span><br><span class="line">at java.io.<span class="module-access"><span class="module"><span class="identifier">FileInputStream</span>.</span></span><span class="keyword">open</span>(Native Method)</span><br><span class="line">at java.io.FileInputStream.&amp;lt;init&amp;gt;(<span class="module-access"><span class="module"><span class="identifier">FileInputStream</span>.</span></span>java:<span class="number">138</span>)</span><br><span class="line">at java.io.FileReader.&amp;lt;init&amp;gt;(<span class="module-access"><span class="module"><span class="identifier">FileReader</span>.</span></span>java:<span class="number">72</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>parse<span class="constructor">PackageName(Configuration.<span class="params">java</span>:204)</span></span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>root<span class="constructor">Of(Configuration.<span class="params">java</span>:180)</span></span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>traverse(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">140</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>traverse(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">167</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>traverse(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">167</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>traverse(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">167</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>traverse(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">167</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>traverse(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">167</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>traverse(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">167</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>traverse(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">167</span>)</span><br><span class="line">at Configuration.&amp;lt;init&amp;gt;(<span class="module-access"><span class="module"><span class="identifier">Configuration</span>.</span></span>java:<span class="number">72</span>)</span><br><span class="line">at <span class="module-access"><span class="module"><span class="identifier">Main</span>.</span></span>main(<span class="module-access"><span class="module"><span class="identifier">Main</span>.</span></span>java:<span class="number">37</span>)</span><br></pre></td></tr></table></figure></li></ul><p>解决办法是将<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java</code><br>修改为:<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.j</code><br>即可.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>使用Android Studio看Android源码很爽，下面是他们的优缺点：</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>和Android 完美结合</li><li>代码提示很全</li><li>代码跳转很强</li><li>IDE比Eclipse好看(我说的是黑色主题)</li><li>插件很强大(底层是IDEA你懂得)</li><li>免费(SourceInsight负分,啥?你用的破解版? 当我没说)</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对C＋＋代码的支持不是很好</li><li>有一定的上手难度</li></ul><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化之过渡绘制 - 实战篇</title>
      <link href="/2015/01/13/android-performance-optimization-overdraw-2/"/>
      <url>/2015/01/13/android-performance-optimization-overdraw-2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇<a href="https://www.androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/" target="_blank" rel="noopener">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p><p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。</p><p>如果没有看过前一篇，可以点这里：<a href="https://www.androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/" target="_blank" rel="noopener">Android性能优化之过渡绘制(一)</a></p><hr><a id="more"></a><h2 id="定位过渡绘制区域"><a href="#定位过渡绘制区域" class="headerlink" title="定位过渡绘制区域"></a>定位过渡绘制区域</h2><h3 id="打开GPU过渡绘制选项"><a href="#打开GPU过渡绘制选项" class="headerlink" title="打开GPU过渡绘制选项:"></a>打开GPU过渡绘制选项:</h3><p>设置—辅助功能–开发人员工具–硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域.</p><h3 id="清理后台"><a href="#清理后台" class="headerlink" title="清理后台"></a>清理后台</h3><p>Kill掉(即清后台)要测试的应用,重新打开就可以看到效果.下面以文件管理器和设置为例子,如下图</p><p><img src="/images/overdraw-1/filemanager-1.png" alt="文件管理器">)<img src="/images/overdraw-1/settings.png" alt="设置"></p><p>从图上可以看出,按照过渡绘制从好到坏(蓝-绿-粉红-红)来看,文件管理器的过渡绘制是非常严重的,而设置界面的过渡绘制则在可以接受的范围内.下面就以文件管理器为主要分析对象,来看看如何对文件管理器的过渡绘制进行优化.</p><h3 id="从文件管理器的图-分析出过渡绘制区域"><a href="#从文件管理器的图-分析出过渡绘制区域" class="headerlink" title="从文件管理器的图,分析出过渡绘制区域:."></a>从文件管理器的图,分析出过渡绘制区域:.</h3><ul><li>首先看最上面的ActionBar和最下面的SmartBar,对比设置界面的ActionBar就可以知道,整个文件管理器存在一个不透明的背景,导致每次绘制时,都要先绘制这个看不见且不透明的背景.这个背景一般是应用的主题自带的背景,所以GPU过渡绘制显示其位蓝色,这个背景是可以进行优化的.</li><li>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制,去掉第一条我们提的那个全局背景,还有一层背景,也就是1x的过渡绘制,对比setting可知,这个背景色也是可以去掉的.</li><li>最容易看出的是这两条,我们先分析和优化这两条,然后再进行其他的优化.</li></ul><h2 id="优化过渡绘制区域"><a href="#优化过渡绘制区域" class="headerlink" title="优化过渡绘制区域"></a>优化过渡绘制区域</h2><p>在进行位置确认后，我们大概确定了过渡绘制的区域,让我们来使用工具来进行验证和View确认.</p><p>打开Monitor(Eclipse和Android Studio中都有快捷打开按钮,即DDMS,右上角选择 Hierarchy View,大概使用如图</p><p><img src="/images/overdraw-1/HierarchyView-1.png" alt="Hierarchy View"></p><p>其中根节点:PhoneWindos$DecorView是整个视图的根节点,唯一的子节点是ActionBarOverlayLayout,这个Layout包含了ActionBar,应用程序,以及SmartBar.</p><p>下面讲述如何从Hierarchy View结合代码分析出需要进行修改的区域</p><h3 id="去除默认背景"><a href="#去除默认背景" class="headerlink" title="去除默认背景"></a>去除默认背景</h3><p>上面分析过渡绘制区域的第一条,整个window存在一个背景,所以进行了一次重绘,这个背景的重绘是系统级别的,和主题有关,即这个背景是属于ActionBarOverlayLayout的.这种类型的过渡绘制解决也比较方便,在文件管理器的主Activity的onCreate方法中,加入</p><p><code>this.getWindow().setBackgroundDrawableResource(android.R.color.transparent);</code></p><p>就可以将这个看不见的主题背景去掉.下面是去掉主题背景后的效果图(一张是划开,一张是没有划开):</p><p><img src="/images/overdraw-1/filemanager-2.png" alt="文件管理器">)<img src="/images/overdraw-1/filemanager-3.png" alt="文件管理器"></p><p>对比优化前的图可以发现,背景被去掉之后,少了一层过渡绘制. ActionBar上的蓝色已经消失了.中间的内容由绿色变为蓝色</p><h3 id="消除子控件背景"><a href="#消除子控件背景" class="headerlink" title="消除子控件背景"></a>消除子控件背景</h3><p>上面分析的第二条说”<strong>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制</strong>”,现在中间部分变成了蓝色,但是这是一个全局的背景,导致右边的view拉过来之后,还是存在大量的红色和绿色. 继续分析Hierarchy View,找到中间view对应的视图:DragRelativeLayout,查看源码可知,DragRelativeLayout继承自公共控件:SlidingMenu ，SlidingMenu 由CustomViewAbove和CustomViewBehind组成,前者是上面可以左右拉动的那部分,后者是底部不能拉动的那部分(这个从HierarchyView中也可以看出来:如下图所示:</p><p><img src="/images/overdraw-1/HierarchyView-2.png" alt="Hierarchy View"></p><p>点击CustomViewBehind,查看其所占的区域,就可以发现背景是这个View进行绘制的,打开CustomViewBehind的代码可以发现其构造函数中包含下面的代码:<br><code>setBackgroundColor(getResources().getColor(R.color.mz_slidingmenu_background_light));</code><br>这个背景是不需要的,查看源码可知,这个view会在SlidingMenu.setMenu的时候,被覆盖掉,还是看不到的.所以这一层view是可以去掉的.下面是去掉一层背景之后的预览图:</p><p><img src="/images/overdraw-1/filemanager-4.png" alt="文件管理器">)<img src="/images/overdraw-1/filemanager-5.png" alt="文件管理器"></p><p>可以看到这一层背景去掉之后,过渡绘制减轻了很多.</p><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>接着进行分析,可以看到CustomViewAbove也是存在一个过渡绘制的背景的,查看Hierarchy View的CustomViewAbove的子节点,可以看到过渡绘制是由ListView导致的.其id为:FilesList,在代码中找到它,并对他进行分析.在我将PartitionItemLayout中onDraw()函数的setBounds去掉之后,过渡绘制进一步改善了(但是ListItem的View的颜色也比之前要浅了,这一步优化需要根据具体情况进行) 下面是优化后的效果图:</p><p><img src="/images/overdraw-1/filemanager-6.png" alt="文件管理器">)<img src="/images/overdraw-1/filemanager-7.png" alt="文件管理器"></p><p>可以看到图中的过渡绘制已经非常少了.!点个赞!</p><hr><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><h3 id="Lint工具"><a href="#Lint工具" class="headerlink" title="Lint工具"></a>Lint工具</h3><p>Lint工具的使用比较简单,根据给出的提示做对应的修改即可.有时候需要工具具体情况来确定是否需要修改. 下图是一个简单地例子.箭头处提示这个Layout或者它的父Layout是不必须的.具体修改方法即去掉FrameLayout,将RelativeLayout提升为根VIew即可.</p><p><img src="/images/overdraw-1/lint-1.png" alt="Lint"></p><p>Lint工具还会针对代码中潜在的不合理或者Bed Code做出修改意见.比较重要的提示包括</p><ul><li>声明但是没有使用的变量</li><li>可能会产生的空指针</li><li>没必要书写的return,continue</li><li>复杂代码的简化写法</li><li>for循环的简化写法:foreach</li><li>无效的判空</li><li>空if</li><li>无效或者未使用的import</li></ul><h3 id="使用Tracer-For-OpenGL-ES"><a href="#使用Tracer-For-OpenGL-ES" class="headerlink" title="使用Tracer For OpenGL ES"></a>使用Tracer For OpenGL ES</h3><p>Tracer工具也在Android Device Monitor中.点击右上角的Tracer for OpenGL ES按钮就可以进入(如果没有这个按钮,点击旁边的Open Perspective按钮,从选项中选择Tracer for OpenGL ES即可).初次打开Tracer工具,里面是没有内容的,点击右上角的两个按钮(一个是打开现有的GLTrace文件,另一个是新建GLTrace文件)。点击Trace按钮, 手机会自动启动应用程序并启动对应的Activity,当手机上的内容完全绘制出来之后,就可以点击Stop按钮,生成GlTrace文件.文件会自动打开.</p><p><img src="/images/overdraw-1/Tracer-1.png" alt="Tracer"></p><p>分析GLTrace文件，下图是优化过后的图,对比优化前的图可以发现,优化后不会去绘制默认的背景图和CustomViewBehind的背景图.</p><p><img src="/images/overdraw-1/Tracer-2.png" alt="Tracer"></p><p>这只是一帧的绘制,如果多操作几下生成多个帧的绘制trace文件,会发现这两个背景会被多次的重绘,去掉后不仅会减轻过渡绘制,也会加快GUP的绘制速度.</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="noopener">优化过程</a></li><li><a href="http://blog.csdn.net/yihongyuelan/article/details/12169647" target="_blank" rel="noopener">反编译并添加gpu显示</a></li><li><a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect" target="_blank" rel="noopener">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a></li><li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="noopener">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a></li><li><a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html" target="_blank" rel="noopener">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a></li><li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html" target="_blank" rel="noopener">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a></li><li><a href="http://developer.android.com/tools/help/hierarchy-viewer.html" target="_blank" rel="noopener">http://developer.android.com/tools/help/hierarchy-viewer.html</a></li><li><a href="http://tools.android.com/tips/lint" target="_blank" rel="noopener">http://tools.android.com/tips/lint</a></li></ol><hr><blockquote><p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&wvr=6" target="_blank" rel="noopener">Gracker</a></p><p>出处：<a href="https://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/">androidperformance.com</a></p><p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p><p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&wvr=6&mod=wenzhangmod" target="_blank" rel="noopener">微博打赏</a></p></blockquote><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化之过渡绘制 - 理论篇</title>
      <link href="/2014/10/20/android-performance-optimization-overdraw-1/"/>
      <url>/2014/10/20/android-performance-optimization-overdraw-1/</url>
      
        <content type="html"><![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p><p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p><h2 id="过渡绘制概念"><a href="#过渡绘制概念" class="headerlink" title="过渡绘制概念"></a>过渡绘制概念</h2><p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p><a id="more"></a><h2 id="过渡绘制的原因"><a href="#过渡绘制的原因" class="headerlink" title="过渡绘制的原因"></a>过渡绘制的原因</h2><ol><li>太多的View叠加</li><li>复杂的层级叠加</li><li>更长的inflation时间</li></ol><h2 id="过渡绘制和不合理的xml布局的影响"><a href="#过渡绘制和不合理的xml布局的影响" class="headerlink" title="过渡绘制和不合理的xml布局的影响"></a>过渡绘制和不合理的xml布局的影响</h2><ol><li>布局文件是一个xml文件，inflate布局文件其实就是解析xml，根据标签信息创建相应的布局对象并做关联。xml中的标签和属性设置越多，节点树的深度越深，在解析时要执行的判断逻辑、函数的嵌套和递归就越多，所以时间消耗越多；</li><li>inflate操作只是布局影响的第一个环节，一个界面要显示出来，在requestLayout后还要执行一系列的measure、layout、draw的操作，每一步的执行时间都会受到布局本身的影响。而界面的最终显示是所有这些操作完成后才实现的，所以如果布局质量差，会增加每一步操作的时间成本，最终显示时间就会比较长。</li></ol><h2 id="过渡绘制的一些基本概念"><a href="#过渡绘制的一些基本概念" class="headerlink" title="过渡绘制的一些基本概念:"></a>过渡绘制的一些基本概念:</h2><p>Android提供了三个工具来帮助辨别和解决重绘问题：Hierachy Viewer，Tracer for OpenGL和Show GPU overdraw。前两个可以在ADT工具或者独立的monitor工具中找到，最后一个是在开发者选项的一部分.</p><ol><li>GPU过渡绘制测试:对于过度绘制的测试主要通过人工进行测试，也是发现应用过渡绘制的首选途径 .通过打开开发者选项中的 显示GPU过度绘制(魅族手机:设置—辅助功能–开发人员工具–硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域. (魅族手机需要打开开发者模式：需要在电话界面输入: <em>#</em>#6961#<em>#</em> )) 来进行测试（PS：只有android4.2及以上的版本才具备此功能)</li><li>颜色标识: GPU过渡绘制从好到差:蓝-绿-淡红-红<ul><li>蓝色1x过度绘制</li><li>绿色2x过度绘制</li><li>淡红色3x过度绘制</li><li>红色超过4x过度绘制</li></ul></li><li>验收标准:<ul><li>控制过度绘制为2x</li><li>不允许存在4x过度绘制</li><li>不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域）</li></ul></li></ol><h2 id="优化工具介绍"><a href="#优化工具介绍" class="headerlink" title="优化工具介绍"></a>优化工具介绍</h2><ol><li><p>Lint工具:</p><ul><li>Eclipse中,点击即可,下面的窗口中会出现提示,根据提示和具体解决办法消除.</li><li>Android Studio自带Lint工具,不合理或者需要优化和注意的地方,会用黄色标记出来.</li><li>Lint工具不仅对布局有很好的优化建议,对代码中不合理的活着存在潜在风险的模块也会提出优化建议,所以一个好的建议是:多使用Lint工具检查自己的应用,尽量消除所有的建议.</li><li>Lint工具可以用命令行来运行,具体使用可以参考:<a href="tools.android.com">tools.android.com</a><br><img src="/images/overdraw-1/lint.png" alt="Lint"></li></ul></li><li><p>Lint工具的提升例子(摘自官方文档):</p><ul><li>Use compound drawables(使用compound drawables) - A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable.</li><li>Merge root frame(使用Merge根框架) - If a FrameLayout is the root of a layout and does not provide background or padding etc, it can be replaced with a merge tag which is slightly more efficient.</li><li>Useless leaf(去除无用的分支) - A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.</li><li>Useless parent (去除无用的父控件)- A layout with children that has no siblings, is not a ScrollView or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.</li><li>Deep layouts (注意Layout的深度) - Layouts with too much nesting are bad for performance. Consider using flatter layouts such as RelativeLayout or GridLayout to improve performance. The default maximum depth is</li></ul></li><li><p>Hierarchy Viewer:此工具是一个ADT工具（或者monitor,最新版本的SDK建议不使用独立的HV工具,而是直接在monitor中进行操作.）的一部分，可以被用作对视图层级进行快速解读。在处理布局问题时特别有用，对于性能问题也很适用。Hierarchy Viewer默认只能在非加密设备使用，例如工程机，工程平板或者模拟器。为了能够在任何手机上使用Hierarchy Viewer，你得在你的应用中添加ViewServer，这是一个开源库,使用方法可以参考这里。连接上设备，打开Hierarchy Viewer(定位到tools/目录下，直接执行hierarchyviewer的命令，选定需要查看的Process，再点击Load View Hierarchy会显示出当前界面的布局Tree。在每个模块的Traffic light上有三个灯，分别代表了Measure, Layout and Draw三个步骤的性能。</p></li></ol><h2 id="布局优化建议"><a href="#布局优化建议" class="headerlink" title="布局优化建议"></a>布局优化建议</h2><p>在Android UI布局过程中，通过遵守一些惯用、有效的布局原则，我们可以制作出高效且复用性高的UI，概括来说包括如下几点：</p><ul><li><p>尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，</p><ul><li>在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点.</li><li>在完成相对较复杂的布局时,建议使用RelativeLayout,RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局.</li></ul></li><li><p>将可复用的组件抽取出来并通过include标签使用；</p></li><li><p>使用ViewStub标签来加载一些不常用的布局；</p></li><li><p>动态地inflation view性能要比SetVisiblity性能要好.当然用VIewStub是最好的选择.</p></li><li><p>使用merge标签减少布局的嵌套层次</p></li><li><p>去掉多余的背景颜色(查看背景颜色是否多余,可以将HierarchyView中的图导出为psd文件,然后用Photoshop查看.具体可以参考这个<a href="https://www.youtube.com/watch?v=URyoiAt8098" target="_blank" rel="noopener">视频</a>)</p><ul><li>对于有多层背景颜色的Layout来说,留最上面一层的颜色即可,其他底层的颜色都可以去掉</li><li>对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为&quot;@android:color/transparent”,来解决对应的问题</li></ul></li><li><p>内嵌使用包含layout_weight属性的LinearLayout会在绘制时花费昂贵的系统资源，因为每一个子组件都需要被测量两次。在使用ListView与GridView的时候，这个问题显的尤其重要，因为子组件会重复被创建.所以要尽量避免使用Layout_weight</p></li><li><p>使得Layout宽而浅，而不是窄而深（在Hierarchy Viewer的Tree视图里面体现）</p></li></ul><h2 id="源码相关"><a href="#源码相关" class="headerlink" title="源码相关"></a>源码相关</h2><p>另外有能力看源码的同学，下面是绘制OverDraw的源码位置：/frameworks/base/libs/hwui/OpenGLRenderer.cpp,有兴趣的可以去研究研究。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> OpenGLRenderer::renderOverdraw() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCaches.debugOverdraw &amp;amp;&amp;amp; getTargetFbo() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> Rect* clip = &amp;amp;mTilingClip;</span><br><span class="line"></span><br><span class="line">        mCaches.enableScissor();</span><br><span class="line">        mCaches.setScissor(clip-&amp;gt;left, mFirstSnapshot-&amp;gt;height - clip-&amp;gt;bottom,</span><br><span class="line">                clip-&amp;gt;right - clip-&amp;gt;left, clip-&amp;gt;bottom - clip-&amp;gt;top);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1x overdraw</span></span><br><span class="line">        mCaches.stencil.enableDebugTest(<span class="number">2</span>);</span><br><span class="line">        drawColor(mCaches.getOverdrawColor(<span class="number">1</span>), SkXfermode::kSrcOver_Mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2x overdraw</span></span><br><span class="line">        mCaches.stencil.enableDebugTest(<span class="number">3</span>);</span><br><span class="line">        drawColor(mCaches.getOverdrawColor(<span class="number">2</span>), SkXfermode::kSrcOver_Mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3x overdraw</span></span><br><span class="line">        mCaches.stencil.enableDebugTest(<span class="number">4</span>);</span><br><span class="line">        drawColor(mCaches.getOverdrawColor(<span class="number">3</span>), SkXfermode::kSrcOver_Mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4x overdraw and higher</span></span><br><span class="line">        mCaches.stencil.enableDebugTest(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">        drawColor(mCaches.getOverdrawColor(<span class="number">4</span>), SkXfermode::kSrcOver_Mode);</span><br><span class="line"></span><br><span class="line">        mCaches.stencil.disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> OpenGLRenderer::countOverdraw() &#123;</span><br><span class="line">    size_t count = mWidth * mHeight;</span><br><span class="line">    <span class="built_in">uint</span>32_t* buffer = new <span class="built_in">uint</span>32_t[count];</span><br><span class="line">    glReadPixels(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, &amp;amp;buffer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    size_t total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &amp;lt; count; i++) &#123;</span><br><span class="line">        total += buffer[i] &amp;amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOverdraw = total / <span class="built_in">float</span>(count);</span><br><span class="line"></span><br><span class="line">    delete[] buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有QA可能用得到的一个指标：OverDraw数值，这个的源码位置在Framework/base/core/java/android/view/HardwareRender.java中(5.0中去掉了这个数值的显示)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> debugOverdraw(<span class="keyword">View</span>.AttachInfo attachInfo, Rect dirty,</span><br><span class="line">                HardwareCanvas canvas, DisplayList displayList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mDebugOverdraw == OVERDRAW_TYPE_COUNT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDebugOverdrawLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mDebugOverdrawLayer = createHardwareLayer(mWidth, mHeight, <span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDebugOverdrawLayer.getWidth() != mWidth ||</span><br><span class="line">                        mDebugOverdrawLayer.getHeight() != mHeight) &#123;</span><br><span class="line">                    mDebugOverdrawLayer.resize(mWidth, mHeight);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mDebugOverdrawLayer.isValid()) &#123;</span><br><span class="line">                    mDebugOverdraw = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                HardwareCanvas layerCanvas = mDebugOverdrawLayer.<span class="keyword">start</span>(canvas, dirty);</span><br><span class="line">                countOverdraw(layerCanvas);</span><br><span class="line">                final <span class="type">int</span> restoreCount = layerCanvas.save();</span><br><span class="line">                layerCanvas.drawDisplayList(displayList, <span class="keyword">null</span>, DisplayList.FLAG_CLIP_CHILDREN);</span><br><span class="line">                layerCanvas.restoreToCount(restoreCount);</span><br><span class="line">                mDebugOverdrawLayer.<span class="keyword">end</span>(canvas);</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> overdraw = getOverdraw(layerCanvas);</span><br><span class="line">                DisplayMetrics metrics = attachInfo.mRootView.getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">                drawOverdrawCounter(canvas, overdraw, metrics.density);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="type">void</span> drawOverdrawCounter(HardwareCanvas canvas, <span class="type">float</span> overdraw, <span class="type">float</span> density) &#123;</span><br><span class="line">            final String <span class="type">text</span> = String.format(\"%.2fx\", overdraw);</span><br><span class="line">            final Paint paint = setupPaint(density);</span><br><span class="line">            // HSBtoColor will clamp the <span class="keyword">values</span> <span class="keyword">in</span> the <span class="number">0.</span><span class="number">.1</span> range</span><br><span class="line">            paint.setColor(Color.HSBtoColor(<span class="number">0.28</span>f - <span class="number">0.28</span>f * overdraw / <span class="number">3.5</span>f, <span class="number">0.8</span>f, <span class="number">1.0</span>f));</span><br><span class="line"></span><br><span class="line">            canvas.drawText(<span class="type">text</span>, density * <span class="number">4.0</span>f, mHeight - paint.getFontMetrics().bottom, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="noopener">优化过程</a></li><li><a href="http://blog.csdn.net/yihongyuelan/article/details/12169647" target="_blank" rel="noopener">反编译并添加gpu显示</a></li><li><a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect" target="_blank" rel="noopener">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a></li><li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="noopener">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a></li><li><a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html" target="_blank" rel="noopener">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a></li><li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html" target="_blank" rel="noopener">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a></li><li><a href="http://developer.android.com/tools/help/hierarchy-viewer.html" target="_blank" rel="noopener">http://developer.android.com/tools/help/hierarchy-viewer.html</a></li><li><a href="http://tools.android.com/tips/lint" target="_blank" rel="noopener">http://tools.android.com/tips/lint</a></li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 小技巧 - 如何让EditText不自动获取焦点</title>
      <link href="/2014/06/03/android-edittext-do-not-auto-get-focus/"/>
      <url>/2014/06/03/android-edittext-do-not-auto-get-focus/</url>
      
        <content type="html"><![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p><p>这里有个很简单也很实用的技巧,即在EditText的父Layout中,加入下面的两个属性即可:</p><pre class="lang:java decode:true ">android:focusable="true"  android:focusableInTouchMode="true"</pre><p>这样做的原理是让用户进入到这个页面之后,EditText的父控件 获取焦点,这样的话EditText就获取不到焦点,软键盘也不会自动弹起.只有在点击EditText的时候,软键盘才会弹起.</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 小技巧 -2</title>
      <link href="/2014/05/31/android-tips-round-up-2/"/>
      <url>/2014/05/31/android-tips-round-up-2/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29" target="_blank" rel="noopener">DateUtils.formatDateTime()</a> 用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p><p>[AlarmManager.setInexactRepeating](<a href="http://developer.android.com/reference/android/app/AlarmManager.html#setInexactRepeating" target="_blank" rel="noopener">http://developer.android.com/reference/android/app/AlarmManager.html#setInexactRepeating</a>(int, long, long, android.app.PendingIntent)) 通过闹铃分组的方式省电,即使你只调用了一个闹钟,这也是一个好的选择,（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象,这里详细说一下:setInexactRepeating指的是设置非准确闹钟,使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC, startTime,intervalL, pendingIntent),非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个, 所以这么看来,非准时闹钟一般来说比较节约能源.</p><p>[Formatter.formatFileSize()](<a href="http://developer.android.com/reference/android/text/format/Formatter.html#formatFileSize" target="_blank" rel="noopener">http://developer.android.com/reference/android/text/format/Formatter.html#formatFileSize</a>(android.content.Context, long)) 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB,G,KB之类的字符串.</p><p><a href="http://developer.android.com/reference/android/app/ActionBar.html#hide()" target="_blank" rel="noopener">ActionBar.hide()</a>/<a href="http://developer.android.com/reference/android/app/ActionBar.html#show()" target="_blank" rel="noopener">.show()</a> 顾名思义,隐藏和显示ActionBar,可以优雅地在全屏和带Actionbar之间转换.</p><p>[Linkify.addLinks()](<a href="http://developer.android.com/reference/android/text/util/Linkify.html#addLinks" target="_blank" rel="noopener">http://developer.android.com/reference/android/text/util/Linkify.html#addLinks</a>(android.text.Spannable, int))  在Text上添加链接.很实用.</p><p><a href="http://developer.android.com/reference/android/text/StaticLayout.html" target="_blank" rel="noopener">StaticLayout</a> 在自定义 View 中渲染文字的时候很实用。</p><p><a href="http://developer.android.com/reference/android/app/Activity.html#onBackPressed()" target="_blank" rel="noopener">Activity.onBackPressed()</a> 很方便的管理back键的方法,有时候需要自己控制返回键的事件的时候,可以重写一下.比如加入 “点两下back键退出” 功能.</p><p><a href="http://developer.android.com/reference/android/view/GestureDetector.html" target="_blank" rel="noopener">GestureDetector</a> 用来监听和相应对应的手势事件,比如点击,长按,慢滑动,快滑动,用起来很简单,比你自己实现要方便许多.</p><p><a href="http://developer.android.com/reference/android/graphics/DrawFilter.html" target="_blank" rel="noopener">DrawFilter</a> 可以让你在不调用onDrew方法的情况下,操作canvas,比了个如,你可以在创建自定义 View 的时候设置一个 DrawFilter，给父 View 里面的所有 View 设置反别名。</p><p><a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass()" target="_blank" rel="noopener">ActivityManager.getMemoryClass()</a> 告诉你你的机器还有多少内存,在计算缓存大小的时候会比较有用.</p><p><a href="http://developer.android.com/reference/android/view/ViewStub.html" target="_blank" rel="noopener">ViewStub</a> 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。</p><p><a href="http://developer.android.com/reference/android/os/SystemClock.html#sleep(long)" target="_blank" rel="noopener">SystemClock.sleep()</a> 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。</p><p><a href="http://developer.android.com/reference/android/util/DisplayMetrics.html#density" target="_blank" rel="noopener">DisplayMetrics.density</a> 这个方法你可以获取设备像素密度,大部分时候最好让系统来自动进行缩放资源之类的操作,但是有时候控制的效果会更好一些.(尤其是在自定义View的时候).</p><p>[Pair.create()](<a href="http://developer.android.com/reference/android/util/Pair.html#create" target="_blank" rel="noopener">http://developer.android.com/reference/android/util/Pair.html#create</a>(A, B)) 方便构建类和构造器的方法。</p><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><ol><li><a href="https://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="noopener">Part1</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="noopener">Part2</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="noopener">Part3</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="noopener">Part4</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="noopener">Part5</a></li></ol><p>原文地址:<a href="http://blog.danlew.net/2014/04/14/android-tips-round-up-part-2/" target="_blank" rel="noopener">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-2/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="noopener">http://blog.danlew.net/about/</a><br>本文地址:<a href="https://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="noopener">https://www.androidperformance.com/android-tips-round-up-2.html</a> 转载请注明.</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 小技巧 - 1</title>
      <link href="/2014/05/28/android-tips-round-up-1/"/>
      <url>/2014/05/28/android-tips-round-up-1/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[])" target="_blank" rel="noopener">Activity.startActivities()</a> 常用于在应用程序中间启动其他的Activity.</p><p><a href="http://developer.android.com/reference/android/text/TextUtils.html#isEmpty(java.lang.CharSequence)" target="_blank" rel="noopener">TextUtils.isEmpty()</a> 简单的工具类,用于检测是否为空</p><p><a href="http://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String)" target="_blank" rel="noopener">Html.fromHtml()</a> 用于生成一个Html,参数可以是一个字符串.个人认为它不是很快,所以我不怎么经常去用.（我说不经常用它是为了重点突出这句话：请多手动构建 Spannable 来替换 Html.fromHtml），但是它对渲染从 web 上获取的文字还是很不错的。</p><p><a href="http://developer.android.com/reference/android/widget/TextView.html#setError%28java.lang.CharSequence%29" target="_blank" rel="noopener">TextView.setError()</a> 在验证用户输入的时候很棒</p><p><a href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html" target="_blank" rel="noopener">Build.VERSION_CODES</a> 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性</p><p><a href="http://developer.android.com/reference/android/util/Log.html#getStackTraceString(java.lang.Throwable)" target="_blank" rel="noopener">Log.getStackTraceString()</a> 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候.</p><p><a href="http://developer.android.com/reference/android/view/LayoutInflater.html#from%28android.content.Context%29" target="_blank" rel="noopener">LayoutInflater.from()</a> 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多.</p><p><a href="http://developer.android.com/reference/android/view/ViewConfiguration.html#getScaledTouchSlop%28%29" target="_blank" rel="noopener">ViewConfiguration.getScaledTouchSlop()</a> 使用 ViewConfiguration 中提供的值以保证所有触摸的交互都是统一的。这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动.当然这个值也可以自己来决定.但是为了一致性,还是使用标准的值较好.</p><p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#convertKeypadLettersToDigits%28java.lang.String%29" target="_blank" rel="noopener">PhoneNumberUtils.convertKeypadLettersToDigits</a> 顾名思义.将字母转换为数字,类似于T9输入法,</p><p><a href="http://developer.android.com/reference/android/content/Context.html#getCacheDir%28%29" target="_blank" rel="noopener">Context.getCacheDir()</a> 获取缓存数据文件夹的路径,很简单但是知道的人不多,这个路径通常在SD卡上(这里的SD卡指的是广义上的SD卡,包括外部存储和内部存储)Adnroid/data/您的应用程序包名/cache/  下面.测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空.</p><p><a href="http://developer.android.com/reference/android/animation/ArgbEvaluator.html" target="_blank" rel="noopener">ArgbEvaluator</a> 用于处理颜色的渐变。就像 Chris Banes 说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。这个没用过,不明其所以然,回头再补充.</p><p><a href="http://developer.android.com/reference/android/view/ContextThemeWrapper.html" target="_blank" rel="noopener">ContextThemeWrapper</a> 方便在运行的时候修改主题.</p><p><a href="http://developer.android.com/reference/android/widget/Space.html" target="_blank" rel="noopener">Space</a> space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。</p><p><a href="http://developer.android.com/reference/android/animation/ValueAnimator.html#reverse%28%29" target="_blank" rel="noopener">ValueAnimator.reverse()</a> 这个方法可以很顺利地取消正在运行的动画.我超喜欢.</p><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><ol><li><a href="https://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="noopener">Part1</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="noopener">Part2</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="noopener">Part3</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="noopener">Part4</a></li><li><a href="https://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="noopener">Part5</a></li></ol><p>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/" target="_blank" rel="noopener">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="noopener">http://blog.danlew.net/about/</a><br>本文地址:<a href="https://www.androidperformance.com/android-tips-round-up-1.html" target="_blank" rel="noopener">https://www.androidperformance.com/android-tips-round-up-1.html</a> 转载请注明.</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Tools - Log2File</title>
      <link href="/2014/05/02/android_log_to_file/"/>
      <url>/2014/05/02/android_log_to_file/</url>
      
        <content type="html"><![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><div style="color: #000000;"><ol><li>无法连接电脑进行调试（usb线被usbotg占用）</li><li>Log不容易被抓取</li><li>Bug出现很随机，不是必出现</li><li>其他自己脑补</li></ol><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0.说明"></a>0.说明</h2><p>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" target="_blank" rel="noopener" title="Log2File类的使用">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" target="_blank" rel="noopener" title="Log2File的github地址">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a></p><a id="more"></a><h2 id="1-Log2File工具类源码"><a href="#1-Log2File工具类源码" class="headerlink" title="1.Log2File工具类源码"></a>1.Log2File工具类源码</h2><pre class="lang:java decode:true " title="Log2File工具类源码">import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.Date;import android.content.Context;import android.os.Environment;public class Log2File{    private static boolean  logInit;    private static BufferedWriter writer;    private Log2File()    {    }    /**     * 初始化Log,创建log文件     * @param ctx     * @param fileName     * @return     */    public static boolean init(Context ctx, String fileName)    {        if(!logInit)        {                       String state = Environment.getExternalStorageState();            if (Environment.MEDIA_MOUNTED.equals(state))            {                File sdDir = Environment.getExternalStorageDirectory();                File logDir = new File(sdDir.getAbsolutePath() + "/log2file/" +                         ctx.getPackageName() + "/");                try {                    if(!logDir.exists())                    {                        logDir.mkdirs();                    }                    File logFile = new File(logDir, fileName);                    logFile.createNewFile();                    writer = new BufferedWriter(new FileWriter(logFile, true));                    logInit = true;                } catch (IOException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }        }        return logInit;    }    /**     * 写一条log     * @param msg     */    public static void w(String msg)    {        if(logInit)        {            try {                Date date = new Date();                writer.write("[" + date.toLocaleString() + "] " + msg);                writer.newLine();                writer.flush();            } catch (IOException e) {                // TODO Auto-generated catch block            }        }    }    /**     * 关闭log     */    public static void close()    {        if(logInit)        {            try {                writer.close();                writer = null;            } catch (IOException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }            logInit = false;        }    }}</pre><h2 id="2-Log2File类的使用"><a href="#2-Log2File类的使用" class="headerlink" title="2.Log2File类的使用"></a>2.Log2File类的使用</h2><div>这个工具类的使用比较简单</div><div>1.首先调用init进行初始化</div><div><pre class="lang:java decode:true " title="Log2File类的初始化">Log2File.init(context, fileName);</pre>2.调用w()进行输出<pre class="lang:java decode:true " title="调用w(String msg)函数进行输出">Log2File.w(String msg);</pre>3.使用完毕后，记得要关闭Log<pre class="lang:java decode:true  crayon-selected" title="关闭Log">Log2File.close();</pre></div></div><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Service：开发自己的通知中心(2):辅助性服务实战</title>
      <link href="/2014/04/01/android-service-build-your-own-notification-servers-app/"/>
      <url>/2014/04/01/android-service-build-your-own-notification-servers-app/</url>
      
        <content type="html"><![CDATA[<h2 id="1-辅助性服务实战介绍"><a href="#1-辅助性服务实战介绍" class="headerlink" title="1.辅助性服务实战介绍"></a>1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p><a id="more"></a><p>下面就来介绍如何开发自己的通知中心。</p><h2 id="2-开发第三方通知中心"><a href="#2-开发第三方通知中心" class="headerlink" title="2.开发第三方通知中心"></a>2.开发第三方通知中心</h2><h3 id="2-1继承AccessibilitySerivce"><a href="#2-1继承AccessibilitySerivce" class="headerlink" title="2.1继承AccessibilitySerivce"></a>2.1继承AccessibilitySerivce</h3><p>按照上一篇辅助性服务的介绍，一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建，我们这里建立一个服务，继承AccessibilitySerivce</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.accessibilityservice.AccessibilityService;</span><br><span class="line"><span class="keyword">import</span> android.accessibilityservice.AccessibilityServiceInfo;</span><br><span class="line"><span class="keyword">import</span> android.app.Notification;</span><br><span class="line"><span class="keyword">import</span> android.app.PendingIntent;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.accessibility.AccessibilityEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.accessibility.AccessibilityNodeInfo;</span><br><span class="line"><span class="keyword">import</span> android.view.accessibility.AccessibilityRecord;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationFetcherService</span> <span class="keyword">extends</span> <span class="title">AccessibilityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = \<span class="string">"NotificationFetcherService: \";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public void onAccessibilityEvent(AccessibilityEvent event) &#123;</span></span><br><span class="line"><span class="string">        if (!(event.getEventType() == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED) )&#123;</span></span><br><span class="line"><span class="string">            return;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Notification localNotification = (Notification)event.getParcelableData();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if (localNotification != null) &#123;</span></span><br><span class="line"><span class="string">            Intent intent=new Intent();</span></span><br><span class="line"><span class="string">            intent.putExtra(\"NotifyData\", localNotification);</span></span><br><span class="line"><span class="string">            intent.setAction(\".NotificationFetcherService\");</span></span><br><span class="line"><span class="string">            sendBroadcast(intent);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    protected void onServiceConnected() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Define it in both xml file and here,  for compatibility with pre-ICS devices</span></span><br><span class="line"><span class="string">        AccessibilityServiceInfo info = new AccessibilityServiceInfo();</span></span><br><span class="line"><span class="string">        info.eventTypes = AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED |</span></span><br><span class="line"><span class="string">                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED | </span></span><br><span class="line"><span class="string">                AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;</span></span><br><span class="line"><span class="string">        setServiceInfo(info);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public void onInterrupt() &#123;</span></span><br><span class="line"><span class="string">        System.out.println(\"onInterrupt\");</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>继承AccessibilitySerivce必须要重写几个重要的方法：</p><ol><li>onServiceConnected方法负责在服务和Activity绑定的时候，进行初始化数据，这里新建了一个AccessibilityServiceInfo对象，并将TYPE_NOTIFICATION_STATE_CHANGED、TYPE_WINDOW_STATE_CHANGED、TYPE_WINDOW_CONTENT_CHANGED纳入监听范围，TYPE_NOTIFICATION_STATE_CHANGED表示这个服务可以监听Notification的变化，我们正是使用这个特性来实现第三方的通知中心功能。</li><li>onInterrupt是服务断开时调用的函数</li><li>onAccessibilityEvent是最重要的，它负责监听所注册的eventTypes（在onServiceConnected中注册的）的事件。从上面的代码中我们可以得到一个Notification对象：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification localNotification = (Notification)event.getParcelableData();</span><br></pre></td></tr></table></figure><p>得到Notification对象之后，就可以进行自己的操作，我这里是通过广播的形式，将收到的Notification发送给Activity进行处理。</p><p>这里也会碰到一个小问题：当一个Notification对象太大时（比如截图、未接来电等，Notification.contentView就很大，通过广播传播会出现data过大无法传输的问题），这时可以把Notification.contentView对象暂时保存在Application中，然后再置为null，Activity中接收到数据后，再进行赋值。</p><h3 id="2-2在Manifest中注册service"><a href="#2-2在Manifest中注册service" class="headerlink" title="2.2在Manifest中注册service"></a>2.2在Manifest中注册service</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">\</span>"<span class="attr">.NotificationFetcherService</span>\"</span></span><br><span class="line"><span class="tag">            <span class="attr">android:permission</span>=<span class="string">\</span>"<span class="attr">android.permission.BIND_ACCESSIBILITY_SERVICE</span>\" &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">\</span>"<span class="attr">android.accessibilityservice.AccessibilityService</span>\" /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">\</span>"<span class="attr">android.accessibilityservice</span>\"</span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">\</span>"@<span class="attr">xml</span>/<span class="attr">accessibilityserviceconfig</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里就是普通的service注册，注意 &lt;mate-data&gt;标签中的xml文件：从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和service一样的配置，使用XML来定义。如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。比如上面的代码，我们在res/xml/中建立accessibilityaseviceconfig.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">accessibility-service</span> <span class="attr">xmlns:android</span>=<span class="string">\</span>"<span class="attr">http:</span>//<span class="attr">schemas.android.com</span>/<span class="attr">apk</span>/<span class="attr">res</span>/<span class="attr">android</span>\"</span></span><br><span class="line"><span class="tag">    <span class="attr">android:accessibilityEventTypes</span>=<span class="string">\</span>"<span class="attr">typeWindowStateChanged</span>|<span class="attr">typeNotificationStateChanged</span>|<span class="attr">typeWindowContentChanged</span>\"</span></span><br><span class="line"><span class="tag">    <span class="attr">android:accessibilityFeedbackType</span>=<span class="string">\</span>"<span class="attr">feedbackGeneric</span>\"</span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>服务这里就配置好了。</p><h3 id="2-3-接受并处理Notification"><a href="#2-3-接受并处理Notification" class="headerlink" title="2.3 接受并处理Notification"></a>2.3 接受并处理Notification</h3><p>下面的Activity中就可以接受这个数据，然后怎么处理就看自己了，这里只是简单地显示出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.app.Notification;</span><br><span class="line"><span class="keyword">import</span> android.app.PendingIntent;</span><br><span class="line"><span class="keyword">import</span> android.app.PendingIntent.CanceledException;</span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"><span class="keyword">import</span> android.os.Process;</span><br><span class="line"><span class="keyword">import</span> android.text.method.ScrollingMovementMethod;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.RemoteViews;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificaitonActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOTIFY_DATA_FLAG = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NOTIFY_DATA_ID_STR= \<span class="string">"NotifyData\";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private NotifyDataReceiver  receiver;</span></span><br><span class="line"><span class="string">    private TextView textView;</span></span><br><span class="line"><span class="string">    private LinearLayout rootLayout;</span></span><br><span class="line"><span class="string">    private Button button;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    protected void onCreate(Bundle savedInstanceState) &#123;</span></span><br><span class="line"><span class="string">        super.onCreate(savedInstanceState);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        setContentView(R.layout.activity_main);</span></span><br><span class="line"><span class="string">        textView = (TextView) findViewById(R.id.notify_test_textview);</span></span><br><span class="line"><span class="string">        textView.setMovementMethod(ScrollingMovementMethod.getInstance());</span></span><br><span class="line"><span class="string">        rootLayout = (LinearLayout) findViewById(R.id.root_layout);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        registerBroadcast();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        button = (Button) findViewById(R.id.test_button);</span></span><br><span class="line"><span class="string">        button.setOnClickListener(new View.OnClickListener() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            @Override</span></span><br><span class="line"><span class="string">            public void onClick(View v) &#123;</span></span><br><span class="line"><span class="string">                Button b = new Button(NotificaitonActivity.this);</span></span><br><span class="line"><span class="string">                b.setText("</span>Tthis<span class="string">");</span></span><br><span class="line"><span class="string">                rootLayout.addView(b);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private void registerBroadcast() &#123;</span></span><br><span class="line"><span class="string">        receiver = new NotifyDataReceiver();</span></span><br><span class="line"><span class="string">        IntentFilter filter = new IntentFilter();</span></span><br><span class="line"><span class="string">        filter.addAction("</span>.NotificationFetcherService<span class="string">");</span></span><br><span class="line"><span class="string">        this.registerReceiver(receiver, filter);</span></span><br><span class="line"><span class="string">        Log.e("</span>Dx:<span class="string">", "</span>Broadcast registered.........<span class="string">");</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private void addToUi(RemoteViews remoteView) &#123;</span></span><br><span class="line"><span class="string">        rootLayout.addView(remoteView);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private void showNotify(String notiString) &#123;</span></span><br><span class="line"><span class="string">        textView.setText(textView.getText() + \"n\" + notiString);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private class NotifyDataReceiver extends BroadcastReceiver&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        @Override</span></span><br><span class="line"><span class="string">        public void onReceive(Context context, Intent intent) &#123;</span></span><br><span class="line"><span class="string">            Log.e(\"Dx:\", \"Receiver got msg in onReceive()...\");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            Parcelable notifyParcelable = intent.getParcelableExtra(\"NotifyData\");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            if (notifyParcelable != null) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                Notification notification = (Notification) notifyParcelable;</span></span><br><span class="line"><span class="string">                showNotify(\"tickerText: \" + notification.tickerText);</span></span><br><span class="line"><span class="string">                showNotify(\"toString: \" + (String)(notification.toString()));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                RemoteViews remoteV = notification.contentView;</span></span><br><span class="line"><span class="string">                if (remoteV==null) &#123;</span></span><br><span class="line"><span class="string">                    showNotify(\"remoteView is: null\" );</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    showNotify(\"remoteView is: not null\" );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    addToUi(remoteV);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                PendingIntent pendIntent = notification.contentIntent;</span></span><br><span class="line"><span class="string">                if (pendIntent==null) &#123;</span></span><br><span class="line"><span class="string">                    showNotify(\"pendIntent is: null\" );</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                showNotify(\"pendIntent is: not null\" );</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                showNotify(\"**************************\" );</span></span><br><span class="line"><span class="string">                showNotify(\"                    \" );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>注：这里有很重要的一点，由于AccessibilityService的特殊性，用户必须手动到设置-辅助功能中，打开对应的服务，我们才可以通过AccessibilityService获得对应的数据，这一点非常重要。</p><p>上面的Activity只是简单地显示Notification，关于更多Notification的操作，可以参考Notification这个类，其中重要的属性有：contentView，flags。要模拟真正的通知中心，还是要费一番功夫的。这里由于公司项目的保密，暂不提供对应的实现代码（其实得到Notification就已经成功了一半了），有兴趣的同学可以私下和我交流。</p><h2 id="3-总结和问题"><a href="#3-总结和问题" class="headerlink" title="3.总结和问题"></a>3.总结和问题</h2><p>AccessibilityService的实战就讲到这里，这一篇博文也是拖了一段时间才写完的，也算是为前一段时间的项目做个了结。</p><p>项目中目前还存在的问题：</p><ol><li>无法获取安装这个应用之前的系统的Notification</li><li>得到的Notification对象没法保存在本地，所以这个服务被杀掉之后，所有的数据都会丢失。（试过用db4o这种对象数据库来进行存储，发现行不通）</li><li>对Android系统的Notification对象的行为模仿不够（有些系统的事件监听不到，比如usb的插拔、usb调试的开关等）</li></ol><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android:Ubuntu 下执行 Adb 命令找不到设备</title>
      <link href="/2014/03/25/ubuntu-adb-can-not-find-devices/"/>
      <url>/2014/03/25/ubuntu-adb-can-not-find-devices/</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题概述"><a href="#1-问题概述" class="headerlink" title="1.问题概述"></a>1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p><p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p><h2 id="2-问题解决方案"><a href="#2-问题解决方案" class="headerlink" title="2.问题解决方案"></a>2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p><ol><li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li><li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li></ol><a id="more"></a><h3 id="2-1-运行lsusb"><a href="#2-1-运行lsusb" class="headerlink" title="2.1.运行lsusb"></a><span style="color: #000000;">2.1.运行lsusb</span></h3><pre class="lang:java decode:true">~ » lsusb                                                                  Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 003 Device 004: ID 1532:0016 Razer USA, Ltd DeathAdder MouseBus 003 Device 003: ID 05d5:624c Super Gate Technology Co., Ltd Bus 003 Device 033: ID 0421:06e8 Nokia Mobile Phones Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hu</pre><h3 id="2-2-注册到udve的rules文件"><a href="#2-2-注册到udve的rules文件" class="headerlink" title="2.2.注册到udve的rules文件"></a><span style="color: #000000;">2.2.注册到udve的rules文件</span></h3><pre class="lang:java decode:true">vim  /etc/udev/rules.d/51-android.rules    添加这个ID：1ebf，如下：    SUBSYSTEM=="usb", SYSFS{"Nokia Mobile Phones"}=="0421", MODE="06e8"   保存文件并运行：    sudo chmod a+rx /etc/udev/rules.d/51-android.rules    sudo /etc/init.d/udev restart    运行结果如下：    Rather than invoking init scripts through /etc/init.d, use the service(8)    utility, e.g. service udev restart    Since the script you are attempting to invoke has been converted to an    Upstart job, you may also use the stop(8) and then start(8) utilities,    e.g. stop udev ; start udev. The restart(8) utility is also available.    udev stop/waiting    udev start/running, process 14636</pre><h3 id="2-3-使用sudo-关闭和启动adb"><a href="#2-3-使用sudo-关闭和启动adb" class="headerlink" title=" 2.3.使用sudo 关闭和启动adb"></a><span style="color: #000000;"> 2.3.使用sudo 关闭和启动adb</span></h3><pre class="lang:java decode:true">cd ~/tools/android-sdk-linux_x86/platform-tools  sudo ./adb kill-server  sudo ./adb start-server</pre><p><span style="color: #000000;"><span style="color: #ff0000;"> 注：一般情况下，上面的操作就可以。特殊情况下，usb设备还是不能被识别，比如我手上这台Nokia X</span>。那么继续：</span></p><h3 id="2-4-打开-～-android-adb-usb-ini，加入之前的lsusb得到的信息"><a href="#2-4-打开-～-android-adb-usb-ini，加入之前的lsusb得到的信息" class="headerlink" title="2.4.打开 ～/.android/adb_usb.ini，加入之前的lsusb得到的信息"></a><span style="color: #000000;">2.4.打开 ～/.android/adb_usb.ini，加入之前的lsusb得到的信息</span></h3><pre class="lang:java decode:true"># ANDROID 4RD PARTY USB VENDOR ID LIST -- DO NOT EDIT.# USE 'android update adb' TO GENERATE.# 1 USB VENDOR ID PER LINE#for nokia x0x0421</pre><p><span style="color: #000000;"> 保存关闭后，就可以识别了。windows下也是如此，不多叙述了。</span></p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Service：开发自己的通知中心(1):辅助性服务介绍</title>
      <link href="/2014/03/17/android-build-your-own-android-notification-service-app/"/>
      <url>/2014/03/17/android-build-your-own-android-notification-service-app/</url>
      
        <content type="html"><![CDATA[<h1 id="1-辅助性服务介绍"><a href="#1-辅助性服务介绍" class="headerlink" title="1 辅助性服务介绍"></a>1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p><a id="more"></a><h1 id="2-创建自己的辅助性服务"><a href="#2-创建自己的辅助性服务" class="headerlink" title="2 创建自己的辅助性服务"></a>2 创建自己的辅助性服务</h1><h2 id="2-1-继承AccessibilitySerivce"><a href="#2-1-继承AccessibilitySerivce" class="headerlink" title="2.1 继承AccessibilitySerivce"></a>2.1 继承AccessibilitySerivce</h2><p>一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建。在任何情况下，创建这类服务的步骤都是一样的。在你的工程中，创建一个类继续AccessibilitySerivce。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.accessibilityservice.AccessibilityService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessibilityService</span> <span class="keyword">extends</span> <span class="title">AccessibilityService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccessibilityEvent</span><span class="params">(AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-在mainfest中声明service"><a href="#2-2-在mainfest中声明service" class="headerlink" title="2.2 在mainfest中声明service"></a>2.2 在mainfest中声明service</h2><p>像其他服务一样，你也可以在mainfest文件中声明它。记得要指定它处理android.accessibilityservice这个意图。以便当应用程序触发一个AccessibilityEvent时，这个服务能被调用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> &gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyAccessibilityService"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.accessibilityservice.AccessibilityService"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">     . . .</span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-配置serivce"><a href="#2-3-配置serivce" class="headerlink" title="2.3 配置serivce"></a>2.3 配置serivce</h2><p>如果你为这个服务创建一个新的工程的话，且不打算要一个应用程序，你可以把它启动活动的类（通常叫做MainActivity.java)从你的源文件中删除。同时也把相应的活动元素从你的mainfest文件中删除。<br>配置自己的辅助性服务<br>为你的辅助性服务设置配置变量，用它来告诉系统，如何和何时你想要它运行。哪一类事件你想要去响应？这个服务对所有的应用程序都是活动的吗？或者只有指定的包名的？它使用什么样的反馈？<br>你有两种方法去设置这些变量。反向兼容的方法是以代码的形式来设置它们。<br>可以使setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo).如果要这样做的话，要重写onServiceConnected()方法，然后配置在那里配置你的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    info.eventTypes = AccessibilityEvent.TYPE_VIEW_CLICKED |</span><br><span class="line">            AccessibilityEvent.TYPE_VIEW_FOCUSED;</span><br><span class="line">    info.packageNames = <span class="keyword">new</span> String[]</span><br><span class="line">            &#123;<span class="string">"com.example.android.myFirstApp"</span>, <span class="string">"com.example.android.mySecondApp"</span>&#125;;</span><br><span class="line">    info.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN;</span><br><span class="line">    info.flags = AccessibilityServiceInfo.DEFAULT;</span><br><span class="line">    info.notificationTimeout = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.setServiceInfo(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和上面一样的配置，使用XML来定义，格式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;accessibility-service</span><br><span class="line">     android:accessibilityEventTypes=<span class="string">"typeViewClicked|typeViewFocused"</span></span><br><span class="line">     android:packageNames=<span class="string">"com.example.android.myFirstApp, com.example.android.mySecondApp"</span></span><br><span class="line">     android:accessibilityFeedbackType=<span class="string">"feedbackSpoken"</span></span><br><span class="line">     android:notificationTimeout=<span class="string">"100"</span></span><br><span class="line">     android:settingsActivity=<span class="string">"com.example.android.apis.accessibility.TestBackActivity"</span></span><br><span class="line">     android:canRetrieveWindowContent=<span class="string">"true"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加 meta-data;标签,并指向这个XML资源文件。假如你把你的XML文件存储在res/xml/serviceconfig.xml这个路径下，新的标签格式如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyAccessibilityService"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.accessibilityservice.AccessibilityService"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"android.accessibilityservice"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:resource</span>=<span class="string">"@xml/serviceconfig"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4-响应AccessibilityEvents事件"><a href="#2-4-响应AccessibilityEvents事件" class="headerlink" title="2.4 响应AccessibilityEvents事件"></a>2.4 响应AccessibilityEvents事件</h2><p>现在,您的服务被设置为运行和监听事件，写一些代码，这样当一个AccessibilityEvent真的到来，它就知道要做什么了！<br>从重写onAccessibilityEvent(AccessibilityEvent)方法开始。然后使用getEventType()来确定事件类型，然后用getContentDescription来取出任何与触发事件相关的标签文本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccessibilityEvent</span><span class="params">(AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> eventType = event.getEventType();</span><br><span class="line">    String eventText = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span>(eventType) &#123;</span><br><span class="line">        <span class="keyword">case</span> AccessibilityEvent.TYPE_VIEW_CLICKED:</span><br><span class="line">            eventText = <span class="string">"Focused: "</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AccessibilityEvent.TYPE_VIEW_FOCUSED:</span><br><span class="line">            eventText = <span class="string">"Focused: "</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventText = eventText + event.getContentDescription();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something nifty with this text, like speak the composed string</span></span><br><span class="line">    <span class="comment">// back to the user.</span></span><br><span class="line">    speakToUser(eventText);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为更多的上下文查询视图层次结构<br>这一步是可选的，然而它非常有用。Android 4.0(API level 14)的一个新特性：可以用AccessibilityService来查询视图层次结构，收集事件所生成的一些UI组件信息，还有这些UI的父控件和子控件。要做到这一点，确保在你的XML配置文件中做了如下设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:canRetrieveWindowContent=<span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>如果设置了，通过getSource()可获得一个AccessibilityNodeInfo对象。如果发起的窗口事件仍然是活动的窗口，该调用将会返回一个对象,否则，会返回null。下面这段代码演示何时接收一个事件，步骤如下：<br>立即捕获触发事件的父视图。<br>在那个视图中，寻找一个标签和一个复选框作的子视图。<br>如果找到，创建一个字符串来向用户报告，以表明这个标签是否被选择了。<br>如果遍历视图层次结构后返回null,则会退出该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alternative onAccessibilityEvent, that uses AccessibilityNodeInfo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccessibilityEvent</span><span class="params">(AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AccessibilityNodeInfo source = event.getSource();</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab the parent of the view that fired the event.</span></span><br><span class="line">    AccessibilityNodeInfo rowNode = getListItemNodeInfo(source);</span><br><span class="line">    <span class="keyword">if</span> (rowNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using this parent, get references to both child nodes, the label and the checkbox.</span></span><br><span class="line">    AccessibilityNodeInfo labelNode = rowNode.getChild(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (labelNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rowNode.recycle();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AccessibilityNodeInfo completeNode = rowNode.getChild(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (completeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rowNode.recycle();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine what the task is and whether or not it's complete, based on</span></span><br><span class="line">    <span class="comment">// the text inside the label, and the state of the check-box.</span></span><br><span class="line">    <span class="keyword">if</span> (rowNode.getChildCount() &lt; <span class="number">2</span> || !rowNode.getChild(<span class="number">1</span>).isCheckable()) &#123;</span><br><span class="line">        rowNode.recycle();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CharSequence taskLabel = labelNode.getText();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isComplete = completeNode.isChecked();</span><br><span class="line">    String completeStr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isComplete) &#123;</span><br><span class="line">        completeStr = getString(R.string.checked);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        completeStr = getString(R.string.not_checked);</span><br><span class="line">    &#125;</span><br><span class="line">    String reportStr = taskLabel + completeStr;</span><br><span class="line">    speakToUser(reportStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你有一个完整的，可以工作的辅助性服务。现在，你也可以试着配置一下，看看Android的text-to-speech engine,或使用Vibrator提供触觉反馈是如何与用户交互。</p><p>最后，要使用配置好的service，必须要到“设置–辅助性服务”中打开对应的service，然后才能相应对应的事件。</p><h1 id="关于我-amp-amp-博客"><a href="#关于我-amp-amp-博客" class="headerlink" title="关于我 &amp;&amp; 博客"></a>关于我 &amp;&amp; 博客</h1><ol><li><a href="https://www.androidperformance.com/about/" target="_blank" rel="noopener">关于我</a> , 非常希望和大家一起交流 , 共同进步 .</li><li><a href="https://androidperformance.com/2019/12/01/BlogMap/">博客内容导航</a></li><li><a href="https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/">优秀博客文章记录 - Android 性能优化必知必会</a></li></ol><blockquote><p><strong>一个人可以走的更快 , 一群人可以走的更远</strong></p></blockquote><p><img src="/images/WechatIMG581.png" alt="微信扫一扫"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
