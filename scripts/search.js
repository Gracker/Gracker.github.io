/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/algoliasearch-helper/index.js":
/*!****************************************************!*\
  !*** ./node_modules/algoliasearch-helper/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AlgoliaSearchHelper = __webpack_require__(/*! ./src/algoliasearch.helper */ "./node_modules/algoliasearch-helper/src/algoliasearch.helper.js");

var SearchParameters = __webpack_require__(/*! ./src/SearchParameters */ "./node_modules/algoliasearch-helper/src/SearchParameters/index.js");
var SearchResults = __webpack_require__(/*! ./src/SearchResults */ "./node_modules/algoliasearch-helper/src/SearchResults/index.js");

/**
 * The algoliasearchHelper module is the function that will let its
 * contains everything needed to use the Algoliasearch
 * Helper. It is a also a function that instanciate the helper.
 * To use the helper, you also need the Algolia JS client v3.
 * @example
 * //using the UMD build
 * var client = algoliasearch('latency', '6be0576ff61c053d5f9a3225e2a90f76');
 * var helper = algoliasearchHelper(client, 'bestbuy', {
 *   facets: ['shipping'],
 *   disjunctiveFacets: ['category']
 * });
 * helper.on('result', function(event) {
 *   console.log(event.results);
 * });
 * helper
 *   .toggleFacetRefinement('category', 'Movies & TV Shows')
 *   .toggleFacetRefinement('shipping', 'Free shipping')
 *   .search();
 * @example
 * // The helper is an event emitter using the node API
 * helper.on('result', updateTheResults);
 * helper.once('result', updateTheResults);
 * helper.removeListener('result', updateTheResults);
 * helper.removeAllListeners('result');
 * @module algoliasearchHelper
 * @param  {AlgoliaSearch} client an AlgoliaSearch client
 * @param  {string} index the name of the index to query
 * @param  {SearchParameters|object} opts an object defining the initial config of the search. It doesn't have to be a {SearchParameters}, just an object containing the properties you need from it.
 * @return {AlgoliaSearchHelper}
 */
function algoliasearchHelper(client, index, opts) {
  return new AlgoliaSearchHelper(client, index, opts);
}

/**
 * The version currently used
 * @member module:algoliasearchHelper.version
 * @type {number}
 */
algoliasearchHelper.version = __webpack_require__(/*! ./src/version.js */ "./node_modules/algoliasearch-helper/src/version.js");

/**
 * Constructor for the Helper.
 * @member module:algoliasearchHelper.AlgoliaSearchHelper
 * @type {AlgoliaSearchHelper}
 */
algoliasearchHelper.AlgoliaSearchHelper = AlgoliaSearchHelper;

/**
 * Constructor for the object containing all the parameters of the search.
 * @member module:algoliasearchHelper.SearchParameters
 * @type {SearchParameters}
 */
algoliasearchHelper.SearchParameters = SearchParameters;

/**
 * Constructor for the object containing the results of the search.
 * @member module:algoliasearchHelper.SearchResults
 * @type {SearchResults}
 */
algoliasearchHelper.SearchResults = SearchResults;

module.exports = algoliasearchHelper;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/DerivedHelper/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/DerivedHelper/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var inherits = __webpack_require__(/*! ../functions/inherits */ "./node_modules/algoliasearch-helper/src/functions/inherits.js");

/**
 * A DerivedHelper is a way to create sub requests to
 * Algolia from a main helper.
 * @class
 * @classdesc The DerivedHelper provides an event based interface for search callbacks:
 *  - search: when a search is triggered using the `search()` method.
 *  - result: when the response is retrieved from Algolia and is processed.
 *    This event contains a {@link SearchResults} object and the
 *    {@link SearchParameters} corresponding to this answer.
 */
function DerivedHelper(mainHelper, fn) {
  this.main = mainHelper;
  this.fn = fn;
  this.lastResults = null;
}

inherits(DerivedHelper, events.EventEmitter);

/**
 * Detach this helper from the main helper
 * @return {undefined}
 * @throws Error if the derived helper is already detached
 */
DerivedHelper.prototype.detach = function() {
  this.removeAllListeners();
  this.main.detachDerivedHelper(this);
};

DerivedHelper.prototype.getModifiedState = function(parameters) {
  return this.fn(parameters);
};

module.exports = DerivedHelper;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/SearchParameters/RefinementList.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/SearchParameters/RefinementList.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Functions to manipulate refinement lists
 *
 * The RefinementList is not formally defined through a prototype but is based
 * on a specific structure.
 *
 * @module SearchParameters.refinementList
 *
 * @typedef {string[]} SearchParameters.refinementList.Refinements
 * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList
 */

var defaultsPure = __webpack_require__(/*! ../functions/defaultsPure */ "./node_modules/algoliasearch-helper/src/functions/defaultsPure.js");
var omit = __webpack_require__(/*! ../functions/omit */ "./node_modules/algoliasearch-helper/src/functions/omit.js");
var objectHasKeys = __webpack_require__(/*! ../functions/objectHasKeys */ "./node_modules/algoliasearch-helper/src/functions/objectHasKeys.js");

var lib = {
  /**
   * Adds a refinement to a RefinementList
   * @param {RefinementList} refinementList the initial list
   * @param {string} attribute the attribute to refine
   * @param {string} value the value of the refinement, if the value is not a string it will be converted
   * @return {RefinementList} a new and updated refinement list
   */
  addRefinement: function addRefinement(refinementList, attribute, value) {
    if (lib.isRefined(refinementList, attribute, value)) {
      return refinementList;
    }

    var valueAsString = '' + value;

    var facetRefinement = !refinementList[attribute] ?
      [valueAsString] :
      refinementList[attribute].concat(valueAsString);

    var mod = {};

    mod[attribute] = facetRefinement;

    return defaultsPure({}, mod, refinementList);
  },
  /**
   * Removes refinement(s) for an attribute:
   *  - if the value is specified removes the refinement for the value on the attribute
   *  - if no value is specified removes all the refinements for this attribute
   * @param {RefinementList} refinementList the initial list
   * @param {string} attribute the attribute to refine
   * @param {string} [value] the value of the refinement
   * @return {RefinementList} a new and updated refinement lst
   */
  removeRefinement: function removeRefinement(refinementList, attribute, value) {
    if (value === undefined) {
      // we use the "filter" form of clearRefinement, since it leaves empty values as-is
      // the form with a string will remove the attribute completely
      return lib.clearRefinement(refinementList, function(v, f) {
        return attribute === f;
      });
    }

    var valueAsString = '' + value;

    return lib.clearRefinement(refinementList, function(v, f) {
      return attribute === f && valueAsString === v;
    });
  },
  /**
   * Toggles the refinement value for an attribute.
   * @param {RefinementList} refinementList the initial list
   * @param {string} attribute the attribute to refine
   * @param {string} value the value of the refinement
   * @return {RefinementList} a new and updated list
   */
  toggleRefinement: function toggleRefinement(refinementList, attribute, value) {
    if (value === undefined) throw new Error('toggleRefinement should be used with a value');

    if (lib.isRefined(refinementList, attribute, value)) {
      return lib.removeRefinement(refinementList, attribute, value);
    }

    return lib.addRefinement(refinementList, attribute, value);
  },
  /**
   * Clear all or parts of a RefinementList. Depending on the arguments, three
   * kinds of behavior can happen:
   *  - if no attribute is provided: clears the whole list
   *  - if an attribute is provided as a string: clears the list for the specific attribute
   *  - if an attribute is provided as a function: discards the elements for which the function returns true
   * @param {RefinementList} refinementList the initial list
   * @param {string} [attribute] the attribute or function to discard
   * @param {string} [refinementType] optional parameter to give more context to the attribute function
   * @return {RefinementList} a new and updated refinement list
   */
  clearRefinement: function clearRefinement(refinementList, attribute, refinementType) {
    if (attribute === undefined) {
      if (!objectHasKeys(refinementList)) {
        return refinementList;
      }
      return {};
    } else if (typeof attribute === 'string') {
      return omit(refinementList, [attribute]);
    } else if (typeof attribute === 'function') {
      var hasChanged = false;

      var newRefinementList = Object.keys(refinementList).reduce(function(memo, key) {
        var values = refinementList[key] || [];
        var facetList = values.filter(function(value) {
          return !attribute(value, key, refinementType);
        });

        if (facetList.length !== values.length) {
          hasChanged = true;
        }
        memo[key] = facetList;

        return memo;
      }, {});

      if (hasChanged) return newRefinementList;
      return refinementList;
    }
  },
  /**
   * Test if the refinement value is used for the attribute. If no refinement value
   * is provided, test if the refinementList contains any refinement for the
   * given attribute.
   * @param {RefinementList} refinementList the list of refinement
   * @param {string} attribute name of the attribute
   * @param {string} [refinementValue] value of the filter/refinement
   * @return {boolean}
   */
  isRefined: function isRefined(refinementList, attribute, refinementValue) {
    var containsRefinements = !!refinementList[attribute] &&
      refinementList[attribute].length > 0;

    if (refinementValue === undefined || !containsRefinements) {
      return containsRefinements;
    }

    var refinementValueAsString = '' + refinementValue;

    return refinementList[attribute].indexOf(refinementValueAsString) !== -1;
  }
};

module.exports = lib;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/SearchParameters/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/SearchParameters/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var merge = __webpack_require__(/*! ../functions/merge */ "./node_modules/algoliasearch-helper/src/functions/merge.js");
var defaultsPure = __webpack_require__(/*! ../functions/defaultsPure */ "./node_modules/algoliasearch-helper/src/functions/defaultsPure.js");
var intersection = __webpack_require__(/*! ../functions/intersection */ "./node_modules/algoliasearch-helper/src/functions/intersection.js");
var find = __webpack_require__(/*! ../functions/find */ "./node_modules/algoliasearch-helper/src/functions/find.js");
var valToNumber = __webpack_require__(/*! ../functions/valToNumber */ "./node_modules/algoliasearch-helper/src/functions/valToNumber.js");
var omit = __webpack_require__(/*! ../functions/omit */ "./node_modules/algoliasearch-helper/src/functions/omit.js");
var objectHasKeys = __webpack_require__(/*! ../functions/objectHasKeys */ "./node_modules/algoliasearch-helper/src/functions/objectHasKeys.js");
var isValidUserToken = __webpack_require__(/*! ../utils/isValidUserToken */ "./node_modules/algoliasearch-helper/src/utils/isValidUserToken.js");

var RefinementList = __webpack_require__(/*! ./RefinementList */ "./node_modules/algoliasearch-helper/src/SearchParameters/RefinementList.js");

/**
 * isEqual, but only for numeric refinement values, possible values:
 * - 5
 * - [5]
 * - [[5]]
 * - [[5,5],[4]]
 */
function isEqualNumericRefinement(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    return (
      a.length === b.length &&
      a.every(function(el, i) {
        return isEqualNumericRefinement(b[i], el);
      })
    );
  }
  return a === b;
}

/**
 * like _.find but using deep equality to be able to use it
 * to find arrays.
 * @private
 * @param {any[]} array array to search into (elements are base or array of base)
 * @param {any} searchedValue the value we're looking for (base or array of base)
 * @return {any} the searched value or undefined
 */
function findArray(array, searchedValue) {
  return find(array, function(currentValue) {
    return isEqualNumericRefinement(currentValue, searchedValue);
  });
}

/**
 * The facet list is the structure used to store the list of values used to
 * filter a single attribute.
 * @typedef {string[]} SearchParameters.FacetList
 */

/**
 * Structure to store numeric filters with the operator as the key. The supported operators
 * are `=`, `>`, `<`, `>=`, `<=` and `!=`.
 * @typedef {Object.<string, Array.<number|number[]>>} SearchParameters.OperatorList
 */

/**
 * SearchParameters is the data structure that contains all the information
 * usable for making a search to Algolia API. It doesn't do the search itself,
 * nor does it contains logic about the parameters.
 * It is an immutable object, therefore it has been created in a way that each
 * changes does not change the object itself but returns a copy with the
 * modification.
 * This object should probably not be instantiated outside of the helper. It will
 * be provided when needed. This object is documented for reference as you'll
 * get it from events generated by the {@link AlgoliaSearchHelper}.
 * If need be, instantiate the Helper from the factory function {@link SearchParameters.make}
 * @constructor
 * @classdesc contains all the parameters of a search
 * @param {object|SearchParameters} newParameters existing parameters or partial object
 * for the properties of a new SearchParameters
 * @see SearchParameters.make
 * @example <caption>SearchParameters of the first query in
 *   <a href="http://demos.algolia.com/instant-search-demo/">the instant search demo</a></caption>
{
   "query": "",
   "disjunctiveFacets": [
      "customerReviewCount",
      "category",
      "salePrice_range",
      "manufacturer"
  ],
   "maxValuesPerFacet": 30,
   "page": 0,
   "hitsPerPage": 10,
   "facets": [
      "type",
      "shipping"
  ]
}
 */
function SearchParameters(newParameters) {
  var params = newParameters ? SearchParameters._parseNumbers(newParameters) : {};

  if (params.userToken !== undefined && !isValidUserToken(params.userToken)) {
    console.warn('[algoliasearch-helper] The `userToken` parameter is invalid. This can lead to wrong analytics.\n  - Format: [a-zA-Z0-9_-]{1,64}');
  }
  /**
   * This attribute contains the list of all the conjunctive facets
   * used. This list will be added to requested facets in the
   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.
   * @member {string[]}
   */
  this.facets = params.facets || [];
  /**
   * This attribute contains the list of all the disjunctive facets
   * used. This list will be added to requested facets in the
   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.
   * @member {string[]}
   */
  this.disjunctiveFacets = params.disjunctiveFacets || [];
  /**
   * This attribute contains the list of all the hierarchical facets
   * used. This list will be added to requested facets in the
   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.
   * Hierarchical facets are a sub type of disjunctive facets that
   * let you filter faceted attributes hierarchically.
   * @member {string[]|object[]}
   */
  this.hierarchicalFacets = params.hierarchicalFacets || [];

  // Refinements
  /**
   * This attribute contains all the filters that need to be
   * applied on the conjunctive facets. Each facet must be properly
   * defined in the `facets` attribute.
   *
   * The key is the name of the facet, and the `FacetList` contains all
   * filters selected for the associated facet name.
   *
   * When querying algolia, the values stored in this attribute will
   * be translated into the `facetFilters` attribute.
   * @member {Object.<string, SearchParameters.FacetList>}
   */
  this.facetsRefinements = params.facetsRefinements || {};
  /**
   * This attribute contains all the filters that need to be
   * excluded from the conjunctive facets. Each facet must be properly
   * defined in the `facets` attribute.
   *
   * The key is the name of the facet, and the `FacetList` contains all
   * filters excluded for the associated facet name.
   *
   * When querying algolia, the values stored in this attribute will
   * be translated into the `facetFilters` attribute.
   * @member {Object.<string, SearchParameters.FacetList>}
   */
  this.facetsExcludes = params.facetsExcludes || {};
  /**
   * This attribute contains all the filters that need to be
   * applied on the disjunctive facets. Each facet must be properly
   * defined in the `disjunctiveFacets` attribute.
   *
   * The key is the name of the facet, and the `FacetList` contains all
   * filters selected for the associated facet name.
   *
   * When querying algolia, the values stored in this attribute will
   * be translated into the `facetFilters` attribute.
   * @member {Object.<string, SearchParameters.FacetList>}
   */
  this.disjunctiveFacetsRefinements = params.disjunctiveFacetsRefinements || {};
  /**
   * This attribute contains all the filters that need to be
   * applied on the numeric attributes.
   *
   * The key is the name of the attribute, and the value is the
   * filters to apply to this attribute.
   *
   * When querying algolia, the values stored in this attribute will
   * be translated into the `numericFilters` attribute.
   * @member {Object.<string, SearchParameters.OperatorList>}
   */
  this.numericRefinements = params.numericRefinements || {};
  /**
   * This attribute contains all the tags used to refine the query.
   *
   * When querying algolia, the values stored in this attribute will
   * be translated into the `tagFilters` attribute.
   * @member {string[]}
   */
  this.tagRefinements = params.tagRefinements || [];
  /**
   * This attribute contains all the filters that need to be
   * applied on the hierarchical facets. Each facet must be properly
   * defined in the `hierarchicalFacets` attribute.
   *
   * The key is the name of the facet, and the `FacetList` contains all
   * filters selected for the associated facet name. The FacetList values
   * are structured as a string that contain the values for each level
   * separated by the configured separator.
   *
   * When querying algolia, the values stored in this attribute will
   * be translated into the `facetFilters` attribute.
   * @member {Object.<string, SearchParameters.FacetList>}
   */
  this.hierarchicalFacetsRefinements = params.hierarchicalFacetsRefinements || {};

  var self = this;
  Object.keys(params).forEach(function(paramName) {
    var isKeyKnown = SearchParameters.PARAMETERS.indexOf(paramName) !== -1;
    var isValueDefined = params[paramName] !== undefined;

    if (!isKeyKnown && isValueDefined) {
      self[paramName] = params[paramName];
    }
  });
}

/**
 * List all the properties in SearchParameters and therefore all the known Algolia properties
 * This doesn't contain any beta/hidden features.
 * @private
 */
SearchParameters.PARAMETERS = Object.keys(new SearchParameters());

/**
 * @private
 * @param {object} partialState full or part of a state
 * @return {object} a new object with the number keys as number
 */
SearchParameters._parseNumbers = function(partialState) {
  // Do not reparse numbers in SearchParameters, they ought to be parsed already
  if (partialState instanceof SearchParameters) return partialState;

  var numbers = {};

  var numberKeys = [
    'aroundPrecision',
    'aroundRadius',
    'getRankingInfo',
    'minWordSizefor2Typos',
    'minWordSizefor1Typo',
    'page',
    'maxValuesPerFacet',
    'distinct',
    'minimumAroundRadius',
    'hitsPerPage',
    'minProximity'
  ];

  numberKeys.forEach(function(k) {
    var value = partialState[k];
    if (typeof value === 'string') {
      var parsedValue = parseFloat(value);
      // global isNaN is ok to use here, value is only number or NaN
      numbers[k] = isNaN(parsedValue) ? value : parsedValue;
    }
  });

  // there's two formats of insideBoundingBox, we need to parse
  // the one which is an array of float geo rectangles
  if (Array.isArray(partialState.insideBoundingBox)) {
    numbers.insideBoundingBox = partialState.insideBoundingBox.map(function(geoRect) {
      if (Array.isArray(geoRect)) {
        return geoRect.map(function(value) {
          return parseFloat(value);
        });
      }
      return geoRect;
    });
  }

  if (partialState.numericRefinements) {
    var numericRefinements = {};
    Object.keys(partialState.numericRefinements).forEach(function(attribute) {
      var operators = partialState.numericRefinements[attribute] || {};
      numericRefinements[attribute] = {};
      Object.keys(operators).forEach(function(operator) {
        var values = operators[operator];
        var parsedValues = values.map(function(v) {
          if (Array.isArray(v)) {
            return v.map(function(vPrime) {
              if (typeof vPrime === 'string') {
                return parseFloat(vPrime);
              }
              return vPrime;
            });
          } else if (typeof v === 'string') {
            return parseFloat(v);
          }
          return v;
        });
        numericRefinements[attribute][operator] = parsedValues;
      });
    });
    numbers.numericRefinements = numericRefinements;
  }

  return merge({}, partialState, numbers);
};

/**
 * Factory for SearchParameters
 * @param {object|SearchParameters} newParameters existing parameters or partial
 * object for the properties of a new SearchParameters
 * @return {SearchParameters} frozen instance of SearchParameters
 */
SearchParameters.make = function makeSearchParameters(newParameters) {
  var instance = new SearchParameters(newParameters);

  var hierarchicalFacets = newParameters.hierarchicalFacets || [];
  hierarchicalFacets.forEach(function(facet) {
    if (facet.rootPath) {
      var currentRefinement = instance.getHierarchicalRefinement(facet.name);

      if (currentRefinement.length > 0 && currentRefinement[0].indexOf(facet.rootPath) !== 0) {
        instance = instance.clearRefinements(facet.name);
      }

      // get it again in case it has been cleared
      currentRefinement = instance.getHierarchicalRefinement(facet.name);
      if (currentRefinement.length === 0) {
        instance = instance.toggleHierarchicalFacetRefinement(facet.name, facet.rootPath);
      }
    }
  });

  return instance;
};

/**
 * Validates the new parameters based on the previous state
 * @param {SearchParameters} currentState the current state
 * @param {object|SearchParameters} parameters the new parameters to set
 * @return {Error|null} Error if the modification is invalid, null otherwise
 */
SearchParameters.validate = function(currentState, parameters) {
  var params = parameters || {};

  if (currentState.tagFilters && params.tagRefinements && params.tagRefinements.length > 0) {
    return new Error(
      '[Tags] Cannot switch from the managed tag API to the advanced API. It is probably ' +
      'an error, if it is really what you want, you should first clear the tags with clearTags method.');
  }

  if (currentState.tagRefinements.length > 0 && params.tagFilters) {
    return new Error(
      '[Tags] Cannot switch from the advanced tag API to the managed API. It is probably ' +
      'an error, if it is not, you should first clear the tags with clearTags method.');
  }

  if (
    currentState.numericFilters &&
    params.numericRefinements &&
    objectHasKeys(params.numericRefinements)
  ) {
    return new Error(
      "[Numeric filters] Can't switch from the advanced to the managed API. It" +
        ' is probably an error, if this is really what you want, you have to first' +
        ' clear the numeric filters.'
    );
  }

  if (objectHasKeys(currentState.numericRefinements) && params.numericFilters) {
    return new Error(
      "[Numeric filters] Can't switch from the managed API to the advanced. It" +
      ' is probably an error, if this is really what you want, you have to first' +
      ' clear the numeric filters.');
  }

  return null;
};

SearchParameters.prototype = {
  constructor: SearchParameters,

  /**
   * Remove all refinements (disjunctive + conjunctive + excludes + numeric filters)
   * @method
   * @param {undefined|string|SearchParameters.clearCallback} [attribute] optional string or function
   * - If not given, means to clear all the filters.
   * - If `string`, means to clear all refinements for the `attribute` named filter.
   * - If `function`, means to clear all the refinements that return truthy values.
   * @return {SearchParameters}
   */
  clearRefinements: function clearRefinements(attribute) {
    var patch = {
      numericRefinements: this._clearNumericRefinements(attribute),
      facetsRefinements: RefinementList.clearRefinement(
        this.facetsRefinements,
        attribute,
        'conjunctiveFacet'
      ),
      facetsExcludes: RefinementList.clearRefinement(
        this.facetsExcludes,
        attribute,
        'exclude'
      ),
      disjunctiveFacetsRefinements: RefinementList.clearRefinement(
        this.disjunctiveFacetsRefinements,
        attribute,
        'disjunctiveFacet'
      ),
      hierarchicalFacetsRefinements: RefinementList.clearRefinement(
        this.hierarchicalFacetsRefinements,
        attribute,
        'hierarchicalFacet'
      )
    };
    if (
      patch.numericRefinements === this.numericRefinements &&
      patch.facetsRefinements === this.facetsRefinements &&
      patch.facetsExcludes === this.facetsExcludes &&
      patch.disjunctiveFacetsRefinements === this.disjunctiveFacetsRefinements &&
      patch.hierarchicalFacetsRefinements === this.hierarchicalFacetsRefinements
    ) {
      return this;
    }
    return this.setQueryParameters(patch);
  },
  /**
   * Remove all the refined tags from the SearchParameters
   * @method
   * @return {SearchParameters}
   */
  clearTags: function clearTags() {
    if (this.tagFilters === undefined && this.tagRefinements.length === 0) return this;

    return this.setQueryParameters({
      tagFilters: undefined,
      tagRefinements: []
    });
  },
  /**
   * Set the index.
   * @method
   * @param {string} index the index name
   * @return {SearchParameters}
   */
  setIndex: function setIndex(index) {
    if (index === this.index) return this;

    return this.setQueryParameters({
      index: index
    });
  },
  /**
   * Query setter
   * @method
   * @param {string} newQuery value for the new query
   * @return {SearchParameters}
   */
  setQuery: function setQuery(newQuery) {
    if (newQuery === this.query) return this;

    return this.setQueryParameters({
      query: newQuery
    });
  },
  /**
   * Page setter
   * @method
   * @param {number} newPage new page number
   * @return {SearchParameters}
   */
  setPage: function setPage(newPage) {
    if (newPage === this.page) return this;

    return this.setQueryParameters({
      page: newPage
    });
  },
  /**
   * Facets setter
   * The facets are the simple facets, used for conjunctive (and) faceting.
   * @method
   * @param {string[]} facets all the attributes of the algolia records used for conjunctive faceting
   * @return {SearchParameters}
   */
  setFacets: function setFacets(facets) {
    return this.setQueryParameters({
      facets: facets
    });
  },
  /**
   * Disjunctive facets setter
   * Change the list of disjunctive (or) facets the helper chan handle.
   * @method
   * @param {string[]} facets all the attributes of the algolia records used for disjunctive faceting
   * @return {SearchParameters}
   */
  setDisjunctiveFacets: function setDisjunctiveFacets(facets) {
    return this.setQueryParameters({
      disjunctiveFacets: facets
    });
  },
  /**
   * HitsPerPage setter
   * Hits per page represents the number of hits retrieved for this query
   * @method
   * @param {number} n number of hits retrieved per page of results
   * @return {SearchParameters}
   */
  setHitsPerPage: function setHitsPerPage(n) {
    if (this.hitsPerPage === n) return this;

    return this.setQueryParameters({
      hitsPerPage: n
    });
  },
  /**
   * typoTolerance setter
   * Set the value of typoTolerance
   * @method
   * @param {string} typoTolerance new value of typoTolerance ("true", "false", "min" or "strict")
   * @return {SearchParameters}
   */
  setTypoTolerance: function setTypoTolerance(typoTolerance) {
    if (this.typoTolerance === typoTolerance) return this;

    return this.setQueryParameters({
      typoTolerance: typoTolerance
    });
  },
  /**
   * Add a numeric filter for a given attribute
   * When value is an array, they are combined with OR
   * When value is a single value, it will combined with AND
   * @method
   * @param {string} attribute attribute to set the filter on
   * @param {string} operator operator of the filter (possible values: =, >, >=, <, <=, !=)
   * @param {number | number[]} value value of the filter
   * @return {SearchParameters}
   * @example
   * // for price = 50 or 40
   * searchparameter.addNumericRefinement('price', '=', [50, 40]);
   * @example
   * // for size = 38 and 40
   * searchparameter.addNumericRefinement('size', '=', 38);
   * searchparameter.addNumericRefinement('size', '=', 40);
   */
  addNumericRefinement: function(attribute, operator, v) {
    var value = valToNumber(v);

    if (this.isNumericRefined(attribute, operator, value)) return this;

    var mod = merge({}, this.numericRefinements);

    mod[attribute] = merge({}, mod[attribute]);

    if (mod[attribute][operator]) {
      // Array copy
      mod[attribute][operator] = mod[attribute][operator].slice();
      // Add the element. Concat can't be used here because value can be an array.
      mod[attribute][operator].push(value);
    } else {
      mod[attribute][operator] = [value];
    }

    return this.setQueryParameters({
      numericRefinements: mod
    });
  },
  /**
   * Get the list of conjunctive refinements for a single facet
   * @param {string} facetName name of the attribute used for faceting
   * @return {string[]} list of refinements
   */
  getConjunctiveRefinements: function(facetName) {
    if (!this.isConjunctiveFacet(facetName)) {
      return [];
    }
    return this.facetsRefinements[facetName] || [];
  },
  /**
   * Get the list of disjunctive refinements for a single facet
   * @param {string} facetName name of the attribute used for faceting
   * @return {string[]} list of refinements
   */
  getDisjunctiveRefinements: function(facetName) {
    if (!this.isDisjunctiveFacet(facetName)) {
      return [];
    }
    return this.disjunctiveFacetsRefinements[facetName] || [];
  },
  /**
   * Get the list of hierarchical refinements for a single facet
   * @param {string} facetName name of the attribute used for faceting
   * @return {string[]} list of refinements
   */
  getHierarchicalRefinement: function(facetName) {
    // we send an array but we currently do not support multiple
    // hierarchicalRefinements for a hierarchicalFacet
    return this.hierarchicalFacetsRefinements[facetName] || [];
  },
  /**
   * Get the list of exclude refinements for a single facet
   * @param {string} facetName name of the attribute used for faceting
   * @return {string[]} list of refinements
   */
  getExcludeRefinements: function(facetName) {
    if (!this.isConjunctiveFacet(facetName)) {
      return [];
    }
    return this.facetsExcludes[facetName] || [];
  },

  /**
   * Remove all the numeric filter for a given (attribute, operator)
   * @method
   * @param {string} attribute attribute to set the filter on
   * @param {string} [operator] operator of the filter (possible values: =, >, >=, <, <=, !=)
   * @param {number} [number] the value to be removed
   * @return {SearchParameters}
   */
  removeNumericRefinement: function(attribute, operator, paramValue) {
    if (paramValue !== undefined) {
      if (!this.isNumericRefined(attribute, operator, paramValue)) {
        return this;
      }
      return this.setQueryParameters({
        numericRefinements: this._clearNumericRefinements(function(value, key) {
          return (
            key === attribute &&
            value.op === operator &&
            isEqualNumericRefinement(value.val, valToNumber(paramValue))
          );
        })
      });
    } else if (operator !== undefined) {
      if (!this.isNumericRefined(attribute, operator)) return this;
      return this.setQueryParameters({
        numericRefinements: this._clearNumericRefinements(function(value, key) {
          return key === attribute && value.op === operator;
        })
      });
    }

    if (!this.isNumericRefined(attribute)) return this;
    return this.setQueryParameters({
      numericRefinements: this._clearNumericRefinements(function(value, key) {
        return key === attribute;
      })
    });
  },
  /**
   * Get the list of numeric refinements for a single facet
   * @param {string} facetName name of the attribute used for faceting
   * @return {SearchParameters.OperatorList} list of refinements
   */
  getNumericRefinements: function(facetName) {
    return this.numericRefinements[facetName] || {};
  },
  /**
   * Return the current refinement for the (attribute, operator)
   * @param {string} attribute attribute in the record
   * @param {string} operator operator applied on the refined values
   * @return {Array.<number|number[]>} refined values
   */
  getNumericRefinement: function(attribute, operator) {
    return this.numericRefinements[attribute] && this.numericRefinements[attribute][operator];
  },
  /**
   * Clear numeric filters.
   * @method
   * @private
   * @param {string|SearchParameters.clearCallback} [attribute] optional string or function
   * - If not given, means to clear all the filters.
   * - If `string`, means to clear all refinements for the `attribute` named filter.
   * - If `function`, means to clear all the refinements that return truthy values.
   * @return {Object.<string, OperatorList>}
   */
  _clearNumericRefinements: function _clearNumericRefinements(attribute) {
    if (attribute === undefined) {
      if (!objectHasKeys(this.numericRefinements)) {
        return this.numericRefinements;
      }
      return {};
    } else if (typeof attribute === 'string') {
      return omit(this.numericRefinements, [attribute]);
    } else if (typeof attribute === 'function') {
      var hasChanged = false;
      var numericRefinements = this.numericRefinements;
      var newNumericRefinements = Object.keys(numericRefinements).reduce(function(memo, key) {
        var operators = numericRefinements[key];
        var operatorList = {};

        operators = operators || {};
        Object.keys(operators).forEach(function(operator) {
          var values = operators[operator] || [];
          var outValues = [];
          values.forEach(function(value) {
            var predicateResult = attribute({val: value, op: operator}, key, 'numeric');
            if (!predicateResult) outValues.push(value);
          });
          if (outValues.length !== values.length) {
            hasChanged = true;
          }
          operatorList[operator] = outValues;
        });

        memo[key] = operatorList;

        return memo;
      }, {});

      if (hasChanged) return newNumericRefinements;
      return this.numericRefinements;
    }
  },
  /**
   * Add a facet to the facets attribute of the helper configuration, if it
   * isn't already present.
   * @method
   * @param {string} facet facet name to add
   * @return {SearchParameters}
   */
  addFacet: function addFacet(facet) {
    if (this.isConjunctiveFacet(facet)) {
      return this;
    }

    return this.setQueryParameters({
      facets: this.facets.concat([facet])
    });
  },
  /**
   * Add a disjunctive facet to the disjunctiveFacets attribute of the helper
   * configuration, if it isn't already present.
   * @method
   * @param {string} facet disjunctive facet name to add
   * @return {SearchParameters}
   */
  addDisjunctiveFacet: function addDisjunctiveFacet(facet) {
    if (this.isDisjunctiveFacet(facet)) {
      return this;
    }

    return this.setQueryParameters({
      disjunctiveFacets: this.disjunctiveFacets.concat([facet])
    });
  },
  /**
   * Add a hierarchical facet to the hierarchicalFacets attribute of the helper
   * configuration.
   * @method
   * @param {object} hierarchicalFacet hierarchical facet to add
   * @return {SearchParameters}
   * @throws will throw an error if a hierarchical facet with the same name was already declared
   */
  addHierarchicalFacet: function addHierarchicalFacet(hierarchicalFacet) {
    if (this.isHierarchicalFacet(hierarchicalFacet.name)) {
      throw new Error(
        'Cannot declare two hierarchical facets with the same name: `' + hierarchicalFacet.name + '`');
    }

    return this.setQueryParameters({
      hierarchicalFacets: this.hierarchicalFacets.concat([hierarchicalFacet])
    });
  },
  /**
   * Add a refinement on a "normal" facet
   * @method
   * @param {string} facet attribute to apply the faceting on
   * @param {string} value value of the attribute (will be converted to string)
   * @return {SearchParameters}
   */
  addFacetRefinement: function addFacetRefinement(facet, value) {
    if (!this.isConjunctiveFacet(facet)) {
      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');
    }
    if (RefinementList.isRefined(this.facetsRefinements, facet, value)) return this;

    return this.setQueryParameters({
      facetsRefinements: RefinementList.addRefinement(this.facetsRefinements, facet, value)
    });
  },
  /**
   * Exclude a value from a "normal" facet
   * @method
   * @param {string} facet attribute to apply the exclusion on
   * @param {string} value value of the attribute (will be converted to string)
   * @return {SearchParameters}
   */
  addExcludeRefinement: function addExcludeRefinement(facet, value) {
    if (!this.isConjunctiveFacet(facet)) {
      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');
    }
    if (RefinementList.isRefined(this.facetsExcludes, facet, value)) return this;

    return this.setQueryParameters({
      facetsExcludes: RefinementList.addRefinement(this.facetsExcludes, facet, value)
    });
  },
  /**
   * Adds a refinement on a disjunctive facet.
   * @method
   * @param {string} facet attribute to apply the faceting on
   * @param {string} value value of the attribute (will be converted to string)
   * @return {SearchParameters}
   */
  addDisjunctiveFacetRefinement: function addDisjunctiveFacetRefinement(facet, value) {
    if (!this.isDisjunctiveFacet(facet)) {
      throw new Error(
        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');
    }

    if (RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)) return this;

    return this.setQueryParameters({
      disjunctiveFacetsRefinements: RefinementList.addRefinement(
        this.disjunctiveFacetsRefinements, facet, value)
    });
  },
  /**
   * addTagRefinement adds a tag to the list used to filter the results
   * @param {string} tag tag to be added
   * @return {SearchParameters}
   */
  addTagRefinement: function addTagRefinement(tag) {
    if (this.isTagRefined(tag)) return this;

    var modification = {
      tagRefinements: this.tagRefinements.concat(tag)
    };

    return this.setQueryParameters(modification);
  },
  /**
   * Remove a facet from the facets attribute of the helper configuration, if it
   * is present.
   * @method
   * @param {string} facet facet name to remove
   * @return {SearchParameters}
   */
  removeFacet: function removeFacet(facet) {
    if (!this.isConjunctiveFacet(facet)) {
      return this;
    }

    return this.clearRefinements(facet).setQueryParameters({
      facets: this.facets.filter(function(f) {
        return f !== facet;
      })
    });
  },
  /**
   * Remove a disjunctive facet from the disjunctiveFacets attribute of the
   * helper configuration, if it is present.
   * @method
   * @param {string} facet disjunctive facet name to remove
   * @return {SearchParameters}
   */
  removeDisjunctiveFacet: function removeDisjunctiveFacet(facet) {
    if (!this.isDisjunctiveFacet(facet)) {
      return this;
    }

    return this.clearRefinements(facet).setQueryParameters({
      disjunctiveFacets: this.disjunctiveFacets.filter(function(f) {
        return f !== facet;
      })
    });
  },
  /**
   * Remove a hierarchical facet from the hierarchicalFacets attribute of the
   * helper configuration, if it is present.
   * @method
   * @param {string} facet hierarchical facet name to remove
   * @return {SearchParameters}
   */
  removeHierarchicalFacet: function removeHierarchicalFacet(facet) {
    if (!this.isHierarchicalFacet(facet)) {
      return this;
    }

    return this.clearRefinements(facet).setQueryParameters({
      hierarchicalFacets: this.hierarchicalFacets.filter(function(f) {
        return f.name !== facet;
      })
    });
  },
  /**
   * Remove a refinement set on facet. If a value is provided, it will clear the
   * refinement for the given value, otherwise it will clear all the refinement
   * values for the faceted attribute.
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {string} [value] value used to filter
   * @return {SearchParameters}
   */
  removeFacetRefinement: function removeFacetRefinement(facet, value) {
    if (!this.isConjunctiveFacet(facet)) {
      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');
    }
    if (!RefinementList.isRefined(this.facetsRefinements, facet, value)) return this;

    return this.setQueryParameters({
      facetsRefinements: RefinementList.removeRefinement(this.facetsRefinements, facet, value)
    });
  },
  /**
   * Remove a negative refinement on a facet
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {string} value value used to filter
   * @return {SearchParameters}
   */
  removeExcludeRefinement: function removeExcludeRefinement(facet, value) {
    if (!this.isConjunctiveFacet(facet)) {
      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');
    }
    if (!RefinementList.isRefined(this.facetsExcludes, facet, value)) return this;

    return this.setQueryParameters({
      facetsExcludes: RefinementList.removeRefinement(this.facetsExcludes, facet, value)
    });
  },
  /**
   * Remove a refinement on a disjunctive facet
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {string} value value used to filter
   * @return {SearchParameters}
   */
  removeDisjunctiveFacetRefinement: function removeDisjunctiveFacetRefinement(facet, value) {
    if (!this.isDisjunctiveFacet(facet)) {
      throw new Error(
        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');
    }
    if (!RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)) return this;

    return this.setQueryParameters({
      disjunctiveFacetsRefinements: RefinementList.removeRefinement(
        this.disjunctiveFacetsRefinements, facet, value)
    });
  },
  /**
   * Remove a tag from the list of tag refinements
   * @method
   * @param {string} tag the tag to remove
   * @return {SearchParameters}
   */
  removeTagRefinement: function removeTagRefinement(tag) {
    if (!this.isTagRefined(tag)) return this;

    var modification = {
      tagRefinements: this.tagRefinements.filter(function(t) {
        return t !== tag;
      })
    };

    return this.setQueryParameters(modification);
  },
  /**
   * Generic toggle refinement method to use with facet, disjunctive facets
   * and hierarchical facets
   * @param  {string} facet the facet to refine
   * @param  {string} value the associated value
   * @return {SearchParameters}
   * @throws will throw an error if the facet is not declared in the settings of the helper
   * @deprecated since version 2.19.0, see {@link SearchParameters#toggleFacetRefinement}
   */
  toggleRefinement: function toggleRefinement(facet, value) {
    return this.toggleFacetRefinement(facet, value);
  },
  /**
   * Generic toggle refinement method to use with facet, disjunctive facets
   * and hierarchical facets
   * @param  {string} facet the facet to refine
   * @param  {string} value the associated value
   * @return {SearchParameters}
   * @throws will throw an error if the facet is not declared in the settings of the helper
   */
  toggleFacetRefinement: function toggleFacetRefinement(facet, value) {
    if (this.isHierarchicalFacet(facet)) {
      return this.toggleHierarchicalFacetRefinement(facet, value);
    } else if (this.isConjunctiveFacet(facet)) {
      return this.toggleConjunctiveFacetRefinement(facet, value);
    } else if (this.isDisjunctiveFacet(facet)) {
      return this.toggleDisjunctiveFacetRefinement(facet, value);
    }

    throw new Error('Cannot refine the undeclared facet ' + facet +
      '; it should be added to the helper options facets, disjunctiveFacets or hierarchicalFacets');
  },
  /**
   * Switch the refinement applied over a facet/value
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {value} value value used for filtering
   * @return {SearchParameters}
   */
  toggleConjunctiveFacetRefinement: function toggleConjunctiveFacetRefinement(facet, value) {
    if (!this.isConjunctiveFacet(facet)) {
      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');
    }

    return this.setQueryParameters({
      facetsRefinements: RefinementList.toggleRefinement(this.facetsRefinements, facet, value)
    });
  },
  /**
   * Switch the refinement applied over a facet/value
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {value} value value used for filtering
   * @return {SearchParameters}
   */
  toggleExcludeFacetRefinement: function toggleExcludeFacetRefinement(facet, value) {
    if (!this.isConjunctiveFacet(facet)) {
      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');
    }

    return this.setQueryParameters({
      facetsExcludes: RefinementList.toggleRefinement(this.facetsExcludes, facet, value)
    });
  },
  /**
   * Switch the refinement applied over a facet/value
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {value} value value used for filtering
   * @return {SearchParameters}
   */
  toggleDisjunctiveFacetRefinement: function toggleDisjunctiveFacetRefinement(facet, value) {
    if (!this.isDisjunctiveFacet(facet)) {
      throw new Error(
        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');
    }

    return this.setQueryParameters({
      disjunctiveFacetsRefinements: RefinementList.toggleRefinement(
        this.disjunctiveFacetsRefinements, facet, value)
    });
  },
  /**
   * Switch the refinement applied over a facet/value
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {value} value value used for filtering
   * @return {SearchParameters}
   */
  toggleHierarchicalFacetRefinement: function toggleHierarchicalFacetRefinement(facet, value) {
    if (!this.isHierarchicalFacet(facet)) {
      throw new Error(
        facet + ' is not defined in the hierarchicalFacets attribute of the helper configuration');
    }

    var separator = this._getHierarchicalFacetSeparator(this.getHierarchicalFacetByName(facet));

    var mod = {};

    var upOneOrMultipleLevel = this.hierarchicalFacetsRefinements[facet] !== undefined &&
      this.hierarchicalFacetsRefinements[facet].length > 0 && (
      // remove current refinement:
      // refinement was 'beer > IPA', call is toggleRefine('beer > IPA'), refinement should be `beer`
      this.hierarchicalFacetsRefinements[facet][0] === value ||
      // remove a parent refinement of the current refinement:
      //  - refinement was 'beer > IPA > Flying dog'
      //  - call is toggleRefine('beer > IPA')
      //  - refinement should be `beer`
      this.hierarchicalFacetsRefinements[facet][0].indexOf(value + separator) === 0
    );

    if (upOneOrMultipleLevel) {
      if (value.indexOf(separator) === -1) {
        // go back to root level
        mod[facet] = [];
      } else {
        mod[facet] = [value.slice(0, value.lastIndexOf(separator))];
      }
    } else {
      mod[facet] = [value];
    }

    return this.setQueryParameters({
      hierarchicalFacetsRefinements: defaultsPure({}, mod, this.hierarchicalFacetsRefinements)
    });
  },

  /**
   * Adds a refinement on a hierarchical facet.
   * @param {string} facet the facet name
   * @param {string} path the hierarchical facet path
   * @return {SearchParameter} the new state
   * @throws Error if the facet is not defined or if the facet is refined
   */
  addHierarchicalFacetRefinement: function(facet, path) {
    if (this.isHierarchicalFacetRefined(facet)) {
      throw new Error(facet + ' is already refined.');
    }
    if (!this.isHierarchicalFacet(facet)) {
      throw new Error(facet + ' is not defined in the hierarchicalFacets attribute of the helper configuration.');
    }
    var mod = {};
    mod[facet] = [path];
    return this.setQueryParameters({
      hierarchicalFacetsRefinements: defaultsPure({}, mod, this.hierarchicalFacetsRefinements)
    });
  },

  /**
   * Removes the refinement set on a hierarchical facet.
   * @param {string} facet the facet name
   * @return {SearchParameter} the new state
   * @throws Error if the facet is not defined or if the facet is not refined
   */
  removeHierarchicalFacetRefinement: function(facet) {
    if (!this.isHierarchicalFacetRefined(facet)) {
      return this;
    }
    var mod = {};
    mod[facet] = [];
    return this.setQueryParameters({
      hierarchicalFacetsRefinements: defaultsPure({}, mod, this.hierarchicalFacetsRefinements)
    });
  },
  /**
   * Switch the tag refinement
   * @method
   * @param {string} tag the tag to remove or add
   * @return {SearchParameters}
   */
  toggleTagRefinement: function toggleTagRefinement(tag) {
    if (this.isTagRefined(tag)) {
      return this.removeTagRefinement(tag);
    }

    return this.addTagRefinement(tag);
  },
  /**
   * Test if the facet name is from one of the disjunctive facets
   * @method
   * @param {string} facet facet name to test
   * @return {boolean}
   */
  isDisjunctiveFacet: function(facet) {
    return this.disjunctiveFacets.indexOf(facet) > -1;
  },
  /**
   * Test if the facet name is from one of the hierarchical facets
   * @method
   * @param {string} facetName facet name to test
   * @return {boolean}
   */
  isHierarchicalFacet: function(facetName) {
    return this.getHierarchicalFacetByName(facetName) !== undefined;
  },
  /**
   * Test if the facet name is from one of the conjunctive/normal facets
   * @method
   * @param {string} facet facet name to test
   * @return {boolean}
   */
  isConjunctiveFacet: function(facet) {
    return this.facets.indexOf(facet) > -1;
  },
  /**
   * Returns true if the facet is refined, either for a specific value or in
   * general.
   * @method
   * @param {string} facet name of the attribute for used for faceting
   * @param {string} value, optional value. If passed will test that this value
   * is filtering the given facet.
   * @return {boolean} returns true if refined
   */
  isFacetRefined: function isFacetRefined(facet, value) {
    if (!this.isConjunctiveFacet(facet)) {
      return false;
    }
    return RefinementList.isRefined(this.facetsRefinements, facet, value);
  },
  /**
   * Returns true if the facet contains exclusions or if a specific value is
   * excluded.
   *
   * @method
   * @param {string} facet name of the attribute for used for faceting
   * @param {string} [value] optional value. If passed will test that this value
   * is filtering the given facet.
   * @return {boolean} returns true if refined
   */
  isExcludeRefined: function isExcludeRefined(facet, value) {
    if (!this.isConjunctiveFacet(facet)) {
      return false;
    }
    return RefinementList.isRefined(this.facetsExcludes, facet, value);
  },
  /**
   * Returns true if the facet contains a refinement, or if a value passed is a
   * refinement for the facet.
   * @method
   * @param {string} facet name of the attribute for used for faceting
   * @param {string} value optional, will test if the value is used for refinement
   * if there is one, otherwise will test if the facet contains any refinement
   * @return {boolean}
   */
  isDisjunctiveFacetRefined: function isDisjunctiveFacetRefined(facet, value) {
    if (!this.isDisjunctiveFacet(facet)) {
      return false;
    }
    return RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value);
  },
  /**
   * Returns true if the facet contains a refinement, or if a value passed is a
   * refinement for the facet.
   * @method
   * @param {string} facet name of the attribute for used for faceting
   * @param {string} value optional, will test if the value is used for refinement
   * if there is one, otherwise will test if the facet contains any refinement
   * @return {boolean}
   */
  isHierarchicalFacetRefined: function isHierarchicalFacetRefined(facet, value) {
    if (!this.isHierarchicalFacet(facet)) {
      return false;
    }

    var refinements = this.getHierarchicalRefinement(facet);

    if (!value) {
      return refinements.length > 0;
    }

    return refinements.indexOf(value) !== -1;
  },
  /**
   * Test if the triple (attribute, operator, value) is already refined.
   * If only the attribute and the operator are provided, it tests if the
   * contains any refinement value.
   * @method
   * @param {string} attribute attribute for which the refinement is applied
   * @param {string} [operator] operator of the refinement
   * @param {string} [value] value of the refinement
   * @return {boolean} true if it is refined
   */
  isNumericRefined: function isNumericRefined(attribute, operator, value) {
    if (value === undefined && operator === undefined) {
      return !!this.numericRefinements[attribute];
    }

    var isOperatorDefined =
      this.numericRefinements[attribute] &&
      this.numericRefinements[attribute][operator] !== undefined;

    if (value === undefined || !isOperatorDefined) {
      return isOperatorDefined;
    }

    var parsedValue = valToNumber(value);
    var isAttributeValueDefined =
      findArray(this.numericRefinements[attribute][operator], parsedValue) !==
      undefined;

    return isOperatorDefined && isAttributeValueDefined;
  },
  /**
   * Returns true if the tag refined, false otherwise
   * @method
   * @param {string} tag the tag to check
   * @return {boolean}
   */
  isTagRefined: function isTagRefined(tag) {
    return this.tagRefinements.indexOf(tag) !== -1;
  },
  /**
   * Returns the list of all disjunctive facets refined
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {value} value value used for filtering
   * @return {string[]}
   */
  getRefinedDisjunctiveFacets: function getRefinedDisjunctiveFacets() {
    var self = this;

    // attributes used for numeric filter can also be disjunctive
    var disjunctiveNumericRefinedFacets = intersection(
      Object.keys(this.numericRefinements).filter(function(facet) {
        return Object.keys(self.numericRefinements[facet]).length > 0;
      }),
      this.disjunctiveFacets
    );

    return Object.keys(this.disjunctiveFacetsRefinements).filter(function(facet) {
      return self.disjunctiveFacetsRefinements[facet].length > 0;
    })
      .concat(disjunctiveNumericRefinedFacets)
      .concat(this.getRefinedHierarchicalFacets());
  },
  /**
   * Returns the list of all disjunctive facets refined
   * @method
   * @param {string} facet name of the attribute used for faceting
   * @param {value} value value used for filtering
   * @return {string[]}
   */
  getRefinedHierarchicalFacets: function getRefinedHierarchicalFacets() {
    var self = this;
    return intersection(
      // enforce the order between the two arrays,
      // so that refinement name index === hierarchical facet index
      this.hierarchicalFacets.map(function(facet) { return facet.name; }),
      Object.keys(this.hierarchicalFacetsRefinements).filter(function(facet) {
        return self.hierarchicalFacetsRefinements[facet].length > 0;
      })
    );
  },
  /**
   * Returned the list of all disjunctive facets not refined
   * @method
   * @return {string[]}
   */
  getUnrefinedDisjunctiveFacets: function() {
    var refinedFacets = this.getRefinedDisjunctiveFacets();

    return this.disjunctiveFacets.filter(function(f) {
      return refinedFacets.indexOf(f) === -1;
    });
  },

  managedParameters: [
    'index',
    'facets', 'disjunctiveFacets', 'facetsRefinements',
    'facetsExcludes', 'disjunctiveFacetsRefinements',
    'numericRefinements', 'tagRefinements', 'hierarchicalFacets', 'hierarchicalFacetsRefinements'
  ],
  getQueryParams: function getQueryParams() {
    var managedParameters = this.managedParameters;

    var queryParams = {};

    var self = this;
    Object.keys(this).forEach(function(paramName) {
      var paramValue = self[paramName];
      if (managedParameters.indexOf(paramName) === -1 && paramValue !== undefined) {
        queryParams[paramName] = paramValue;
      }
    });

    return queryParams;
  },
  /**
   * Let the user set a specific value for a given parameter. Will return the
   * same instance if the parameter is invalid or if the value is the same as the
   * previous one.
   * @method
   * @param {string} parameter the parameter name
   * @param {any} value the value to be set, must be compliant with the definition
   * of the attribute on the object
   * @return {SearchParameters} the updated state
   */
  setQueryParameter: function setParameter(parameter, value) {
    if (this[parameter] === value) return this;

    var modification = {};

    modification[parameter] = value;

    return this.setQueryParameters(modification);
  },
  /**
   * Let the user set any of the parameters with a plain object.
   * @method
   * @param {object} params all the keys and the values to be updated
   * @return {SearchParameters} a new updated instance
   */
  setQueryParameters: function setQueryParameters(params) {
    if (!params) return this;

    var error = SearchParameters.validate(this, params);

    if (error) {
      throw error;
    }

    var self = this;
    var nextWithNumbers = SearchParameters._parseNumbers(params);
    var previousPlainObject = Object.keys(this).reduce(function(acc, key) {
      acc[key] = self[key];
      return acc;
    }, {});

    var nextPlainObject = Object.keys(nextWithNumbers).reduce(
      function(previous, key) {
        var isPreviousValueDefined = previous[key] !== undefined;
        var isNextValueDefined = nextWithNumbers[key] !== undefined;

        if (isPreviousValueDefined && !isNextValueDefined) {
          return omit(previous, [key]);
        }

        if (isNextValueDefined) {
          previous[key] = nextWithNumbers[key];
        }

        return previous;
      },
      previousPlainObject
    );

    return new this.constructor(nextPlainObject);
  },

  /**
   * Returns a new instance with the page reset. Two scenarios possible:
   * the page is omitted -> return the given instance
   * the page is set -> return a new instance with a page of 0
   * @return {SearchParameters} a new updated instance
   */
  resetPage: function() {
    if (this.page === undefined) {
      return this;
    }

    return this.setPage(0);
  },

  /**
   * Helper function to get the hierarchicalFacet separator or the default one (`>`)
   * @param  {object} hierarchicalFacet
   * @return {string} returns the hierarchicalFacet.separator or `>` as default
   */
  _getHierarchicalFacetSortBy: function(hierarchicalFacet) {
    return hierarchicalFacet.sortBy || ['isRefined:desc', 'name:asc'];
  },

  /**
   * Helper function to get the hierarchicalFacet separator or the default one (`>`)
   * @private
   * @param  {object} hierarchicalFacet
   * @return {string} returns the hierarchicalFacet.separator or `>` as default
   */
  _getHierarchicalFacetSeparator: function(hierarchicalFacet) {
    return hierarchicalFacet.separator || ' > ';
  },

  /**
   * Helper function to get the hierarchicalFacet prefix path or null
   * @private
   * @param  {object} hierarchicalFacet
   * @return {string} returns the hierarchicalFacet.rootPath or null as default
   */
  _getHierarchicalRootPath: function(hierarchicalFacet) {
    return hierarchicalFacet.rootPath || null;
  },

  /**
   * Helper function to check if we show the parent level of the hierarchicalFacet
   * @private
   * @param  {object} hierarchicalFacet
   * @return {string} returns the hierarchicalFacet.showParentLevel or true as default
   */
  _getHierarchicalShowParentLevel: function(hierarchicalFacet) {
    if (typeof hierarchicalFacet.showParentLevel === 'boolean') {
      return hierarchicalFacet.showParentLevel;
    }
    return true;
  },

  /**
   * Helper function to get the hierarchicalFacet by it's name
   * @param  {string} hierarchicalFacetName
   * @return {object} a hierarchicalFacet
   */
  getHierarchicalFacetByName: function(hierarchicalFacetName) {
    return find(
      this.hierarchicalFacets,
      function(f) {
        return f.name === hierarchicalFacetName;
      }
    );
  },

  /**
   * Get the current breadcrumb for a hierarchical facet, as an array
   * @param  {string} facetName Hierarchical facet name
   * @return {array.<string>} the path as an array of string
   */
  getHierarchicalFacetBreadcrumb: function(facetName) {
    if (!this.isHierarchicalFacet(facetName)) {
      return [];
    }

    var refinement = this.getHierarchicalRefinement(facetName)[0];
    if (!refinement) return [];

    var separator = this._getHierarchicalFacetSeparator(
      this.getHierarchicalFacetByName(facetName)
    );
    var path = refinement.split(separator);
    return path.map(function(part) {
      return part.trim();
    });
  },

  toString: function() {
    return JSON.stringify(this, null, 2);
  }
};

/**
 * Callback used for clearRefinement method
 * @callback SearchParameters.clearCallback
 * @param {OperatorList|FacetList} value the value of the filter
 * @param {string} key the current attribute name
 * @param {string} type `numeric`, `disjunctiveFacet`, `conjunctiveFacet`, `hierarchicalFacet` or `exclude`
 * depending on the type of facet
 * @return {boolean} `true` if the element should be removed. `false` otherwise.
 */
module.exports = SearchParameters;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = generateTrees;

var orderBy = __webpack_require__(/*! ../functions/orderBy */ "./node_modules/algoliasearch-helper/src/functions/orderBy.js");
var find = __webpack_require__(/*! ../functions/find */ "./node_modules/algoliasearch-helper/src/functions/find.js");
var prepareHierarchicalFacetSortBy = __webpack_require__(/*! ../functions/formatSort */ "./node_modules/algoliasearch-helper/src/functions/formatSort.js");

function generateTrees(state) {
  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {
    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];
    var hierarchicalFacetRefinement =
      (state.hierarchicalFacetsRefinements[hierarchicalFacet.name] &&
        state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0]) ||
      '';
    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(
      hierarchicalFacet
    );
    var hierarchicalRootPath = state._getHierarchicalRootPath(
      hierarchicalFacet
    );
    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(
      hierarchicalFacet
    );
    var sortBy = prepareHierarchicalFacetSortBy(
      state._getHierarchicalFacetSortBy(hierarchicalFacet)
    );

    var rootExhaustive = hierarchicalFacetResult.every(function(facetResult) {
      return facetResult.exhaustive;
    });

    var generateTreeFn = generateHierarchicalTree(
      sortBy,
      hierarchicalSeparator,
      hierarchicalRootPath,
      hierarchicalShowParentLevel,
      hierarchicalFacetRefinement
    );

    var results = hierarchicalFacetResult;

    if (hierarchicalRootPath) {
      results = hierarchicalFacetResult.slice(
        hierarchicalRootPath.split(hierarchicalSeparator).length
      );
    }

    return results.reduce(generateTreeFn, {
      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,
      count: null, // root level, no count
      isRefined: true, // root level, always refined
      path: null, // root level, no path
      exhaustive: rootExhaustive,
      data: null
    });
  };
}

function generateHierarchicalTree(
  sortBy,
  hierarchicalSeparator,
  hierarchicalRootPath,
  hierarchicalShowParentLevel,
  currentRefinement
) {
  return function generateTree(
    hierarchicalTree,
    hierarchicalFacetResult,
    currentHierarchicalLevel
  ) {
    var parent = hierarchicalTree;

    if (currentHierarchicalLevel > 0) {
      var level = 0;

      parent = hierarchicalTree;

      while (level < currentHierarchicalLevel) {
        /**
         * @type {object[]]} hierarchical data
         */
        var data = parent && Array.isArray(parent.data) ? parent.data : [];
        parent = find(data, function(subtree) {
          return subtree.isRefined;
        });
        level++;
      }
    }

    // we found a refined parent, let's add current level data under it
    if (parent) {
      // filter values in case an object has multiple categories:
      //   {
      //     categories: {
      //       level0: ['beers', 'bières'],
      //       level1: ['beers > IPA', 'bières > Belges']
      //     }
      //   }
      //
      // If parent refinement is `beers`, then we do not want to have `bières > Belges`
      // showing up

      var picked = Object.keys(hierarchicalFacetResult.data)
        .map(function(facetValue) {
          return [facetValue, hierarchicalFacetResult.data[facetValue]];
        })
        .filter(function(tuple) {
          var facetValue = tuple[0];
          return onlyMatchingTree(
            facetValue,
            parent.path || hierarchicalRootPath,
            currentRefinement,
            hierarchicalSeparator,
            hierarchicalRootPath,
            hierarchicalShowParentLevel
          );
        });

      parent.data = orderBy(
        picked.map(function(tuple) {
          var facetValue = tuple[0];
          var facetCount = tuple[1];

          return format(
            facetCount,
            facetValue,
            hierarchicalSeparator,
            currentRefinement,
            hierarchicalFacetResult.exhaustive
          );
        }),
        sortBy[0],
        sortBy[1]
      );
    }

    return hierarchicalTree;
  };
}

function onlyMatchingTree(
  facetValue,
  parentPath,
  currentRefinement,
  hierarchicalSeparator,
  hierarchicalRootPath,
  hierarchicalShowParentLevel
) {
  // we want the facetValue is a child of hierarchicalRootPath
  if (
    hierarchicalRootPath &&
    (facetValue.indexOf(hierarchicalRootPath) !== 0 ||
      hierarchicalRootPath === facetValue)
  ) {
    return false;
  }

  // we always want root levels (only when there is no prefix path)
  return (
    (!hierarchicalRootPath &&
      facetValue.indexOf(hierarchicalSeparator) === -1) ||
    // if there is a rootPath, being root level mean 1 level under rootPath
    (hierarchicalRootPath &&
      facetValue.split(hierarchicalSeparator).length -
        hierarchicalRootPath.split(hierarchicalSeparator).length ===
        1) ||
    // if current refinement is a root level and current facetValue is a root level,
    // keep the facetValue
    (facetValue.indexOf(hierarchicalSeparator) === -1 &&
      currentRefinement.indexOf(hierarchicalSeparator) === -1) ||
    // currentRefinement is a child of the facet value
    currentRefinement.indexOf(facetValue) === 0 ||
    // facetValue is a child of the current parent, add it
    (facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 &&
      (hierarchicalShowParentLevel ||
        facetValue.indexOf(currentRefinement) === 0))
  );
}

function format(
  facetCount,
  facetValue,
  hierarchicalSeparator,
  currentRefinement,
  exhaustive
) {
  var parts = facetValue.split(hierarchicalSeparator);
  return {
    name: parts[parts.length - 1].trim(),
    path: facetValue,
    count: facetCount,
    isRefined:
      currentRefinement === facetValue ||
      currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,
    exhaustive: exhaustive,
    data: null
  };
}


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/SearchResults/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/SearchResults/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var merge = __webpack_require__(/*! ../functions/merge */ "./node_modules/algoliasearch-helper/src/functions/merge.js");
var defaultsPure = __webpack_require__(/*! ../functions/defaultsPure */ "./node_modules/algoliasearch-helper/src/functions/defaultsPure.js");
var orderBy = __webpack_require__(/*! ../functions/orderBy */ "./node_modules/algoliasearch-helper/src/functions/orderBy.js");
var compact = __webpack_require__(/*! ../functions/compact */ "./node_modules/algoliasearch-helper/src/functions/compact.js");
var find = __webpack_require__(/*! ../functions/find */ "./node_modules/algoliasearch-helper/src/functions/find.js");
var findIndex = __webpack_require__(/*! ../functions/findIndex */ "./node_modules/algoliasearch-helper/src/functions/findIndex.js");
var formatSort = __webpack_require__(/*! ../functions/formatSort */ "./node_modules/algoliasearch-helper/src/functions/formatSort.js");

var generateHierarchicalTree = __webpack_require__(/*! ./generate-hierarchical-tree */ "./node_modules/algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js");

/**
 * @typedef SearchResults.Facet
 * @type {object}
 * @property {string} name name of the attribute in the record
 * @property {object} data the faceting data: value, number of entries
 * @property {object} stats undefined unless facet_stats is retrieved from algolia
 */

/**
 * @typedef SearchResults.HierarchicalFacet
 * @type {object}
 * @property {string} name name of the current value given the hierarchical level, trimmed.
 * If root node, you get the facet name
 * @property {number} count number of objects matching this hierarchical value
 * @property {string} path the current hierarchical value full path
 * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise
 * @property {HierarchicalFacet[]} data sub values for the current level
 */

/**
 * @typedef SearchResults.FacetValue
 * @type {object}
 * @property {string} name the facet value itself
 * @property {number} count times this facet appears in the results
 * @property {boolean} isRefined is the facet currently selected
 * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)
 */

/**
 * @typedef Refinement
 * @type {object}
 * @property {string} type the type of filter used:
 * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`
 * @property {string} attributeName name of the attribute used for filtering
 * @property {string} name the value of the filter
 * @property {number} numericValue the value as a number. Only for numeric filters.
 * @property {string} operator the operator used. Only for numeric filters.
 * @property {number} count the number of computed hits for this filter. Only on facets.
 * @property {boolean} exhaustive if the count is exhaustive
 */

/**
 * @param {string[]} attributes
 */
function getIndices(attributes) {
  var indices = {};

  attributes.forEach(function(val, idx) {
    indices[val] = idx;
  });

  return indices;
}

function assignFacetStats(dest, facetStats, key) {
  if (facetStats && facetStats[key]) {
    dest.stats = facetStats[key];
  }
}

/**
 * @typedef {Object} HierarchicalFacet
 * @property {string} name
 * @property {string[]} attributes
 */

/**
 * @param {HierarchicalFacet[]} hierarchicalFacets
 * @param {string} hierarchicalAttributeName
 */
function findMatchingHierarchicalFacetFromAttributeName(
  hierarchicalFacets,
  hierarchicalAttributeName
) {
  return find(hierarchicalFacets, function facetKeyMatchesAttribute(
    hierarchicalFacet
  ) {
    var facetNames = hierarchicalFacet.attributes || [];
    return facetNames.indexOf(hierarchicalAttributeName) > -1;
  });
}

/*eslint-disable */
/**
 * Constructor for SearchResults
 * @class
 * @classdesc SearchResults contains the results of a query to Algolia using the
 * {@link AlgoliaSearchHelper}.
 * @param {SearchParameters} state state that led to the response
 * @param {array.<object>} results the results from algolia client
 * @example <caption>SearchResults of the first query in
 * <a href="http://demos.algolia.com/instant-search-demo">the instant search demo</a></caption>
{
   "hitsPerPage": 10,
   "processingTimeMS": 2,
   "facets": [
      {
         "name": "type",
         "data": {
            "HardGood": 6627,
            "BlackTie": 550,
            "Music": 665,
            "Software": 131,
            "Game": 456,
            "Movie": 1571
         },
         "exhaustive": false
      },
      {
         "exhaustive": false,
         "data": {
            "Free shipping": 5507
         },
         "name": "shipping"
      }
  ],
   "hits": [
      {
         "thumbnailImage": "http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif",
         "_highlightResult": {
            "shortDescription": {
               "matchLevel": "none",
               "value": "Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection",
               "matchedWords": []
            },
            "category": {
               "matchLevel": "none",
               "value": "Computer Security Software",
               "matchedWords": []
            },
            "manufacturer": {
               "matchedWords": [],
               "value": "Webroot",
               "matchLevel": "none"
            },
            "name": {
               "value": "Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows",
               "matchedWords": [],
               "matchLevel": "none"
            }
         },
         "image": "http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg",
         "shipping": "Free shipping",
         "bestSellingRank": 4,
         "shortDescription": "Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection",
         "url": "http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ",
         "name": "Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows",
         "category": "Computer Security Software",
         "salePrice_range": "1 - 50",
         "objectID": "1688832",
         "type": "Software",
         "customerReviewCount": 5980,
         "salePrice": 49.99,
         "manufacturer": "Webroot"
      },
      ....
  ],
   "nbHits": 10000,
   "disjunctiveFacets": [
      {
         "exhaustive": false,
         "data": {
            "5": 183,
            "12": 112,
            "7": 149,
            ...
         },
         "name": "customerReviewCount",
         "stats": {
            "max": 7461,
            "avg": 157.939,
            "min": 1
         }
      },
      {
         "data": {
            "Printer Ink": 142,
            "Wireless Speakers": 60,
            "Point & Shoot Cameras": 48,
            ...
         },
         "name": "category",
         "exhaustive": false
      },
      {
         "exhaustive": false,
         "data": {
            "> 5000": 2,
            "1 - 50": 6524,
            "501 - 2000": 566,
            "201 - 500": 1501,
            "101 - 200": 1360,
            "2001 - 5000": 47
         },
         "name": "salePrice_range"
      },
      {
         "data": {
            "Dynex™": 202,
            "Insignia™": 230,
            "PNY": 72,
            ...
         },
         "name": "manufacturer",
         "exhaustive": false
      }
  ],
   "query": "",
   "nbPages": 100,
   "page": 0,
   "index": "bestbuy"
}
 **/
/*eslint-enable */
function SearchResults(state, results) {
  var mainSubResponse = results[0];

  this._rawResults = results;

  var self = this;

  // https://www.algolia.com/doc/api-reference/api-methods/search/#response
  Object.keys(mainSubResponse).forEach(function(key) {
    self[key] = mainSubResponse[key];
  });

  /**
   * query used to generate the results
   * @name query
   * @member {string}
   * @memberof SearchResults
   * @instance
   */
  /**
   * The query as parsed by the engine given all the rules.
   * @name parsedQuery
   * @member {string}
   * @memberof SearchResults
   * @instance
   */
  /**
   * all the records that match the search parameters. Each record is
   * augmented with a new attribute `_highlightResult`
   * which is an object keyed by attribute and with the following properties:
   *  - `value` : the value of the facet highlighted (html)
   *  - `matchLevel`: full, partial or none depending on how the query terms match
   * @name hits
   * @member {object[]}
   * @memberof SearchResults
   * @instance
   */
  /**
   * index where the results come from
   * @name index
   * @member {string}
   * @memberof SearchResults
   * @instance
   */
  /**
   * number of hits per page requested
   * @name hitsPerPage
   * @member {number}
   * @memberof SearchResults
   * @instance
   */
  /**
   * total number of hits of this query on the index
   * @name nbHits
   * @member {number}
   * @memberof SearchResults
   * @instance
   */
  /**
   * total number of pages with respect to the number of hits per page and the total number of hits
   * @name nbPages
   * @member {number}
   * @memberof SearchResults
   * @instance
   */
  /**
   * current page
   * @name page
   * @member {number}
   * @memberof SearchResults
   * @instance
   */
  /**
   * The position if the position was guessed by IP.
   * @name aroundLatLng
   * @member {string}
   * @memberof SearchResults
   * @instance
   * @example "48.8637,2.3615",
   */
  /**
   * The radius computed by Algolia.
   * @name automaticRadius
   * @member {string}
   * @memberof SearchResults
   * @instance
   * @example "126792922",
   */
  /**
   * String identifying the server used to serve this request.
   *
   * getRankingInfo needs to be set to `true` for this to be returned
   *
   * @name serverUsed
   * @member {string}
   * @memberof SearchResults
   * @instance
   * @example "c7-use-2.algolia.net",
   */
  /**
   * Boolean that indicates if the computation of the counts did time out.
   * @deprecated
   * @name timeoutCounts
   * @member {boolean}
   * @memberof SearchResults
   * @instance
   */
  /**
   * Boolean that indicates if the computation of the hits did time out.
   * @deprecated
   * @name timeoutHits
   * @member {boolean}
   * @memberof SearchResults
   * @instance
   */
  /**
   * True if the counts of the facets is exhaustive
   * @name exhaustiveFacetsCount
   * @member {boolean}
   * @memberof SearchResults
   * @instance
   */
  /**
   * True if the number of hits is exhaustive
   * @name exhaustiveNbHits
   * @member {boolean}
   * @memberof SearchResults
   * @instance
   */
  /**
   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).
   * @name userData
   * @member {object[]}
   * @memberof SearchResults
   * @instance
   */
  /**
   * queryID is the unique identifier of the query used to generate the current search results.
   * This value is only available if the `clickAnalytics` search parameter is set to `true`.
   * @name queryID
   * @member {string}
   * @memberof SearchResults
   * @instance
   */

  /**
   * sum of the processing time of all the queries
   * @member {number}
   */
  this.processingTimeMS = results.reduce(function(sum, result) {
    return result.processingTimeMS === undefined
      ? sum
      : sum + result.processingTimeMS;
  }, 0);

  /**
   * disjunctive facets results
   * @member {SearchResults.Facet[]}
   */
  this.disjunctiveFacets = [];
  /**
   * disjunctive facets results
   * @member {SearchResults.HierarchicalFacet[]}
   */
  this.hierarchicalFacets = state.hierarchicalFacets.map(function initFutureTree() {
    return [];
  });
  /**
   * other facets results
   * @member {SearchResults.Facet[]}
   */
  this.facets = [];

  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();

  var facetsIndices = getIndices(state.facets);
  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);
  var nextDisjunctiveResult = 1;

  // Since we send request only for disjunctive facets that have been refined,
  // we get the facets information from the first, general, response.

  var mainFacets = mainSubResponse.facets || {};

  Object.keys(mainFacets).forEach(function(facetKey) {
    var facetValueObject = mainFacets[facetKey];

    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(
      state.hierarchicalFacets,
      facetKey
    );

    if (hierarchicalFacet) {
      // Place the hierarchicalFacet data at the correct index depending on
      // the attributes order that was defined at the helper initialization
      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);
      var idxAttributeName = findIndex(state.hierarchicalFacets, function(f) {
        return f.name === hierarchicalFacet.name;
      });
      self.hierarchicalFacets[idxAttributeName][facetIndex] = {
        attribute: facetKey,
        data: facetValueObject,
        exhaustive: mainSubResponse.exhaustiveFacetsCount
      };
    } else {
      var isFacetDisjunctive = state.disjunctiveFacets.indexOf(facetKey) !== -1;
      var isFacetConjunctive = state.facets.indexOf(facetKey) !== -1;
      var position;

      if (isFacetDisjunctive) {
        position = disjunctiveFacetsIndices[facetKey];
        self.disjunctiveFacets[position] = {
          name: facetKey,
          data: facetValueObject,
          exhaustive: mainSubResponse.exhaustiveFacetsCount
        };
        assignFacetStats(self.disjunctiveFacets[position], mainSubResponse.facets_stats, facetKey);
      }
      if (isFacetConjunctive) {
        position = facetsIndices[facetKey];
        self.facets[position] = {
          name: facetKey,
          data: facetValueObject,
          exhaustive: mainSubResponse.exhaustiveFacetsCount
        };
        assignFacetStats(self.facets[position], mainSubResponse.facets_stats, facetKey);
      }
    }
  });

  // Make sure we do not keep holes within the hierarchical facets
  this.hierarchicalFacets = compact(this.hierarchicalFacets);

  // aggregate the refined disjunctive facets
  disjunctiveFacets.forEach(function(disjunctiveFacet) {
    var result = results[nextDisjunctiveResult];
    var facets = result && result.facets ? result.facets : {};
    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet);

    // There should be only item in facets.
    Object.keys(facets).forEach(function(dfacet) {
      var facetResults = facets[dfacet];

      var position;

      if (hierarchicalFacet) {
        position = findIndex(state.hierarchicalFacets, function(f) {
          return f.name === hierarchicalFacet.name;
        });
        var attributeIndex = findIndex(self.hierarchicalFacets[position], function(f) {
          return f.attribute === dfacet;
        });

        // previous refinements and no results so not able to find it
        if (attributeIndex === -1) {
          return;
        }

        self.hierarchicalFacets[position][attributeIndex].data = merge(
          {},
          self.hierarchicalFacets[position][attributeIndex].data,
          facetResults
        );
      } else {
        position = disjunctiveFacetsIndices[dfacet];

        var dataFromMainRequest = mainSubResponse.facets && mainSubResponse.facets[dfacet] || {};

        self.disjunctiveFacets[position] = {
          name: dfacet,
          data: defaultsPure({}, facetResults, dataFromMainRequest),
          exhaustive: result.exhaustiveFacetsCount
        };
        assignFacetStats(self.disjunctiveFacets[position], result.facets_stats, dfacet);

        if (state.disjunctiveFacetsRefinements[dfacet]) {
          state.disjunctiveFacetsRefinements[dfacet].forEach(function(refinementValue) {
            // add the disjunctive refinements if it is no more retrieved
            if (!self.disjunctiveFacets[position].data[refinementValue] &&
              state.disjunctiveFacetsRefinements[dfacet].indexOf(refinementValue) > -1) {
              self.disjunctiveFacets[position].data[refinementValue] = 0;
            }
          });
        }
      }
    });
    nextDisjunctiveResult++;
  });

  // if we have some root level values for hierarchical facets, merge them
  state.getRefinedHierarchicalFacets().forEach(function(refinedFacet) {
    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);
    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);

    var currentRefinement = state.getHierarchicalRefinement(refinedFacet);
    // if we are already at a root refinement (or no refinement at all), there is no
    // root level values request
    if (currentRefinement.length === 0 || currentRefinement[0].split(separator).length < 2) {
      return;
    }

    var result = results[nextDisjunctiveResult];
    var facets = result && result.facets
      ? result.facets
      : {};
    Object.keys(facets).forEach(function(dfacet) {
      var facetResults = facets[dfacet];
      var position = findIndex(state.hierarchicalFacets, function(f) {
        return f.name === hierarchicalFacet.name;
      });
      var attributeIndex = findIndex(self.hierarchicalFacets[position], function(f) {
        return f.attribute === dfacet;
      });

      // previous refinements and no results so not able to find it
      if (attributeIndex === -1) {
        return;
      }

      // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),
      // then the disjunctive values will be `beers` (count: 100),
      // but we do not want to display
      //   | beers (100)
      //     > IPA (5)
      // We want
      //   | beers (5)
      //     > IPA (5)
      var defaultData = {};

      if (currentRefinement.length > 0) {
        var root = currentRefinement[0].split(separator)[0];
        defaultData[root] = self.hierarchicalFacets[position][attributeIndex].data[root];
      }

      self.hierarchicalFacets[position][attributeIndex].data = defaultsPure(
        defaultData,
        facetResults,
        self.hierarchicalFacets[position][attributeIndex].data
      );
    });

    nextDisjunctiveResult++;
  });

  // add the excludes
  Object.keys(state.facetsExcludes).forEach(function(facetName) {
    var excludes = state.facetsExcludes[facetName];
    var position = facetsIndices[facetName];

    self.facets[position] = {
      name: facetName,
      data: mainSubResponse.facets[facetName],
      exhaustive: mainSubResponse.exhaustiveFacetsCount
    };
    excludes.forEach(function(facetValue) {
      self.facets[position] = self.facets[position] || {name: facetName};
      self.facets[position].data = self.facets[position].data || {};
      self.facets[position].data[facetValue] = 0;
    });
  });

  /**
   * @type {Array}
   */
  this.hierarchicalFacets = this.hierarchicalFacets.map(generateHierarchicalTree(state));

  /**
   * @type {Array}
   */
  this.facets = compact(this.facets);
  /**
   * @type {Array}
   */
  this.disjunctiveFacets = compact(this.disjunctiveFacets);

  this._state = state;
}

/**
 * Get a facet object with its name
 * @deprecated
 * @param {string} name name of the faceted attribute
 * @return {SearchResults.Facet} the facet object
 */
SearchResults.prototype.getFacetByName = function(name) {
  function predicate(facet) {
    return facet.name === name;
  }

  return find(this.facets, predicate) ||
    find(this.disjunctiveFacets, predicate) ||
    find(this.hierarchicalFacets, predicate);
};

/**
 * Get the facet values of a specified attribute from a SearchResults object.
 * @private
 * @param {SearchResults} results the search results to search in
 * @param {string} attribute name of the faceted attribute to search for
 * @return {array|object} facet values. For the hierarchical facets it is an object.
 */
function extractNormalizedFacetValues(results, attribute) {
  function predicate(facet) {
    return facet.name === attribute;
  }

  if (results._state.isConjunctiveFacet(attribute)) {
    var facet = find(results.facets, predicate);
    if (!facet) return [];

    return Object.keys(facet.data).map(function(name) {
      return {
        name: name,
        count: facet.data[name],
        isRefined: results._state.isFacetRefined(attribute, name),
        isExcluded: results._state.isExcludeRefined(attribute, name)
      };
    });
  } else if (results._state.isDisjunctiveFacet(attribute)) {
    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);
    if (!disjunctiveFacet) return [];

    return Object.keys(disjunctiveFacet.data).map(function(name) {
      return {
        name: name,
        count: disjunctiveFacet.data[name],
        isRefined: results._state.isDisjunctiveFacetRefined(attribute, name)
      };
    });
  } else if (results._state.isHierarchicalFacet(attribute)) {
    return find(results.hierarchicalFacets, predicate);
  }
}

/**
 * Sort nodes of a hierarchical or disjunctive facet results
 * @private
 * @param {function} sortFn
 * @param {HierarchicalFacet|Array} node node upon which we want to apply the sort
 * @param {string[]} names attribute names
 * @param {number} [level=0] current index in the names array
 */
function recSort(sortFn, node, names, level) {
  level = level || 0;

  if (Array.isArray(node)) {
    return sortFn(node, names[level]);
  }

  if (!node.data || node.data.length === 0) {
    return node;
  }

  var children = node.data.map(function(childNode) {
    return recSort(sortFn, childNode, names, level + 1);
  });
  var sortedChildren = sortFn(children, names[level]);
  var newNode = defaultsPure({data: sortedChildren}, node);
  return newNode;
}

SearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];

function vanillaSortFn(order, data) {
  return data.sort(order);
}

/**
 * @typedef FacetOrdering
 * @type {Object}
 * @property {string[]} [order]
 * @property {'count' | 'alpha' | 'hidden'} [sortRemainingBy]
 */

/**
 * Sorts facet arrays via their facet ordering
 * @param {Array} facetValues the values
 * @param {FacetOrdering} facetOrdering the ordering
 * @returns {Array}
 */
function sortViaFacetOrdering(facetValues, facetOrdering) {
  var orderedFacets = [];
  var remainingFacets = [];

  var order = facetOrdering.order || [];
  /**
   * an object with the keys being the values in order, the values their index:
   * ['one', 'two'] -> { one: 0, two: 1 }
   */
  var reverseOrder = order.reduce(function(acc, name, i) {
    acc[name] = i;
    return acc;
  }, {});

  facetValues.forEach(function(item) {
    // hierarchical facets get sorted using their raw name
    var name = item.path || item.name;
    if (reverseOrder[name] !== undefined) {
      orderedFacets[reverseOrder[name]] = item;
    } else {
      remainingFacets.push(item);
    }
  });

  var sortRemainingBy = facetOrdering.sortRemainingBy;
  var ordering;
  if (sortRemainingBy === 'hidden') {
    return orderedFacets;
  } else if (sortRemainingBy === 'alpha') {
    ordering = [['path', 'name'], ['asc', 'asc']];
  } else {
    ordering = [['count'], ['desc']];
  }

  return orderedFacets.concat(
    orderBy(remainingFacets, ordering[0], ordering[1])
  );
}

/**
 * @param {SearchResults} results the search results class
 * @param {string} attribute the attribute to retrieve ordering of
 * @returns {FacetOrdering=}
 */
function getFacetOrdering(results, attribute) {
  return (
    results.renderingContent &&
    results.renderingContent.facetOrdering &&
    results.renderingContent.facetOrdering.values &&
    results.renderingContent.facetOrdering.values[attribute]
  );
}

/**
 * Get a the list of values for a given facet attribute. Those values are sorted
 * refinement first, descending count (bigger value on top), and name ascending
 * (alphabetical order). The sort formula can overridden using either string based
 * predicates or a function.
 *
 * This method will return all the values returned by the Algolia engine plus all
 * the values already refined. This means that it can happen that the
 * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)
 * might not be respected if you have facet values that are already refined.
 * @param {string} attribute attribute name
 * @param {object} opts configuration options.
 * @param {boolean} [opts.facetOrdering]
 * Force the use of facetOrdering from the result if a sortBy is present. If
 * sortBy isn't present, facetOrdering will be used automatically.
 * @param {Array.<string> | function} opts.sortBy
 * When using strings, it consists of
 * the name of the [FacetValue](#SearchResults.FacetValue) or the
 * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the
 * order (`asc` or `desc`). For example to order the value by count, the
 * argument would be `['count:asc']`.
 *
 * If only the attribute name is specified, the ordering defaults to the one
 * specified in the default value for this attribute.
 *
 * When not specified, the order is
 * ascending.  This parameter can also be a function which takes two facet
 * values and should return a number, 0 if equal, 1 if the first argument is
 * bigger or -1 otherwise.
 *
 * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`
 * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of
 * the attribute requested (hierarchical, disjunctive or conjunctive)
 * @example
 * helper.on('result', function(event){
 *   //get values ordered only by name ascending using the string predicate
 *   event.results.getFacetValues('city', {sortBy: ['name:asc']});
 *   //get values  ordered only by count ascending using a function
 *   event.results.getFacetValues('city', {
 *     // this is equivalent to ['count:asc']
 *     sortBy: function(a, b) {
 *       if (a.count === b.count) return 0;
 *       if (a.count > b.count)   return 1;
 *       if (b.count > a.count)   return -1;
 *     }
 *   });
 * });
 */
SearchResults.prototype.getFacetValues = function(attribute, opts) {
  var facetValues = extractNormalizedFacetValues(this, attribute);
  if (!facetValues) {
    return undefined;
  }

  var options = defaultsPure({}, opts, {
    sortBy: SearchResults.DEFAULT_SORT,
    // if no sortBy is given, attempt to sort based on facetOrdering
    // if it is given, we still allow to sort via facet ordering first
    facetOrdering: !(opts && opts.sortBy)
  });

  var results = this;
  var attributes;
  if (Array.isArray(facetValues)) {
    attributes = [attribute];
  } else {
    var config = results._state.getHierarchicalFacetByName(facetValues.name);
    attributes = config.attributes;
  }

  return recSort(function(data, facetName) {
    if (options.facetOrdering) {
      var facetOrdering = getFacetOrdering(results, facetName);
      if (Boolean(facetOrdering)) {
        return sortViaFacetOrdering(data, facetOrdering);
      }
    }

    if (Array.isArray(options.sortBy)) {
      var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);
      return orderBy(data, order[0], order[1]);
    } else if (typeof options.sortBy === 'function') {
      return vanillaSortFn(options.sortBy, data);
    }
    throw new Error(
      'options.sortBy is optional but if defined it must be ' +
        'either an array of string (predicates) or a sorting function'
    );
  }, facetValues, attributes);
};

/**
 * Returns the facet stats if attribute is defined and the facet contains some.
 * Otherwise returns undefined.
 * @param {string} attribute name of the faceted attribute
 * @return {object} The stats of the facet
 */
SearchResults.prototype.getFacetStats = function(attribute) {
  if (this._state.isConjunctiveFacet(attribute)) {
    return getFacetStatsIfAvailable(this.facets, attribute);
  } else if (this._state.isDisjunctiveFacet(attribute)) {
    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);
  }

  return undefined;
};

/**
 * @typedef {Object} FacetListItem
 * @property {string} name
 */

/**
 * @param {FacetListItem[]} facetList (has more items, but enough for here)
 * @param {string} facetName
 */
function getFacetStatsIfAvailable(facetList, facetName) {
  var data = find(facetList, function(facet) {
    return facet.name === facetName;
  });
  return data && data.stats;
}

/**
 * Returns all refinements for all filters + tags. It also provides
 * additional information: count and exhaustiveness for each filter.
 *
 * See the [refinement type](#Refinement) for an exhaustive view of the available
 * data.
 *
 * Note that for a numeric refinement, results are grouped per operator, this
 * means that it will return responses for operators which are empty.
 *
 * @return {Array.<Refinement>} all the refinements
 */
SearchResults.prototype.getRefinements = function() {
  var state = this._state;
  var results = this;
  var res = [];

  Object.keys(state.facetsRefinements).forEach(function(attributeName) {
    state.facetsRefinements[attributeName].forEach(function(name) {
      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));
    });
  });

  Object.keys(state.facetsExcludes).forEach(function(attributeName) {
    state.facetsExcludes[attributeName].forEach(function(name) {
      res.push(getRefinement(state, 'exclude', attributeName, name, results.facets));
    });
  });

  Object.keys(state.disjunctiveFacetsRefinements).forEach(function(attributeName) {
    state.disjunctiveFacetsRefinements[attributeName].forEach(function(name) {
      res.push(getRefinement(state, 'disjunctive', attributeName, name, results.disjunctiveFacets));
    });
  });

  Object.keys(state.hierarchicalFacetsRefinements).forEach(function(attributeName) {
    state.hierarchicalFacetsRefinements[attributeName].forEach(function(name) {
      res.push(getHierarchicalRefinement(state, attributeName, name, results.hierarchicalFacets));
    });
  });


  Object.keys(state.numericRefinements).forEach(function(attributeName) {
    var operators = state.numericRefinements[attributeName];
    Object.keys(operators).forEach(function(operator) {
      operators[operator].forEach(function(value) {
        res.push({
          type: 'numeric',
          attributeName: attributeName,
          name: value,
          numericValue: value,
          operator: operator
        });
      });
    });
  });

  state.tagRefinements.forEach(function(name) {
    res.push({type: 'tag', attributeName: '_tags', name: name});
  });

  return res;
};

/**
 * @typedef {Object} Facet
 * @property {string} name
 * @property {Object} data
 * @property {boolean} exhaustive
 */

/**
 * @param {*} state
 * @param {*} type
 * @param {string} attributeName
 * @param {*} name
 * @param {Facet[]} resultsFacets
 */
function getRefinement(state, type, attributeName, name, resultsFacets) {
  var facet = find(resultsFacets, function(f) {
    return f.name === attributeName;
  });
  var count = facet && facet.data && facet.data[name] ? facet.data[name] : 0;
  var exhaustive = (facet && facet.exhaustive) || false;

  return {
    type: type,
    attributeName: attributeName,
    name: name,
    count: count,
    exhaustive: exhaustive
  };
}

/**
 * @param {*} state
 * @param {string} attributeName
 * @param {*} name
 * @param {Facet[]} resultsFacets
 */
function getHierarchicalRefinement(state, attributeName, name, resultsFacets) {
  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);
  var separator = state._getHierarchicalFacetSeparator(facetDeclaration);
  var split = name.split(separator);
  var rootFacet = find(resultsFacets, function(facet) {
    return facet.name === attributeName;
  });

  var facet = split.reduce(function(intermediateFacet, part) {
    var newFacet =
      intermediateFacet && find(intermediateFacet.data, function(f) {
        return f.name === part;
      });
    return newFacet !== undefined ? newFacet : intermediateFacet;
  }, rootFacet);

  var count = (facet && facet.count) || 0;
  var exhaustive = (facet && facet.exhaustive) || false;
  var path = (facet && facet.path) || '';

  return {
    type: 'hierarchical',
    attributeName: attributeName,
    name: path,
    count: count,
    exhaustive: exhaustive
  };
}

module.exports = SearchResults;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/algoliasearch.helper.js":
/*!***********************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/algoliasearch.helper.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var SearchParameters = __webpack_require__(/*! ./SearchParameters */ "./node_modules/algoliasearch-helper/src/SearchParameters/index.js");
var SearchResults = __webpack_require__(/*! ./SearchResults */ "./node_modules/algoliasearch-helper/src/SearchResults/index.js");
var DerivedHelper = __webpack_require__(/*! ./DerivedHelper */ "./node_modules/algoliasearch-helper/src/DerivedHelper/index.js");
var requestBuilder = __webpack_require__(/*! ./requestBuilder */ "./node_modules/algoliasearch-helper/src/requestBuilder.js");

var events = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var inherits = __webpack_require__(/*! ./functions/inherits */ "./node_modules/algoliasearch-helper/src/functions/inherits.js");
var objectHasKeys = __webpack_require__(/*! ./functions/objectHasKeys */ "./node_modules/algoliasearch-helper/src/functions/objectHasKeys.js");
var omit = __webpack_require__(/*! ./functions/omit */ "./node_modules/algoliasearch-helper/src/functions/omit.js");
var merge = __webpack_require__(/*! ./functions/merge */ "./node_modules/algoliasearch-helper/src/functions/merge.js");

var version = __webpack_require__(/*! ./version */ "./node_modules/algoliasearch-helper/src/version.js");

/**
 * Event triggered when a parameter is set or updated
 * @event AlgoliaSearchHelper#event:change
 * @property {object} event
 * @property {SearchParameters} event.state the current parameters with the latest changes applied
 * @property {SearchResults} event.results the previous results received from Algolia. `null` before the first request
 * @example
 * helper.on('change', function(event) {
 *   console.log('The parameters have changed');
 * });
 */

/**
 * Event triggered when a main search is sent to Algolia
 * @event AlgoliaSearchHelper#event:search
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search
 * @property {SearchResults} event.results the results from the previous search. `null` if it is the first search.
 * @example
 * helper.on('search', function(event) {
 *   console.log('Search sent');
 * });
 */

/**
 * Event triggered when a search using `searchForFacetValues` is sent to Algolia
 * @event AlgoliaSearchHelper#event:searchForFacetValues
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search it is the first search.
 * @property {string} event.facet the facet searched into
 * @property {string} event.query the query used to search in the facets
 * @example
 * helper.on('searchForFacetValues', function(event) {
 *   console.log('searchForFacetValues sent');
 * });
 */

/**
 * Event triggered when a search using `searchOnce` is sent to Algolia
 * @event AlgoliaSearchHelper#event:searchOnce
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search it is the first search.
 * @example
 * helper.on('searchOnce', function(event) {
 *   console.log('searchOnce sent');
 * });
 */

/**
 * Event triggered when the results are retrieved from Algolia
 * @event AlgoliaSearchHelper#event:result
 * @property {object} event
 * @property {SearchResults} event.results the results received from Algolia
 * @property {SearchParameters} event.state the parameters used to query Algolia. Those might be different from the one in the helper instance (for example if the network is unreliable).
 * @example
 * helper.on('result', function(event) {
 *   console.log('Search results received');
 * });
 */

/**
 * Event triggered when Algolia sends back an error. For example, if an unknown parameter is
 * used, the error can be caught using this event.
 * @event AlgoliaSearchHelper#event:error
 * @property {object} event
 * @property {Error} event.error the error returned by the Algolia.
 * @example
 * helper.on('error', function(event) {
 *   console.log('Houston we got a problem.');
 * });
 */

/**
 * Event triggered when the queue of queries have been depleted (with any result or outdated queries)
 * @event AlgoliaSearchHelper#event:searchQueueEmpty
 * @example
 * helper.on('searchQueueEmpty', function() {
 *   console.log('No more search pending');
 *   // This is received before the result event if we're not expecting new results
 * });
 *
 * helper.search();
 */

/**
 * Initialize a new AlgoliaSearchHelper
 * @class
 * @classdesc The AlgoliaSearchHelper is a class that ease the management of the
 * search. It provides an event based interface for search callbacks:
 *  - change: when the internal search state is changed.
 *    This event contains a {@link SearchParameters} object and the
 *    {@link SearchResults} of the last result if any.
 *  - search: when a search is triggered using the `search()` method.
 *  - result: when the response is retrieved from Algolia and is processed.
 *    This event contains a {@link SearchResults} object and the
 *    {@link SearchParameters} corresponding to this answer.
 *  - error: when the response is an error. This event contains the error returned by the server.
 * @param  {AlgoliaSearch} client an AlgoliaSearch client
 * @param  {string} index the index name to query
 * @param  {SearchParameters | object} options an object defining the initial
 * config of the search. It doesn't have to be a {SearchParameters},
 * just an object containing the properties you need from it.
 */
function AlgoliaSearchHelper(client, index, options) {
  if (typeof client.addAlgoliaAgent === 'function') {
    client.addAlgoliaAgent('JS Helper (' + version + ')');
  }

  this.setClient(client);
  var opts = options || {};
  opts.index = index;
  this.state = SearchParameters.make(opts);
  this.lastResults = null;
  this._queryId = 0;
  this._lastQueryIdReceived = -1;
  this.derivedHelpers = [];
  this._currentNbQueries = 0;
}

inherits(AlgoliaSearchHelper, events.EventEmitter);

/**
 * Start the search with the parameters set in the state. When the
 * method is called, it triggers a `search` event. The results will
 * be available through the `result` event. If an error occurs, an
 * `error` will be fired instead.
 * @return {AlgoliaSearchHelper}
 * @fires search
 * @fires result
 * @fires error
 * @chainable
 */
AlgoliaSearchHelper.prototype.search = function() {
  this._search({onlyWithDerivedHelpers: false});
  return this;
};

AlgoliaSearchHelper.prototype.searchOnlyWithDerivedHelpers = function() {
  this._search({onlyWithDerivedHelpers: true});
  return this;
};

/**
 * Gets the search query parameters that would be sent to the Algolia Client
 * for the hits
 * @return {object} Query Parameters
 */
AlgoliaSearchHelper.prototype.getQuery = function() {
  var state = this.state;
  return requestBuilder._getHitsSearchParams(state);
};

/**
 * Start a search using a modified version of the current state. This method does
 * not trigger the helper lifecycle and does not modify the state kept internally
 * by the helper. This second aspect means that the next search call will be the
 * same as a search call before calling searchOnce.
 * @param {object} options can contain all the parameters that can be set to SearchParameters
 * plus the index
 * @param {function} [callback] optional callback executed when the response from the
 * server is back.
 * @return {promise|undefined} if a callback is passed the method returns undefined
 * otherwise it returns a promise containing an object with two keys :
 *  - content with a SearchResults
 *  - state with the state used for the query as a SearchParameters
 * @example
 * // Changing the number of records returned per page to 1
 * // This example uses the callback API
 * var state = helper.searchOnce({hitsPerPage: 1},
 *   function(error, content, state) {
 *     // if an error occurred it will be passed in error, otherwise its value is null
 *     // content contains the results formatted as a SearchResults
 *     // state is the instance of SearchParameters used for this search
 *   });
 * @example
 * // Changing the number of records returned per page to 1
 * // This example uses the promise API
 * var state1 = helper.searchOnce({hitsPerPage: 1})
 *                 .then(promiseHandler);
 *
 * function promiseHandler(res) {
 *   // res contains
 *   // {
 *   //   content : SearchResults
 *   //   state   : SearchParameters (the one used for this specific search)
 *   // }
 * }
 */
AlgoliaSearchHelper.prototype.searchOnce = function(options, cb) {
  var tempState = !options ? this.state : this.state.setQueryParameters(options);
  var queries = requestBuilder._getQueries(tempState.index, tempState);
  var self = this;

  this._currentNbQueries++;

  this.emit('searchOnce', {
    state: tempState
  });

  if (cb) {
    this.client
      .search(queries)
      .then(function(content) {
        self._currentNbQueries--;
        if (self._currentNbQueries === 0) {
          self.emit('searchQueueEmpty');
        }

        cb(null, new SearchResults(tempState, content.results), tempState);
      })
      .catch(function(err) {
        self._currentNbQueries--;
        if (self._currentNbQueries === 0) {
          self.emit('searchQueueEmpty');
        }

        cb(err, null, tempState);
      });

    return undefined;
  }

  return this.client.search(queries).then(function(content) {
    self._currentNbQueries--;
    if (self._currentNbQueries === 0) self.emit('searchQueueEmpty');
    return {
      content: new SearchResults(tempState, content.results),
      state: tempState,
      _originalResponse: content
    };
  }, function(e) {
    self._currentNbQueries--;
    if (self._currentNbQueries === 0) self.emit('searchQueueEmpty');
    throw e;
  });
};

 /**
 * Start the search for answers with the parameters set in the state.
 * This method returns a promise.
 * @param {Object} options - the options for answers API call
 * @param {string[]} options.attributesForPrediction - Attributes to use for predictions. If empty, `searchableAttributes` is used instead.
 * @param {string[]} options.queryLanguages - The languages in the query. Currently only supports ['en'].
 * @param {number} options.nbHits - Maximum number of answers to retrieve from the Answers Engine. Cannot be greater than 1000.
 *
 * @return {promise} the answer results
 */
AlgoliaSearchHelper.prototype.findAnswers = function(options) {
  var state = this.state;
  var derivedHelper = this.derivedHelpers[0];
  if (!derivedHelper) {
    return Promise.resolve([]);
  }
  var derivedState = derivedHelper.getModifiedState(state);
  var data = merge(
    {
      attributesForPrediction: options.attributesForPrediction,
      nbHits: options.nbHits
    },
    {
      params: omit(requestBuilder._getHitsSearchParams(derivedState), [
        'attributesToSnippet',
        'hitsPerPage',
        'restrictSearchableAttributes',
        'snippetEllipsisText' // FIXME remove this line once the engine is fixed.
      ])
    }
  );

  var errorMessage = 'search for answers was called, but this client does not have a function client.initIndex(index).findAnswers';
  if (typeof this.client.initIndex !== 'function') {
    throw new Error(errorMessage);
  }
  var index = this.client.initIndex(derivedState.index);
  if (typeof index.findAnswers !== 'function') {
    throw new Error(errorMessage);
  }
  return index.findAnswers(derivedState.query, options.queryLanguages, data);
};

/**
 * Structure of each result when using
 * [`searchForFacetValues()`](reference.html#AlgoliaSearchHelper#searchForFacetValues)
 * @typedef FacetSearchHit
 * @type {object}
 * @property {string} value the facet value
 * @property {string} highlighted the facet value highlighted with the query string
 * @property {number} count number of occurrence of this facet value
 * @property {boolean} isRefined true if the value is already refined
 */

/**
 * Structure of the data resolved by the
 * [`searchForFacetValues()`](reference.html#AlgoliaSearchHelper#searchForFacetValues)
 * promise.
 * @typedef FacetSearchResult
 * @type {object}
 * @property {FacetSearchHit} facetHits the results for this search for facet values
 * @property {number} processingTimeMS time taken by the query inside the engine
 */

/**
 * Search for facet values based on an query and the name of a faceted attribute. This
 * triggers a search and will return a promise. On top of using the query, it also sends
 * the parameters from the state so that the search is narrowed down to only the possible values.
 *
 * See the description of [FacetSearchResult](reference.html#FacetSearchResult)
 * @param {string} facet the name of the faceted attribute
 * @param {string} query the string query for the search
 * @param {number} [maxFacetHits] the maximum number values returned. Should be > 0 and <= 100
 * @param {object} [userState] the set of custom parameters to use on top of the current state. Setting a property to `undefined` removes
 * it in the generated query.
 * @return {promise.<FacetSearchResult>} the results of the search
 */
AlgoliaSearchHelper.prototype.searchForFacetValues = function(facet, query, maxFacetHits, userState) {
  var clientHasSFFV = typeof this.client.searchForFacetValues === 'function';
  if (
    !clientHasSFFV &&
    typeof this.client.initIndex !== 'function'
  ) {
    throw new Error(
      'search for facet values (searchable) was called, but this client does not have a function client.searchForFacetValues or client.initIndex(index).searchForFacetValues'
    );
  }
  var state = this.state.setQueryParameters(userState || {});
  var isDisjunctive = state.isDisjunctiveFacet(facet);
  var algoliaQuery = requestBuilder.getSearchForFacetQuery(facet, query, maxFacetHits, state);

  this._currentNbQueries++;
  var self = this;

  this.emit('searchForFacetValues', {
    state: state,
    facet: facet,
    query: query
  });

  var searchForFacetValuesPromise = clientHasSFFV
    ? this.client.searchForFacetValues([{indexName: state.index, params: algoliaQuery}])
    : this.client.initIndex(state.index).searchForFacetValues(algoliaQuery);

  return searchForFacetValuesPromise.then(function addIsRefined(content) {
    self._currentNbQueries--;
    if (self._currentNbQueries === 0) self.emit('searchQueueEmpty');

    content = Array.isArray(content) ? content[0] : content;

    content.facetHits.forEach(function(f) {
      f.isRefined = isDisjunctive
        ? state.isDisjunctiveFacetRefined(facet, f.value)
        : state.isFacetRefined(facet, f.value);
    });

    return content;
  }, function(e) {
    self._currentNbQueries--;
    if (self._currentNbQueries === 0) self.emit('searchQueueEmpty');
    throw e;
  });
};

/**
 * Sets the text query used for the search.
 *
 * This method resets the current page to 0.
 * @param  {string} q the user query
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.setQuery = function(q) {
  this._change({
    state: this.state.resetPage().setQuery(q),
    isPageReset: true
  });

  return this;
};

/**
 * Remove all the types of refinements except tags. A string can be provided to remove
 * only the refinements of a specific attribute. For more advanced use case, you can
 * provide a function instead. This function should follow the
 * [clearCallback definition](#SearchParameters.clearCallback).
 *
 * This method resets the current page to 0.
 * @param {string} [name] optional name of the facet / attribute on which we want to remove all refinements
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 * @example
 * // Removing all the refinements
 * helper.clearRefinements().search();
 * @example
 * // Removing all the filters on a the category attribute.
 * helper.clearRefinements('category').search();
 * @example
 * // Removing only the exclude filters on the category facet.
 * helper.clearRefinements(function(value, attribute, type) {
 *   return type === 'exclude' && attribute === 'category';
 * }).search();
 */
AlgoliaSearchHelper.prototype.clearRefinements = function(name) {
  this._change({
    state: this.state.resetPage().clearRefinements(name),
    isPageReset: true
  });

  return this;
};

/**
 * Remove all the tag filters.
 *
 * This method resets the current page to 0.
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.clearTags = function() {
  this._change({
    state: this.state.resetPage().clearTags(),
    isPageReset: true
  });

  return this;
};

/**
 * Adds a disjunctive filter to a faceted attribute with the `value` provided. If the
 * filter is already set, it doesn't change the filters.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} value the associated value (will be converted to string)
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.addDisjunctiveFacetRefinement = function(facet, value) {
  this._change({
    state: this.state.resetPage().addDisjunctiveFacetRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addDisjunctiveFacetRefinement}
 */
AlgoliaSearchHelper.prototype.addDisjunctiveRefine = function() {
  return this.addDisjunctiveFacetRefinement.apply(this, arguments);
};

/**
 * Adds a refinement on a hierarchical facet. It will throw
 * an exception if the facet is not defined or if the facet
 * is already refined.
 *
 * This method resets the current page to 0.
 * @param {string} facet the facet name
 * @param {string} path the hierarchical facet path
 * @return {AlgoliaSearchHelper}
 * @throws Error if the facet is not defined or if the facet is refined
 * @chainable
 * @fires change
 */
AlgoliaSearchHelper.prototype.addHierarchicalFacetRefinement = function(facet, value) {
  this._change({
    state: this.state.resetPage().addHierarchicalFacetRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * Adds a an numeric filter to an attribute with the `operator` and `value` provided. If the
 * filter is already set, it doesn't change the filters.
 *
 * This method resets the current page to 0.
 * @param  {string} attribute the attribute on which the numeric filter applies
 * @param  {string} operator the operator of the filter
 * @param  {number} value the value of the filter
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.addNumericRefinement = function(attribute, operator, value) {
  this._change({
    state: this.state.resetPage().addNumericRefinement(attribute, operator, value),
    isPageReset: true
  });

  return this;
};

/**
 * Adds a filter to a faceted attribute with the `value` provided. If the
 * filter is already set, it doesn't change the filters.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} value the associated value (will be converted to string)
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.addFacetRefinement = function(facet, value) {
  this._change({
    state: this.state.resetPage().addFacetRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addFacetRefinement}
 */
AlgoliaSearchHelper.prototype.addRefine = function() {
  return this.addFacetRefinement.apply(this, arguments);
};


/**
 * Adds a an exclusion filter to a faceted attribute with the `value` provided. If the
 * filter is already set, it doesn't change the filters.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} value the associated value (will be converted to string)
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.addFacetExclusion = function(facet, value) {
  this._change({
    state: this.state.resetPage().addExcludeRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addFacetExclusion}
 */
AlgoliaSearchHelper.prototype.addExclude = function() {
  return this.addFacetExclusion.apply(this, arguments);
};

/**
 * Adds a tag filter with the `tag` provided. If the
 * filter is already set, it doesn't change the filters.
 *
 * This method resets the current page to 0.
 * @param {string} tag the tag to add to the filter
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.addTag = function(tag) {
  this._change({
    state: this.state.resetPage().addTagRefinement(tag),
    isPageReset: true
  });

  return this;
};

/**
 * Removes an numeric filter to an attribute with the `operator` and `value` provided. If the
 * filter is not set, it doesn't change the filters.
 *
 * Some parameters are optional, triggering different behavior:
 *  - if the value is not provided, then all the numeric value will be removed for the
 *  specified attribute/operator couple.
 *  - if the operator is not provided either, then all the numeric filter on this attribute
 *  will be removed.
 *
 * This method resets the current page to 0.
 * @param  {string} attribute the attribute on which the numeric filter applies
 * @param  {string} [operator] the operator of the filter
 * @param  {number} [value] the value of the filter
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.removeNumericRefinement = function(attribute, operator, value) {
  this._change({
    state: this.state.resetPage().removeNumericRefinement(attribute, operator, value),
    isPageReset: true
  });

  return this;
};

/**
 * Removes a disjunctive filter to a faceted attribute with the `value` provided. If the
 * filter is not set, it doesn't change the filters.
 *
 * If the value is omitted, then this method will remove all the filters for the
 * attribute.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} [value] the associated value
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.removeDisjunctiveFacetRefinement = function(facet, value) {
  this._change({
    state: this.state.resetPage().removeDisjunctiveFacetRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeDisjunctiveFacetRefinement}
 */
AlgoliaSearchHelper.prototype.removeDisjunctiveRefine = function() {
  return this.removeDisjunctiveFacetRefinement.apply(this, arguments);
};

/**
 * Removes the refinement set on a hierarchical facet.
 * @param {string} facet the facet name
 * @return {AlgoliaSearchHelper}
 * @throws Error if the facet is not defined or if the facet is not refined
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.removeHierarchicalFacetRefinement = function(facet) {
  this._change({
    state: this.state.resetPage().removeHierarchicalFacetRefinement(facet),
    isPageReset: true
  });

  return this;
};

/**
 * Removes a filter to a faceted attribute with the `value` provided. If the
 * filter is not set, it doesn't change the filters.
 *
 * If the value is omitted, then this method will remove all the filters for the
 * attribute.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} [value] the associated value
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.removeFacetRefinement = function(facet, value) {
  this._change({
    state: this.state.resetPage().removeFacetRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeFacetRefinement}
 */
AlgoliaSearchHelper.prototype.removeRefine = function() {
  return this.removeFacetRefinement.apply(this, arguments);
};

/**
 * Removes an exclusion filter to a faceted attribute with the `value` provided. If the
 * filter is not set, it doesn't change the filters.
 *
 * If the value is omitted, then this method will remove all the filters for the
 * attribute.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} [value] the associated value
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.removeFacetExclusion = function(facet, value) {
  this._change({
    state: this.state.resetPage().removeExcludeRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeFacetExclusion}
 */
AlgoliaSearchHelper.prototype.removeExclude = function() {
  return this.removeFacetExclusion.apply(this, arguments);
};

/**
 * Removes a tag filter with the `tag` provided. If the
 * filter is not set, it doesn't change the filters.
 *
 * This method resets the current page to 0.
 * @param {string} tag tag to remove from the filter
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.removeTag = function(tag) {
  this._change({
    state: this.state.resetPage().removeTagRefinement(tag),
    isPageReset: true
  });

  return this;
};

/**
 * Adds or removes an exclusion filter to a faceted attribute with the `value` provided. If
 * the value is set then it removes it, otherwise it adds the filter.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} value the associated value
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.toggleFacetExclusion = function(facet, value) {
  this._change({
    state: this.state.resetPage().toggleExcludeFacetRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#toggleFacetExclusion}
 */
AlgoliaSearchHelper.prototype.toggleExclude = function() {
  return this.toggleFacetExclusion.apply(this, arguments);
};

/**
 * Adds or removes a filter to a faceted attribute with the `value` provided. If
 * the value is set then it removes it, otherwise it adds the filter.
 *
 * This method can be used for conjunctive, disjunctive and hierarchical filters.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} value the associated value
 * @return {AlgoliaSearchHelper}
 * @throws Error will throw an error if the facet is not declared in the settings of the helper
 * @fires change
 * @chainable
 * @deprecated since version 2.19.0, see {@link AlgoliaSearchHelper#toggleFacetRefinement}
 */
AlgoliaSearchHelper.prototype.toggleRefinement = function(facet, value) {
  return this.toggleFacetRefinement(facet, value);
};

/**
 * Adds or removes a filter to a faceted attribute with the `value` provided. If
 * the value is set then it removes it, otherwise it adds the filter.
 *
 * This method can be used for conjunctive, disjunctive and hierarchical filters.
 *
 * This method resets the current page to 0.
 * @param  {string} facet the facet to refine
 * @param  {string} value the associated value
 * @return {AlgoliaSearchHelper}
 * @throws Error will throw an error if the facet is not declared in the settings of the helper
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.toggleFacetRefinement = function(facet, value) {
  this._change({
    state: this.state.resetPage().toggleFacetRefinement(facet, value),
    isPageReset: true
  });

  return this;
};

/**
 * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#toggleFacetRefinement}
 */
AlgoliaSearchHelper.prototype.toggleRefine = function() {
  return this.toggleFacetRefinement.apply(this, arguments);
};

/**
 * Adds or removes a tag filter with the `value` provided. If
 * the value is set then it removes it, otherwise it adds the filter.
 *
 * This method resets the current page to 0.
 * @param {string} tag tag to remove or add
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.toggleTag = function(tag) {
  this._change({
    state: this.state.resetPage().toggleTagRefinement(tag),
    isPageReset: true
  });

  return this;
};

/**
 * Increments the page number by one.
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 * @example
 * helper.setPage(0).nextPage().getPage();
 * // returns 1
 */
AlgoliaSearchHelper.prototype.nextPage = function() {
  var page = this.state.page || 0;
  return this.setPage(page + 1);
};

/**
 * Decrements the page number by one.
 * @fires change
 * @return {AlgoliaSearchHelper}
 * @chainable
 * @example
 * helper.setPage(1).previousPage().getPage();
 * // returns 0
 */
AlgoliaSearchHelper.prototype.previousPage = function() {
  var page = this.state.page || 0;
  return this.setPage(page - 1);
};

/**
 * @private
 */
function setCurrentPage(page) {
  if (page < 0) throw new Error('Page requested below 0.');

  this._change({
    state: this.state.setPage(page),
    isPageReset: false
  });

  return this;
}

/**
 * Change the current page
 * @deprecated
 * @param  {number} page The page number
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.setCurrentPage = setCurrentPage;

/**
 * Updates the current page.
 * @function
 * @param  {number} page The page number
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.setPage = setCurrentPage;

/**
 * Updates the name of the index that will be targeted by the query.
 *
 * This method resets the current page to 0.
 * @param {string} name the index name
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.setIndex = function(name) {
  this._change({
    state: this.state.resetPage().setIndex(name),
    isPageReset: true
  });

  return this;
};

/**
 * Update a parameter of the search. This method reset the page
 *
 * The complete list of parameters is available on the
 * [Algolia website](https://www.algolia.com/doc/rest#query-an-index).
 * The most commonly used parameters have their own [shortcuts](#query-parameters-shortcuts)
 * or benefit from higher-level APIs (all the kind of filters and facets have their own API)
 *
 * This method resets the current page to 0.
 * @param {string} parameter name of the parameter to update
 * @param {any} value new value of the parameter
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 * @example
 * helper.setQueryParameter('hitsPerPage', 20).search();
 */
AlgoliaSearchHelper.prototype.setQueryParameter = function(parameter, value) {
  this._change({
    state: this.state.resetPage().setQueryParameter(parameter, value),
    isPageReset: true
  });

  return this;
};

/**
 * Set the whole state (warning: will erase previous state)
 * @param {SearchParameters} newState the whole new state
 * @return {AlgoliaSearchHelper}
 * @fires change
 * @chainable
 */
AlgoliaSearchHelper.prototype.setState = function(newState) {
  this._change({
    state: SearchParameters.make(newState),
    isPageReset: false
  });

  return this;
};

/**
 * Override the current state without triggering a change event.
 * Do not use this method unless you know what you are doing. (see the example
 * for a legit use case)
 * @param {SearchParameters} newState the whole new state
 * @return {AlgoliaSearchHelper}
 * @example
 *  helper.on('change', function(state){
 *    // In this function you might want to find a way to store the state in the url/history
 *    updateYourURL(state)
 *  })
 *  window.onpopstate = function(event){
 *    // This is naive though as you should check if the state is really defined etc.
 *    helper.overrideStateWithoutTriggeringChangeEvent(event.state).search()
 *  }
 * @chainable
 */
AlgoliaSearchHelper.prototype.overrideStateWithoutTriggeringChangeEvent = function(newState) {
  this.state = new SearchParameters(newState);
  return this;
};

/**
 * Check if an attribute has any numeric, conjunctive, disjunctive or hierarchical filters.
 * @param {string} attribute the name of the attribute
 * @return {boolean} true if the attribute is filtered by at least one value
 * @example
 * // hasRefinements works with numeric, conjunctive, disjunctive and hierarchical filters
 * helper.hasRefinements('price'); // false
 * helper.addNumericRefinement('price', '>', 100);
 * helper.hasRefinements('price'); // true
 *
 * helper.hasRefinements('color'); // false
 * helper.addFacetRefinement('color', 'blue');
 * helper.hasRefinements('color'); // true
 *
 * helper.hasRefinements('material'); // false
 * helper.addDisjunctiveFacetRefinement('material', 'plastic');
 * helper.hasRefinements('material'); // true
 *
 * helper.hasRefinements('categories'); // false
 * helper.toggleFacetRefinement('categories', 'kitchen > knife');
 * helper.hasRefinements('categories'); // true
 *
 */
AlgoliaSearchHelper.prototype.hasRefinements = function(attribute) {
  if (objectHasKeys(this.state.getNumericRefinements(attribute))) {
    return true;
  } else if (this.state.isConjunctiveFacet(attribute)) {
    return this.state.isFacetRefined(attribute);
  } else if (this.state.isDisjunctiveFacet(attribute)) {
    return this.state.isDisjunctiveFacetRefined(attribute);
  } else if (this.state.isHierarchicalFacet(attribute)) {
    return this.state.isHierarchicalFacetRefined(attribute);
  }

  // there's currently no way to know that the user did call `addNumericRefinement` at some point
  // thus we cannot distinguish if there once was a numeric refinement that was cleared
  // so we will return false in every other situations to be consistent
  // while what we should do here is throw because we did not find the attribute in any type
  // of refinement
  return false;
};

/**
 * Check if a value is excluded for a specific faceted attribute. If the value
 * is omitted then the function checks if there is any excluding refinements.
 *
 * @param  {string}  facet name of the attribute for used for faceting
 * @param  {string}  [value] optional value. If passed will test that this value
   * is filtering the given facet.
 * @return {boolean} true if refined
 * @example
 * helper.isExcludeRefined('color'); // false
 * helper.isExcludeRefined('color', 'blue') // false
 * helper.isExcludeRefined('color', 'red') // false
 *
 * helper.addFacetExclusion('color', 'red');
 *
 * helper.isExcludeRefined('color'); // true
 * helper.isExcludeRefined('color', 'blue') // false
 * helper.isExcludeRefined('color', 'red') // true
 */
AlgoliaSearchHelper.prototype.isExcluded = function(facet, value) {
  return this.state.isExcludeRefined(facet, value);
};

/**
 * @deprecated since 2.4.0, see {@link AlgoliaSearchHelper#hasRefinements}
 */
AlgoliaSearchHelper.prototype.isDisjunctiveRefined = function(facet, value) {
  return this.state.isDisjunctiveFacetRefined(facet, value);
};

/**
 * Check if the string is a currently filtering tag.
 * @param {string} tag tag to check
 * @return {boolean}
 */
AlgoliaSearchHelper.prototype.hasTag = function(tag) {
  return this.state.isTagRefined(tag);
};

/**
 * @deprecated since 2.4.0, see {@link AlgoliaSearchHelper#hasTag}
 */
AlgoliaSearchHelper.prototype.isTagRefined = function() {
  return this.hasTagRefinements.apply(this, arguments);
};


/**
 * Get the name of the currently used index.
 * @return {string}
 * @example
 * helper.setIndex('highestPrice_products').getIndex();
 * // returns 'highestPrice_products'
 */
AlgoliaSearchHelper.prototype.getIndex = function() {
  return this.state.index;
};

function getCurrentPage() {
  return this.state.page;
}

/**
 * Get the currently selected page
 * @deprecated
 * @return {number} the current page
 */
AlgoliaSearchHelper.prototype.getCurrentPage = getCurrentPage;
/**
 * Get the currently selected page
 * @function
 * @return {number} the current page
 */
AlgoliaSearchHelper.prototype.getPage = getCurrentPage;

/**
 * Get all the tags currently set to filters the results.
 *
 * @return {string[]} The list of tags currently set.
 */
AlgoliaSearchHelper.prototype.getTags = function() {
  return this.state.tagRefinements;
};

/**
 * Get the list of refinements for a given attribute. This method works with
 * conjunctive, disjunctive, excluding and numerical filters.
 *
 * See also SearchResults#getRefinements
 *
 * @param {string} facetName attribute name used for faceting
 * @return {Array.<FacetRefinement|NumericRefinement>} All Refinement are objects that contain a value, and
 * a type. Numeric also contains an operator.
 * @example
 * helper.addNumericRefinement('price', '>', 100);
 * helper.getRefinements('price');
 * // [
 * //   {
 * //     "value": [
 * //       100
 * //     ],
 * //     "operator": ">",
 * //     "type": "numeric"
 * //   }
 * // ]
 * @example
 * helper.addFacetRefinement('color', 'blue');
 * helper.addFacetExclusion('color', 'red');
 * helper.getRefinements('color');
 * // [
 * //   {
 * //     "value": "blue",
 * //     "type": "conjunctive"
 * //   },
 * //   {
 * //     "value": "red",
 * //     "type": "exclude"
 * //   }
 * // ]
 * @example
 * helper.addDisjunctiveFacetRefinement('material', 'plastic');
 * // [
 * //   {
 * //     "value": "plastic",
 * //     "type": "disjunctive"
 * //   }
 * // ]
 */
AlgoliaSearchHelper.prototype.getRefinements = function(facetName) {
  var refinements = [];

  if (this.state.isConjunctiveFacet(facetName)) {
    var conjRefinements = this.state.getConjunctiveRefinements(facetName);

    conjRefinements.forEach(function(r) {
      refinements.push({
        value: r,
        type: 'conjunctive'
      });
    });

    var excludeRefinements = this.state.getExcludeRefinements(facetName);

    excludeRefinements.forEach(function(r) {
      refinements.push({
        value: r,
        type: 'exclude'
      });
    });
  } else if (this.state.isDisjunctiveFacet(facetName)) {
    var disjRefinements = this.state.getDisjunctiveRefinements(facetName);

    disjRefinements.forEach(function(r) {
      refinements.push({
        value: r,
        type: 'disjunctive'
      });
    });
  }

  var numericRefinements = this.state.getNumericRefinements(facetName);

  Object.keys(numericRefinements).forEach(function(operator) {
    var value = numericRefinements[operator];

    refinements.push({
      value: value,
      operator: operator,
      type: 'numeric'
    });
  });

  return refinements;
};

/**
 * Return the current refinement for the (attribute, operator)
 * @param {string} attribute attribute in the record
 * @param {string} operator operator applied on the refined values
 * @return {Array.<number|number[]>} refined values
 */
AlgoliaSearchHelper.prototype.getNumericRefinement = function(attribute, operator) {
  return this.state.getNumericRefinement(attribute, operator);
};

/**
 * Get the current breadcrumb for a hierarchical facet, as an array
 * @param  {string} facetName Hierarchical facet name
 * @return {array.<string>} the path as an array of string
 */
AlgoliaSearchHelper.prototype.getHierarchicalFacetBreadcrumb = function(facetName) {
  return this.state.getHierarchicalFacetBreadcrumb(facetName);
};

// /////////// PRIVATE

/**
 * Perform the underlying queries
 * @private
 * @return {undefined}
 * @fires search
 * @fires result
 * @fires error
 */
AlgoliaSearchHelper.prototype._search = function(options) {
  var state = this.state;
  var states = [];
  var mainQueries = [];

  if (!options.onlyWithDerivedHelpers) {
    mainQueries = requestBuilder._getQueries(state.index, state);

    states.push({
      state: state,
      queriesCount: mainQueries.length,
      helper: this
    });

    this.emit('search', {
      state: state,
      results: this.lastResults
    });
  }

  var derivedQueries = this.derivedHelpers.map(function(derivedHelper) {
    var derivedState = derivedHelper.getModifiedState(state);
    var derivedStateQueries = requestBuilder._getQueries(derivedState.index, derivedState);

    states.push({
      state: derivedState,
      queriesCount: derivedStateQueries.length,
      helper: derivedHelper
    });

    derivedHelper.emit('search', {
      state: derivedState,
      results: derivedHelper.lastResults
    });

    return derivedStateQueries;
  });

  var queries = Array.prototype.concat.apply(mainQueries, derivedQueries);
  var queryId = this._queryId++;

  this._currentNbQueries++;

  try {
    this.client.search(queries)
      .then(this._dispatchAlgoliaResponse.bind(this, states, queryId))
      .catch(this._dispatchAlgoliaError.bind(this, queryId));
  } catch (error) {
    // If we reach this part, we're in an internal error state
    this.emit('error', {
      error: error
    });
  }
};

/**
 * Transform the responses as sent by the server and transform them into a user
 * usable object that merge the results of all the batch requests. It will dispatch
 * over the different helper + derived helpers (when there are some).
 * @private
 * @param {array.<{SearchParameters, AlgoliaQueries, AlgoliaSearchHelper}>}
 *  state state used for to generate the request
 * @param {number} queryId id of the current request
 * @param {object} content content of the response
 * @return {undefined}
 */
AlgoliaSearchHelper.prototype._dispatchAlgoliaResponse = function(states, queryId, content) {
  // FIXME remove the number of outdated queries discarded instead of just one

  if (queryId < this._lastQueryIdReceived) {
    // Outdated answer
    return;
  }

  this._currentNbQueries -= (queryId - this._lastQueryIdReceived);
  this._lastQueryIdReceived = queryId;

  if (this._currentNbQueries === 0) this.emit('searchQueueEmpty');

  var results = content.results.slice();

  states.forEach(function(s) {
    var state = s.state;
    var queriesCount = s.queriesCount;
    var helper = s.helper;
    var specificResults = results.splice(0, queriesCount);

    var formattedResponse = helper.lastResults = new SearchResults(state, specificResults);

    helper.emit('result', {
      results: formattedResponse,
      state: state
    });
  });
};

AlgoliaSearchHelper.prototype._dispatchAlgoliaError = function(queryId, error) {
  if (queryId < this._lastQueryIdReceived) {
    // Outdated answer
    return;
  }

  this._currentNbQueries -= queryId - this._lastQueryIdReceived;
  this._lastQueryIdReceived = queryId;

  this.emit('error', {
    error: error
  });

  if (this._currentNbQueries === 0) this.emit('searchQueueEmpty');
};

AlgoliaSearchHelper.prototype.containsRefinement = function(query, facetFilters, numericFilters, tagFilters) {
  return query ||
    facetFilters.length !== 0 ||
    numericFilters.length !== 0 ||
    tagFilters.length !== 0;
};

/**
 * Test if there are some disjunctive refinements on the facet
 * @private
 * @param {string} facet the attribute to test
 * @return {boolean}
 */
AlgoliaSearchHelper.prototype._hasDisjunctiveRefinements = function(facet) {
  return this.state.disjunctiveRefinements[facet] &&
    this.state.disjunctiveRefinements[facet].length > 0;
};

AlgoliaSearchHelper.prototype._change = function(event) {
  var state = event.state;
  var isPageReset = event.isPageReset;

  if (state !== this.state) {
    this.state = state;

    this.emit('change', {
      state: this.state,
      results: this.lastResults,
      isPageReset: isPageReset
    });
  }
};

/**
 * Clears the cache of the underlying Algolia client.
 * @return {AlgoliaSearchHelper}
 */
AlgoliaSearchHelper.prototype.clearCache = function() {
  this.client.clearCache && this.client.clearCache();
  return this;
};

/**
 * Updates the internal client instance. If the reference of the clients
 * are equal then no update is actually done.
 * @param  {AlgoliaSearch} newClient an AlgoliaSearch client
 * @return {AlgoliaSearchHelper}
 */
AlgoliaSearchHelper.prototype.setClient = function(newClient) {
  if (this.client === newClient) return this;

  if (typeof newClient.addAlgoliaAgent === 'function') {
    newClient.addAlgoliaAgent('JS Helper (' + version + ')');
  }
  this.client = newClient;

  return this;
};

/**
 * Gets the instance of the currently used client.
 * @return {AlgoliaSearch}
 */
AlgoliaSearchHelper.prototype.getClient = function() {
  return this.client;
};

/**
 * Creates an derived instance of the Helper. A derived helper
 * is a way to request other indices synchronised with the lifecycle
 * of the main Helper. This mechanism uses the multiqueries feature
 * of Algolia to aggregate all the requests in a single network call.
 *
 * This method takes a function that is used to create a new SearchParameter
 * that will be used to create requests to Algolia. Those new requests
 * are created just before the `search` event. The signature of the function
 * is `SearchParameters -> SearchParameters`.
 *
 * This method returns a new DerivedHelper which is an EventEmitter
 * that fires the same `search`, `result` and `error` events. Those
 * events, however, will receive data specific to this DerivedHelper
 * and the SearchParameters that is returned by the call of the
 * parameter function.
 * @param {function} fn SearchParameters -> SearchParameters
 * @return {DerivedHelper}
 */
AlgoliaSearchHelper.prototype.derive = function(fn) {
  var derivedHelper = new DerivedHelper(this, fn);
  this.derivedHelpers.push(derivedHelper);
  return derivedHelper;
};

/**
 * This method detaches a derived Helper from the main one. Prefer using the one from the
 * derived helper itself, to remove the event listeners too.
 * @private
 * @return {undefined}
 * @throws Error
 */
AlgoliaSearchHelper.prototype.detachDerivedHelper = function(derivedHelper) {
  var pos = this.derivedHelpers.indexOf(derivedHelper);
  if (pos === -1) throw new Error('Derived helper already detached');
  this.derivedHelpers.splice(pos, 1);
};

/**
 * This method returns true if there is currently at least one on-going search.
 * @return {boolean} true if there is a search pending
 */
AlgoliaSearchHelper.prototype.hasPendingRequests = function() {
  return this._currentNbQueries > 0;
};

/**
 * @typedef AlgoliaSearchHelper.NumericRefinement
 * @type {object}
 * @property {number[]} value the numbers that are used for filtering this attribute with
 * the operator specified.
 * @property {string} operator the faceting data: value, number of entries
 * @property {string} type will be 'numeric'
 */

/**
 * @typedef AlgoliaSearchHelper.FacetRefinement
 * @type {object}
 * @property {string} value the string use to filter the attribute
 * @property {string} type the type of filter: 'conjunctive', 'disjunctive', 'exclude'
 */

module.exports = AlgoliaSearchHelper;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/compact.js":
/*!********************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/compact.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function compact(array) {
  if (!Array.isArray(array)) {
    return [];
  }

  return array.filter(Boolean);
};


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/defaultsPure.js":
/*!*************************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/defaultsPure.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


// NOTE: this behaves like lodash/defaults, but doesn't mutate the target
// it also preserve keys order
module.exports = function defaultsPure() {
  var sources = Array.prototype.slice.call(arguments);

  return sources.reduceRight(function(acc, source) {
    Object.keys(Object(source)).forEach(function(key) {
      if (source[key] === undefined) {
        return;
      }
      if (acc[key] !== undefined) {
        // remove if already added, so that we can add it in correct order
        delete acc[key];
      }
      acc[key] = source[key];
    });
    return acc;
  }, {});
};


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/find.js":
/*!*****************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/find.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";


// @MAJOR can be replaced by native Array#find when we change support
module.exports = function find(array, comparator) {
  if (!Array.isArray(array)) {
    return undefined;
  }

  for (var i = 0; i < array.length; i++) {
    if (comparator(array[i])) {
      return array[i];
    }
  }
};


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/findIndex.js":
/*!**********************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/findIndex.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


// @MAJOR can be replaced by native Array#findIndex when we change support
module.exports = function find(array, comparator) {
  if (!Array.isArray(array)) {
    return -1;
  }

  for (var i = 0; i < array.length; i++) {
    if (comparator(array[i])) {
      return i;
    }
  }
  return -1;
};


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/formatSort.js":
/*!***********************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/formatSort.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var find = __webpack_require__(/*! ./find */ "./node_modules/algoliasearch-helper/src/functions/find.js");

/**
 * Transform sort format from user friendly notation to lodash format
 * @param {string[]} sortBy array of predicate of the form "attribute:order"
 * @param {string[]} [defaults] array of predicate of the form "attribute:order"
 * @return {array.<string[]>} array containing 2 elements : attributes, orders
 */
module.exports = function formatSort(sortBy, defaults) {
  var defaultInstructions = (defaults || []).map(function(sort) {
    return sort.split(':');
  });

  return sortBy.reduce(
    function preparePredicate(out, sort) {
      var sortInstruction = sort.split(':');

      var matchingDefault = find(defaultInstructions, function(
        defaultInstruction
      ) {
        return defaultInstruction[0] === sortInstruction[0];
      });

      if (sortInstruction.length > 1 || !matchingDefault) {
        out[0].push(sortInstruction[0]);
        out[1].push(sortInstruction[1]);
        return out;
      }

      out[0].push(matchingDefault[0]);
      out[1].push(matchingDefault[1]);
      return out;
    },
    [[], []]
  );
};


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/inherits.js":
/*!*********************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/inherits.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


function inherits(ctor, superCtor) {
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

module.exports = inherits;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/intersection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/intersection.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


function intersection(arr1, arr2) {
  return arr1.filter(function(value, index) {
    return (
      arr2.indexOf(value) > -1 &&
      arr1.indexOf(value) === index /* skips duplicates */
    );
  });
}

module.exports = intersection;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/merge.js":
/*!******************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/merge.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";


function clone(value) {
  if (typeof value === 'object' && value !== null) {
    return _merge(Array.isArray(value) ? [] : {}, value);
  }
  return value;
}

function isObjectOrArrayOrFunction(value) {
  return (
    typeof value === 'function' ||
    Array.isArray(value) ||
    Object.prototype.toString.call(value) === '[object Object]'
  );
}

function _merge(target, source) {
  if (target === source) {
    return target;
  }

  for (var key in source) {
    if (!Object.prototype.hasOwnProperty.call(source, key)) {
      continue;
    }

    var sourceVal = source[key];
    var targetVal = target[key];

    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {
      continue;
    }

    if (isObjectOrArrayOrFunction(targetVal) && isObjectOrArrayOrFunction(sourceVal)) {
      target[key] = _merge(targetVal, sourceVal);
    } else {
      target[key] = clone(sourceVal);
    }
  }
  return target;
}

/**
 * This method is like Object.assign, but recursively merges own and inherited
 * enumerable keyed properties of source objects into the destination object.
 *
 * NOTE: this behaves like lodash/merge, but:
 * - does mutate functions if they are a source
 * - treats non-plain objects as plain
 * - does not work for circular objects
 * - treats sparse arrays as sparse
 * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays
 *
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 */

function merge(target) {
  if (!isObjectOrArrayOrFunction(target)) {
    target = {};
  }

  for (var i = 1, l = arguments.length; i < l; i++) {
    var source = arguments[i];

    if (isObjectOrArrayOrFunction(source)) {
      _merge(target, source);
    }
  }
  return target;
}

module.exports = merge;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/objectHasKeys.js":
/*!**************************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/objectHasKeys.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";


function objectHasKeys(obj) {
  return obj && Object.keys(obj).length > 0;
}

module.exports = objectHasKeys;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/omit.js":
/*!*****************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/omit.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";


// https://github.com/babel/babel/blob/3aaafae053fa75febb3aa45d45b6f00646e30ba4/packages/babel-helpers/src/helpers.js#L604-L620
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source === null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key;
  var i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

module.exports = _objectWithoutPropertiesLoose;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/orderBy.js":
/*!********************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/orderBy.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined;
    var valIsNull = value === null;

    var othIsDefined = other !== undefined;
    var othIsNull = other === null;

    if (
      (!othIsNull && value > other) ||
      (valIsNull && othIsDefined) ||
      !valIsDefined
    ) {
      return 1;
    }
    if (
      (!valIsNull && value < other) ||
      (othIsNull && valIsDefined) ||
      !othIsDefined
    ) {
      return -1;
    }
  }
  return 0;
}

/**
 * @param {Array<object>} collection object with keys in attributes
 * @param {Array<string>} iteratees attributes
 * @param {Array<string>} orders asc | desc
 */
function orderBy(collection, iteratees, orders) {
  if (!Array.isArray(collection)) {
    return [];
  }

  if (!Array.isArray(orders)) {
    orders = [];
  }

  var result = collection.map(function(value, index) {
    return {
      criteria: iteratees.map(function(iteratee) {
        return value[iteratee];
      }),
      index: index,
      value: value
    };
  });

  result.sort(function comparer(object, other) {
    var index = -1;

    while (++index < object.criteria.length) {
      var res = compareAscending(object.criteria[index], other.criteria[index]);
      if (res) {
        if (index >= orders.length) {
          return res;
        }
        if (orders[index] === 'desc') {
          return -res;
        }
        return res;
      }
    }

    // This ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  });

  return result.map(function(res) {
    return res.value;
  });
}

module.exports = orderBy;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/functions/valToNumber.js":
/*!************************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/functions/valToNumber.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";


function valToNumber(v) {
  if (typeof v === 'number') {
    return v;
  } else if (typeof v === 'string') {
    return parseFloat(v);
  } else if (Array.isArray(v)) {
    return v.map(valToNumber);
  }

  throw new Error('The value should be a number, a parsable string or an array of those.');
}

module.exports = valToNumber;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/requestBuilder.js":
/*!*****************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/requestBuilder.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var merge = __webpack_require__(/*! ./functions/merge */ "./node_modules/algoliasearch-helper/src/functions/merge.js");

var requestBuilder = {
  /**
   * Get all the queries to send to the client, those queries can used directly
   * with the Algolia client.
   * @private
   * @return {object[]} The queries
   */
  _getQueries: function getQueries(index, state) {
    var queries = [];

    // One query for the hits
    queries.push({
      indexName: index,
      params: requestBuilder._getHitsSearchParams(state)
    });

    // One for each disjunctive facets
    state.getRefinedDisjunctiveFacets().forEach(function(refinedFacet) {
      queries.push({
        indexName: index,
        params: requestBuilder._getDisjunctiveFacetSearchParams(state, refinedFacet)
      });
    });

    // maybe more to get the root level of hierarchical facets when activated
    state.getRefinedHierarchicalFacets().forEach(function(refinedFacet) {
      var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);

      var currentRefinement = state.getHierarchicalRefinement(refinedFacet);
      // if we are deeper than level 0 (starting from `beer > IPA`)
      // we want to get the root values
      var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);
      if (currentRefinement.length > 0 && currentRefinement[0].split(separator).length > 1) {
        queries.push({
          indexName: index,
          params: requestBuilder._getDisjunctiveFacetSearchParams(state, refinedFacet, true)
        });
      }
    });

    return queries;
  },

  /**
   * Build search parameters used to fetch hits
   * @private
   * @return {object.<string, any>}
   */
  _getHitsSearchParams: function(state) {
    var facets = state.facets
      .concat(state.disjunctiveFacets)
      .concat(requestBuilder._getHitsHierarchicalFacetsAttributes(state));


    var facetFilters = requestBuilder._getFacetFilters(state);
    var numericFilters = requestBuilder._getNumericFilters(state);
    var tagFilters = requestBuilder._getTagFilters(state);
    var additionalParams = {
      facets: facets,
      tagFilters: tagFilters
    };

    if (facetFilters.length > 0) {
      additionalParams.facetFilters = facetFilters;
    }

    if (numericFilters.length > 0) {
      additionalParams.numericFilters = numericFilters;
    }

    return merge({}, state.getQueryParams(), additionalParams);
  },

  /**
   * Build search parameters used to fetch a disjunctive facet
   * @private
   * @param  {string} facet the associated facet name
   * @param  {boolean} hierarchicalRootLevel ?? FIXME
   * @return {object}
   */
  _getDisjunctiveFacetSearchParams: function(state, facet, hierarchicalRootLevel) {
    var facetFilters = requestBuilder._getFacetFilters(state, facet, hierarchicalRootLevel);
    var numericFilters = requestBuilder._getNumericFilters(state, facet);
    var tagFilters = requestBuilder._getTagFilters(state);
    var additionalParams = {
      hitsPerPage: 1,
      page: 0,
      attributesToRetrieve: [],
      attributesToHighlight: [],
      attributesToSnippet: [],
      tagFilters: tagFilters,
      analytics: false,
      clickAnalytics: false
    };

    var hierarchicalFacet = state.getHierarchicalFacetByName(facet);

    if (hierarchicalFacet) {
      additionalParams.facets = requestBuilder._getDisjunctiveHierarchicalFacetAttribute(
        state,
        hierarchicalFacet,
        hierarchicalRootLevel
      );
    } else {
      additionalParams.facets = facet;
    }

    if (numericFilters.length > 0) {
      additionalParams.numericFilters = numericFilters;
    }

    if (facetFilters.length > 0) {
      additionalParams.facetFilters = facetFilters;
    }

    return merge({}, state.getQueryParams(), additionalParams);
  },

  /**
   * Return the numeric filters in an algolia request fashion
   * @private
   * @param {string} [facetName] the name of the attribute for which the filters should be excluded
   * @return {string[]} the numeric filters in the algolia format
   */
  _getNumericFilters: function(state, facetName) {
    if (state.numericFilters) {
      return state.numericFilters;
    }

    var numericFilters = [];

    Object.keys(state.numericRefinements).forEach(function(attribute) {
      var operators = state.numericRefinements[attribute] || {};
      Object.keys(operators).forEach(function(operator) {
        var values = operators[operator] || [];
        if (facetName !== attribute) {
          values.forEach(function(value) {
            if (Array.isArray(value)) {
              var vs = value.map(function(v) {
                return attribute + operator + v;
              });
              numericFilters.push(vs);
            } else {
              numericFilters.push(attribute + operator + value);
            }
          });
        }
      });
    });

    return numericFilters;
  },

  /**
   * Return the tags filters depending
   * @private
   * @return {string}
   */
  _getTagFilters: function(state) {
    if (state.tagFilters) {
      return state.tagFilters;
    }

    return state.tagRefinements.join(',');
  },


  /**
   * Build facetFilters parameter based on current refinements. The array returned
   * contains strings representing the facet filters in the algolia format.
   * @private
   * @param  {string} [facet] if set, the current disjunctive facet
   * @return {array.<string>}
   */
  _getFacetFilters: function(state, facet, hierarchicalRootLevel) {
    var facetFilters = [];

    var facetsRefinements = state.facetsRefinements || {};
    Object.keys(facetsRefinements).forEach(function(facetName) {
      var facetValues = facetsRefinements[facetName] || [];
      facetValues.forEach(function(facetValue) {
        facetFilters.push(facetName + ':' + facetValue);
      });
    });

    var facetsExcludes = state.facetsExcludes || {};
    Object.keys(facetsExcludes).forEach(function(facetName) {
      var facetValues = facetsExcludes[facetName] || [];
      facetValues.forEach(function(facetValue) {
        facetFilters.push(facetName + ':-' + facetValue);
      });
    });

    var disjunctiveFacetsRefinements = state.disjunctiveFacetsRefinements || {};
    Object.keys(disjunctiveFacetsRefinements).forEach(function(facetName) {
      var facetValues = disjunctiveFacetsRefinements[facetName] || [];
      if (facetName === facet || !facetValues || facetValues.length === 0) {
        return;
      }
      var orFilters = [];

      facetValues.forEach(function(facetValue) {
        orFilters.push(facetName + ':' + facetValue);
      });

      facetFilters.push(orFilters);
    });

    var hierarchicalFacetsRefinements = state.hierarchicalFacetsRefinements || {};
    Object.keys(hierarchicalFacetsRefinements).forEach(function(facetName) {
      var facetValues = hierarchicalFacetsRefinements[facetName] || [];
      var facetValue = facetValues[0];

      if (facetValue === undefined) {
        return;
      }

      var hierarchicalFacet = state.getHierarchicalFacetByName(facetName);
      var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);
      var rootPath = state._getHierarchicalRootPath(hierarchicalFacet);
      var attributeToRefine;
      var attributesIndex;

      // we ask for parent facet values only when the `facet` is the current hierarchical facet
      if (facet === facetName) {
        // if we are at the root level already, no need to ask for facet values, we get them from
        // the hits query
        if (facetValue.indexOf(separator) === -1 || (!rootPath && hierarchicalRootLevel === true) ||
          (rootPath && rootPath.split(separator).length === facetValue.split(separator).length)) {
          return;
        }

        if (!rootPath) {
          attributesIndex = facetValue.split(separator).length - 2;
          facetValue = facetValue.slice(0, facetValue.lastIndexOf(separator));
        } else {
          attributesIndex = rootPath.split(separator).length - 1;
          facetValue = rootPath;
        }

        attributeToRefine = hierarchicalFacet.attributes[attributesIndex];
      } else {
        attributesIndex = facetValue.split(separator).length - 1;

        attributeToRefine = hierarchicalFacet.attributes[attributesIndex];
      }

      if (attributeToRefine) {
        facetFilters.push([attributeToRefine + ':' + facetValue]);
      }
    });

    return facetFilters;
  },

  _getHitsHierarchicalFacetsAttributes: function(state) {
    var out = [];

    return state.hierarchicalFacets.reduce(
      // ask for as much levels as there's hierarchical refinements
      function getHitsAttributesForHierarchicalFacet(allAttributes, hierarchicalFacet) {
        var hierarchicalRefinement = state.getHierarchicalRefinement(hierarchicalFacet.name)[0];

        // if no refinement, ask for root level
        if (!hierarchicalRefinement) {
          allAttributes.push(hierarchicalFacet.attributes[0]);
          return allAttributes;
        }

        var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);
        var level = hierarchicalRefinement.split(separator).length;
        var newAttributes = hierarchicalFacet.attributes.slice(0, level + 1);

        return allAttributes.concat(newAttributes);
      }, out);
  },

  _getDisjunctiveHierarchicalFacetAttribute: function(state, hierarchicalFacet, rootLevel) {
    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);
    if (rootLevel === true) {
      var rootPath = state._getHierarchicalRootPath(hierarchicalFacet);
      var attributeIndex = 0;

      if (rootPath) {
        attributeIndex = rootPath.split(separator).length;
      }
      return [hierarchicalFacet.attributes[attributeIndex]];
    }

    var hierarchicalRefinement = state.getHierarchicalRefinement(hierarchicalFacet.name)[0] || '';
    // if refinement is 'beers > IPA > Flying dog',
    // then we want `facets: ['beers > IPA']` as disjunctive facet (parent level values)

    var parentLevel = hierarchicalRefinement.split(separator).length - 1;
    return hierarchicalFacet.attributes.slice(0, parentLevel + 1);
  },

  getSearchForFacetQuery: function(facetName, query, maxFacetHits, state) {
    var stateForSearchForFacetValues = state.isDisjunctiveFacet(facetName) ?
      state.clearRefinements(facetName) :
      state;
    var searchForFacetSearchParameters = {
      facetQuery: query,
      facetName: facetName
    };
    if (typeof maxFacetHits === 'number') {
      searchForFacetSearchParameters.maxFacetHits = maxFacetHits;
    }
    return merge(
      {},
      requestBuilder._getHitsSearchParams(stateForSearchForFacetValues),
      searchForFacetSearchParameters
    );
  }
};

module.exports = requestBuilder;


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/utils/isValidUserToken.js":
/*!*************************************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/utils/isValidUserToken.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isValidUserToken(userToken) {
  if (userToken === null) {
    return false;
  }
  return /^[a-zA-Z0-9_-]{1,64}$/.test(userToken);
};


/***/ }),

/***/ "./node_modules/algoliasearch-helper/src/version.js":
/*!**********************************************************!*\
  !*** ./node_modules/algoliasearch-helper/src/version.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


module.exports = '3.5.5';


/***/ }),

/***/ "./node_modules/algoliasearch/dist/algoliasearch-lite.umd.js":
/*!*******************************************************************!*\
  !*** ./node_modules/algoliasearch/dist/algoliasearch-lite.umd.js ***!
  \*******************************************************************/
/***/ (function(module) {

/*! algoliasearch-lite.umd.js | 4.10.3 | © Algolia, inc. | https://github.com/algolia/algoliasearch-client-javascript */
!function(e,t){ true?module.exports=t():0}(this,(function(){"use strict";function e(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function t(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function r(r){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?t(Object(o),!0).forEach((function(t){e(r,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(o)):t(Object(o)).forEach((function(e){Object.defineProperty(r,e,Object.getOwnPropertyDescriptor(o,e))}))}return r}function n(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}function o(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var r=[],n=!0,o=!1,a=void 0;try{for(var u,i=e[Symbol.iterator]();!(n=(u=i.next()).done)&&(r.push(u.value),!t||r.length!==t);n=!0);}catch(e){o=!0,a=e}finally{try{n||null==i.return||i.return()}finally{if(o)throw a}}return r}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function a(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function u(e){var t,r="algoliasearch-client-js-".concat(e.key),n=function(){return void 0===t&&(t=e.localStorage||window.localStorage),t},a=function(){return JSON.parse(n().getItem(r)||"{}")};return{get:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{miss:function(){return Promise.resolve()}};return Promise.resolve().then((function(){var r=JSON.stringify(e),n=a()[r];return Promise.all([n||t(),void 0!==n])})).then((function(e){var t=o(e,2),n=t[0],a=t[1];return Promise.all([n,a||r.miss(n)])})).then((function(e){return o(e,1)[0]}))},set:function(e,t){return Promise.resolve().then((function(){var o=a();return o[JSON.stringify(e)]=t,n().setItem(r,JSON.stringify(o)),t}))},delete:function(e){return Promise.resolve().then((function(){var t=a();delete t[JSON.stringify(e)],n().setItem(r,JSON.stringify(t))}))},clear:function(){return Promise.resolve().then((function(){n().removeItem(r)}))}}}function i(e){var t=a(e.caches),r=t.shift();return void 0===r?{get:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{miss:function(){return Promise.resolve()}},n=t();return n.then((function(e){return Promise.all([e,r.miss(e)])})).then((function(e){return o(e,1)[0]}))},set:function(e,t){return Promise.resolve(t)},delete:function(e){return Promise.resolve()},clear:function(){return Promise.resolve()}}:{get:function(e,n){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{miss:function(){return Promise.resolve()}};return r.get(e,n,o).catch((function(){return i({caches:t}).get(e,n,o)}))},set:function(e,n){return r.set(e,n).catch((function(){return i({caches:t}).set(e,n)}))},delete:function(e){return r.delete(e).catch((function(){return i({caches:t}).delete(e)}))},clear:function(){return r.clear().catch((function(){return i({caches:t}).clear()}))}}}function s(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{serializable:!0},t={};return{get:function(r,n){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{miss:function(){return Promise.resolve()}},a=JSON.stringify(r);if(a in t)return Promise.resolve(e.serializable?JSON.parse(t[a]):t[a]);var u=n(),i=o&&o.miss||function(){return Promise.resolve()};return u.then((function(e){return i(e)})).then((function(){return u}))},set:function(r,n){return t[JSON.stringify(r)]=e.serializable?JSON.stringify(n):n,Promise.resolve(n)},delete:function(e){return delete t[JSON.stringify(e)],Promise.resolve()},clear:function(){return t={},Promise.resolve()}}}function c(e){for(var t=e.length-1;t>0;t--){var r=Math.floor(Math.random()*(t+1)),n=e[t];e[t]=e[r],e[r]=n}return e}function l(e,t){return t?(Object.keys(t).forEach((function(r){e[r]=t[r](e)})),e):e}function f(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];var o=0;return e.replace(/%s/g,(function(){return encodeURIComponent(r[o++])}))}var h={WithinQueryParameters:0,WithinHeaders:1};function d(e,t){var r=e||{},n=r.data||{};return Object.keys(r).forEach((function(e){-1===["timeout","headers","queryParameters","data","cacheable"].indexOf(e)&&(n[e]=r[e])})),{data:Object.entries(n).length>0?n:void 0,timeout:r.timeout||t,headers:r.headers||{},queryParameters:r.queryParameters||{},cacheable:r.cacheable}}var m={Read:1,Write:2,Any:3},p=1,v=2,y=3;function g(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:p;return r(r({},e),{},{status:t,lastUpdate:Date.now()})}function b(e){return"string"==typeof e?{protocol:"https",url:e,accept:m.Any}:{protocol:e.protocol||"https",url:e.url,accept:e.accept||m.Any}}var O="GET",P="POST";function q(e,t){return Promise.all(t.map((function(t){return e.get(t,(function(){return Promise.resolve(g(t))}))}))).then((function(e){var r=e.filter((function(e){return function(e){return e.status===p||Date.now()-e.lastUpdate>12e4}(e)})),n=e.filter((function(e){return function(e){return e.status===y&&Date.now()-e.lastUpdate<=12e4}(e)})),o=[].concat(a(r),a(n));return{getTimeout:function(e,t){return(0===n.length&&0===e?1:n.length+3+e)*t},statelessHosts:o.length>0?o.map((function(e){return b(e)})):t}}))}function j(e,t,n,o){var u=[],i=function(e,t){if(e.method===O||void 0===e.data&&void 0===t.data)return;var n=Array.isArray(e.data)?e.data:r(r({},e.data),t.data);return JSON.stringify(n)}(n,o),s=function(e,t){var n=r(r({},e.headers),t.headers),o={};return Object.keys(n).forEach((function(e){var t=n[e];o[e.toLowerCase()]=t})),o}(e,o),c=n.method,l=n.method!==O?{}:r(r({},n.data),o.data),f=r(r(r({"x-algolia-agent":e.userAgent.value},e.queryParameters),l),o.queryParameters),h=0,d=function t(r,a){var l=r.pop();if(void 0===l)throw{name:"RetryError",message:"Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.",transporterStackTrace:A(u)};var d={data:i,headers:s,method:c,url:S(l,n.path,f),connectTimeout:a(h,e.timeouts.connect),responseTimeout:a(h,o.timeout)},m=function(e){var t={request:d,response:e,host:l,triesLeft:r.length};return u.push(t),t},p={onSuccess:function(e){return function(e){try{return JSON.parse(e.content)}catch(t){throw function(e,t){return{name:"DeserializationError",message:e,response:t}}(t.message,e)}}(e)},onRetry:function(n){var o=m(n);return n.isTimedOut&&h++,Promise.all([e.logger.info("Retryable failure",x(o)),e.hostsCache.set(l,g(l,n.isTimedOut?y:v))]).then((function(){return t(r,a)}))},onFail:function(e){throw m(e),function(e,t){var r=e.content,n=e.status,o=r;try{o=JSON.parse(r).message}catch(e){}return function(e,t,r){return{name:"ApiError",message:e,status:t,transporterStackTrace:r}}(o,n,t)}(e,A(u))}};return e.requester.send(d).then((function(e){return function(e,t){return function(e){var t=e.status;return e.isTimedOut||function(e){var t=e.isTimedOut,r=e.status;return!t&&0==~~r}(e)||2!=~~(t/100)&&4!=~~(t/100)}(e)?t.onRetry(e):2==~~(e.status/100)?t.onSuccess(e):t.onFail(e)}(e,p)}))};return q(e.hostsCache,t).then((function(e){return d(a(e.statelessHosts).reverse(),e.getTimeout)}))}function w(e){var t={value:"Algolia for JavaScript (".concat(e,")"),add:function(e){var r="; ".concat(e.segment).concat(void 0!==e.version?" (".concat(e.version,")"):"");return-1===t.value.indexOf(r)&&(t.value="".concat(t.value).concat(r)),t}};return t}function S(e,t,r){var n=T(r),o="".concat(e.protocol,"://").concat(e.url,"/").concat("/"===t.charAt(0)?t.substr(1):t);return n.length&&(o+="?".concat(n)),o}function T(e){return Object.keys(e).map((function(t){return f("%s=%s",t,(r=e[t],"[object Object]"===Object.prototype.toString.call(r)||"[object Array]"===Object.prototype.toString.call(r)?JSON.stringify(e[t]):e[t]));var r})).join("&")}function A(e){return e.map((function(e){return x(e)}))}function x(e){var t=e.request.headers["x-algolia-api-key"]?{"x-algolia-api-key":"*****"}:{};return r(r({},e),{},{request:r(r({},e.request),{},{headers:r(r({},e.request.headers),t)})})}var N=function(e){var t=e.appId,n=function(e,t,r){var n={"x-algolia-api-key":r,"x-algolia-application-id":t};return{headers:function(){return e===h.WithinHeaders?n:{}},queryParameters:function(){return e===h.WithinQueryParameters?n:{}}}}(void 0!==e.authMode?e.authMode:h.WithinHeaders,t,e.apiKey),a=function(e){var t=e.hostsCache,r=e.logger,n=e.requester,a=e.requestsCache,u=e.responsesCache,i=e.timeouts,s=e.userAgent,c=e.hosts,l=e.queryParameters,f={hostsCache:t,logger:r,requester:n,requestsCache:a,responsesCache:u,timeouts:i,userAgent:s,headers:e.headers,queryParameters:l,hosts:c.map((function(e){return b(e)})),read:function(e,t){var r=d(t,f.timeouts.read),n=function(){return j(f,f.hosts.filter((function(e){return 0!=(e.accept&m.Read)})),e,r)};if(!0!==(void 0!==r.cacheable?r.cacheable:e.cacheable))return n();var a={request:e,mappedRequestOptions:r,transporter:{queryParameters:f.queryParameters,headers:f.headers}};return f.responsesCache.get(a,(function(){return f.requestsCache.get(a,(function(){return f.requestsCache.set(a,n()).then((function(e){return Promise.all([f.requestsCache.delete(a),e])}),(function(e){return Promise.all([f.requestsCache.delete(a),Promise.reject(e)])})).then((function(e){var t=o(e,2);t[0];return t[1]}))}))}),{miss:function(e){return f.responsesCache.set(a,e)}})},write:function(e,t){return j(f,f.hosts.filter((function(e){return 0!=(e.accept&m.Write)})),e,d(t,f.timeouts.write))}};return f}(r(r({hosts:[{url:"".concat(t,"-dsn.algolia.net"),accept:m.Read},{url:"".concat(t,".algolia.net"),accept:m.Write}].concat(c([{url:"".concat(t,"-1.algolianet.com")},{url:"".concat(t,"-2.algolianet.com")},{url:"".concat(t,"-3.algolianet.com")}]))},e),{},{headers:r(r(r({},n.headers()),{"content-type":"application/x-www-form-urlencoded"}),e.headers),queryParameters:r(r({},n.queryParameters()),e.queryParameters)}));return l({transporter:a,appId:t,addAlgoliaAgent:function(e,t){a.userAgent.add({segment:e,version:t})},clearCache:function(){return Promise.all([a.requestsCache.clear(),a.responsesCache.clear()]).then((function(){}))}},e.methods)},C=function(e){return function(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n={transporter:e.transporter,appId:e.appId,indexName:t};return l(n,r.methods)}},k=function(e){return function(t,n){var o=t.map((function(e){return r(r({},e),{},{params:T(e.params||{})})}));return e.transporter.read({method:P,path:"1/indexes/*/queries",data:{requests:o},cacheable:!0},n)}},J=function(e){return function(t,o){return Promise.all(t.map((function(t){var a=t.params,u=a.facetName,i=a.facetQuery,s=n(a,["facetName","facetQuery"]);return C(e)(t.indexName,{methods:{searchForFacetValues:F}}).searchForFacetValues(u,i,r(r({},o),s))})))}},E=function(e){return function(t,r,n){return e.transporter.read({method:P,path:f("1/answers/%s/prediction",e.indexName),data:{query:t,queryLanguages:r},cacheable:!0},n)}},I=function(e){return function(t,r){return e.transporter.read({method:P,path:f("1/indexes/%s/query",e.indexName),data:{query:t},cacheable:!0},r)}},F=function(e){return function(t,r,n){return e.transporter.read({method:P,path:f("1/indexes/%s/facets/%s/query",e.indexName,t),data:{facetQuery:r},cacheable:!0},n)}},R=1,D=2,W=3;function H(e,t,n){var o,a={appId:e,apiKey:t,timeouts:{connect:1,read:2,write:30},requester:{send:function(e){return new Promise((function(t){var r=new XMLHttpRequest;r.open(e.method,e.url,!0),Object.keys(e.headers).forEach((function(t){return r.setRequestHeader(t,e.headers[t])}));var n,o=function(e,n){return setTimeout((function(){r.abort(),t({status:0,content:n,isTimedOut:!0})}),1e3*e)},a=o(e.connectTimeout,"Connection timeout");r.onreadystatechange=function(){r.readyState>r.OPENED&&void 0===n&&(clearTimeout(a),n=o(e.responseTimeout,"Socket timeout"))},r.onerror=function(){0===r.status&&(clearTimeout(a),clearTimeout(n),t({content:r.responseText||"Network request failed",status:r.status,isTimedOut:!1}))},r.onload=function(){clearTimeout(a),clearTimeout(n),t({content:r.responseText,status:r.status,isTimedOut:!1})},r.send(e.data)}))}},logger:(o=W,{debug:function(e,t){return R>=o&&console.debug(e,t),Promise.resolve()},info:function(e,t){return D>=o&&console.info(e,t),Promise.resolve()},error:function(e,t){return console.error(e,t),Promise.resolve()}}),responsesCache:s(),requestsCache:s({serializable:!1}),hostsCache:i({caches:[u({key:"".concat("4.10.3","-").concat(e)}),s()]}),userAgent:w("4.10.3").add({segment:"Browser",version:"lite"}),authMode:h.WithinQueryParameters};return N(r(r(r({},a),n),{},{methods:{search:k,searchForFacetValues:J,multipleQueries:k,multipleSearchForFacetValues:J,initIndex:function(e){return function(t){return C(e)(t,{methods:{search:I,searchForFacetValues:F,findAnswers:E}})}}}}))}return H.version="4.10.3",H}));


/***/ }),

/***/ "./src/js/util.js":
/*!************************!*\
  !*** ./src/js/util.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.regexp.exec.js */ "./node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ "./node_modules/core-js/modules/es.string.replace.js");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.regexp.constructor.js */ "./node_modules/core-js/modules/es.regexp.constructor.js");
/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ "./node_modules/core-js/modules/es.regexp.to-string.js");
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.parse-int.js */ "./node_modules/core-js/modules/es.parse-int.js");
/* harmony import */ var core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_4__);





// stopBodyScroll 方法依赖
var bodyEl = document.body;
var windowTop = 0;
var bodyElPosition = bodyEl.style.position;
var archerUtil = {
  // 回到顶部
  backTop: function backTop(event) {
    event.preventDefault();
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  },
  // 获取元素在页面上相对左上角的位置
  getAbsPosition: function getAbsPosition(e) {
    var x = e.offsetLeft,
        y = e.offsetTop;
    var current = e.offsetParent;

    while (current !== null) {
      x += current.offsetLeft;
      y += current.offsetTop;
      current = current.offsetParent;
    }

    return {
      x: x,
      y: y
    };
  },
  // 格式化日期
  dateFormater: function dateFormater(date, fmt) {
    var o = {
      'M+': date.getMonth() + 1,
      // 月份
      'd+': date.getDate(),
      // 日
      'h+': date.getHours(),
      // 小时
      'm+': date.getMinutes(),
      // 分
      's+': date.getSeconds(),
      // 秒
      'q+': Math.floor((date.getMonth() + 3) / 3),
      // 季度
      S: date.getMilliseconds() // 毫秒

    };

    if (/(y+)/.test(fmt)) {
      fmt = fmt.replace(RegExp.$1, String(date.getFullYear()).substr(4 - RegExp.$1.length));
    }

    for (var k in o) {
      if (new RegExp('(' + k + ')').test(fmt)) {
        fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(String(o[k]).length));
      }
    }

    return fmt;
  },
  // 获取 1rem 对应的 px 值
  rem: function rem() {
    return parseInt($('html').css('font-size'), 10);
  },
  // 设置地址栏 hash
  setWindowHash: function setWindowHash(hash) {
    window.history.replaceState({}, '', "#/".concat(hash));
  },
  // 读取地址栏 hash
  getWindowHash: function getWindowHash() {
    return window.location.hash.replace(/^#\//, '#');
  },
  // rAF 的 ticking
  rafTick: function rafTick(ticking, updateFunc) {
    if (!ticking) {
      requestAnimationFrame(updateFunc);
    }

    ticking = true;
  },
  // 固定 body
  // see: https://segmentfault.com/a/1190000012313337
  stopBodyScroll: function stopBodyScroll(isFixed) {
    if (isFixed) {
      windowTop = window.scrollY;
      bodyEl.style.position = 'fixed';
      bodyEl.style.top = -windowTop + 'px';
      bodyEl.style.width = '100%';
    } else {
      bodyEl.style.position = bodyElPosition;
      bodyEl.style.top = '';
      bodyEl.style.width = '';
      window.scrollTo(0, windowTop);
    }
  },
  // 函数节流
  throttle: function throttle(func, wait) {
    var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var timer;
    return function () {
      var _this = this;

      var args = arguments;

      if (!timer) {
        if (immediate) {
          timer = setTimeout(function () {
            timer = undefined;
          }, wait);
          func.apply(this, args);
        } else {
          timer = setTimeout(function () {
            timer = undefined;
            func.apply(_this, args);
          }, wait);
        }
      }
    };
  },
  // 函数防抖
  debounce: function debounce(func, wait) {
    var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var timer;
    return function () {
      var _this2 = this;

      var args = arguments;
      timer && clearTimeout(timer);

      if (immediate) {
        !timer && func.apply(this, args);
        timer = setTimeout(function () {
          timer = undefined;
        }, wait);
      } else {
        timer = setTimeout(function () {
          func.apply(_this2, args);
        }, wait);
      }
    };
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (archerUtil);

/***/ }),

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/core-js/internals/a-function.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/advance-string-index.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/advance-string-index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push.call(target, value); // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ ((module) => {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] < 4 ? 1 : match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__(/*! ../modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;

module.exports = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    });

    redefine(String.prototype, KEY, methods[0]);
    redefine(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-substitution.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/get-substitution.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var floor = Math.floor;
var replace = ''.replace;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace.call(replacement, symbols, function (match, ch) {
    var capture;
    switch (ch.charAt(0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return str.slice(0, position);
      case "'": return str.slice(tailPos);
      case '<':
        capture = namedCaptures[ch.slice(1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = {}.hasOwnProperty;

module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty.call(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = Function.toString;

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-regexp.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-regexp.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return typeof $Symbol == 'function' && Object(it) instanceof $Symbol;
};


/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/number-parse-int.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/number-parse-int.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var trim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim;
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var $parseInt = global.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(toString(string));
  return $parseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-proto -- safe */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (pref !== 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(/*! ./classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var regexpExec = __webpack_require__(/*! ./regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var regexpFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var stickyHelpers = __webpack_require__(/*! ../internals/regexp-sticky-helpers */ "./node_modules/core-js/internals/regexp-sticky-helpers.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getInternalState = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").get;
var UNSUPPORTED_DOT_ALL = __webpack_require__(/*! ../internals/regexp-unsupported-dot-all */ "./node_modules/core-js/internals/regexp-unsupported-dot-all.js");
var UNSUPPORTED_NCG = __webpack_require__(/*! ../internals/regexp-unsupported-ncg */ "./node_modules/core-js/internals/regexp-unsupported-ncg.js");

var nativeExec = RegExp.prototype.exec;
var nativeReplace = shared('native-string-replace', String.prototype.replace);

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  // eslint-disable-next-line max-statements -- TODO
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = patchedExec.call(raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = str.slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str.charAt(re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-sticky-helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-sticky-helpers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = global.RegExp;

exports.UNSUPPORTED_Y = fails(function () {
  var re = $RegExp('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-unsupported-dot-all.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-unsupported-dot-all.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ./fails */ "./node_modules/core-js/internals/fails.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('.', 's');
  return !(re.dotAll && re.exec('\n') && re.flags === 's');
});


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-unsupported-ncg.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-unsupported-ncg.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ./fails */ "./node_modules/core-js/internals/fails.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ ((module) => {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/same-value.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/same-value.js ***!
  \******************************************************/
/***/ ((module) => {

// `SameValue` abstract operation
// https://tc39.es/ecma262/#sec-samevalue
// eslint-disable-next-line es/no-object-is -- safe
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = function (key, value) {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-species.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.16.2',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/internals/string-multibyte.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `String.prototype.codePointAt` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = input[TO_PRIMITIVE];
  var result;
  if (exoticToPrim !== undefined) {
    if (pref === undefined) pref = 'default';
    result = exoticToPrim.call(input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : String(key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-string.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-string.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

module.exports = function (argument) {
  if (isSymbol(argument)) throw TypeError('Cannot convert a Symbol value to a string');
  return String(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ ((module) => {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/***/ ((module) => {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.find.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.find.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $find = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").find;
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-int.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-int.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var parseIntImplementation = __webpack_require__(/*! ../internals/number-parse-int */ "./node_modules/core-js/internals/number-parse-int.js");

// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
$({ global: true, forced: parseInt != parseIntImplementation }, {
  parseInt: parseIntImplementation
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.constructor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var getFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var stickyHelpers = __webpack_require__(/*! ../internals/regexp-sticky-helpers */ "./node_modules/core-js/internals/regexp-sticky-helpers.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var enforceInternalState = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").enforce;
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var UNSUPPORTED_DOT_ALL = __webpack_require__(/*! ../internals/regexp-unsupported-dot-all */ "./node_modules/core-js/internals/regexp-unsupported-dot-all.js");
var UNSUPPORTED_NCG = __webpack_require__(/*! ../internals/regexp-unsupported-ncg */ "./node_modules/core-js/internals/regexp-unsupported-ncg.js");

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
// TODO: Use only propper RegExpIdentifierName
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

var BASE_FORCED = DESCRIPTORS &&
  (!CORRECT_NEW || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function () {
    re2[MATCH] = false;
    // RegExp constructor can alter flags and IsRegExp works correct with @@match
    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
  }));

var handleDotAll = function (string) {
  var length = string.length;
  var index = 0;
  var result = '';
  var brackets = false;
  var chr;
  for (; index <= length; index++) {
    chr = string.charAt(index);
    if (chr === '\\') {
      result += chr + string.charAt(++index);
      continue;
    }
    if (!brackets && chr === '.') {
      result += '[\\s\\S]';
    } else {
      if (chr === '[') {
        brackets = true;
      } else if (chr === ']') {
        brackets = false;
      } result += chr;
    }
  } return result;
};

var handleNCG = function (string) {
  var length = string.length;
  var index = 0;
  var result = '';
  var named = [];
  var names = {};
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = '';
  var chr;
  for (; index <= length; index++) {
    chr = string.charAt(index);
    if (chr === '\\') {
      chr = chr + string.charAt(++index);
    } else if (chr === ']') {
      brackets = false;
    } else if (!brackets) switch (true) {
      case chr === '[':
        brackets = true;
        break;
      case chr === '(':
        if (IS_NCG.test(string.slice(index + 1))) {
          index += 2;
          ncg = true;
        }
        result += chr;
        groupid++;
        continue;
      case chr === '>' && ncg:
        if (groupname === '' || has(names, groupname)) {
          throw new SyntaxError('Invalid capture group name');
        }
        names[groupname] = true;
        named.push([groupname, groupid]);
        ncg = false;
        groupname = '';
        continue;
    }
    if (ncg) groupname += chr;
    else result += chr;
  } return [result, named];
};

// `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor
if (isForced('RegExp', BASE_FORCED)) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;

    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }

    if (patternIsRegExp || pattern instanceof RegExpWrapper) {
      pattern = pattern.source;
      if (flagsAreUndefined) flags = 'flags' in rawPattern ? rawPattern.flags : getFlags.call(rawPattern);
    }

    pattern = pattern === undefined ? '' : toString(pattern);
    flags = flags === undefined ? '' : toString(flags);
    rawPattern = pattern;

    if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
      dotAll = !!flags && flags.indexOf('s') > -1;
      if (dotAll) flags = flags.replace(/s/g, '');
    }

    rawFlags = flags;

    if (UNSUPPORTED_Y && 'sticky' in re1) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    if (UNSUPPORTED_NCG) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }

    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);

    if (dotAll || sticky || groups.length) {
      state = enforceInternalState(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky) state.sticky = true;
      if (groups.length) state.groups = groups;
    }

    if (pattern !== rawPattern) try {
      // fails in old engines, but we have no alternatives for unsupported regex syntax
      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
    } catch (error) { /* empty */ }

    return result;
  };

  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };

  for (var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;) {
    proxy(keys[index++]);
  }

  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.es/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.exec.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.exec.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var exec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var flags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = $toString(R.source);
    var rf = R.flags;
    var f = $toString(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.replace.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.replace.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var getSubstitution = __webpack_require__(/*! ../internals/get-substitution */ "./node_modules/core-js/internals/get-substitution.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(toString(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (string, replaceValue) {
      var rx = anObject(this);
      var S = toString(string);

      if (
        typeof replaceValue === 'string' &&
        replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1 &&
        replaceValue.indexOf('$<') === -1
      ) {
        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
        if (res.done) return res.value;
      }

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = toString(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = toString(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = toString(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = toString(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.search.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.search.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var sameValue = __webpack_require__(/*! ../internals/same-value */ "./node_modules/core-js/internals/same-value.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@search logic
fixRegExpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.es/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
    function (string) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(nativeSearch, rx, S);

      if (res.done) return res.value;

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),

/***/ "./node_modules/hogan.js/lib/compiler.js":
/*!***********************************************!*\
  !*** ./node_modules/hogan.js/lib/compiler.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

(function (Hogan) {
  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rQuot = /\"/g,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      rLineSep = /\u2028/,
      rParagraphSep = /\u2029/;

  Hogan.tags = {
    '#': 1, '^': 2, '<': 3, '$': 4,
    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
    '{': 10, '&': 11, '_t': 12
  };

  Hogan.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push({tag: '_t', text: new String(buf)});
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||
          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (tokens[j].text) {
            if ((next = tokens[j+1]) && next.tag == '>') {
              // set indent to token value
              next.indent = tokens[j].text.toString()
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[delimiters.length - 1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state == IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) == '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state == IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = Hogan.tags[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType == '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType == '{') {
            if (ctag == '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);

    return tokens;
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) != tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) != tag.charAt(i)) {
        return false;
      }
    }

    return true;
  }

  // the tags allowed inside super templates
  var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        tail = null,
        token = null;

    tail = stack[stack.length - 1];

    while (tokens.length > 0) {
      token = tokens.shift();

      if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {
        throw new Error('Illegal content in < super tag.');
      }

      if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
      } else if (token.tag == '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else if (token.tag == '\n') {
        token.last = (tokens.length == 0) || (tokens[0].tag == '\n');
      }

      instructions.push(token);
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o == token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c == close && tags[i].o == open) {
        return true;
      }
    }
  }

  function stringifySubstitutions(obj) {
    var items = [];
    for (var key in obj) {
      items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
    }
    return "{ " + items.join(",") + " }";
  }

  function stringifyPartials(codeObj) {
    var partials = [];
    for (var key in codeObj.partials) {
      partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
    }
    return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
  }

  Hogan.stringify = function(codeObj, text, options) {
    return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) +  "}";
  }

  var serialNo = 0;
  Hogan.generate = function(tree, text, options) {
    serialNo = 0;
    var context = { code: '', subs: {}, partials: {} };
    Hogan.walk(tree, context);

    if (options.asString) {
      return this.stringify(context, text, options);
    }

    return this.makeTemplate(context, text, options);
  }

  Hogan.wrapMain = function(code) {
    return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
  }

  Hogan.template = Hogan.Template;

  Hogan.makeTemplate = function(codeObj, text, options) {
    var template = this.makePartials(codeObj);
    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));
    return new this.template(template, text, this, options);
  }

  Hogan.makePartials = function(codeObj) {
    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
    for (key in template.partials) {
      template.partials[key] = this.makePartials(template.partials[key]);
    }
    for (key in codeObj.subs) {
      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);
    }
    return template;
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\"')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r')
            .replace(rLineSep, '\\u2028')
            .replace(rParagraphSep, '\\u2029');
  }

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function createPartial(node, context) {
    var prefix = "<" + (context.prefix || "");
    var sym = prefix + node.n + serialNo++;
    context.partials[sym] = {name: node.n, partials: {}};
    context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
    return sym;
  }

  Hogan.codegen = {
    '#': function(node, context) {
      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                      'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + " " + node.ctag + '")){' +
                      't.rs(c,p,' + 'function(c,p,t){';
      Hogan.walk(node.nodes, context);
      context.code += '});c.pop();}';
    },

    '^': function(node, context) {
      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
      Hogan.walk(node.nodes, context);
      context.code += '};';
    },

    '>': createPartial,
    '<': function(node, context) {
      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
      Hogan.walk(node.nodes, ctx);
      var template = context.partials[createPartial(node, context)];
      template.subs = ctx.subs;
      template.partials = ctx.partials;
    },

    '$': function(node, context) {
      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
      Hogan.walk(node.nodes, ctx);
      context.subs[node.n] = ctx.code;
      if (!context.inPartial) {
        context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
      }
    },

    '\n': function(node, context) {
      context.code += write('"\\n"' + (node.last ? '' : ' + i'));
    },

    '_v': function(node, context) {
      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    },

    '_t': function(node, context) {
      context.code += write('"' + esc(node.text) + '"');
    },

    '{': tripleStache,

    '&': tripleStache
  }

  function tripleStache(node, context) {
    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
  }

  function write(s) {
    return 't.b(' + s + ');';
  }

  Hogan.walk = function(nodelist, context) {
    var func;
    for (var i = 0, l = nodelist.length; i < l; i++) {
      func = Hogan.codegen[nodelist[i].tag];
      func && func(nodelist[i], context);
    }
    return context;
  }

  Hogan.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  }

  Hogan.cache = {};

  Hogan.cacheKey = function(text, options) {
    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
  }

  Hogan.compile = function(text, options) {
    options = options || {};
    var key = Hogan.cacheKey(text, options);
    var template = this.cache[key];

    if (template) {
      var partials = template.partials;
      for (var name in partials) {
        delete partials[name].instance;
      }
      return template;
    }

    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    return this.cache[key] = template;
  }
})( true ? exports : 0);


/***/ }),

/***/ "./node_modules/hogan.js/lib/hogan.js":
/*!********************************************!*\
  !*** ./node_modules/hogan.js/lib/hogan.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// This file is for use with Node.js. See dist/ for browser files.

var Hogan = __webpack_require__(/*! ./compiler */ "./node_modules/hogan.js/lib/compiler.js");
Hogan.Template = __webpack_require__(/*! ./template */ "./node_modules/hogan.js/lib/template.js").Template;
Hogan.template = Hogan.Template;
module.exports = Hogan;


/***/ }),

/***/ "./node_modules/hogan.js/lib/template.js":
/*!***********************************************!*\
  !*** ./node_modules/hogan.js/lib/template.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

var Hogan = {};

(function (Hogan) {
  Hogan.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || '';
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.buf = '';
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we've instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance && partial.base == template) {
        return partial.instance;
      }

      if (typeof template == 'string') {
        if (!this.c) {
          throw new Error("No compiler available.");
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (!partials.stackText) partials.stackText = {};
        for (key in partial.subs) {
          if (!partials.stackText[key]) {
            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
          }
        }
        template = createSpecializedPartial(template, partial.subs, partial.partials,
          this.stackSubs, this.stackPartials, partials.stackText);
      }
      this.partials[symbol].instance = template;

      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return '';
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val == 'function') {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === '.' && isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i < names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found !== undefined) {
            cx = val;
            val = found;
          } else {
            val = '';
          }
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val == 'function') {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val !== undefined) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : "";
      }

      if (!returnFound && typeof val == 'function') {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error('Lambda features disabled.');
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: function(s) { this.buf += s; },

    fl: function() { var r = this.buf; this.buf = ''; return r; },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result == 'function') {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result == 'function') {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }

  };

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val;

    if (scope && typeof scope == 'object') {

      if (scope[key] !== undefined) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet && scope.get && typeof scope.get == 'function') {
        val = scope.get(key);
      }
    }

    return val;
  }

  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
    function PartialTemplate() {};
    PartialTemplate.prototype = instance;
    function Substitutions() {};
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.buf = '';

    stackSubs = stackSubs || {};
    partial.stackSubs = stackSubs;
    partial.subsText = stackText;
    for (key in subs) {
      if (!stackSubs[key]) stackSubs[key] = subs[key];
    }
    for (key in stackSubs) {
      partial.subs[key] = stackSubs[key];
    }

    stackPartials = stackPartials || {};
    partial.stackPartials = stackPartials;
    for (key in partials) {
      if (!stackPartials[key]) stackPartials[key] = partials[key];
    }
    for (key in stackPartials) {
      partial.partials[key] = stackPartials[key];
    }

    return partial;
  }

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  };

})( true ? exports : 0);


/***/ }),

/***/ "./node_modules/instantsearch.js/es/components/Hits/Hits.js":
/*!******************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/components/Hits/Hits.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Template_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Template/Template */ "./node_modules/instantsearch.js/es/components/Template/Template.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/** @jsx h */




var Hits = function Hits(_ref) {
  var results = _ref.results,
      hits = _ref.hits,
      bindEvent = _ref.bindEvent,
      cssClasses = _ref.cssClasses,
      templateProps = _ref.templateProps;

  if (results.hits.length === 0) {
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_Template_Template__WEBPACK_IMPORTED_MODULE_2__.default, _extends({}, templateProps, {
      templateKey: "empty",
      rootProps: {
        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(cssClasses.root, cssClasses.emptyRoot)
      },
      data: results
    }));
  }

  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    className: cssClasses.root
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("ol", {
    className: cssClasses.list
  }, hits.map(function (hit, index) {
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_Template_Template__WEBPACK_IMPORTED_MODULE_2__.default, _extends({}, templateProps, {
      templateKey: "item",
      rootTagName: "li",
      rootProps: {
        className: cssClasses.item
      },
      key: hit.objectID,
      data: _objectSpread(_objectSpread({}, hit), {}, {
        __hitIndex: index
      }),
      bindEvent: bindEvent
    }));
  })));
};

Hits.defaultProps = {
  results: {
    hits: []
  },
  hits: []
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Hits);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/components/Pagination/Pagination.js":
/*!******************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/components/Pagination/Pagination.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _PaginationLink__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PaginationLink */ "./node_modules/instantsearch.js/es/components/Pagination/PaginationLink.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/isSpecialClick.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** @jsx h */




var defaultProps = {
  currentPage: 0,
  nbPages: 0,
  pages: []
};

var Pagination = /*#__PURE__*/function (_Component) {
  _inherits(Pagination, _Component);

  var _super = _createSuper(Pagination);

  function Pagination() {
    var _this;

    _classCallCheck(this, Pagination);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "handleClick", function (pageNumber, event) {
      if ((0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)(event)) {
        // do not alter the default browser behavior
        // if one special key is down
        return;
      }

      event.preventDefault();

      _this.props.setCurrentPage(pageNumber);
    });

    _defineProperty(_assertThisInitialized(_this), "previousPageLink", function () {
      return _this.pageLink({
        ariaLabel: 'Previous',
        additionalClassName: _this.props.cssClasses.previousPageItem,
        isDisabled: _this.props.isFirstPage,
        label: _this.props.templates.previous,
        pageNumber: _this.props.currentPage - 1,
        createURL: _this.props.createURL
      });
    });

    _defineProperty(_assertThisInitialized(_this), "nextPageLink", function () {
      return _this.pageLink({
        ariaLabel: 'Next',
        additionalClassName: _this.props.cssClasses.nextPageItem,
        isDisabled: _this.props.isLastPage,
        label: _this.props.templates.next,
        pageNumber: _this.props.currentPage + 1,
        createURL: _this.props.createURL
      });
    });

    _defineProperty(_assertThisInitialized(_this), "firstPageLink", function () {
      return _this.pageLink({
        ariaLabel: 'First',
        additionalClassName: _this.props.cssClasses.firstPageItem,
        isDisabled: _this.props.isFirstPage,
        label: _this.props.templates.first,
        pageNumber: 0,
        createURL: _this.props.createURL
      });
    });

    _defineProperty(_assertThisInitialized(_this), "lastPageLink", function () {
      return _this.pageLink({
        ariaLabel: 'Last',
        additionalClassName: _this.props.cssClasses.lastPageItem,
        isDisabled: _this.props.isLastPage,
        label: _this.props.templates.last,
        pageNumber: _this.props.nbPages - 1,
        createURL: _this.props.createURL
      });
    });

    _defineProperty(_assertThisInitialized(_this), "pages", function () {
      return _this.props.pages.map(function (pageNumber) {
        return _this.pageLink({
          ariaLabel: "".concat(pageNumber + 1),
          additionalClassName: _this.props.cssClasses.pageItem,
          isSelected: pageNumber === _this.props.currentPage,
          label: "".concat(pageNumber + 1),
          pageNumber: pageNumber,
          createURL: _this.props.createURL
        });
      });
    });

    return _this;
  }

  _createClass(Pagination, [{
    key: "pageLink",
    value: function pageLink(_ref) {
      var label = _ref.label,
          ariaLabel = _ref.ariaLabel,
          pageNumber = _ref.pageNumber,
          _ref$additionalClassN = _ref.additionalClassName,
          additionalClassName = _ref$additionalClassN === void 0 ? null : _ref$additionalClassN,
          _ref$isDisabled = _ref.isDisabled,
          isDisabled = _ref$isDisabled === void 0 ? false : _ref$isDisabled,
          _ref$isSelected = _ref.isSelected,
          isSelected = _ref$isSelected === void 0 ? false : _ref$isSelected,
          createURL = _ref.createURL;
      var cssClasses = {
        item: classnames__WEBPACK_IMPORTED_MODULE_1___default()(this.props.cssClasses.item, additionalClassName),
        link: this.props.cssClasses.link
      };

      if (isDisabled) {
        cssClasses.item = classnames__WEBPACK_IMPORTED_MODULE_1___default()(cssClasses.item, this.props.cssClasses.disabledItem);
      } else if (isSelected) {
        cssClasses.item = classnames__WEBPACK_IMPORTED_MODULE_1___default()(cssClasses.item, this.props.cssClasses.selectedItem);
      }

      var url = !isDisabled ? createURL(pageNumber) : '#';
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_PaginationLink__WEBPACK_IMPORTED_MODULE_3__.default, {
        ariaLabel: ariaLabel,
        cssClasses: cssClasses,
        handleClick: this.handleClick,
        isDisabled: isDisabled,
        key: label + pageNumber + ariaLabel,
        label: label,
        pageNumber: pageNumber,
        url: url
      });
    }
  }, {
    key: "render",
    value: function render() {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(this.props.cssClasses.root, _defineProperty({}, this.props.cssClasses.noRefinementRoot, this.props.nbPages <= 1))
      }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("ul", {
        className: this.props.cssClasses.list
      }, this.props.showFirst && this.firstPageLink(), this.props.showPrevious && this.previousPageLink(), this.pages(), this.props.showNext && this.nextPageLink(), this.props.showLast && this.lastPageLink()));
    }
  }]);

  return Pagination;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

_defineProperty(Pagination, "defaultProps", defaultProps);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pagination);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/components/Pagination/PaginationLink.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/components/Pagination/PaginationLink.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/** @jsx h */


var PaginationLink = function PaginationLink(_ref) {
  var cssClasses = _ref.cssClasses,
      label = _ref.label,
      ariaLabel = _ref.ariaLabel,
      url = _ref.url,
      isDisabled = _ref.isDisabled,
      handleClick = _ref.handleClick,
      pageNumber = _ref.pageNumber;

  if (isDisabled) {
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("li", {
      className: cssClasses.item
    }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("span", {
      className: cssClasses.link,
      dangerouslySetInnerHTML: {
        __html: label
      }
    }));
  }

  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("li", {
    className: cssClasses.item
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("a", {
    className: cssClasses.link,
    "aria-label": ariaLabel,
    href: url,
    onClick: function onClick(event) {
      return handleClick(pageNumber, event);
    },
    dangerouslySetInnerHTML: {
      __html: label
    }
  }));
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PaginationLink);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/components/SearchBox/SearchBox.js":
/*!****************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/components/SearchBox/SearchBox.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");
/* harmony import */ var _Template_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Template/Template */ "./node_modules/instantsearch.js/es/components/Template/Template.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** @jsx h */



var defaultProps = {
  query: '',
  showSubmit: true,
  showReset: true,
  showLoadingIndicator: true,
  autofocus: false,
  searchAsYouType: true,
  isSearchStalled: false,
  disabled: false,
  onChange: _lib_utils__WEBPACK_IMPORTED_MODULE_1__.default,
  onSubmit: _lib_utils__WEBPACK_IMPORTED_MODULE_1__.default,
  onReset: _lib_utils__WEBPACK_IMPORTED_MODULE_1__.default,
  refine: _lib_utils__WEBPACK_IMPORTED_MODULE_1__.default
};

var SearchBox = /*#__PURE__*/function (_Component) {
  _inherits(SearchBox, _Component);

  var _super = _createSuper(SearchBox);

  function SearchBox() {
    var _this;

    _classCallCheck(this, SearchBox);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      query: _this.props.query,
      focused: false
    });

    _defineProperty(_assertThisInitialized(_this), "input", (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)());

    _defineProperty(_assertThisInitialized(_this), "onInput", function (event) {
      var _this$props = _this.props,
          searchAsYouType = _this$props.searchAsYouType,
          refine = _this$props.refine,
          onChange = _this$props.onChange;
      var query = event.target.value;

      if (searchAsYouType) {
        refine(query);
      }

      _this.setState({
        query: query
      });

      onChange(event);
    });

    _defineProperty(_assertThisInitialized(_this), "onSubmit", function (event) {
      var _this$props2 = _this.props,
          searchAsYouType = _this$props2.searchAsYouType,
          refine = _this$props2.refine,
          onSubmit = _this$props2.onSubmit;
      event.preventDefault();
      event.stopPropagation();

      if (_this.input.current) {
        _this.input.current.blur();
      }

      if (!searchAsYouType) {
        refine(_this.state.query);
      }

      onSubmit(event);
      return false;
    });

    _defineProperty(_assertThisInitialized(_this), "onReset", function (event) {
      var _this$props3 = _this.props,
          refine = _this$props3.refine,
          onReset = _this$props3.onReset;
      var query = '';

      if (_this.input.current) {
        _this.input.current.focus();
      }

      refine(query);

      _this.setState({
        query: query
      });

      onReset(event);
    });

    _defineProperty(_assertThisInitialized(_this), "onBlur", function () {
      _this.setState({
        focused: false
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onFocus", function () {
      _this.setState({
        focused: true
      });
    });

    return _this;
  }

  _createClass(SearchBox, [{
    key: "resetInput",
    value:
    /**
     * This public method is used in the RefinementList SFFV search box
     * to reset the input state when an item is selected.
     *
     * @see RefinementList#componentWillReceiveProps
     * @return {undefined}
     */
    function resetInput() {
      this.setState({
        query: ''
      });
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      /**
       * when the user is typing, we don't want to replace the query typed
       * by the user (state.query) with the query exposed by the connector (props.query)
       * see: https://github.com/algolia/instantsearch.js/issues/4141
       */
      if (!this.state.focused && nextProps.query !== this.state.query) {
        this.setState({
          query: nextProps.query
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props,
          cssClasses = _this$props4.cssClasses,
          placeholder = _this$props4.placeholder,
          autofocus = _this$props4.autofocus,
          showSubmit = _this$props4.showSubmit,
          showReset = _this$props4.showReset,
          showLoadingIndicator = _this$props4.showLoadingIndicator,
          templates = _this$props4.templates,
          isSearchStalled = _this$props4.isSearchStalled;
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
        className: cssClasses.root
      }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("form", {
        action: "",
        role: "search",
        className: cssClasses.form,
        noValidate: true,
        onSubmit: this.onSubmit // @ts-expect-error `onReset` attibute is missing in preact 10.0.0 JSX types
        ,
        onReset: this.onReset
      }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("input", {
        ref: this.input,
        value: this.state.query,
        disabled: this.props.disabled,
        className: cssClasses.input,
        type: "search",
        placeholder: placeholder,
        autoFocus: autofocus,
        autoComplete: "off",
        autoCorrect: "off" // @ts-expect-error `autoCapitalize` attibute is missing in preact 10.0.0 JSX types
        ,
        autoCapitalize: "off",
        spellCheck: "false",
        maxLength: 512,
        onInput: this.onInput,
        onBlur: this.onBlur,
        onFocus: this.onFocus
      }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_Template_Template__WEBPACK_IMPORTED_MODULE_2__.default, {
        templateKey: "submit",
        rootTagName: "button",
        rootProps: {
          className: cssClasses.submit,
          type: 'submit',
          title: 'Submit the search query.',
          hidden: !showSubmit
        },
        templates: templates,
        data: {
          cssClasses: cssClasses
        }
      }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_Template_Template__WEBPACK_IMPORTED_MODULE_2__.default, {
        templateKey: "reset",
        rootTagName: "button",
        rootProps: {
          className: cssClasses.reset,
          type: 'reset',
          title: 'Clear the search query.',
          hidden: !(showReset && this.state.query.trim() && !isSearchStalled)
        },
        templates: templates,
        data: {
          cssClasses: cssClasses
        }
      }), showLoadingIndicator && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_Template_Template__WEBPACK_IMPORTED_MODULE_2__.default, {
        templateKey: "loadingIndicator",
        rootTagName: "span",
        rootProps: {
          className: cssClasses.loadingIndicator,
          hidden: !isSearchStalled
        },
        templates: templates,
        data: {
          cssClasses: cssClasses
        }
      })));
    }
  }]);

  return SearchBox;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

_defineProperty(SearchBox, "defaultProps", defaultProps);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SearchBox);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/components/Stats/Stats.js":
/*!********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/components/Stats/Stats.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Template_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Template/Template */ "./node_modules/instantsearch.js/es/components/Template/Template.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/** @jsx h */




var Stats = function Stats(_ref) {
  var nbHits = _ref.nbHits,
      nbSortedHits = _ref.nbSortedHits,
      cssClasses = _ref.cssClasses,
      templateProps = _ref.templateProps,
      rest = _objectWithoutProperties(_ref, ["nbHits", "nbSortedHits", "cssClasses", "templateProps"]);

  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()(cssClasses.root)
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_Template_Template__WEBPACK_IMPORTED_MODULE_2__.default, _extends({}, templateProps, {
    templateKey: "text",
    rootTagName: "span",
    rootProps: {
      className: cssClasses.text
    },
    data: _objectSpread({
      hasManySortedResults: nbSortedHits && nbSortedHits > 1,
      hasNoSortedResults: nbSortedHits === 0,
      hasOneSortedResults: nbSortedHits === 1,
      hasManyResults: nbHits > 1,
      hasNoResults: nbHits === 0,
      hasOneResult: nbHits === 1,
      nbHits: nbHits,
      nbSortedHits: nbSortedHits,
      cssClasses: cssClasses
    }, rest)
  })));
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stats);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/components/Template/Template.js":
/*!**************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/components/Template/Template.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/isEqual.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/renderTemplate.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** @jsx h */


var defaultProps = {
  data: {},
  rootTagName: 'div',
  useCustomCompileOptions: {},
  templates: {},
  templatesConfig: {}
};

// @TODO: Template should be a generic and receive TData to pass to Templates (to avoid TTemplateData to be set as `any`)
var Template = /*#__PURE__*/function (_Component) {
  _inherits(Template, _Component);

  var _super = _createSuper(Template);

  function Template() {
    _classCallCheck(this, Template);

    return _super.apply(this, arguments);
  }

  _createClass(Template, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      return !(0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.default)(this.props.data, nextProps.data) || this.props.templateKey !== nextProps.templateKey || !(0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.default)(this.props.rootProps, nextProps.rootProps);
    }
  }, {
    key: "render",
    value: function render() {
      var RootTagName = this.props.rootTagName;
      var useCustomCompileOptions = this.props.useCustomCompileOptions[this.props.templateKey];
      var compileOptions = useCustomCompileOptions ? this.props.templatesConfig.compileOptions : {};
      var content = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)({
        templates: this.props.templates,
        templateKey: this.props.templateKey,
        compileOptions: compileOptions,
        helpers: this.props.templatesConfig.helpers,
        data: this.props.data,
        bindEvent: this.props.bindEvent
      });

      if (content === null) {
        // Adds a noscript to the DOM but virtual DOM is null
        // See http://facebook.github.io/react/docs/component-specs.html#render
        return null;
      }

      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(RootTagName, _extends({}, this.props.rootProps, {
        dangerouslySetInnerHTML: {
          __html: content
        }
      }));
    }
  }]);

  return Template;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

_defineProperty(Template, "defaultProps", defaultProps);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Template);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/connectors/configure/connectConfigure.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/connectors/configure/connectConfigure.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! algoliasearch-helper */ "./node_modules/algoliasearch-helper/index.js");
/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/isPlainObject.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/mergeSearchParameters.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Refine the given search parameters.
 */

var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.createDocumentationMessageGenerator)({
  name: 'configure',
  connector: true
});

function getInitialSearchParameters(state, widgetParams) {
  // We leverage the helper internals to remove the `widgetParams` from
  // the state. The function `setQueryParameters` omits the values that
  // are `undefined` on the next state.
  return state.setQueryParameters(Object.keys(widgetParams.searchParameters).reduce(function (acc, key) {
    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, undefined));
  }, {}));
}

var connectConfigure = function connectConfigure() {
  var renderFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _lib_utils__WEBPACK_IMPORTED_MODULE_2__.default;
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lib_utils__WEBPACK_IMPORTED_MODULE_2__.default;
  return function (widgetParams) {
    if (!widgetParams || !(0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.default)(widgetParams.searchParameters)) {
      throw new Error(withUsage('The `searchParameters` option expects an object.'));
    }

    var connectorState = {};

    function refine(helper) {
      return function (searchParameters) {
        // Merge new `searchParameters` with the ones set from other widgets
        var actualState = getInitialSearchParameters(helper.state, widgetParams);
        var nextSearchParameters = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.default)(actualState, new (algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default().SearchParameters)(searchParameters)); // Update original `widgetParams.searchParameters` to the new refined one

        widgetParams.searchParameters = searchParameters; // Trigger a search with the resolved search parameters

        helper.setState(nextSearchParameters).search();
      };
    }

    return {
      $$type: 'ais.configure',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref) {
        var state = _ref.state;
        unmountFn();
        return getInitialSearchParameters(state, widgetParams);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        var _renderState$configur;

        var widgetRenderState = this.getWidgetRenderState(renderOptions);
        return _objectSpread(_objectSpread({}, renderState), {}, {
          configure: _objectSpread(_objectSpread({}, widgetRenderState), {}, {
            widgetParams: _objectSpread(_objectSpread({}, widgetRenderState.widgetParams), {}, {
              searchParameters: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.default)(new (algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default().SearchParameters)((_renderState$configur = renderState.configure) === null || _renderState$configur === void 0 ? void 0 : _renderState$configur.widgetParams.searchParameters), new (algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default().SearchParameters)(widgetRenderState.widgetParams.searchParameters)).getQueryParams()
            })
          })
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var helper = _ref2.helper;

        if (!connectorState.refine) {
          connectorState.refine = refine(helper);
        }

        return {
          refine: connectorState.refine,
          widgetParams: widgetParams
        };
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(state, _ref3) {
        var uiState = _ref3.uiState;
        return (0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.default)(state, new (algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default().SearchParameters)(_objectSpread(_objectSpread({}, uiState.configure), widgetParams.searchParameters)));
      },
      getWidgetUiState: function getWidgetUiState(uiState) {
        return _objectSpread(_objectSpread({}, uiState), {}, {
          configure: _objectSpread(_objectSpread({}, uiState.configure), widgetParams.searchParameters)
        });
      }
    };
  };
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (connectConfigure);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/connectors/hits/connectHits.js":
/*!*************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/connectors/hits/connectHits.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/checkRendering.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/createSendEventForHits.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/hits-absolute-position.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/hits-query-id.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.createDocumentationMessageGenerator)({
  name: 'hits',
  connector: true
});

var connectHits = function connectHits(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lib_utils__WEBPACK_IMPORTED_MODULE_1__.default;
  (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)(renderFn, withUsage());
  return function (widgetParams) {
    var _ref = widgetParams || {},
        _ref$escapeHTML = _ref.escapeHTML,
        escapeHTML = _ref$escapeHTML === void 0 ? true : _ref$escapeHTML,
        _ref$transformItems = _ref.transformItems,
        transformItems = _ref$transformItems === void 0 ? function (items) {
      return items;
    } : _ref$transformItems;

    var sendEvent;
    var bindEvent;
    return {
      $$type: 'ais.hits',
      init: function init(initOptions) {
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {
          instantSearchInstance: initOptions.instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var renderState = this.getWidgetRenderState(renderOptions);
        renderState.sendEvent('view', renderState.hits);
        renderFn(_objectSpread(_objectSpread({}, renderState), {}, {
          instantSearchInstance: renderOptions.instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return _objectSpread(_objectSpread({}, renderState), {}, {
          hits: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var results = _ref2.results,
            helper = _ref2.helper,
            instantSearchInstance = _ref2.instantSearchInstance;

        if (!sendEvent) {
          sendEvent = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.createSendEventForHits)({
            instantSearchInstance: instantSearchInstance,
            index: helper.getIndex(),
            widgetType: this.$$type
          });
        }

        if (!bindEvent) {
          bindEvent = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.createBindEventForHits)({
            index: helper.getIndex(),
            widgetType: this.$$type
          });
        }

        if (!results) {
          return {
            hits: [],
            results: undefined,
            sendEvent: sendEvent,
            bindEvent: bindEvent,
            widgetParams: widgetParams
          };
        }

        if (escapeHTML && results.hits.length > 0) {
          results.hits = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.escapeHits)(results.hits);
        }

        var initialEscaped = results.hits.__escaped;
        results.hits = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.addAbsolutePosition)(results.hits, results.page, results.hitsPerPage);
        results.hits = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_6__.addQueryID)(results.hits, results.queryID);
        results.hits = transformItems(results.hits); // Make sure the escaped tag stays, even after mapping over the hits.
        // This prevents the hits from being double-escaped if there are multiple
        // hits widgets mounted on the page.

        results.hits.__escaped = initialEscaped;
        return {
          hits: results.hits,
          results: results,
          sendEvent: sendEvent,
          bindEvent: bindEvent,
          widgetParams: widgetParams
        };
      },
      dispose: function dispose(_ref3) {
        var state = _ref3.state;
        unmountFn();

        if (!escapeHTML) {
          return state;
        }

        return state.setQueryParameters(Object.keys(_lib_utils__WEBPACK_IMPORTED_MODULE_4__.TAG_PLACEHOLDER).reduce(function (acc, key) {
          return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, undefined));
        }, {}));
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(state) {
        if (!escapeHTML) {
          return state;
        }

        return state.setQueryParameters(_lib_utils__WEBPACK_IMPORTED_MODULE_4__.TAG_PLACEHOLDER);
      }
    };
  };
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (connectHits);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/connectors/pagination/Paginator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/connectors/pagination/Paginator.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/range.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Paginator = /*#__PURE__*/function () {
  function Paginator(params) {
    _classCallCheck(this, Paginator);

    _defineProperty(this, "currentPage", void 0);

    _defineProperty(this, "total", void 0);

    _defineProperty(this, "padding", void 0);

    this.currentPage = params.currentPage;
    this.total = params.total;
    this.padding = params.padding;
  }

  _createClass(Paginator, [{
    key: "pages",
    value: function pages() {
      var total = this.total,
          currentPage = this.currentPage,
          padding = this.padding;
      if (total === 0) return [0];
      var totalDisplayedPages = this.nbPagesDisplayed(padding, total);

      if (totalDisplayedPages === total) {
        return (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.default)({
          end: total
        });
      }

      var paddingLeft = this.calculatePaddingLeft(currentPage, padding, total, totalDisplayedPages);
      var paddingRight = totalDisplayedPages - paddingLeft;
      var first = currentPage - paddingLeft;
      var last = currentPage + paddingRight;
      return (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.default)({
        start: first,
        end: last
      });
    }
  }, {
    key: "nbPagesDisplayed",
    value: function nbPagesDisplayed(padding, total) {
      return Math.min(2 * padding + 1, total);
    }
  }, {
    key: "calculatePaddingLeft",
    value: function calculatePaddingLeft(current, padding, total, totalDisplayedPages) {
      if (current <= padding) {
        return current;
      }

      if (current >= total - padding) {
        return totalDisplayedPages - (total - current);
      }

      return padding;
    }
  }, {
    key: "isLastPage",
    value: function isLastPage() {
      return this.currentPage === this.total - 1 || this.total === 0;
    }
  }, {
    key: "isFirstPage",
    value: function isFirstPage() {
      return this.currentPage === 0;
    }
  }]);

  return Paginator;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Paginator);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/connectors/pagination/connectPagination.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/connectors/pagination/connectPagination.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/checkRendering.js");
/* harmony import */ var _Paginator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Paginator */ "./node_modules/instantsearch.js/es/connectors/pagination/Paginator.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.createDocumentationMessageGenerator)({
  name: 'pagination',
  connector: true
});

/**
 * **Pagination** connector provides the logic to build a widget that will let the user
 * choose the current page of the results.
 *
 * When using the pagination with Algolia, you should be aware that the engine won't provide you pages
 * beyond the 1000th hits by default. You can find more information on the [Algolia documentation](https://www.algolia.com/doc/guides/searching/pagination/#pagination-limitations).
 */
var connectPagination = function connectPagination(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lib_utils__WEBPACK_IMPORTED_MODULE_1__.default;
  (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)(renderFn, withUsage());
  return function (widgetParams) {
    var _ref = widgetParams || {},
        totalPages = _ref.totalPages,
        _ref$padding = _ref.padding,
        padding = _ref$padding === void 0 ? 3 : _ref$padding;

    var pager = new _Paginator__WEBPACK_IMPORTED_MODULE_3__.default({
      currentPage: 0,
      total: 0,
      padding: padding
    });
    var connectorState = {};

    function getMaxPage(_ref2) {
      var nbPages = _ref2.nbPages;
      return totalPages !== undefined ? Math.min(totalPages, nbPages) : nbPages;
    }

    return {
      $$type: 'ais.pagination',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref3) {
        var state = _ref3.state;
        unmountFn();
        return state.setQueryParameter('page', undefined);
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {
        var searchParameters = _ref4.searchParameters;
        var page = searchParameters.page || 0;

        if (!page) {
          return uiState;
        }

        return _objectSpread(_objectSpread({}, uiState), {}, {
          page: page + 1
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {
        var uiState = _ref5.uiState;
        var page = uiState.page ? uiState.page - 1 : 0;
        return searchParameters.setQueryParameter('page', page);
      },
      getWidgetRenderState: function getWidgetRenderState(_ref6) {
        var results = _ref6.results,
            helper = _ref6.helper,
            createURL = _ref6.createURL;

        if (!connectorState.refine) {
          connectorState.refine = function (page) {
            helper.setPage(page);
            helper.search();
          };
        }

        if (!connectorState.createURL) {
          connectorState.createURL = function (state) {
            return function (page) {
              return createURL(state.setPage(page));
            };
          };
        }

        var state = helper.state;
        var page = state.page || 0;
        var nbPages = getMaxPage(results || {
          nbPages: 0
        });
        pager.currentPage = page;
        pager.total = nbPages;
        return {
          createURL: connectorState.createURL(state),
          refine: connectorState.refine,
          canRefine: nbPages > 1,
          currentRefinement: page,
          nbHits: (results === null || results === void 0 ? void 0 : results.nbHits) || 0,
          nbPages: nbPages,
          pages: results ? pager.pages() : [],
          isFirstPage: pager.isFirstPage(),
          isLastPage: pager.isLastPage(),
          widgetParams: widgetParams
        };
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return _objectSpread(_objectSpread({}, renderState), {}, {
          pagination: this.getWidgetRenderState(renderOptions)
        });
      }
    };
  };
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (connectPagination);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/connectors/search-box/connectSearchBox.js":
/*!************************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/connectors/search-box/connectSearchBox.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/checkRendering.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.createDocumentationMessageGenerator)({
  name: 'search-box',
  connector: true
});

/**
 * **SearchBox** connector provides the logic to build a widget that will let the user search for a query.
 *
 * The connector provides to the rendering: `refine()` to set the query. The behaviour of this function
 * may be impacted by the `queryHook` widget parameter.
 */
var connectSearchBox = function connectSearchBox(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lib_utils__WEBPACK_IMPORTED_MODULE_1__.default;
  (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)(renderFn, withUsage());
  return function (widgetParams) {
    var _ref = widgetParams || {},
        queryHook = _ref.queryHook;

    function clear(helper) {
      return function () {
        helper.setQuery('').search();
      };
    }

    var _refine;

    var _clear = function _clear() {};

    function _cachedClear() {
      _clear();
    }

    return {
      $$type: 'ais.searchBox',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref2) {
        var state = _ref2.state;
        unmountFn();
        return state.setQueryParameter('query', undefined);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return _objectSpread(_objectSpread({}, renderState), {}, {
          searchBox: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref3) {
        var helper = _ref3.helper,
            searchMetadata = _ref3.searchMetadata;

        if (!_refine) {
          var setQueryAndSearch = function setQueryAndSearch(query) {
            if (query !== helper.state.query) {
              helper.setQuery(query).search();
            }
          };

          _refine = function _refine(query) {
            if (queryHook) {
              queryHook(query, setQueryAndSearch);
              return;
            }

            setQueryAndSearch(query);
          };
        }

        _clear = clear(helper);
        return {
          query: helper.state.query || '',
          refine: _refine,
          clear: _cachedClear,
          widgetParams: widgetParams,
          isSearchStalled: searchMetadata.isSearchStalled
        };
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {
        var searchParameters = _ref4.searchParameters;
        var query = searchParameters.query || '';

        if (query === '' || uiState && uiState.query === query) {
          return uiState;
        }

        return _objectSpread(_objectSpread({}, uiState), {}, {
          query: query
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {
        var uiState = _ref5.uiState;
        return searchParameters.setQueryParameter('query', uiState.query || '');
      }
    };
  };
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (connectSearchBox);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/connectors/stats/connectStats.js":
/*!***************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/connectors/stats/connectStats.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/checkRendering.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.createDocumentationMessageGenerator)({
  name: 'stats',
  connector: true
});
/**
 * **Stats** connector provides the logic to build a custom widget that will displays
 * search statistics (hits number and processing time).
 */

var connectStats = function connectStats(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lib_utils__WEBPACK_IMPORTED_MODULE_1__.default;
  (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)(renderFn, withUsage());
  return function (widgetParams) {
    return {
      $$type: 'ais.stats',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose() {
        unmountFn();
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return _objectSpread(_objectSpread({}, renderState), {}, {
          stats: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref) {
        var results = _ref.results,
            helper = _ref.helper;

        if (!results) {
          return {
            hitsPerPage: helper.state.hitsPerPage,
            nbHits: 0,
            nbSortedHits: undefined,
            areHitsSorted: false,
            nbPages: 0,
            page: helper.state.page || 0,
            processingTimeMS: -1,
            query: helper.state.query || '',
            widgetParams: widgetParams
          };
        }

        return {
          hitsPerPage: results.hitsPerPage,
          nbHits: results.nbHits,
          nbSortedHits: results.nbSortedHits,
          areHitsSorted: typeof results.appliedRelevancyStrictness !== 'undefined' && results.appliedRelevancyStrictness > 0 && results.nbSortedHits !== results.nbHits,
          nbPages: results.nbPages,
          page: results.page,
          processingTimeMS: results.processingTimeMS,
          query: results.query,
          widgetParams: widgetParams
        };
      }
    };
  };
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (connectStats);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/helpers/get-insights-anonymous-user-token.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/helpers/get-insights-anonymous-user-token.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANONYMOUS_TOKEN_COOKIE_KEY": () => (/* binding */ ANONYMOUS_TOKEN_COOKIE_KEY),
/* harmony export */   "getInsightsAnonymousUserTokenInternal": () => (/* binding */ getInsightsAnonymousUserTokenInternal),
/* harmony export */   "default": () => (/* binding */ getInsightsAnonymousUserToken)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/logger.js");

var ANONYMOUS_TOKEN_COOKIE_KEY = '_ALGOLIA';

function getCookie(name) {
  var prefix = "".concat(name, "=");
  var cookies = document.cookie.split(';');

  for (var i = 0; i < cookies.length; i++) {
    var cookie = cookies[i];

    while (cookie.charAt(0) === ' ') {
      cookie = cookie.substring(1);
    }

    if (cookie.indexOf(prefix) === 0) {
      return cookie.substring(prefix.length, cookie.length);
    }
  }

  return undefined;
}

function getInsightsAnonymousUserTokenInternal() {
  return getCookie(ANONYMOUS_TOKEN_COOKIE_KEY);
}
/**
 * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/
 */

function getInsightsAnonymousUserToken() {
   true ? (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.warning)(false, "`getInsightsAnonymousUserToken` function has been deprecated. It is still supported in 4.x releases, but not further. It is replaced by the `insights` middleware.\n\nFor more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/") : 0;
  return getInsightsAnonymousUserTokenInternal();
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/helpers/highlight.js":
/*!***************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/helpers/highlight.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ highlight)
/* harmony export */ });
/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/suit */ "./node_modules/instantsearch.js/es/lib/suit.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js");


var suit = (0,_lib_suit__WEBPACK_IMPORTED_MODULE_0__.component)('Highlight');
function highlight(_ref) {
  var attribute = _ref.attribute,
      _ref$highlightedTagNa = _ref.highlightedTagName,
      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,
      hit = _ref.hit,
      _ref$cssClasses = _ref.cssClasses,
      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;

  var _ref2 = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.default)(hit._highlightResult, attribute) || {},
      _ref2$value = _ref2.value,
      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular


  var className = suit({
    descendantName: 'highlighted'
  }) + (cssClasses.highlighted ? " ".concat(cssClasses.highlighted) : '');
  return attributeValue.replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_2__.TAG_REPLACEMENT.highlightPreTag, 'g'), "<".concat(highlightedTagName, " class=\"").concat(className, "\">")).replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_2__.TAG_REPLACEMENT.highlightPostTag, 'g'), "</".concat(highlightedTagName, ">"));
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/helpers/insights.js":
/*!**************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/helpers/insights.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readDataAttributes": () => (/* binding */ readDataAttributes),
/* harmony export */   "hasDataAttributes": () => (/* binding */ hasDataAttributes),
/* harmony export */   "writeDataAttributes": () => (/* binding */ writeDataAttributes),
/* harmony export */   "default": () => (/* binding */ insights)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/serializer.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


function readDataAttributes(domElement) {
  var method = domElement.getAttribute('data-insights-method');
  var serializedPayload = domElement.getAttribute('data-insights-payload');

  if (typeof serializedPayload !== 'string') {
    throw new Error('The insights helper expects `data-insights-payload` to be a base64-encoded JSON string.');
  }

  try {
    var payload = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.deserializePayload)(serializedPayload);
    return {
      method: method,
      payload: payload
    };
  } catch (error) {
    throw new Error('The insights helper was unable to parse `data-insights-payload`.');
  }
}
function hasDataAttributes(domElement) {
  return domElement.hasAttribute('data-insights-method');
}
function writeDataAttributes(_ref) {
  var method = _ref.method,
      payload = _ref.payload;

  if (_typeof(payload) !== 'object') {
    throw new Error("The insights helper expects the payload to be an object.");
  }

  var serializedPayload;

  try {
    serializedPayload = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.serializePayload)(payload);
  } catch (error) {
    throw new Error("Could not JSON serialize the payload object.");
  }

  return "data-insights-method=\"".concat(method, "\" data-insights-payload=\"").concat(serializedPayload, "\"");
}
/**
 * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/
 */

function insights(method, payload) {
   true ? (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.warning)(false, "`insights` function has been deprecated. It is still supported in 4.x releases, but not further. It is replaced by the `insights` middleware.\n\nFor more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/") : 0;
  return writeDataAttributes({
    method: method,
    payload: payload
  });
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/helpers/reverseHighlight.js":
/*!**********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/helpers/reverseHighlight.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ reverseHighlight)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/concatHighlightedParts.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/reverseHighlightedParts.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getHighlightedParts.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js");
/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/suit */ "./node_modules/instantsearch.js/es/lib/suit.js");


var suit = (0,_lib_suit__WEBPACK_IMPORTED_MODULE_0__.component)('ReverseHighlight');
function reverseHighlight(_ref) {
  var attribute = _ref.attribute,
      _ref$highlightedTagNa = _ref.highlightedTagName,
      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,
      hit = _ref.hit,
      _ref$cssClasses = _ref.cssClasses,
      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;

  var _ref2 = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.default)(hit._highlightResult, attribute) || {},
      _ref2$value = _ref2.value,
      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular


  var className = suit({
    descendantName: 'highlighted'
  }) + (cssClasses.highlighted ? " ".concat(cssClasses.highlighted) : '');
  var reverseHighlightedValue = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)((0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.default)((0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.default)(attributeValue)));
  return reverseHighlightedValue.replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_5__.TAG_REPLACEMENT.highlightPreTag, 'g'), "<".concat(highlightedTagName, " class=\"").concat(className, "\">")).replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_5__.TAG_REPLACEMENT.highlightPostTag, 'g'), "</".concat(highlightedTagName, ">"));
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/helpers/reverseSnippet.js":
/*!********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/helpers/reverseSnippet.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ reverseSnippet)
/* harmony export */ });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/concatHighlightedParts.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/reverseHighlightedParts.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getHighlightedParts.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js");
/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/suit */ "./node_modules/instantsearch.js/es/lib/suit.js");


var suit = (0,_lib_suit__WEBPACK_IMPORTED_MODULE_0__.component)('ReverseSnippet');
function reverseSnippet(_ref) {
  var attribute = _ref.attribute,
      _ref$highlightedTagNa = _ref.highlightedTagName,
      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,
      hit = _ref.hit,
      _ref$cssClasses = _ref.cssClasses,
      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;

  var _ref2 = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.default)(hit._snippetResult, attribute) || {},
      _ref2$value = _ref2.value,
      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular


  var className = suit({
    descendantName: 'highlighted'
  }) + (cssClasses.highlighted ? " ".concat(cssClasses.highlighted) : '');
  var reverseHighlightedValue = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)((0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.default)((0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.default)(attributeValue)));
  return reverseHighlightedValue.replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_5__.TAG_REPLACEMENT.highlightPreTag, 'g'), "<".concat(highlightedTagName, " class=\"").concat(className, "\">")).replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_5__.TAG_REPLACEMENT.highlightPostTag, 'g'), "</".concat(highlightedTagName, ">"));
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/helpers/snippet.js":
/*!*************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/helpers/snippet.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ snippet)
/* harmony export */ });
/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/suit */ "./node_modules/instantsearch.js/es/lib/suit.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js");


var suit = (0,_lib_suit__WEBPACK_IMPORTED_MODULE_0__.component)('Snippet');
function snippet(_ref) {
  var attribute = _ref.attribute,
      _ref$highlightedTagNa = _ref.highlightedTagName,
      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,
      hit = _ref.hit,
      _ref$cssClasses = _ref.cssClasses,
      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;

  var _ref2 = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.default)(hit._snippetResult, attribute) || {},
      _ref2$value = _ref2.value,
      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular


  var className = suit({
    descendantName: 'highlighted'
  }) + (cssClasses.highlighted ? " ".concat(cssClasses.highlighted) : '');
  return attributeValue.replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_2__.TAG_REPLACEMENT.highlightPreTag, 'g'), "<".concat(highlightedTagName, " class=\"").concat(className, "\">")).replace(new RegExp(_lib_utils__WEBPACK_IMPORTED_MODULE_2__.TAG_REPLACEMENT.highlightPostTag, 'g'), "</".concat(highlightedTagName, ">"));
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/index.js":
/*!***************************************************!*\
  !*** ./node_modules/instantsearch.js/es/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_InstantSearch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/InstantSearch */ "./node_modules/instantsearch.js/es/lib/InstantSearch.js");
/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/version */ "./node_modules/instantsearch.js/es/lib/version.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers */ "./node_modules/instantsearch.js/es/helpers/highlight.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers */ "./node_modules/instantsearch.js/es/helpers/reverseHighlight.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helpers */ "./node_modules/instantsearch.js/es/helpers/snippet.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers */ "./node_modules/instantsearch.js/es/helpers/reverseSnippet.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers */ "./node_modules/instantsearch.js/es/helpers/insights.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helpers */ "./node_modules/instantsearch.js/es/helpers/get-insights-anonymous-user-token.js");
/* harmony import */ var _lib_infiniteHitsCache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/infiniteHitsCache */ "./node_modules/instantsearch.js/es/lib/infiniteHitsCache/sessionStorage.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/logger.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types */ "./node_modules/instantsearch.js/es/types/index.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_10__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types__WEBPACK_IMPORTED_MODULE_10__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);






/**
 * InstantSearch is the main component of InstantSearch.js. This object
 * manages the widget and lets you add new ones.
 *
 * Two parameters are required to get you started with InstantSearch.js:
 *  - `indexName`: the main index that you will use for your new search UI
 *  - `searchClient`: the search client to plug to InstantSearch.js
 *
 * The [search client provided by Algolia](algolia.com/doc/api-client/getting-started/what-is-the-api-client/javascript/)
 * needs an `appId` and an `apiKey`. Those parameters can be found in your
 * [Algolia dashboard](https://www.algolia.com/api-keys).
 *
 * If you want to get up and running quickly with InstantSearch.js, have a
 * look at the [getting started](https://www.algolia.com/doc/guides/building-search-ui/getting-started/js/).
 */
var instantsearch = function instantsearch(options) {
  return new _lib_InstantSearch__WEBPACK_IMPORTED_MODULE_0__.default(options);
};

instantsearch.version = _lib_version__WEBPACK_IMPORTED_MODULE_1__.default;
instantsearch.createInfiniteHitsSessionStorageCache = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.deprecate)(_lib_infiniteHitsCache__WEBPACK_IMPORTED_MODULE_3__.default, "import { createInfiniteHitsSessionStorageCache } from 'instantsearch.js/es/helpers'");
instantsearch.highlight = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.deprecate)(_helpers__WEBPACK_IMPORTED_MODULE_4__.default, "import { highlight } from 'instantsearch.js/es/helpers'");
instantsearch.reverseHighlight = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.deprecate)(_helpers__WEBPACK_IMPORTED_MODULE_5__.default, "import { reverseHighlight } from 'instantsearch.js/es/helpers'");
instantsearch.snippet = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.deprecate)(_helpers__WEBPACK_IMPORTED_MODULE_6__.default, "import { snippet } from 'instantsearch.js/es/helpers'");
instantsearch.reverseSnippet = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.deprecate)(_helpers__WEBPACK_IMPORTED_MODULE_7__.default, "import { reverseSnippet } from 'instantsearch.js/es/helpers'");
instantsearch.insights = _helpers__WEBPACK_IMPORTED_MODULE_8__.default;
instantsearch.getInsightsAnonymousUserToken = _helpers__WEBPACK_IMPORTED_MODULE_9__.default;
Object.defineProperty(instantsearch, 'widgets', {
  get: function get() {
    throw new ReferenceError("\"instantsearch.widgets\" are not available from the ES build.\n\nTo import the widgets:\n\nimport { searchBox } from 'instantsearch.js/es/widgets'");
  }
});
Object.defineProperty(instantsearch, 'connectors', {
  get: function get() {
    throw new ReferenceError("\"instantsearch.connectors\" are not available from the ES build.\n\nTo import the connectors:\n\nimport { connectSearchBox } from 'instantsearch.js/es/connectors'");
  }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instantsearch);



/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/InstantSearch.js":
/*!***************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/InstantSearch.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! algoliasearch-helper */ "./node_modules/algoliasearch-helper/index.js");
/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _widgets_index_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../widgets/index/index */ "./node_modules/instantsearch.js/es/widgets/index/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./version */ "./node_modules/instantsearch.js/es/lib/version.js");
/* harmony import */ var _createHelpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./createHelpers */ "./node_modules/instantsearch.js/es/lib/createHelpers.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./node_modules/instantsearch.js/es/lib/utils/defer.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ "./node_modules/instantsearch.js/es/lib/utils/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils */ "./node_modules/instantsearch.js/es/lib/utils/checkIndexUiState.js");
/* harmony import */ var _middlewares_createRouterMiddleware__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../middlewares/createRouterMiddleware */ "./node_modules/instantsearch.js/es/middlewares/createRouterMiddleware.js");
/* harmony import */ var _middlewares_createMetadataMiddleware__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../middlewares/createMetadataMiddleware */ "./node_modules/instantsearch.js/es/middlewares/createMetadataMiddleware.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var withUsage = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.createDocumentationMessageGenerator)({
  name: 'instantsearch'
});

function defaultCreateURL() {
  return '#';
}
/**
 * Global options for an InstantSearch instance.
 */


/**
 * The actual implementation of the InstantSearch. This is
 * created using the `instantsearch` factory function.
 * It emits the 'render' event every time a search is done
 */
var InstantSearch = /*#__PURE__*/function (_EventEmitter) {
  _inherits(InstantSearch, _EventEmitter);

  var _super = _createSuper(InstantSearch);

  function InstantSearch(options) {
    var _this;

    _classCallCheck(this, InstantSearch);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "client", void 0);

    _defineProperty(_assertThisInitialized(_this), "indexName", void 0);

    _defineProperty(_assertThisInitialized(_this), "insightsClient", void 0);

    _defineProperty(_assertThisInitialized(_this), "onStateChange", null);

    _defineProperty(_assertThisInitialized(_this), "helper", void 0);

    _defineProperty(_assertThisInitialized(_this), "mainHelper", void 0);

    _defineProperty(_assertThisInitialized(_this), "mainIndex", void 0);

    _defineProperty(_assertThisInitialized(_this), "started", void 0);

    _defineProperty(_assertThisInitialized(_this), "templatesConfig", void 0);

    _defineProperty(_assertThisInitialized(_this), "renderState", {});

    _defineProperty(_assertThisInitialized(_this), "_stalledSearchDelay", void 0);

    _defineProperty(_assertThisInitialized(_this), "_searchStalledTimer", void 0);

    _defineProperty(_assertThisInitialized(_this), "_isSearchStalled", void 0);

    _defineProperty(_assertThisInitialized(_this), "_initialUiState", void 0);

    _defineProperty(_assertThisInitialized(_this), "_createURL", void 0);

    _defineProperty(_assertThisInitialized(_this), "_searchFunction", void 0);

    _defineProperty(_assertThisInitialized(_this), "_mainHelperSearch", void 0);

    _defineProperty(_assertThisInitialized(_this), "middleware", []);

    _defineProperty(_assertThisInitialized(_this), "sendEventToInsights", void 0);

    _defineProperty(_assertThisInitialized(_this), "scheduleSearch", (0,_utils__WEBPACK_IMPORTED_MODULE_3__.default)(function () {
      if (_this.started) {
        _this.mainHelper.search();
      }
    }));

    _defineProperty(_assertThisInitialized(_this), "scheduleRender", (0,_utils__WEBPACK_IMPORTED_MODULE_3__.default)(function () {
      if (!_this.mainHelper.hasPendingRequests()) {
        clearTimeout(_this._searchStalledTimer);
        _this._searchStalledTimer = null;
        _this._isSearchStalled = false;
      }

      _this.mainIndex.render({
        instantSearchInstance: _assertThisInitialized(_this)
      });

      _this.emit('render');
    }));

    _defineProperty(_assertThisInitialized(_this), "onInternalStateChange", (0,_utils__WEBPACK_IMPORTED_MODULE_3__.default)(function () {
      var nextUiState = _this.mainIndex.getWidgetUiState({});

      _this.middleware.forEach(function (_ref) {
        var instance = _ref.instance;
        instance.onStateChange({
          uiState: nextUiState
        });
      });
    }));

    var _options$indexName = options.indexName,
        indexName = _options$indexName === void 0 ? null : _options$indexName,
        numberLocale = options.numberLocale,
        _options$initialUiSta = options.initialUiState,
        initialUiState = _options$initialUiSta === void 0 ? {} : _options$initialUiSta,
        _options$routing = options.routing,
        routing = _options$routing === void 0 ? null : _options$routing,
        searchFunction = options.searchFunction,
        _options$stalledSearc = options.stalledSearchDelay,
        stalledSearchDelay = _options$stalledSearc === void 0 ? 200 : _options$stalledSearc,
        _options$searchClient = options.searchClient,
        searchClient = _options$searchClient === void 0 ? null : _options$searchClient,
        _options$insightsClie = options.insightsClient,
        insightsClient = _options$insightsClie === void 0 ? null : _options$insightsClie,
        _options$onStateChang = options.onStateChange,
        onStateChange = _options$onStateChang === void 0 ? null : _options$onStateChang;

    if (indexName === null) {
      throw new Error(withUsage('The `indexName` option is required.'));
    }

    if (searchClient === null) {
      throw new Error(withUsage('The `searchClient` option is required.'));
    }

    if (typeof searchClient.search !== 'function') {
      throw new Error("The `searchClient` must implement a `search` method.\n\nSee: https://www.algolia.com/doc/guides/building-search-ui/going-further/backend-search/in-depth/backend-instantsearch/js/");
    }

    if (typeof searchClient.addAlgoliaAgent === 'function') {
      searchClient.addAlgoliaAgent("instantsearch.js (".concat(_version__WEBPACK_IMPORTED_MODULE_4__.default, ")"));
    }

     true ? (0,_utils__WEBPACK_IMPORTED_MODULE_5__.warning)(insightsClient === null, "`insightsClient` property has been deprecated. It is still supported in 4.x releases, but not further. It is replaced by the `insights` middleware.\n\nFor more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/") : 0;

    if (insightsClient && typeof insightsClient !== 'function') {
      throw new Error(withUsage('The `insightsClient` option should be a function.'));
    }

     true ? (0,_utils__WEBPACK_IMPORTED_MODULE_5__.warning)(!options.searchParameters, "The `searchParameters` option is deprecated and will not be supported in InstantSearch.js 4.x.\n\nYou can replace it with the `configure` widget:\n\n```\nsearch.addWidgets([\n  configure(".concat(JSON.stringify(options.searchParameters, null, 2), ")\n]);\n```\n\nSee ").concat((0,_utils__WEBPACK_IMPORTED_MODULE_2__.createDocumentationLink)({
      name: 'configure'
    }))) : 0;
    _this.client = searchClient;
    _this.insightsClient = insightsClient;
    _this.indexName = indexName;
    _this.helper = null;
    _this.mainHelper = null;
    _this.mainIndex = (0,_widgets_index_index__WEBPACK_IMPORTED_MODULE_6__.default)({
      indexName: indexName
    });
    _this.onStateChange = onStateChange;
    _this.started = false;
    _this.templatesConfig = {
      helpers: (0,_createHelpers__WEBPACK_IMPORTED_MODULE_7__.default)({
        numberLocale: numberLocale
      }),
      compileOptions: {}
    };
    _this._stalledSearchDelay = stalledSearchDelay;
    _this._searchStalledTimer = null;
    _this._isSearchStalled = false;
    _this._createURL = defaultCreateURL;
    _this._initialUiState = initialUiState;

    if (searchFunction) {
      _this._searchFunction = searchFunction;
    }

    _this.sendEventToInsights = _utils__WEBPACK_IMPORTED_MODULE_8__.default;

    if (routing) {
      var routerOptions = typeof routing === 'boolean' ? undefined : routing;

      _this.use((0,_middlewares_createRouterMiddleware__WEBPACK_IMPORTED_MODULE_9__.createRouterMiddleware)(routerOptions));
    }

    if ((0,_middlewares_createMetadataMiddleware__WEBPACK_IMPORTED_MODULE_10__.isMetadataEnabled)()) {
      _this.use((0,_middlewares_createMetadataMiddleware__WEBPACK_IMPORTED_MODULE_10__.createMetadataMiddleware)());
    }

    return _this;
  }
  /**
   * Hooks a middleware into the InstantSearch lifecycle.
   */


  _createClass(InstantSearch, [{
    key: "use",
    value: function use() {
      var _this2 = this;

      for (var _len = arguments.length, middleware = new Array(_len), _key = 0; _key < _len; _key++) {
        middleware[_key] = arguments[_key];
      }

      var newMiddlewareList = middleware.map(function (fn) {
        var newMiddleware = _objectSpread({
          subscribe: _utils__WEBPACK_IMPORTED_MODULE_8__.default,
          unsubscribe: _utils__WEBPACK_IMPORTED_MODULE_8__.default,
          onStateChange: _utils__WEBPACK_IMPORTED_MODULE_8__.default
        }, fn({
          instantSearchInstance: _this2
        }));

        _this2.middleware.push({
          creator: fn,
          instance: newMiddleware
        });

        return newMiddleware;
      }); // If the instance has already started, we directly subscribe the
      // middleware so they're notified of changes.

      if (this.started) {
        newMiddlewareList.forEach(function (m) {
          m.subscribe();
        });
      }

      return this;
    }
    /**
     * Removes a middleware from the InstantSearch lifecycle.
     */

  }, {
    key: "unuse",
    value: function unuse() {
      for (var _len2 = arguments.length, middlewareToUnuse = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        middlewareToUnuse[_key2] = arguments[_key2];
      }

      this.middleware.filter(function (m) {
        return middlewareToUnuse.includes(m.creator);
      }).forEach(function (m) {
        return m.instance.unsubscribe();
      });
      this.middleware = this.middleware.filter(function (m) {
        return !middlewareToUnuse.includes(m.creator);
      });
      return this;
    } // @major we shipped with EXPERIMENTAL_use, but have changed that to just `use` now

  }, {
    key: "EXPERIMENTAL_use",
    value: function EXPERIMENTAL_use() {
       true ? (0,_utils__WEBPACK_IMPORTED_MODULE_5__.warning)(false, 'The middleware API is now considered stable, so we recommend replacing `EXPERIMENTAL_use` with `use` before upgrading to the next major version.') : 0;
      return this.use.apply(this, arguments);
    }
    /**
     * Adds a widget to the search instance.
     * A widget can be added either before or after InstantSearch has started.
     * @param widget The widget to add to InstantSearch.
     *
     * @deprecated This method will still be supported in 4.x releases, but not further. It is replaced by `addWidgets([widget])`.
     */

  }, {
    key: "addWidget",
    value: function addWidget(widget) {
       true ? (0,_utils__WEBPACK_IMPORTED_MODULE_5__.warning)(false, 'addWidget will still be supported in 4.x releases, but not further. It is replaced by `addWidgets([widget])`') : 0;
      return this.addWidgets([widget]);
    }
    /**
     * Adds multiple widgets to the search instance.
     * Widgets can be added either before or after InstantSearch has started.
     * @param widgets The array of widgets to add to InstantSearch.
     */

  }, {
    key: "addWidgets",
    value: function addWidgets(widgets) {
      if (!Array.isArray(widgets)) {
        throw new Error(withUsage('The `addWidgets` method expects an array of widgets. Please use `addWidget`.'));
      }

      if (widgets.some(function (widget) {
        return typeof widget.init !== 'function' && typeof widget.render !== 'function';
      })) {
        throw new Error(withUsage('The widget definition expects a `render` and/or an `init` method.'));
      }

      this.mainIndex.addWidgets(widgets);
      return this;
    }
    /**
     * Removes a widget from the search instance.
     * @deprecated This method will still be supported in 4.x releases, but not further. It is replaced by `removeWidgets([widget])`
     * @param widget The widget instance to remove from InstantSearch.
     *
     * The widget must implement a `dispose()` method to clear its state.
     */

  }, {
    key: "removeWidget",
    value: function removeWidget(widget) {
       true ? (0,_utils__WEBPACK_IMPORTED_MODULE_5__.warning)(false, 'removeWidget will still be supported in 4.x releases, but not further. It is replaced by `removeWidgets([widget])`') : 0;
      return this.removeWidgets([widget]);
    }
    /**
     * Removes multiple widgets from the search instance.
     * @param widgets Array of widgets instances to remove from InstantSearch.
     *
     * The widgets must implement a `dispose()` method to clear their states.
     */

  }, {
    key: "removeWidgets",
    value: function removeWidgets(widgets) {
      if (!Array.isArray(widgets)) {
        throw new Error(withUsage('The `removeWidgets` method expects an array of widgets. Please use `removeWidget`.'));
      }

      if (widgets.some(function (widget) {
        return typeof widget.dispose !== 'function';
      })) {
        throw new Error(withUsage('The widget definition expects a `dispose` method.'));
      }

      this.mainIndex.removeWidgets(widgets);
      return this;
    }
    /**
     * Ends the initialization of InstantSearch.js and triggers the
     * first search. This method should be called after all widgets have been added
     * to the instance of InstantSearch.js. InstantSearch.js also supports adding and removing
     * widgets after the start as an **EXPERIMENTAL** feature.
     */

  }, {
    key: "start",
    value: function start() {
      var _this3 = this;

      if (this.started) {
        throw new Error(withUsage('The `start` method has already been called once.'));
      } // This Helper is used for the queries, we don't care about its state. The
      // states are managed at the `index` level. We use this Helper to create
      // DerivedHelper scoped into the `index` widgets.
      // In Vue InstantSearch' hydrate, a main helper gets set before start, so
      // we need to respect this helper as a way to keep all listeners correct.


      var mainHelper = this.mainHelper || algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default()(this.client, this.indexName);

      mainHelper.search = function () {
        // This solution allows us to keep the exact same API for the users but
        // under the hood, we have a different implementation. It should be
        // completely transparent for the rest of the codebase. Only this module
        // is impacted.
        return mainHelper.searchOnlyWithDerivedHelpers();
      };

      if (this._searchFunction) {
        // this client isn't used to actually search, but required for the helper
        // to not throw errors
        var fakeClient = {
          search: function search() {
            return new Promise(_utils__WEBPACK_IMPORTED_MODULE_8__.default);
          }
        };
        this._mainHelperSearch = mainHelper.search.bind(mainHelper);

        mainHelper.search = function () {
          var mainIndexHelper = _this3.mainIndex.getHelper();

          var searchFunctionHelper = algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default()(fakeClient, mainIndexHelper.state.index, mainIndexHelper.state);
          searchFunctionHelper.once('search', function (_ref2) {
            var state = _ref2.state;
            mainIndexHelper.overrideStateWithoutTriggeringChangeEvent(state);

            _this3._mainHelperSearch();
          }); // Forward state changes from `searchFunctionHelper` to `mainIndexHelper`

          searchFunctionHelper.on('change', function (_ref3) {
            var state = _ref3.state;
            mainIndexHelper.setState(state);
          });

          _this3._searchFunction(searchFunctionHelper);

          return mainHelper;
        };
      } // Only the "main" Helper emits the `error` event vs the one for `search`
      // and `results` that are also emitted on the derived one.


      mainHelper.on('error', function (_ref4) {
        var error = _ref4.error;

        _this3.emit('error', {
          error: error
        });
      });
      this.mainHelper = mainHelper;
      this.mainIndex.init({
        instantSearchInstance: this,
        parent: null,
        uiState: this._initialUiState
      });
      this.middleware.forEach(function (_ref5) {
        var instance = _ref5.instance;
        instance.subscribe();
      });
      mainHelper.search(); // Keep the previous reference for legacy purpose, some pattern use
      // the direct Helper access `search.helper` (e.g multi-index).

      this.helper = this.mainIndex.getHelper(); // track we started the search if we add more widgets,
      // to init them directly after add

      this.started = true;
    }
    /**
     * Removes all widgets without triggering a search afterwards. This is an **EXPERIMENTAL** feature,
     * if you find an issue with it, please
     * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20dispose).
     * @return {undefined} This method does not return anything
     */

  }, {
    key: "dispose",
    value: function dispose() {
      this.scheduleSearch.cancel();
      this.scheduleRender.cancel();
      clearTimeout(this._searchStalledTimer);
      this.removeWidgets(this.mainIndex.getWidgets());
      this.mainIndex.dispose(); // You can not start an instance two times, therefore a disposed instance
      // needs to set started as false otherwise this can not be restarted at a
      // later point.

      this.started = false; // The helper needs to be reset to perform the next search from a fresh state.
      // If not reset, it would use the state stored before calling `dispose()`.

      this.removeAllListeners();
      this.mainHelper.removeAllListeners();
      this.mainHelper = null;
      this.helper = null;
      this.middleware.forEach(function (_ref6) {
        var instance = _ref6.instance;
        instance.unsubscribe();
      });
    }
  }, {
    key: "scheduleStalledRender",
    value: function scheduleStalledRender() {
      var _this4 = this;

      if (!this._searchStalledTimer) {
        this._searchStalledTimer = setTimeout(function () {
          _this4._isSearchStalled = true;

          _this4.scheduleRender();
        }, this._stalledSearchDelay);
      }
    }
  }, {
    key: "setUiState",
    value: function setUiState(uiState) {
      if (!this.mainHelper) {
        throw new Error(withUsage('The `start` method needs to be called before `setUiState`.'));
      } // We refresh the index UI state to update the local UI state that the
      // main index passes to the function form of `setUiState`.


      this.mainIndex.refreshUiState();
      var nextUiState = typeof uiState === 'function' ? uiState(this.mainIndex.getWidgetUiState({})) : uiState;

      var setIndexHelperState = function setIndexHelperState(indexWidget) {
        if (true) {
          (0,_utils__WEBPACK_IMPORTED_MODULE_11__.checkIndexUiState)({
            index: indexWidget,
            indexUiState: nextUiState[indexWidget.getIndexId()]
          });
        }

        indexWidget.getHelper().setState(indexWidget.getWidgetSearchParameters(indexWidget.getHelper().state, {
          uiState: nextUiState[indexWidget.getIndexId()]
        }));
        indexWidget.getWidgets().filter(_widgets_index_index__WEBPACK_IMPORTED_MODULE_6__.isIndexWidget).forEach(setIndexHelperState);
      };

      setIndexHelperState(this.mainIndex);
      this.scheduleSearch();
      this.onInternalStateChange();
    }
  }, {
    key: "getUiState",
    value: function getUiState() {
      if (this.started) {
        // We refresh the index UI state to make sure changes from `refine` are taken in account
        this.mainIndex.refreshUiState();
      }

      return this.mainIndex.getWidgetUiState({});
    }
  }, {
    key: "createURL",
    value: function createURL() {
      var nextState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.started) {
        throw new Error(withUsage('The `start` method needs to be called before `createURL`.'));
      }

      return this._createURL(nextState);
    }
  }, {
    key: "refresh",
    value: function refresh() {
      if (!this.mainHelper) {
        throw new Error(withUsage('The `start` method needs to be called before `refresh`.'));
      }

      this.mainHelper.clearCache().search();
    }
  }]);

  return InstantSearch;
}((events__WEBPACK_IMPORTED_MODULE_1___default()));

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InstantSearch);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/createHelpers.js":
/*!***************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/createHelpers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hoganHelpers)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./node_modules/instantsearch.js/es/helpers/highlight.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ "./node_modules/instantsearch.js/es/helpers/reverseHighlight.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./node_modules/instantsearch.js/es/helpers/snippet.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./node_modules/instantsearch.js/es/helpers/reverseSnippet.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers */ "./node_modules/instantsearch.js/es/helpers/insights.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function hoganHelpers(_ref) {
  var numberLocale = _ref.numberLocale;
  return {
    formatNumber: function formatNumber(value, render) {
      return Number(render(value)).toLocaleString(numberLocale);
    },
    highlight: function highlight(options, render) {
      try {
        var highlightOptions = JSON.parse(options);
        return render((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.default)(_objectSpread(_objectSpread({}, highlightOptions), {}, {
          hit: this
        })));
      } catch (error) {
        throw new Error("\nThe highlight helper expects a JSON object of the format:\n{ \"attribute\": \"name\", \"highlightedTagName\": \"mark\" }");
      }
    },
    reverseHighlight: function reverseHighlight(options, render) {
      try {
        var reverseHighlightOptions = JSON.parse(options);
        return render((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.default)(_objectSpread(_objectSpread({}, reverseHighlightOptions), {}, {
          hit: this
        })));
      } catch (error) {
        throw new Error("\n  The reverseHighlight helper expects a JSON object of the format:\n  { \"attribute\": \"name\", \"highlightedTagName\": \"mark\" }");
      }
    },
    snippet: function snippet(options, render) {
      try {
        var snippetOptions = JSON.parse(options);
        return render((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.default)(_objectSpread(_objectSpread({}, snippetOptions), {}, {
          hit: this
        })));
      } catch (error) {
        throw new Error("\nThe snippet helper expects a JSON object of the format:\n{ \"attribute\": \"name\", \"highlightedTagName\": \"mark\" }");
      }
    },
    reverseSnippet: function reverseSnippet(options, render) {
      try {
        var reverseSnippetOptions = JSON.parse(options);
        return render((0,_helpers__WEBPACK_IMPORTED_MODULE_3__.default)(_objectSpread(_objectSpread({}, reverseSnippetOptions), {}, {
          hit: this
        })));
      } catch (error) {
        throw new Error("\n  The reverseSnippet helper expects a JSON object of the format:\n  { \"attribute\": \"name\", \"highlightedTagName\": \"mark\" }");
      }
    },
    insights: function insights(options, render) {
      try {
        var _JSON$parse = JSON.parse(options),
            method = _JSON$parse.method,
            payload = _JSON$parse.payload;

        return render((0,_helpers__WEBPACK_IMPORTED_MODULE_4__.default)(method, _objectSpread({
          objectIDs: [this.objectID]
        }, payload)));
      } catch (error) {
        throw new Error("\nThe insights helper expects a JSON object of the format:\n{ \"method\": \"method-name\", \"payload\": { \"eventName\": \"name of the event\" } }");
      }
    }
  };
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/infiniteHitsCache/sessionStorage.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/infiniteHitsCache/sessionStorage.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createInfiniteHitsSessionStorageCache)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/instantsearch.js/es/lib/utils/isEqual.js");
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



function getStateWithoutPage(state) {
  var _ref = state || {},
      page = _ref.page,
      rest = _objectWithoutProperties(_ref, ["page"]);

  return rest;
}

var KEY = 'ais.infiniteHits';

function hasSessionStorage() {
  return typeof window !== 'undefined' && typeof window.sessionStorage !== 'undefined';
}

function createInfiniteHitsSessionStorageCache() {
  return {
    read: function read(_ref2) {
      var state = _ref2.state;

      if (!hasSessionStorage()) {
        return null;
      }

      try {
        var cache = JSON.parse( // @ts-expect-error JSON.parse() requires a string, but it actually accepts null, too.
        window.sessionStorage.getItem(KEY));
        return cache && (0,_utils__WEBPACK_IMPORTED_MODULE_0__.default)(cache.state, getStateWithoutPage(state)) ? cache.hits : null;
      } catch (error) {
        if (error instanceof SyntaxError) {
          try {
            window.sessionStorage.removeItem(KEY);
          } catch (err) {// do nothing
          }
        }

        return null;
      }
    },
    write: function write(_ref3) {
      var state = _ref3.state,
          hits = _ref3.hits;

      if (!hasSessionStorage()) {
        return;
      }

      try {
        window.sessionStorage.setItem(KEY, JSON.stringify({
          state: getStateWithoutPage(state),
          hits: hits
        }));
      } catch (error) {// do nothing
      }
    }
  };
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/insights/client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/insights/client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "inferPayload": () => (/* binding */ inferPayload),
/* harmony export */   "default": () => (/* binding */ withInsights)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/instantsearch.js/es/lib/utils/find.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/instantsearch.js/es/lib/utils/uniq.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./node_modules/instantsearch.js/es/lib/utils/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var getSelectedHits = function getSelectedHits(hits, selectedObjectIDs) {
  return selectedObjectIDs.map(function (objectID) {
    var hit = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.default)(hits, function (h) {
      return h.objectID === objectID;
    });

    if (typeof hit === 'undefined') {
      throw new Error("Could not find objectID \"".concat(objectID, "\" passed to `clickedObjectIDsAfterSearch` in the returned hits. This is necessary to infer the absolute position and the query ID."));
    }

    return hit;
  });
};

var getQueryID = function getQueryID(selectedHits) {
  var queryIDs = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.default)(selectedHits.map(function (hit) {
    return hit.__queryID;
  }));

  if (queryIDs.length > 1) {
    throw new Error('Insights currently allows a single `queryID`. The `objectIDs` provided map to multiple `queryID`s.');
  }

  var queryID = queryIDs[0];

  if (typeof queryID !== 'string') {
    throw new Error("Could not infer `queryID`. Ensure InstantSearch `clickAnalytics: true` was added with the Configure widget.\n\nSee: https://alg.li/lNiZZ7");
  }

  return queryID;
};

var getPositions = function getPositions(selectedHits) {
  return selectedHits.map(function (hit) {
    return hit.__position;
  });
};

var inferPayload = function inferPayload(_ref) {
  var method = _ref.method,
      results = _ref.results,
      hits = _ref.hits,
      objectIDs = _ref.objectIDs;
  var index = results.index;
  var selectedHits = getSelectedHits(hits, objectIDs);
  var queryID = getQueryID(selectedHits);

  switch (method) {
    case 'clickedObjectIDsAfterSearch':
      {
        var positions = getPositions(selectedHits);
        return {
          index: index,
          queryID: queryID,
          objectIDs: objectIDs,
          positions: positions
        };
      }

    case 'convertedObjectIDsAfterSearch':
      return {
        index: index,
        queryID: queryID,
        objectIDs: objectIDs
      };

    default:
      throw new Error("Unsupported method passed to insights: \"".concat(method, "\"."));
  }
};

var wrapInsightsClient = function wrapInsightsClient(aa, results, hits) {
  return function (method, payload) {
     true ? (0,_utils__WEBPACK_IMPORTED_MODULE_2__.warning)(false, "`insights` function has been deprecated. It is still supported in 4.x releases, but not further. It is replaced by the `insights` middleware.\n\nFor more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/") : 0;

    if (!aa) {
      var withInstantSearchUsage = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.createDocumentationMessageGenerator)({
        name: 'instantsearch'
      });
      throw new Error(withInstantSearchUsage('The `insightsClient` option has not been provided to `instantsearch`.'));
    }

    if (!Array.isArray(payload.objectIDs)) {
      throw new TypeError('Expected `objectIDs` to be an array.');
    }

    var inferredPayload = inferPayload({
      method: method,
      results: results,
      hits: hits,
      objectIDs: payload.objectIDs
    });
    aa(method, _objectSpread(_objectSpread({}, inferredPayload), payload));
  };
};
/**
 * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/
 * It passes `insights` to `HitsWithInsightsListener` and `InfiniteHitsWithInsightsListener`.
 */


function withInsights(connector) {
  return function (renderFn, unmountFn) {
    return connector(function (renderOptions, isFirstRender) {
      var results = renderOptions.results,
          hits = renderOptions.hits,
          instantSearchInstance = renderOptions.instantSearchInstance;

      if (results && hits && instantSearchInstance) {
        var insights = wrapInsightsClient(instantSearchInstance.insightsClient, results, hits);
        return renderFn(_objectSpread(_objectSpread({}, renderOptions), {}, {
          insights: insights
        }), isFirstRender);
      }

      return renderFn(renderOptions, isFirstRender);
    }, unmountFn);
  };
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/insights/listener.js":
/*!*******************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/insights/listener.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/instantsearch.js/es/lib/utils/serializer.js");
/* harmony import */ var _helpers_insights__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/insights */ "./node_modules/instantsearch.js/es/helpers/insights.js");
/** @jsx h */




var findInsightsTarget = function findInsightsTarget(startElement, endElement, validator) {
  var element = startElement;

  while (element && !validator(element)) {
    if (element === endElement) {
      return null;
    }

    element = element.parentElement;
  }

  return element;
};

var parseInsightsEvent = function parseInsightsEvent(element) {
  var serializedPayload = element.getAttribute('data-insights-event');

  if (typeof serializedPayload !== 'string') {
    throw new Error('The insights middleware expects `data-insights-event` to be a base64-encoded JSON string.');
  }

  try {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.deserializePayload)(serializedPayload);
  } catch (error) {
    throw new Error('The insights middleware was unable to parse `data-insights-event`.');
  }
};

var insightsListener = function insightsListener(BaseComponent) {
  function WithInsightsListener(props) {
    var handleClick = function handleClick(event) {
      if (props.sendEvent) {
        // new way with insights middleware
        var targetWithEvent = findInsightsTarget(event.target, event.currentTarget, function (element) {
          return element.hasAttribute('data-insights-event');
        });

        if (targetWithEvent) {
          var payload = parseInsightsEvent(targetWithEvent);
          props.sendEvent(payload);
        }
      } // old way, e.g. instantsearch.insights("clickedObjectIDsAfterSearch", { .. })


      var insightsTarget = findInsightsTarget(event.target, event.currentTarget, function (element) {
        return (0,_helpers_insights__WEBPACK_IMPORTED_MODULE_2__.hasDataAttributes)(element);
      });

      if (insightsTarget) {
        var _readDataAttributes = (0,_helpers_insights__WEBPACK_IMPORTED_MODULE_2__.readDataAttributes)(insightsTarget),
            method = _readDataAttributes.method,
            _payload = _readDataAttributes.payload;

        props.insights(method, _payload);
      }
    };

    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
      onClick: handleClick
    }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(BaseComponent, props));
  }

  return WithInsightsListener;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (insightsListener);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/routers/history.js":
/*!*****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/routers/history.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ historyRouter)
/* harmony export */ });
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");
/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_0__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var setWindowTitle = function setWindowTitle(title) {
  if (title) {
    window.document.title = title;
  }
};

var BrowserHistory = /*#__PURE__*/function () {
  /**
   * Initializes a new storage provider that syncs the search state to the URL
   * using web APIs (`window.location.pushState` and `onpopstate` event).
   */
  function BrowserHistory(_ref) {
    var windowTitle = _ref.windowTitle,
        _ref$writeDelay = _ref.writeDelay,
        writeDelay = _ref$writeDelay === void 0 ? 400 : _ref$writeDelay,
        createURL = _ref.createURL,
        parseURL = _ref.parseURL;

    _classCallCheck(this, BrowserHistory);

    _defineProperty(this, "windowTitle", void 0);

    _defineProperty(this, "writeDelay", void 0);

    _defineProperty(this, "_createURL", void 0);

    _defineProperty(this, "parseURL", void 0);

    _defineProperty(this, "writeTimer", void 0);

    this.windowTitle = windowTitle;
    this.writeTimer = undefined;
    this.writeDelay = writeDelay;
    this._createURL = createURL;
    this.parseURL = parseURL;
    var title = this.windowTitle && this.windowTitle(this.read());
    setWindowTitle(title);
  }
  /**
   * Reads the URL and returns a syncable UI search state.
   */


  _createClass(BrowserHistory, [{
    key: "read",
    value: function read() {
      return this.parseURL({
        qsModule: (qs__WEBPACK_IMPORTED_MODULE_0___default()),
        location: window.location
      });
    }
    /**
     * Pushes a search state into the URL.
     */

  }, {
    key: "write",
    value: function write(routeState) {
      var _this = this;

      var url = this.createURL(routeState);
      var title = this.windowTitle && this.windowTitle(routeState);

      if (this.writeTimer) {
        window.clearTimeout(this.writeTimer);
      }

      this.writeTimer = window.setTimeout(function () {
        setWindowTitle(title);
        window.history.pushState(routeState, title || '', url);
        _this.writeTimer = undefined;
      }, this.writeDelay);
    }
    /**
     * Sets a callback on the `onpopstate` event of the history API of the current page.
     * It enables the URL sync to keep track of the changes.
     */

  }, {
    key: "onUpdate",
    value: function onUpdate(callback) {
      var _this2 = this;

      this._onPopState = function (event) {
        if (_this2.writeTimer) {
          window.clearTimeout(_this2.writeTimer);
          _this2.writeTimer = undefined;
        }

        var routeState = event.state; // At initial load, the state is read from the URL without update.
        // Therefore the state object is not available.
        // In this case, we fallback and read the URL.

        if (!routeState) {
          callback(_this2.read());
        } else {
          callback(routeState);
        }
      };

      window.addEventListener('popstate', this._onPopState);
    }
    /**
     * Creates a complete URL from a given syncable UI state.
     *
     * It always generates the full URL, not a relative one.
     * This allows to handle cases like using a <base href>.
     * See: https://github.com/algolia/instantsearch.js/issues/790
     */

  }, {
    key: "createURL",
    value: function createURL(routeState) {
      return this._createURL({
        qsModule: (qs__WEBPACK_IMPORTED_MODULE_0___default()),
        routeState: routeState,
        location: window.location
      });
    }
    /**
     * Removes the event listener and cleans up the URL.
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this._onPopState) {
        window.removeEventListener('popstate', this._onPopState);
      }

      if (this.writeTimer) {
        window.clearTimeout(this.writeTimer);
      }

      this.write({});
    }
  }]);

  return BrowserHistory;
}();

function historyRouter() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$createURL = _ref2.createURL,
      createURL = _ref2$createURL === void 0 ? function (_ref3) {
    var qsModule = _ref3.qsModule,
        routeState = _ref3.routeState,
        location = _ref3.location;
    var protocol = location.protocol,
        hostname = location.hostname,
        _location$port = location.port,
        port = _location$port === void 0 ? '' : _location$port,
        pathname = location.pathname,
        hash = location.hash;
    var queryString = qsModule.stringify(routeState);
    var portWithPrefix = port === '' ? '' : ":".concat(port); // IE <= 11 has no proper `location.origin` so we cannot rely on it.

    // IE <= 11 has no proper `location.origin` so we cannot rely on it.
    if (!queryString) {
      return "".concat(protocol, "//").concat(hostname).concat(portWithPrefix).concat(pathname).concat(hash);
    }

    return "".concat(protocol, "//").concat(hostname).concat(portWithPrefix).concat(pathname, "?").concat(queryString).concat(hash);
  } : _ref2$createURL,
      _ref2$parseURL = _ref2.parseURL,
      parseURL = _ref2$parseURL === void 0 ? function (_ref4) {
    var qsModule = _ref4.qsModule,
        location = _ref4.location;
    // `qs` by default converts arrays with more than 20 items to an object.
    // We want to avoid this because the data structure manipulated can therefore vary.
    // Setting the limit to `100` seems a good number because the engine's default is 100
    // (it can go up to 1000 but it is very unlikely to select more than 100 items in the UI).
    //
    // Using an `arrayLimit` of `n` allows `n + 1` items.
    //
    // See:
    //   - https://github.com/ljharb/qs#parsing-arrays
    //   - https://www.algolia.com/doc/api-reference/api-parameters/maxValuesPerFacet/
    return qsModule.parse(location.search.slice(1), {
      arrayLimit: 99
    });
  } : _ref2$parseURL,
      _ref2$writeDelay = _ref2.writeDelay,
      writeDelay = _ref2$writeDelay === void 0 ? 400 : _ref2$writeDelay,
      windowTitle = _ref2.windowTitle;

  return new BrowserHistory({
    createURL: createURL,
    parseURL: parseURL,
    writeDelay: writeDelay,
    windowTitle: windowTitle
  });
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/stateMappings/simple.js":
/*!**********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/stateMappings/simple.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ simpleStateMapping)
/* harmony export */ });
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function getIndexStateWithoutConfigure(uiState) {
  var configure = uiState.configure,
      trackedUiState = _objectWithoutProperties(uiState, ["configure"]);

  return trackedUiState;
} // technically a URL could contain any key, since users provide it,
// which is why the input to this function is UiState, not something
// which excludes "configure" as this function does.


function simpleStateMapping() {
  return {
    stateToRoute: function stateToRoute(uiState) {
      return Object.keys(uiState).reduce(function (state, indexId) {
        return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, indexId, getIndexStateWithoutConfigure(uiState[indexId])));
      }, {});
    },
    routeToState: function routeToState() {
      var routeState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return Object.keys(routeState).reduce(function (state, indexId) {
        return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, indexId, getIndexStateWithoutConfigure(routeState[indexId])));
      }, {});
    }
  };
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/suit.js":
/*!******************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/suit.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "component": () => (/* binding */ component)
/* harmony export */ });
var NAMESPACE = 'ais';
var component = function component(componentName) {
  return function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        descendantName = _ref.descendantName,
        modifierName = _ref.modifierName;

    var descendent = descendantName ? "-".concat(descendantName) : '';
    var modifier = modifierName ? "--".concat(modifierName) : '';
    return "".concat(NAMESPACE, "-").concat(componentName).concat(descendent).concat(modifier);
  };
};

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/capitalize.js":
/*!******************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/capitalize.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function capitalize(text) {
  return text.toString().charAt(0).toUpperCase() + text.toString().slice(1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (capitalize);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/checkIndexUiState.js":
/*!*************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/checkIndexUiState.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkIndexUiState": () => (/* binding */ checkIndexUiState)
/* harmony export */ });
/* harmony import */ var _capitalize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./capitalize */ "./node_modules/instantsearch.js/es/lib/utils/capitalize.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger */ "./node_modules/instantsearch.js/es/lib/utils/logger.js");
/* harmony import */ var _typedObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typedObject */ "./node_modules/instantsearch.js/es/lib/utils/typedObject.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



 // Some connectors are responsible for multiple widgets so we need
// to map them.

function getWidgetNames(connectorName) {
  switch (connectorName) {
    case 'range':
      return [];

    case 'menu':
      return ['menu', 'menuSelect'];

    default:
      return [connectorName];
  }
}

var stateToWidgetsMap = {
  query: {
    connectors: ['connectSearchBox'],
    widgets: ['ais.searchBox', 'ais.autocomplete', 'ais.voiceSearch']
  },
  refinementList: {
    connectors: ['connectRefinementList'],
    widgets: ['ais.refinementList']
  },
  menu: {
    connectors: ['connectMenu'],
    widgets: ['ais.menu']
  },
  hierarchicalMenu: {
    connectors: ['connectHierarchicalMenu'],
    widgets: ['ais.hierarchicalMenu']
  },
  numericMenu: {
    connectors: ['connectNumericMenu'],
    widgets: ['ais.numericMenu']
  },
  ratingMenu: {
    connectors: ['connectRatingMenu'],
    widgets: ['ais.ratingMenu']
  },
  range: {
    connectors: ['connectRange'],
    widgets: ['ais.rangeInput', 'ais.rangeSlider', 'ais.range']
  },
  toggle: {
    connectors: ['connectToggleRefinement'],
    widgets: ['ais.toggleRefinement']
  },
  geoSearch: {
    connectors: ['connectGeoSearch'],
    widgets: ['ais.geoSearch']
  },
  sortBy: {
    connectors: ['connectSortBy'],
    widgets: ['ais.sortBy']
  },
  page: {
    connectors: ['connectPagination'],
    widgets: ['ais.pagination', 'ais.infiniteHits']
  },
  hitsPerPage: {
    connectors: ['connectHitsPerPage'],
    widgets: ['ais.hitsPerPage']
  },
  configure: {
    connectors: ['connectConfigure'],
    widgets: ['ais.configure']
  },
  places: {
    connectors: [],
    widgets: ['ais.places']
  }
};
function checkIndexUiState(_ref) {
  var index = _ref.index,
      indexUiState = _ref.indexUiState;
  var mountedWidgets = index.getWidgets().map(function (widget) {
    return widget.$$type;
  }).filter(Boolean);
  var missingWidgets = (0,_typedObject__WEBPACK_IMPORTED_MODULE_0__.keys)(indexUiState).reduce(function (acc, parameter) {
    var widgetUiState = stateToWidgetsMap[parameter];

    if (!widgetUiState) {
      return acc;
    }

    var requiredWidgets = widgetUiState.widgets;

    if (requiredWidgets && !requiredWidgets.some(function (requiredWidget) {
      return mountedWidgets.includes(requiredWidget);
    })) {
      acc.push([parameter, {
        connectors: widgetUiState.connectors,
        widgets: widgetUiState.widgets.map(function (widgetIdentifier) {
          return widgetIdentifier.split('ais.')[1];
        })
      }]);
    }

    return acc;
  }, []);
   true ? (0,_logger__WEBPACK_IMPORTED_MODULE_1__.warning)(missingWidgets.length === 0, "The UI state for the index \"".concat(index.getIndexId(), "\" is not consistent with the widgets mounted.\n\nThis can happen when the UI state is specified via `initialUiState`, `routing` or `setUiState` but that the widgets responsible for this state were not added. This results in those query parameters not being sent to the API.\n\nTo fully reflect the state, some widgets need to be added to the index \"").concat(index.getIndexId(), "\":\n\n").concat(missingWidgets.map(function (_ref2) {
    var _ref4;

    var _ref3 = _slicedToArray(_ref2, 2),
        stateParameter = _ref3[0],
        widgets = _ref3[1].widgets;

    return "- `".concat(stateParameter, "` needs one of these widgets: ").concat((_ref4 = []).concat.apply(_ref4, _toConsumableArray(widgets.map(function (name) {
      return getWidgetNames(name);
    }))).map(function (name) {
      return "\"".concat(name, "\"");
    }).join(', '));
  }).join('\n'), "\n\nIf you do not wish to display widgets but still want to support their search parameters, you can mount \"virtual widgets\" that don't render anything:\n\n```\n").concat(missingWidgets.filter(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        _stateParameter = _ref6[0],
        connectors = _ref6[1].connectors;

    return connectors.length > 0;
  }).map(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        _stateParameter = _ref8[0],
        _ref8$ = _ref8[1],
        connectors = _ref8$.connectors,
        widgets = _ref8$.widgets;

    var capitalizedWidget = (0,_capitalize__WEBPACK_IMPORTED_MODULE_2__.default)(widgets[0]);
    var connectorName = connectors[0];
    return "const virtual".concat(capitalizedWidget, " = ").concat(connectorName, "(() => null);");
  }).join('\n'), "\n\nsearch.addWidgets([\n  ").concat(missingWidgets.filter(function (_ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
        _stateParameter = _ref10[0],
        connectors = _ref10[1].connectors;

    return connectors.length > 0;
  }).map(function (_ref11) {
    var _ref12 = _slicedToArray(_ref11, 2),
        _stateParameter = _ref12[0],
        widgets = _ref12[1].widgets;

    var capitalizedWidget = (0,_capitalize__WEBPACK_IMPORTED_MODULE_2__.default)(widgets[0]);
    return "virtual".concat(capitalizedWidget, "({ /* ... */ })");
  }).join(',\n  '), "\n]);\n```\n\nIf you're using custom widgets that do set these query parameters, we recommend using connectors instead.\n\nSee https://www.algolia.com/doc/guides/building-search-ui/widgets/customize-an-existing-widget/js/#customize-the-complete-ui-of-the-widgets")) : 0;
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/checkRendering.js":
/*!**********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/checkRendering.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getObjectType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getObjectType */ "./node_modules/instantsearch.js/es/lib/utils/getObjectType.js");


function checkRendering(rendering, usage) {
  if (rendering === undefined || typeof rendering !== 'function') {
    throw new Error("The render function is not valid (received type ".concat((0,_getObjectType__WEBPACK_IMPORTED_MODULE_0__.default)(rendering), ").\n\n").concat(usage));
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (checkRendering);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/concatHighlightedParts.js":
/*!******************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/concatHighlightedParts.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ concatHighlightedParts)
/* harmony export */ });
/* harmony import */ var _escape_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./escape-highlight */ "./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js");

function concatHighlightedParts(parts) {
  var highlightPreTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__.TAG_REPLACEMENT.highlightPreTag,
      highlightPostTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__.TAG_REPLACEMENT.highlightPostTag;
  return parts.map(function (part) {
    return part.isHighlighted ? highlightPreTag + part.value + highlightPostTag : part.value;
  }).join('');
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/createSendEventForHits.js":
/*!******************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/createSendEventForHits.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSendEventForHits": () => (/* binding */ createSendEventForHits),
/* harmony export */   "createBindEventForHits": () => (/* binding */ createBindEventForHits)
/* harmony export */ });
/* harmony import */ var _lib_utils_serializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/utils/serializer */ "./node_modules/instantsearch.js/es/lib/utils/serializer.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



var buildPayload = function buildPayload(_ref) {
  var index = _ref.index,
      widgetType = _ref.widgetType,
      methodName = _ref.methodName,
      args = _ref.args;

  if (args.length === 1 && _typeof(args[0]) === 'object') {
    return args[0];
  }

  var eventType = args[0];
  var hits = args[1];
  var eventName = args[2];

  if (!hits) {
    if (true) {
      throw new Error("You need to pass hit or hits as the second argument like:\n  ".concat(methodName, "(eventType, hit);\n  "));
    } else {}
  }

  if ((eventType === 'click' || eventType === 'conversion') && !eventName) {
    if (true) {
      throw new Error("You need to pass eventName as the third argument for 'click' or 'conversion' events like:\n  ".concat(methodName, "('click', hit, 'Product Purchased');\n\n  To learn more about event naming: https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/in-depth/clicks-conversions-best-practices/\n  "));
    } else {}
  }

  var hitsArray = Array.isArray(hits) ? removeEscapedFromHits(hits) : [hits];

  if (hitsArray.length === 0) {
    return null;
  }

  var queryID = hitsArray[0].__queryID;
  var objectIDs = hitsArray.map(function (hit) {
    return hit.objectID;
  });
  var positions = hitsArray.map(function (hit) {
    return hit.__position;
  });

  if (eventType === 'view') {
    return {
      insightsMethod: 'viewedObjectIDs',
      widgetType: widgetType,
      eventType: eventType,
      payload: {
        eventName: eventName || 'Hits Viewed',
        index: index,
        objectIDs: objectIDs
      },
      hits: hitsArray
    };
  } else if (eventType === 'click') {
    return {
      insightsMethod: 'clickedObjectIDsAfterSearch',
      widgetType: widgetType,
      eventType: eventType,
      payload: {
        eventName: eventName,
        index: index,
        queryID: queryID,
        objectIDs: objectIDs,
        positions: positions
      },
      hits: hitsArray
    };
  } else if (eventType === 'conversion') {
    return {
      insightsMethod: 'convertedObjectIDsAfterSearch',
      widgetType: widgetType,
      eventType: eventType,
      payload: {
        eventName: eventName,
        index: index,
        queryID: queryID,
        objectIDs: objectIDs
      },
      hits: hitsArray
    };
  } else if (true) {
    throw new Error("eventType(\"".concat(eventType, "\") is not supported.\n    If you want to send a custom payload, you can pass one object: ").concat(methodName, "(customPayload);\n    "));
  } else {}
};

function removeEscapedFromHits(hits) {
  // this returns without `hits.__escaped`
  // and this way it doesn't mutate the original `hits`
  return hits.map(function (hit) {
    return hit;
  });
}

function createSendEventForHits(_ref2) {
  var instantSearchInstance = _ref2.instantSearchInstance,
      index = _ref2.index,
      widgetType = _ref2.widgetType;

  var sendEventForHits = function sendEventForHits() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var payload = buildPayload({
      widgetType: widgetType,
      index: index,
      methodName: 'sendEvent',
      args: args
    });

    if (payload) {
      instantSearchInstance.sendEventToInsights(payload);
    }
  };

  return sendEventForHits;
}
function createBindEventForHits(_ref3) {
  var index = _ref3.index,
      widgetType = _ref3.widgetType;

  var bindEventForHits = function bindEventForHits() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var payload = buildPayload({
      widgetType: widgetType,
      index: index,
      methodName: 'bindEvent',
      args: args
    });
    return payload ? "data-insights-event=".concat((0,_lib_utils_serializer__WEBPACK_IMPORTED_MODULE_0__.serializePayload)(payload)) : '';
  };

  return bindEventForHits;
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/defer.js":
/*!*************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/defer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var nextMicroTask = Promise.resolve();

var defer = function defer(callback) {
  var progress = null;
  var cancelled = false;

  var fn = function fn() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (progress !== null) {
      return;
    }

    progress = nextMicroTask.then(function () {
      progress = null;

      if (cancelled) {
        cancelled = false;
        return;
      }

      callback.apply(void 0, args);
    });
  };

  fn.wait = function () {
    if (progress === null) {
      throw new Error('The deferred function should be called before calling `wait()`');
    }

    return progress;
  };

  fn.cancel = function () {
    if (progress === null) {
      return;
    }

    cancelled = true;
  };

  return fn;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defer);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/documentation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/documentation.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDocumentationLink": () => (/* binding */ createDocumentationLink),
/* harmony export */   "createDocumentationMessageGenerator": () => (/* binding */ createDocumentationMessageGenerator)
/* harmony export */ });
var createDocumentationLink = function createDocumentationLink(_ref) {
  var name = _ref.name,
      _ref$connector = _ref.connector,
      connector = _ref$connector === void 0 ? false : _ref$connector;
  return ['https://www.algolia.com/doc/api-reference/widgets/', name, '/js/', connector ? '#connector' : ''].join('');
};
var createDocumentationMessageGenerator = function createDocumentationMessageGenerator() {
  for (var _len = arguments.length, widgets = new Array(_len), _key = 0; _key < _len; _key++) {
    widgets[_key] = arguments[_key];
  }

  var links = widgets.map(function (widget) {
    return createDocumentationLink(widget);
  }).join(', ');
  return function (message) {
    return [message, "See documentation: ".concat(links)].filter(Boolean).join('\n\n');
  };
};

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js":
/*!************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TAG_PLACEHOLDER": () => (/* binding */ TAG_PLACEHOLDER),
/* harmony export */   "TAG_REPLACEMENT": () => (/* binding */ TAG_REPLACEMENT),
/* harmony export */   "escapeHits": () => (/* binding */ escapeHits),
/* harmony export */   "escapeFacets": () => (/* binding */ escapeFacets)
/* harmony export */ });
/* harmony import */ var _escape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./escape */ "./node_modules/instantsearch.js/es/lib/utils/escape.js");
/* harmony import */ var _isPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isPlainObject */ "./node_modules/instantsearch.js/es/lib/utils/isPlainObject.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var TAG_PLACEHOLDER = {
  highlightPreTag: '__ais-highlight__',
  highlightPostTag: '__/ais-highlight__'
};
var TAG_REPLACEMENT = {
  highlightPreTag: '<mark>',
  highlightPostTag: '</mark>'
};

function replaceTagsAndEscape(value) {
  return (0,_escape__WEBPACK_IMPORTED_MODULE_0__.default)(value).replace(new RegExp(TAG_PLACEHOLDER.highlightPreTag, 'g'), TAG_REPLACEMENT.highlightPreTag).replace(new RegExp(TAG_PLACEHOLDER.highlightPostTag, 'g'), TAG_REPLACEMENT.highlightPostTag);
}

function recursiveEscape(input) {
  if ((0,_isPlainObject__WEBPACK_IMPORTED_MODULE_1__.default)(input) && typeof input.value !== 'string') {
    return Object.keys(input).reduce(function (acc, key) {
      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, recursiveEscape(input[key])));
    }, {});
  }

  if (Array.isArray(input)) {
    return input.map(recursiveEscape);
  }

  return _objectSpread(_objectSpread({}, input), {}, {
    value: replaceTagsAndEscape(input.value)
  });
}

function escapeHits(hits) {
  if (hits.__escaped === undefined) {
    // We don't override the value on hit because it will mutate the raw results
    // instead we make a shallow copy and we assign the escaped values on it.
    hits = hits.map(function (_ref) {
      var hit = _extends({}, _ref);

      if (hit._highlightResult) {
        hit._highlightResult = recursiveEscape(hit._highlightResult);
      }

      if (hit._snippetResult) {
        hit._snippetResult = recursiveEscape(hit._snippetResult);
      }

      return hit;
    });
    hits.__escaped = true;
  }

  return hits;
}
function escapeFacets(facetHits) {
  return facetHits.map(function (h) {
    return _objectSpread(_objectSpread({}, h), {}, {
      highlighted: replaceTagsAndEscape(h.highlighted)
    });
  });
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/escape.js":
/*!**************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/escape.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This implementation is taken from Lodash implementation.
 * See: https://github.com/lodash/lodash/blob/4.17.11-npm/escape.js
 */
// Used to map characters to HTML entities.
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
}; // Used to match HTML entities and HTML characters.

var regexUnescapedHtml = /[&<>"']/g;
var regexHasUnescapedHtml = RegExp(regexUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 */

function escape(value) {
  return value && regexHasUnescapedHtml.test(value) ? value.replace(regexUnescapedHtml, function (character) {
    return htmlEscapes[character];
  }) : value;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (escape);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/find.js":
/*!************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/find.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// We aren't using the native `Array.prototype.find` because the refactor away from Lodash is not
// published as a major version.
// Relying on the `find` polyfill on user-land, which before was only required for niche use-cases,
// was decided as too risky.
// @MAJOR Replace with the native `Array.prototype.find` method
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
function find(items, predicate) {
  var value;

  for (var i = 0; i < items.length; i++) {
    value = items[i]; // inlined for performance: if (Call(predicate, thisArg, [value, i, list])) {

    if (predicate(value, i, items)) {
      return value;
    }
  }

  return undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (find);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/findIndex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/findIndex.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// We aren't using the native `Array.prototype.findIndex` because the refactor away from Lodash is not
// published as a major version.
// Relying on the `findIndex` polyfill on user-land, which before was only required for niche use-cases,
// was decided as too risky.
// @MAJOR Replace with the native `Array.prototype.findIndex` method
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
function findIndex(array, comparator) {
  if (!Array.isArray(array)) {
    return -1;
  }

  for (var i = 0; i < array.length; i++) {
    if (comparator(array[i])) {
      return i;
    }
  }

  return -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (findIndex);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/getContainerNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/getContainerNode.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isDomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDomElement */ "./node_modules/instantsearch.js/es/lib/utils/isDomElement.js");

/**
 * Return the container. If it's a string, it is considered a
 * css selector and retrieves the first matching element. Otherwise
 * test if it validates that it's a correct DOMElement.
 *
 * @param {string|HTMLElement} selectorOrHTMLElement CSS Selector or container node.
 * @return {HTMLElement} Container node
 * @throws Error when the type is not correct
 */

function getContainerNode(selectorOrHTMLElement) {
  var isSelectorString = typeof selectorOrHTMLElement === 'string';
  var domElement = isSelectorString ? document.querySelector(selectorOrHTMLElement) : selectorOrHTMLElement;

  if (!(0,_isDomElement__WEBPACK_IMPORTED_MODULE_0__.default)(domElement)) {
    var errorMessage = 'Container must be `string` or `HTMLElement`.';

    if (isSelectorString) {
      errorMessage += " Unable to find ".concat(selectorOrHTMLElement);
    }

    throw new Error(errorMessage);
  }

  return domElement;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getContainerNode);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/getHighlightFromSiblings.js":
/*!********************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/getHighlightFromSiblings.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHighlightFromSiblings)
/* harmony export */ });
/* harmony import */ var _unescape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unescape */ "./node_modules/instantsearch.js/es/lib/utils/unescape.js");

var hasAlphanumeric = new RegExp(/\w/i);
function getHighlightFromSiblings(parts, i) {
  var _parts, _parts2;

  var current = parts[i];
  var isNextHighlighted = ((_parts = parts[i + 1]) === null || _parts === void 0 ? void 0 : _parts.isHighlighted) || true;
  var isPreviousHighlighted = ((_parts2 = parts[i - 1]) === null || _parts2 === void 0 ? void 0 : _parts2.isHighlighted) || true;

  if (!hasAlphanumeric.test((0,_unescape__WEBPACK_IMPORTED_MODULE_0__.default)(current.value)) && isPreviousHighlighted === isNextHighlighted) {
    return isPreviousHighlighted;
  }

  return current.isHighlighted;
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/getHighlightedParts.js":
/*!***************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/getHighlightedParts.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHighlightedParts)
/* harmony export */ });
/* harmony import */ var _escape_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./escape-highlight */ "./node_modules/instantsearch.js/es/lib/utils/escape-highlight.js");

function getHighlightedParts(highlightedValue) {
  var highlightPostTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__.TAG_REPLACEMENT.highlightPostTag,
      highlightPreTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__.TAG_REPLACEMENT.highlightPreTag;
  var splitByPreTag = highlightedValue.split(highlightPreTag);
  var firstValue = splitByPreTag.shift();
  var elements = !firstValue ? [] : [{
    value: firstValue,
    isHighlighted: false
  }];
  splitByPreTag.forEach(function (split) {
    var splitByPostTag = split.split(highlightPostTag);
    elements.push({
      value: splitByPostTag[0],
      isHighlighted: true
    });

    if (splitByPostTag[1] !== '') {
      elements.push({
        value: splitByPostTag[1],
        isHighlighted: false
      });
    }
  });
  return elements;
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/getObjectType.js":
/*!*********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/getObjectType.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function getObjectType(object) {
  return Object.prototype.toString.call(object).slice(8, -1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getObjectType);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js":
/*!*************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function getPropertyByPath(object, path) {
  var parts = Array.isArray(path) ? path : path.split('.');
  return parts.reduce(function (current, key) {
    return current && current[key];
  }, object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getPropertyByPath);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/hits-absolute-position.js":
/*!******************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/hits-absolute-position.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addAbsolutePosition": () => (/* binding */ addAbsolutePosition)
/* harmony export */ });
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function addAbsolutePosition(hits, page, hitsPerPage) {
  return hits.map(function (hit, idx) {
    return _objectSpread(_objectSpread({}, hit), {}, {
      __position: hitsPerPage * page + idx + 1
    });
  });
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/hits-query-id.js":
/*!*********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/hits-query-id.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addQueryID": () => (/* binding */ addQueryID)
/* harmony export */ });
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function addQueryID(hits, queryID) {
  if (!queryID) {
    return hits;
  }

  return hits.map(function (hit) {
    return _objectSpread(_objectSpread({}, hit), {}, {
      __queryID: queryID
    });
  });
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/isDomElement.js":
/*!********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/isDomElement.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function isDomElement(object) {
  return object instanceof HTMLElement || Boolean(object) && object.nodeType > 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isDomElement);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/isEqual.js":
/*!***************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/isEqual.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function isPrimitive(obj) {
  return obj !== Object(obj);
}

function isEqual(first, second) {
  if (first === second) {
    return true;
  }

  if (isPrimitive(first) || isPrimitive(second) || typeof first === 'function' || typeof second === 'function') {
    return first === second;
  }

  if (Object.keys(first).length !== Object.keys(second).length) {
    return false;
  }

  for (var _i = 0, _Object$keys = Object.keys(first); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (!(key in second)) {
      return false;
    }

    if (!isEqual(first[key], second[key])) {
      return false;
    }
  }

  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isEqual);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/isPlainObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/isPlainObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * This implementation is taken from Lodash implementation.
 * See: https://github.com/lodash/lodash/blob/master/isPlainObject.js
 */
function getTag(value) {
  if (value === null) {
    return value === undefined ? '[object Undefined]' : '[object Null]';
  }

  return Object.prototype.toString.call(value);
}

function isObjectLike(value) {
  return _typeof(value) === 'object' && value !== null;
}
/**
 * Checks if `value` is a plain object.
 *
 * A plain object is an object created by the `Object`
 * constructor or with a `[[Prototype]]` of `null`.
 */


function isPlainObject(value) {
  if (!isObjectLike(value) || getTag(value) !== '[object Object]') {
    return false;
  }

  if (Object.getPrototypeOf(value) === null) {
    return true;
  }

  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPlainObject);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/isSpecialClick.js":
/*!**********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/isSpecialClick.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function isSpecialClick(event) {
  var isMiddleClick = event.button === 1;
  return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSpecialClick);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/logger.js":
/*!**************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/logger.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "deprecate": () => (/* binding */ deprecate),
/* harmony export */   "warning": () => (/* binding */ _warning)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");


/**
 * Logs a warning when this function is called, in development environment only.
 */
var deprecate = function deprecate(fn, message) {
  return fn;
};
/**
 * Logs a warning
 * This is used to log issues in development environment only.
 */


var warn = _noop__WEBPACK_IMPORTED_MODULE_0__.default;
/**
 * Logs a warning if the condition is not met.
 * This is used to log issues in development environment only.
 */

var _warning = _noop__WEBPACK_IMPORTED_MODULE_0__.default;

if (true) {
  warn = function warn(message) {
    // eslint-disable-next-line no-console
    console.warn("[InstantSearch.js]: ".concat(message.trim()));
  };

  deprecate = function deprecate(fn, message) {
    var hasAlreadyPrinted = false;
    return function () {
      if (!hasAlreadyPrinted) {
        hasAlreadyPrinted = true;
        warn(message);
      }

      return fn.apply(void 0, arguments);
    };
  };

  _warning = function warning(condition, message) {
    if (condition) {
      return;
    }

    var hasAlreadyPrinted = _warning.cache[message];

    if (!hasAlreadyPrinted) {
      _warning.cache[message] = true;
      warn(message);
    }
  };

  _warning.cache = {};
}



/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/mergeSearchParameters.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/mergeSearchParameters.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _findIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./findIndex */ "./node_modules/instantsearch.js/es/lib/utils/findIndex.js");
/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniq */ "./node_modules/instantsearch.js/es/lib/utils/uniq.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




var mergeWithRest = function mergeWithRest(left, right) {
  var facets = right.facets,
      disjunctiveFacets = right.disjunctiveFacets,
      facetsRefinements = right.facetsRefinements,
      facetsExcludes = right.facetsExcludes,
      disjunctiveFacetsRefinements = right.disjunctiveFacetsRefinements,
      numericRefinements = right.numericRefinements,
      tagRefinements = right.tagRefinements,
      hierarchicalFacets = right.hierarchicalFacets,
      hierarchicalFacetsRefinements = right.hierarchicalFacetsRefinements,
      ruleContexts = right.ruleContexts,
      rest = _objectWithoutProperties(right, ["facets", "disjunctiveFacets", "facetsRefinements", "facetsExcludes", "disjunctiveFacetsRefinements", "numericRefinements", "tagRefinements", "hierarchicalFacets", "hierarchicalFacetsRefinements", "ruleContexts"]);

  return left.setQueryParameters(rest);
}; // Merge facets


var mergeFacets = function mergeFacets(left, right) {
  return right.facets.reduce(function (_, name) {
    return _.addFacet(name);
  }, left);
};

var mergeDisjunctiveFacets = function mergeDisjunctiveFacets(left, right) {
  return right.disjunctiveFacets.reduce(function (_, name) {
    return _.addDisjunctiveFacet(name);
  }, left);
};

var mergeHierarchicalFacets = function mergeHierarchicalFacets(left, right) {
  return left.setQueryParameters({
    hierarchicalFacets: right.hierarchicalFacets.reduce(function (facets, facet) {
      var index = (0,_findIndex__WEBPACK_IMPORTED_MODULE_0__.default)(facets, function (_) {
        return _.name === facet.name;
      });

      if (index === -1) {
        return facets.concat(facet);
      }

      var nextFacets = facets.slice();
      nextFacets.splice(index, 1, facet);
      return nextFacets;
    }, left.hierarchicalFacets)
  });
}; // Merge facet refinements


var mergeTagRefinements = function mergeTagRefinements(left, right) {
  return right.tagRefinements.reduce(function (_, value) {
    return _.addTagRefinement(value);
  }, left);
};

var mergeFacetRefinements = function mergeFacetRefinements(left, right) {
  return left.setQueryParameters({
    facetsRefinements: _objectSpread(_objectSpread({}, left.facetsRefinements), right.facetsRefinements)
  });
};

var mergeFacetsExcludes = function mergeFacetsExcludes(left, right) {
  return left.setQueryParameters({
    facetsExcludes: _objectSpread(_objectSpread({}, left.facetsExcludes), right.facetsExcludes)
  });
};

var mergeDisjunctiveFacetsRefinements = function mergeDisjunctiveFacetsRefinements(left, right) {
  return left.setQueryParameters({
    disjunctiveFacetsRefinements: _objectSpread(_objectSpread({}, left.disjunctiveFacetsRefinements), right.disjunctiveFacetsRefinements)
  });
};

var mergeNumericRefinements = function mergeNumericRefinements(left, right) {
  return left.setQueryParameters({
    numericRefinements: _objectSpread(_objectSpread({}, left.numericRefinements), right.numericRefinements)
  });
};

var mergeHierarchicalFacetsRefinements = function mergeHierarchicalFacetsRefinements(left, right) {
  return left.setQueryParameters({
    hierarchicalFacetsRefinements: _objectSpread(_objectSpread({}, left.hierarchicalFacetsRefinements), right.hierarchicalFacetsRefinements)
  });
};

var mergeRuleContexts = function mergeRuleContexts(left, right) {
  var ruleContexts = (0,_uniq__WEBPACK_IMPORTED_MODULE_1__.default)([].concat(left.ruleContexts).concat(right.ruleContexts).filter(Boolean));

  if (ruleContexts.length > 0) {
    return left.setQueryParameters({
      ruleContexts: ruleContexts
    });
  }

  return left;
};

var merge = function merge() {
  for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {
    parameters[_key] = arguments[_key];
  }

  return parameters.reduce(function (left, right) {
    var hierarchicalFacetsRefinementsMerged = mergeHierarchicalFacetsRefinements(left, right);
    var hierarchicalFacetsMerged = mergeHierarchicalFacets(hierarchicalFacetsRefinementsMerged, right);
    var tagRefinementsMerged = mergeTagRefinements(hierarchicalFacetsMerged, right);
    var numericRefinementsMerged = mergeNumericRefinements(tagRefinementsMerged, right);
    var disjunctiveFacetsRefinementsMerged = mergeDisjunctiveFacetsRefinements(numericRefinementsMerged, right);
    var facetsExcludesMerged = mergeFacetsExcludes(disjunctiveFacetsRefinementsMerged, right);
    var facetRefinementsMerged = mergeFacetRefinements(facetsExcludesMerged, right);
    var disjunctiveFacetsMerged = mergeDisjunctiveFacets(facetRefinementsMerged, right);
    var ruleContextsMerged = mergeRuleContexts(disjunctiveFacetsMerged, right);
    var facetsMerged = mergeFacets(ruleContextsMerged, right);
    return mergeWithRest(facetsMerged, right);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (merge);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/noop.js":
/*!************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/noop.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function noop() {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (noop);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/prepareTemplateProps.js":
/*!****************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/prepareTemplateProps.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniq */ "./node_modules/instantsearch.js/es/lib/utils/uniq.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



function prepareTemplates( // can not use = {} here, since the template could have different constraints
defaultTemplates) {
  var templates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var allKeys = (0,_uniq__WEBPACK_IMPORTED_MODULE_0__.default)([].concat(_toConsumableArray(Object.keys(defaultTemplates || {})), _toConsumableArray(Object.keys(templates))));
  return allKeys.reduce(function (config, key) {
    var defaultTemplate = defaultTemplates ? defaultTemplates[key] : undefined;
    var customTemplate = templates[key];
    var isCustomTemplate = customTemplate !== undefined && customTemplate !== defaultTemplate;
    config.templates[key] = isCustomTemplate ? customTemplate // typescript doesn't recognize that this condition asserts customTemplate is defined
    : defaultTemplate;
    config.useCustomCompileOptions[key] = isCustomTemplate;
    return config;
  }, {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    templates: {},
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    useCustomCompileOptions: {}
  });
}
/**
 * Prepares an object to be passed to the Template widget
 */


function prepareTemplateProps(_ref) {
  var defaultTemplates = _ref.defaultTemplates,
      templates = _ref.templates,
      templatesConfig = _ref.templatesConfig;
  var preparedTemplates = prepareTemplates(defaultTemplates, templates);
  return _objectSpread({
    templatesConfig: templatesConfig
  }, preparedTemplates);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (prepareTemplateProps);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/range.js":
/*!*************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/range.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function range(_ref) {
  var _ref$start = _ref.start,
      start = _ref$start === void 0 ? 0 : _ref$start,
      end = _ref.end,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? 1 : _ref$step;
  // We can't divide by 0 so we re-assign the step to 1 if it happens.
  var limitStep = step === 0 ? 1 : step; // In some cases the array to create has a decimal length.
  // We therefore need to round the value.
  // Example:
  //   { start: 1, end: 5000, step: 500 }
  //   => Array length = (5000 - 1) / 500 = 9.998

  var arrayLength = Math.round((end - start) / limitStep);
  return _toConsumableArray(Array(arrayLength)).map(function (_, current) {
    return start + current * limitStep;
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (range);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/renderTemplate.js":
/*!**********************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/renderTemplate.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var hogan_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hogan.js */ "./node_modules/hogan.js/lib/hogan.js");
/* harmony import */ var hogan_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hogan_js__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



// We add all our template helper methods to the template as lambdas. Note
// that lambdas in Mustache are supposed to accept a second argument of
// `render` to get the rendered value, not the literal `{{value}}`. But
// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).
function transformHelpersToHogan() {
  var helpers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var compileOptions = arguments.length > 1 ? arguments[1] : undefined;
  var data = arguments.length > 2 ? arguments[2] : undefined;
  return Object.keys(helpers).reduce(function (acc, helperKey) {
    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, helperKey, function () {
      var _this = this;

      return function (text) {
        var render = function render(value) {
          return hogan_js__WEBPACK_IMPORTED_MODULE_0___default().compile(value, compileOptions).render(_this);
        };

        return helpers[helperKey].call(data, text, render);
      };
    }));
  }, {});
}

function renderTemplate(_ref) {
  var templates = _ref.templates,
      templateKey = _ref.templateKey,
      compileOptions = _ref.compileOptions,
      helpers = _ref.helpers,
      data = _ref.data,
      bindEvent = _ref.bindEvent;
  var template = templates[templateKey];

  if (typeof template !== 'string' && typeof template !== 'function') {
    throw new Error("Template must be 'string' or 'function', was '".concat(_typeof(template), "' (key: ").concat(templateKey, ")"));
  }

  if (typeof template === 'function') {
    return template(data, bindEvent);
  }

  var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);
  return hogan_js__WEBPACK_IMPORTED_MODULE_0___default().compile(template, compileOptions).render(_objectSpread(_objectSpread({}, data), {}, {
    helpers: transformedHelpers
  })).replace(/[ \n\r\t\f\xA0]+/g, function (spaces) {
    return spaces.replace(/(^|\xA0+)[^\xA0]+/g, '$1 ');
  }).trim();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (renderTemplate);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/resolveSearchParameters.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/resolveSearchParameters.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var resolveSearchParameters = function resolveSearchParameters(current) {
  var parent = current.getParent();
  var states = [current.getHelper().state];

  while (parent !== null) {
    states = [parent.getHelper().state].concat(states);
    parent = parent.getParent();
  }

  return states;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolveSearchParameters);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/reverseHighlightedParts.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/reverseHighlightedParts.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ reverseHighlightedParts)
/* harmony export */ });
/* harmony import */ var _getHighlightFromSiblings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getHighlightFromSiblings */ "./node_modules/instantsearch.js/es/lib/utils/getHighlightFromSiblings.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function reverseHighlightedParts(parts) {
  if (!parts.some(function (part) {
    return part.isHighlighted;
  })) {
    return parts.map(function (part) {
      return _objectSpread(_objectSpread({}, part), {}, {
        isHighlighted: false
      });
    });
  }

  return parts.map(function (part, i) {
    return _objectSpread(_objectSpread({}, part), {}, {
      isHighlighted: !(0,_getHighlightFromSiblings__WEBPACK_IMPORTED_MODULE_0__.default)(parts, i)
    });
  });
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/serializer.js":
/*!******************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/serializer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializePayload": () => (/* binding */ serializePayload),
/* harmony export */   "deserializePayload": () => (/* binding */ deserializePayload)
/* harmony export */ });
function serializePayload(payload) {
  return btoa(encodeURIComponent(JSON.stringify(payload)));
}
function deserializePayload(payload) {
  return JSON.parse(decodeURIComponent(atob(payload)));
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/typedObject.js":
/*!*******************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/typedObject.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keys": () => (/* binding */ keys)
/* harmony export */ });
/**
 * A typed version of Object.keys, to use when looping over a static object
 * inspired from https://stackoverflow.com/a/65117465/3185307
 */
var keys = Object.keys;

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/unescape.js":
/*!****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/unescape.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unescape)
/* harmony export */ });
/**
 * This implementation is taken from Lodash implementation.
 * See: https://github.com/lodash/lodash/blob/4.17.11-npm/unescape.js
 */
// Used to map HTML entities to characters.
var htmlEscapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'"
}; // Used to match HTML entities and HTML characters.

var regexEscapedHtml = /&(amp|quot|lt|gt|#39);/g;
var regexHasEscapedHtml = RegExp(regexEscapedHtml.source);
/**
 * Converts the HTML entities "&", "<", ">", '"', and "'" in `string` to their
 * characters.
 */

function unescape(value) {
  return value && regexHasEscapedHtml.test(value) ? value.replace(regexEscapedHtml, function (character) {
    return htmlEscapes[character];
  }) : value;
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/utils/uniq.js":
/*!************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/utils/uniq.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function uniq(array) {
  return array.filter(function (value, index, self) {
    return self.indexOf(value) === index;
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uniq);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/lib/version.js":
/*!*********************************************************!*\
  !*** ./node_modules/instantsearch.js/es/lib/version.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('4.27.2');

/***/ }),

/***/ "./node_modules/instantsearch.js/es/middlewares/createMetadataMiddleware.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/middlewares/createMetadataMiddleware.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isMetadataEnabled": () => (/* binding */ isMetadataEnabled),
/* harmony export */   "createMetadataMiddleware": () => (/* binding */ createMetadataMiddleware)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function extractPayload(widgets, instantSearchInstance, payload) {
  var parent = instantSearchInstance.mainIndex;
  var initOptions = {
    instantSearchInstance: instantSearchInstance,
    parent: parent,
    scopedResults: [],
    state: parent.getHelper().state,
    helper: parent.getHelper(),
    createURL: parent.createURL,
    uiState: instantSearchInstance._initialUiState,
    renderState: instantSearchInstance.renderState,
    templatesConfig: instantSearchInstance.templatesConfig,
    searchMetadata: {
      isSearchStalled: instantSearchInstance._isSearchStalled
    }
  };
  widgets.forEach(function (widget) {
    var widgetParams = {};

    if (widget.getWidgetRenderState) {
      var renderState = widget.getWidgetRenderState(initOptions);

      if (renderState && _typeof(renderState.widgetParams) === 'object') {
        widgetParams = renderState.widgetParams;
      }
    } // since we destructure in all widgets, the parameters with defaults are set to "undefined"


    var params = Object.keys(widgetParams).filter(function (key) {
      return widgetParams[key] !== undefined;
    });
    payload.widgets.push({
      type: widget.$$type,
      widgetType: widget.$$widgetType,
      params: params
    });

    if (widget.$$type === 'ais.index') {
      extractPayload(widget.getWidgets(), instantSearchInstance, payload);
    }
  });
}

function isMetadataEnabled() {
  return typeof window !== 'undefined' && window.navigator.userAgent.indexOf('Algolia Crawler') > -1;
}
/**
 * Exposes the metadata of mounted widgets in a custom
 * `<meta name="instantsearch:widgets" />` tag. The metadata per widget is:
 * - applied parameters
 * - widget name
 * - connector name
 */

function createMetadataMiddleware() {
  return function (_ref) {
    var instantSearchInstance = _ref.instantSearchInstance;
    var payload = {
      widgets: []
    };
    var payloadContainer = document.createElement('meta');
    var refNode = document.querySelector('head');
    payloadContainer.name = 'instantsearch:widgets';
    return {
      onStateChange: function onStateChange() {},
      subscribe: function subscribe() {
        // using setTimeout here to delay extraction until widgets have been added in a tick (e.g. Vue)
        setTimeout(function () {
          var client = instantSearchInstance.client;
          payload.ua = client.transporter && client.transporter.userAgent ? client.transporter.userAgent.value : client._ua;
          extractPayload(instantSearchInstance.mainIndex.getWidgets(), instantSearchInstance, payload);
          payloadContainer.content = JSON.stringify(payload);
          refNode.appendChild(payloadContainer);
        }, 0);
      },
      unsubscribe: function unsubscribe() {
        payloadContainer.remove();
      }
    };
  };
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/middlewares/createRouterMiddleware.js":
/*!********************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/middlewares/createRouterMiddleware.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRouterMiddleware": () => (/* binding */ createRouterMiddleware)
/* harmony export */ });
/* harmony import */ var _lib_stateMappings_simple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/stateMappings/simple */ "./node_modules/instantsearch.js/es/lib/stateMappings/simple.js");
/* harmony import */ var _lib_routers_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/routers/history */ "./node_modules/instantsearch.js/es/lib/routers/history.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/isEqual.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var createRouterMiddleware = function createRouterMiddleware() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _props$router = props.router,
      router = _props$router === void 0 ? (0,_lib_routers_history__WEBPACK_IMPORTED_MODULE_0__.default)() : _props$router,
      _props$stateMapping = props.stateMapping,
      stateMapping = _props$stateMapping === void 0 ? (0,_lib_stateMappings_simple__WEBPACK_IMPORTED_MODULE_1__.default)() : _props$stateMapping;
  return function (_ref) {
    var instantSearchInstance = _ref.instantSearchInstance;

    function topLevelCreateURL(nextState) {
      var uiState = Object.keys(nextState).reduce(function (acc, indexId) {
        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, indexId, nextState[indexId]));
      }, instantSearchInstance.mainIndex.getWidgetUiState({}));
      var route = stateMapping.stateToRoute(uiState);
      return router.createURL(route);
    } // casting to UiState here to keep createURL unaware of custom UiState
    // (as long as it's an object, it's ok)


    instantSearchInstance._createURL = topLevelCreateURL;
    instantSearchInstance._initialUiState = _objectSpread(_objectSpread({}, instantSearchInstance._initialUiState), stateMapping.routeToState(router.read()));
    var lastRouteState = undefined;
    return {
      onStateChange: function onStateChange(_ref2) {
        var uiState = _ref2.uiState;
        var routeState = stateMapping.stateToRoute(uiState);

        if (lastRouteState === undefined || !(0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.default)(lastRouteState, routeState)) {
          router.write(routeState);
          lastRouteState = routeState;
        }
      },
      subscribe: function subscribe() {
        router.onUpdate(function (route) {
          instantSearchInstance.setUiState(stateMapping.routeToState(route));
        });
      },
      unsubscribe: function unsubscribe() {
        router.dispose();
      }
    };
  };
};

/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/algoliasearch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/algoliasearch.js ***!
  \*****************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/component.js":
/*!*************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/component.js ***!
  \*************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/connector.js":
/*!*************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/connector.js ***!
  \*************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/instantsearch.js/es/types/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _utils__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _utils__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _algoliasearch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algoliasearch */ "./node_modules/instantsearch.js/es/types/algoliasearch.js");
/* harmony import */ var _algoliasearch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_algoliasearch__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _algoliasearch__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _algoliasearch__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _results__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./results */ "./node_modules/instantsearch.js/es/types/results.js");
/* harmony import */ var _results__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_results__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _results__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _results__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./component */ "./node_modules/instantsearch.js/es/types/component.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_component__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _component__WEBPACK_IMPORTED_MODULE_3__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _component__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _instantsearch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instantsearch */ "./node_modules/instantsearch.js/es/types/instantsearch.js");
/* harmony import */ var _instantsearch__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_instantsearch__WEBPACK_IMPORTED_MODULE_4__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _instantsearch__WEBPACK_IMPORTED_MODULE_4__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _instantsearch__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _middleware__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./middleware */ "./node_modules/instantsearch.js/es/types/middleware.js");
/* harmony import */ var _middleware__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_middleware__WEBPACK_IMPORTED_MODULE_5__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _middleware__WEBPACK_IMPORTED_MODULE_5__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _middleware__WEBPACK_IMPORTED_MODULE_5__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./router */ "./node_modules/instantsearch.js/es/types/router.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_router__WEBPACK_IMPORTED_MODULE_6__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _router__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _router__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _insights__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./insights */ "./node_modules/instantsearch.js/es/types/insights.js");
/* harmony import */ var _insights__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_insights__WEBPACK_IMPORTED_MODULE_7__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _insights__WEBPACK_IMPORTED_MODULE_7__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _insights__WEBPACK_IMPORTED_MODULE_7__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./connector */ "./node_modules/instantsearch.js/es/types/connector.js");
/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_connector__WEBPACK_IMPORTED_MODULE_8__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _connector__WEBPACK_IMPORTED_MODULE_8__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _connector__WEBPACK_IMPORTED_MODULE_8__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _widget_factory__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./widget-factory */ "./node_modules/instantsearch.js/es/types/widget-factory.js");
/* harmony import */ var _widget_factory__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_widget_factory__WEBPACK_IMPORTED_MODULE_9__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _widget_factory__WEBPACK_IMPORTED_MODULE_9__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _widget_factory__WEBPACK_IMPORTED_MODULE_9__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./widget */ "./node_modules/instantsearch.js/es/types/widget.js");
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_widget__WEBPACK_IMPORTED_MODULE_10__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _widget__WEBPACK_IMPORTED_MODULE_10__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _widget__WEBPACK_IMPORTED_MODULE_10__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _ui_state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ui-state */ "./node_modules/instantsearch.js/es/types/ui-state.js");
/* harmony import */ var _ui_state__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_ui_state__WEBPACK_IMPORTED_MODULE_11__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _ui_state__WEBPACK_IMPORTED_MODULE_11__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _ui_state__WEBPACK_IMPORTED_MODULE_11__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./render-state */ "./node_modules/instantsearch.js/es/types/render-state.js");
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_render_state__WEBPACK_IMPORTED_MODULE_12__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _render_state__WEBPACK_IMPORTED_MODULE_12__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _render_state__WEBPACK_IMPORTED_MODULE_12__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./templates */ "./node_modules/instantsearch.js/es/types/templates.js");
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_templates__WEBPACK_IMPORTED_MODULE_13__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _templates__WEBPACK_IMPORTED_MODULE_13__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _templates__WEBPACK_IMPORTED_MODULE_13__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
// internal
 // Algolia-related


 // component-related

 // instantsearch-related




 // widget-related








/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/insights.js":
/*!************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/insights.js ***!
  \************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/instantsearch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/instantsearch.js ***!
  \*****************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/middleware.js":
/*!**************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/middleware.js ***!
  \**************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/render-state.js":
/*!****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/render-state.js ***!
  \****************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/results.js":
/*!***********************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/results.js ***!
  \***********************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/router.js":
/*!**********************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/router.js ***!
  \**********************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/templates.js":
/*!*************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/templates.js ***!
  \*************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/ui-state.js":
/*!************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/ui-state.js ***!
  \************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/utils.js ***!
  \*********************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/widget-factory.js":
/*!******************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/widget-factory.js ***!
  \******************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/types/widget.js":
/*!**********************************************************!*\
  !*** ./node_modules/instantsearch.js/es/types/widget.js ***!
  \**********************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/instantsearch.js/es/widgets/configure/configure.js":
/*!*************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/widgets/configure/configure.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _connectors_configure_connectConfigure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../connectors/configure/connectConfigure */ "./node_modules/instantsearch.js/es/connectors/configure/connectConfigure.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/noop.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * A list of [search parameters](https://www.algolia.com/doc/api-reference/search-api-parameters/)
 * to enable when the widget mounts.
 */

var configure = function configure(widgetParams) {
  // This is a renderless widget that falls back to the connector's
  // noop render and unmount functions.
  var makeWidget = (0,_connectors_configure_connectConfigure__WEBPACK_IMPORTED_MODULE_0__.default)(_lib_utils__WEBPACK_IMPORTED_MODULE_1__.default);
  return _objectSpread(_objectSpread({}, makeWidget({
    searchParameters: widgetParams
  })), {}, {
    $$widgetType: 'ais.configure'
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (configure);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/widgets/hits/defaultTemplates.js":
/*!***************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/widgets/hits/defaultTemplates.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var defaultTemplates = {
  empty: 'No results',
  item: function item(data) {
    return JSON.stringify(data, null, 2);
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaultTemplates);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/widgets/hits/hits.js":
/*!***************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/widgets/hits/hits.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _connectors_hits_connectHits__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../connectors/hits/connectHits */ "./node_modules/instantsearch.js/es/connectors/hits/connectHits.js");
/* harmony import */ var _components_Hits_Hits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/Hits/Hits */ "./node_modules/instantsearch.js/es/components/Hits/Hits.js");
/* harmony import */ var _defaultTemplates__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./defaultTemplates */ "./node_modules/instantsearch.js/es/widgets/hits/defaultTemplates.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/prepareTemplateProps.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getContainerNode.js");
/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/suit */ "./node_modules/instantsearch.js/es/lib/suit.js");
/* harmony import */ var _lib_insights__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/insights */ "./node_modules/instantsearch.js/es/lib/insights/listener.js");
/* harmony import */ var _lib_insights__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../lib/insights */ "./node_modules/instantsearch.js/es/lib/insights/client.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** @jsx h */








var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.createDocumentationMessageGenerator)({
  name: 'hits'
});
var suit = (0,_lib_suit__WEBPACK_IMPORTED_MODULE_3__.component)('Hits');
var HitsWithInsightsListener = (0,_lib_insights__WEBPACK_IMPORTED_MODULE_4__.default)(_components_Hits_Hits__WEBPACK_IMPORTED_MODULE_5__.default);

var renderer = function renderer(_ref) {
  var renderState = _ref.renderState,
      cssClasses = _ref.cssClasses,
      containerNode = _ref.containerNode,
      templates = _ref.templates;
  return function (_ref2, isFirstRendering) {
    var receivedHits = _ref2.hits,
        results = _ref2.results,
        instantSearchInstance = _ref2.instantSearchInstance,
        insights = _ref2.insights,
        bindEvent = _ref2.bindEvent;

    if (isFirstRendering) {
      renderState.templateProps = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_6__.default)({
        defaultTemplates: _defaultTemplates__WEBPACK_IMPORTED_MODULE_7__.default,
        templatesConfig: instantSearchInstance.templatesConfig,
        templates: templates
      });
      return;
    }

    (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(HitsWithInsightsListener, {
      cssClasses: cssClasses,
      hits: receivedHits,
      results: results,
      templateProps: renderState.templateProps,
      insights: insights,
      sendEvent: function sendEvent(event) {
        instantSearchInstance.sendEventToInsights(event);
      },
      bindEvent: bindEvent
    }), containerNode);
  };
};

var hits = function hits(widgetParams) {
  var _ref3 = widgetParams || {},
      container = _ref3.container,
      escapeHTML = _ref3.escapeHTML,
      transformItems = _ref3.transformItems,
      _ref3$templates = _ref3.templates,
      templates = _ref3$templates === void 0 ? {} : _ref3$templates,
      _ref3$cssClasses = _ref3.cssClasses,
      userCssClasses = _ref3$cssClasses === void 0 ? {} : _ref3$cssClasses;

  if (!container) {
    throw new Error(withUsage('The `container` option is required.'));
  }

  var containerNode = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_8__.default)(container);
  var cssClasses = {
    root: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit(), userCssClasses.root),
    emptyRoot: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      modifierName: 'empty'
    }), userCssClasses.emptyRoot),
    list: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'list'
    }), userCssClasses.list),
    item: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item'
    }), userCssClasses.item)
  };
  var specializedRenderer = renderer({
    containerNode: containerNode,
    cssClasses: cssClasses,
    renderState: {},
    templates: templates
  });
  var makeWidget = (0,_lib_insights__WEBPACK_IMPORTED_MODULE_9__.default)(_connectors_hits_connectHits__WEBPACK_IMPORTED_MODULE_10__.default)(specializedRenderer, function () {
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null, containerNode);
  });
  return _objectSpread(_objectSpread({}, makeWidget({
    escapeHTML: escapeHTML,
    transformItems: transformItems
  })), {}, {
    $$widgetType: 'ais.hits'
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hits);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/widgets/index/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/widgets/index/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isIndexWidget": () => (/* binding */ isIndexWidget),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! algoliasearch-helper */ "./node_modules/algoliasearch-helper/index.js");
/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/mergeSearchParameters.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/resolveSearchParameters.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/checkIndexUiState.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/logger.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }



var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.createDocumentationMessageGenerator)({
  name: 'index-widget'
});
function isIndexWidget(widget) {
  return widget.$$type === 'ais.index';
}
/**
 * This is the same content as helper._change / setState, but allowing for extra
 * UiState to be synchronized.
 * see: https://github.com/algolia/algoliasearch-helper-js/blob/6b835ffd07742f2d6b314022cce6848f5cfecd4a/src/algoliasearch.helper.js#L1311-L1324
 */

function privateHelperSetState(helper, _ref) {
  var state = _ref.state,
      isPageReset = _ref.isPageReset,
      _uiState = _ref._uiState;

  if (state !== helper.state) {
    helper.state = state;
    helper.emit('change', {
      state: helper.state,
      results: helper.lastResults,
      isPageReset: isPageReset,
      _uiState: _uiState
    });
  }
}

function getLocalWidgetsUiState(widgets, widgetStateOptions) {
  var initialUiState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return widgets.reduce(function (uiState, widget) {
    if (isIndexWidget(widget)) {
      return uiState;
    }

    if (!widget.getWidgetUiState && !widget.getWidgetState) {
      return uiState;
    }

    if (widget.getWidgetUiState) {
      return widget.getWidgetUiState(uiState, widgetStateOptions);
    }

    return widget.getWidgetState(uiState, widgetStateOptions);
  }, initialUiState);
}

function getLocalWidgetsSearchParameters(widgets, widgetSearchParametersOptions) {
  var initialSearchParameters = widgetSearchParametersOptions.initialSearchParameters,
      rest = _objectWithoutProperties(widgetSearchParametersOptions, ["initialSearchParameters"]);

  return widgets.filter(function (widget) {
    return !isIndexWidget(widget);
  }).reduce(function (state, widget) {
    if (!widget.getWidgetSearchParameters) {
      return state;
    }

    return widget.getWidgetSearchParameters(state, rest);
  }, initialSearchParameters);
}

function resetPageFromWidgets(widgets) {
  var indexWidgets = widgets.filter(isIndexWidget);

  if (indexWidgets.length === 0) {
    return;
  }

  indexWidgets.forEach(function (widget) {
    var widgetHelper = widget.getHelper();
    privateHelperSetState(widgetHelper, {
      state: widgetHelper.state.resetPage(),
      isPageReset: true
    });
    resetPageFromWidgets(widget.getWidgets());
  });
}

function resolveScopedResultsFromWidgets(widgets) {
  var indexWidgets = widgets.filter(isIndexWidget);
  return indexWidgets.reduce(function (scopedResults, current) {
    return scopedResults.concat.apply(scopedResults, [{
      indexId: current.getIndexId(),
      results: current.getResults(),
      helper: current.getHelper()
    }].concat(_toConsumableArray(resolveScopedResultsFromWidgets(current.getWidgets()))));
  }, []);
}

var index = function index(widgetParams) {
  if (widgetParams === undefined || widgetParams.indexName === undefined) {
    throw new Error(withUsage('The `indexName` option is required.'));
  }

  var indexName = widgetParams.indexName,
      _widgetParams$indexId = widgetParams.indexId,
      indexId = _widgetParams$indexId === void 0 ? indexName : _widgetParams$indexId;
  var localWidgets = [];
  var localUiState = {};
  var localInstantSearchInstance = null;
  var localParent = null;
  var helper = null;
  var derivedHelper = null;
  return {
    $$type: 'ais.index',
    $$widgetType: 'ais.index',
    getIndexName: function getIndexName() {
      return indexName;
    },
    getIndexId: function getIndexId() {
      return indexId;
    },
    getHelper: function getHelper() {
      return helper;
    },
    getResults: function getResults() {
      return derivedHelper && derivedHelper.lastResults;
    },
    getScopedResults: function getScopedResults() {
      var widgetParent = this.getParent(); // If the widget is the root, we consider itself as the only sibling.

      var widgetSiblings = widgetParent ? widgetParent.getWidgets() : [this];
      return resolveScopedResultsFromWidgets(widgetSiblings);
    },
    getParent: function getParent() {
      return localParent;
    },
    createURL: function createURL(nextState) {
      return localInstantSearchInstance._createURL(_defineProperty({}, indexId, getLocalWidgetsUiState(localWidgets, {
        searchParameters: nextState,
        helper: helper
      })));
    },
    getWidgets: function getWidgets() {
      return localWidgets;
    },
    addWidgets: function addWidgets(widgets) {
      var _this = this;

      if (!Array.isArray(widgets)) {
        throw new Error(withUsage('The `addWidgets` method expects an array of widgets.'));
      }

      if (widgets.some(function (widget) {
        return typeof widget.init !== 'function' && typeof widget.render !== 'function';
      })) {
        throw new Error(withUsage('The widget definition expects a `render` and/or an `init` method.'));
      }

      localWidgets = localWidgets.concat(widgets);

      if (localInstantSearchInstance && Boolean(widgets.length)) {
        privateHelperSetState(helper, {
          state: getLocalWidgetsSearchParameters(localWidgets, {
            uiState: localUiState,
            initialSearchParameters: helper.state
          }),
          _uiState: localUiState
        }); // We compute the render state before calling `init` in a separate loop
        // to construct the whole render state object that is then passed to
        // `init`.

        widgets.forEach(function (widget) {
          if (widget.getRenderState) {
            var renderState = widget.getRenderState(localInstantSearchInstance.renderState[_this.getIndexId()] || {}, {
              uiState: localInstantSearchInstance._initialUiState,
              helper: _this.getHelper(),
              parent: _this,
              instantSearchInstance: localInstantSearchInstance,
              state: helper.state,
              renderState: localInstantSearchInstance.renderState,
              templatesConfig: localInstantSearchInstance.templatesConfig,
              createURL: _this.createURL,
              scopedResults: [],
              searchMetadata: {
                isSearchStalled: localInstantSearchInstance._isSearchStalled
              }
            });
            storeRenderState({
              renderState: renderState,
              instantSearchInstance: localInstantSearchInstance,
              parent: _this
            });
          }
        });
        widgets.forEach(function (widget) {
          if (widget.init) {
            widget.init({
              helper: helper,
              parent: _this,
              uiState: localInstantSearchInstance._initialUiState,
              instantSearchInstance: localInstantSearchInstance,
              state: helper.state,
              renderState: localInstantSearchInstance.renderState,
              templatesConfig: localInstantSearchInstance.templatesConfig,
              createURL: _this.createURL,
              scopedResults: [],
              searchMetadata: {
                isSearchStalled: localInstantSearchInstance._isSearchStalled
              }
            });
          }
        });
        localInstantSearchInstance.scheduleSearch();
      }

      return this;
    },
    removeWidgets: function removeWidgets(widgets) {
      var _this2 = this;

      if (!Array.isArray(widgets)) {
        throw new Error(withUsage('The `removeWidgets` method expects an array of widgets.'));
      }

      if (widgets.some(function (widget) {
        return typeof widget.dispose !== 'function';
      })) {
        throw new Error(withUsage('The widget definition expects a `dispose` method.'));
      }

      localWidgets = localWidgets.filter(function (widget) {
        return widgets.indexOf(widget) === -1;
      });

      if (localInstantSearchInstance && Boolean(widgets.length)) {
        var nextState = widgets.reduce(function (state, widget) {
          // the `dispose` method exists at this point we already assert it
          var next = widget.dispose({
            helper: helper,
            state: state,
            parent: _this2
          });
          return next || state;
        }, helper.state);
        localUiState = getLocalWidgetsUiState(localWidgets, {
          searchParameters: nextState,
          helper: helper
        });
        helper.setState(getLocalWidgetsSearchParameters(localWidgets, {
          uiState: localUiState,
          initialSearchParameters: nextState
        }));

        if (localWidgets.length) {
          localInstantSearchInstance.scheduleSearch();
        }
      }

      return this;
    },
    init: function init(_ref2) {
      var _this3 = this;

      var instantSearchInstance = _ref2.instantSearchInstance,
          parent = _ref2.parent,
          uiState = _ref2.uiState;

      if (helper !== null) {
        // helper is already initialized, therefore we do not need to set up
        // any listeners
        return;
      }

      localInstantSearchInstance = instantSearchInstance;
      localParent = parent;
      localUiState = uiState[indexId] || {}; // The `mainHelper` is already defined at this point. The instance is created
      // inside InstantSearch at the `start` method, which occurs before the `init`
      // step.

      var mainHelper = instantSearchInstance.mainHelper;
      var parameters = getLocalWidgetsSearchParameters(localWidgets, {
        uiState: localUiState,
        initialSearchParameters: new (algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default().SearchParameters)({
          index: indexName
        })
      }); // This Helper is only used for state management we do not care about the
      // `searchClient`. Only the "main" Helper created at the `InstantSearch`
      // level is aware of the client.

      helper = algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default()({}, parameters.index, parameters); // We forward the call to `search` to the "main" instance of the Helper
      // which is responsible for managing the queries (it's the only one that is
      // aware of the `searchClient`).

      helper.search = function () {
        if (instantSearchInstance.onStateChange) {
          instantSearchInstance.onStateChange({
            uiState: instantSearchInstance.mainIndex.getWidgetUiState({}),
            setUiState: instantSearchInstance.setUiState.bind(instantSearchInstance)
          }); // We don't trigger a search when controlled because it becomes the
          // responsibility of `setUiState`.

          return mainHelper;
        }

        return mainHelper.search();
      };

      helper.searchWithoutTriggeringOnStateChange = function () {
        return mainHelper.search();
      }; // We use the same pattern for the `searchForFacetValues`.


      helper.searchForFacetValues = function (facetName, facetValue, maxFacetHits, userState) {
        var state = helper.state.setQueryParameters(userState);
        return mainHelper.searchForFacetValues(facetName, facetValue, maxFacetHits, state);
      };

      derivedHelper = mainHelper.derive(function () {
        return _lib_utils__WEBPACK_IMPORTED_MODULE_2__.default.apply(void 0, _toConsumableArray((0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.default)(_this3)));
      }); // Subscribe to the Helper state changes for the page before widgets
      // are initialized. This behavior mimics the original one of the Helper.
      // It makes sense to replicate it at the `init` step. We have another
      // listener on `change` below, once `init` is done.

      helper.on('change', function (_ref3) {
        var isPageReset = _ref3.isPageReset;

        if (isPageReset) {
          resetPageFromWidgets(localWidgets);
        }
      });
      derivedHelper.on('search', function () {
        // The index does not manage the "staleness" of the search. This is the
        // responsibility of the main instance. It does not make sense to manage
        // it at the index level because it's either: all of them or none of them
        // that are stalled. The queries are performed into a single network request.
        instantSearchInstance.scheduleStalledRender();

        if (true) {
          (0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.checkIndexUiState)({
            index: _this3,
            indexUiState: localUiState
          });
        }
      });
      derivedHelper.on('result', function (_ref4) {
        var results = _ref4.results;
        // The index does not render the results it schedules a new render
        // to let all the other indices emit their own results. It allows us to
        // run the render process in one pass.
        instantSearchInstance.scheduleRender(); // the derived helper is the one which actually searches, but the helper
        // which is exposed e.g. via instance.helper, doesn't search, and thus
        // does not have access to lastResults, which it used to in pre-federated
        // search behavior.

        helper.lastResults = results;
      }); // We compute the render state before calling `init` in a separate loop
      // to construct the whole render state object that is then passed to
      // `init`.

      localWidgets.forEach(function (widget) {
        if (widget.getRenderState) {
          var renderState = widget.getRenderState(instantSearchInstance.renderState[_this3.getIndexId()] || {}, {
            uiState: uiState,
            helper: helper,
            parent: _this3,
            instantSearchInstance: instantSearchInstance,
            state: helper.state,
            renderState: instantSearchInstance.renderState,
            templatesConfig: instantSearchInstance.templatesConfig,
            createURL: _this3.createURL,
            scopedResults: [],
            searchMetadata: {
              isSearchStalled: instantSearchInstance._isSearchStalled
            }
          });
          storeRenderState({
            renderState: renderState,
            instantSearchInstance: instantSearchInstance,
            parent: _this3
          });
        }
      });
      localWidgets.forEach(function (widget) {
         true ? (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.warning)( // if it has NO getWidgetState or if it has getWidgetUiState, we don't warn
        // aka we warn if there's _only_ getWidgetState
        !widget.getWidgetState || Boolean(widget.getWidgetUiState), 'The `getWidgetState` method is renamed `getWidgetUiState` and will no longer exist under that name in InstantSearch.js 5.x. Please use `getWidgetUiState` instead.') : 0;

        if (widget.init) {
          widget.init({
            uiState: uiState,
            helper: helper,
            parent: _this3,
            instantSearchInstance: instantSearchInstance,
            state: helper.state,
            renderState: instantSearchInstance.renderState,
            templatesConfig: instantSearchInstance.templatesConfig,
            createURL: _this3.createURL,
            scopedResults: [],
            searchMetadata: {
              isSearchStalled: instantSearchInstance._isSearchStalled
            }
          });
        }
      }); // Subscribe to the Helper state changes for the `uiState` once widgets
      // are initialized. Until the first render, state changes are part of the
      // configuration step. This is mainly for backward compatibility with custom
      // widgets. When the subscription happens before the `init` step, the (static)
      // configuration of the widget is pushed in the URL. That's what we want to avoid.
      // https://github.com/algolia/instantsearch.js/pull/994/commits/4a672ae3fd78809e213de0368549ef12e9dc9454

      helper.on('change', function (event) {
        var state = event.state;
        var _uiState = event._uiState;
        localUiState = getLocalWidgetsUiState(localWidgets, {
          searchParameters: state,
          helper: helper
        }, _uiState || {}); // We don't trigger an internal change when controlled because it
        // becomes the responsibility of `setUiState`.

        if (!instantSearchInstance.onStateChange) {
          instantSearchInstance.onInternalStateChange();
        }
      });
    },
    render: function render(_ref5) {
      var _this4 = this;

      var instantSearchInstance = _ref5.instantSearchInstance;

      if (!this.getResults()) {
        return;
      }

      localWidgets.forEach(function (widget) {
        if (widget.getRenderState) {
          var renderState = widget.getRenderState(instantSearchInstance.renderState[_this4.getIndexId()] || {}, {
            helper: _this4.getHelper(),
            parent: _this4,
            instantSearchInstance: instantSearchInstance,
            results: _this4.getResults(),
            scopedResults: _this4.getScopedResults(),
            state: _this4.getResults()._state,
            renderState: instantSearchInstance.renderState,
            templatesConfig: instantSearchInstance.templatesConfig,
            createURL: _this4.createURL,
            searchMetadata: {
              isSearchStalled: instantSearchInstance._isSearchStalled
            }
          });
          storeRenderState({
            renderState: renderState,
            instantSearchInstance: instantSearchInstance,
            parent: _this4
          });
        }
      });
      localWidgets.forEach(function (widget) {
        // At this point, all the variables used below are set. Both `helper`
        // and `derivedHelper` have been created at the `init` step. The attribute
        // `lastResults` might be `null` though. It's possible that a stalled render
        // happens before the result e.g with a dynamically added index the request might
        // be delayed. The render is triggered for the complete tree but some parts do
        // not have results yet.
        if (widget.render) {
          widget.render({
            helper: helper,
            parent: _this4,
            instantSearchInstance: instantSearchInstance,
            results: _this4.getResults(),
            scopedResults: _this4.getScopedResults(),
            state: _this4.getResults()._state,
            renderState: instantSearchInstance.renderState,
            templatesConfig: instantSearchInstance.templatesConfig,
            createURL: _this4.createURL,
            searchMetadata: {
              isSearchStalled: instantSearchInstance._isSearchStalled
            }
          });
        }
      });
    },
    dispose: function dispose() {
      var _this5 = this;

      localWidgets.forEach(function (widget) {
        if (widget.dispose) {
          // The dispose function is always called once the instance is started
          // (it's an effect of `removeWidgets`). The index is initialized and
          // the Helper is available. We don't care about the return value of
          // `dispose` because the index is removed. We can't call `removeWidgets`
          // because we want to keep the widgets on the instance, to allow idempotent
          // operations on `add` & `remove`.
          widget.dispose({
            helper: helper,
            state: helper.state,
            parent: _this5
          });
        }
      });
      localInstantSearchInstance = null;
      localParent = null;
      helper.removeAllListeners();
      helper = null;
      derivedHelper.detach();
      derivedHelper = null;
    },
    getWidgetUiState: function getWidgetUiState(uiState) {
      return localWidgets.filter(isIndexWidget).reduce(function (previousUiState, innerIndex) {
        return innerIndex.getWidgetUiState(previousUiState);
      }, _objectSpread(_objectSpread({}, uiState), {}, _defineProperty({}, this.getIndexId(), localUiState)));
    },
    getWidgetState: function getWidgetState(uiState) {
       true ? (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.warning)(false, 'The `getWidgetState` method is renamed `getWidgetUiState` and will no longer exist under that name in InstantSearch.js 5.x. Please use `getWidgetUiState` instead.') : 0;
      return this.getWidgetUiState(uiState);
    },
    getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {
      var uiState = _ref6.uiState;
      return getLocalWidgetsSearchParameters(localWidgets, {
        uiState: uiState,
        initialSearchParameters: searchParameters
      });
    },
    refreshUiState: function refreshUiState() {
      localUiState = getLocalWidgetsUiState(localWidgets, {
        searchParameters: this.getHelper().state,
        helper: this.getHelper()
      });
    }
  };
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);

function storeRenderState(_ref7) {
  var renderState = _ref7.renderState,
      instantSearchInstance = _ref7.instantSearchInstance,
      parent = _ref7.parent;
  var parentIndexName = parent ? parent.getIndexId() : instantSearchInstance.mainIndex.getIndexId();
  instantSearchInstance.renderState = _objectSpread(_objectSpread({}, instantSearchInstance.renderState), {}, _defineProperty({}, parentIndexName, _objectSpread(_objectSpread({}, instantSearchInstance.renderState[parentIndexName]), renderState)));
}

/***/ }),

/***/ "./node_modules/instantsearch.js/es/widgets/pagination/pagination.js":
/*!***************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/widgets/pagination/pagination.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Pagination_Pagination__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/Pagination/Pagination */ "./node_modules/instantsearch.js/es/components/Pagination/Pagination.js");
/* harmony import */ var _connectors_pagination_connectPagination__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../connectors/pagination/connectPagination */ "./node_modules/instantsearch.js/es/connectors/pagination/connectPagination.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getContainerNode.js");
/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/suit */ "./node_modules/instantsearch.js/es/lib/suit.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** @jsx h */






var suit = (0,_lib_suit__WEBPACK_IMPORTED_MODULE_2__.component)('Pagination');
var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_3__.createDocumentationMessageGenerator)({
  name: 'pagination'
});
var defaultTemplates = {
  previous: '‹',
  next: '›',
  first: '«',
  last: '»'
};

var renderer = function renderer(_ref) {
  var containerNode = _ref.containerNode,
      cssClasses = _ref.cssClasses,
      templates = _ref.templates,
      showFirst = _ref.showFirst,
      showLast = _ref.showLast,
      showPrevious = _ref.showPrevious,
      showNext = _ref.showNext,
      scrollToNode = _ref.scrollToNode;
  return function (_ref2, isFirstRendering) {
    var createURL = _ref2.createURL,
        currentRefinement = _ref2.currentRefinement,
        nbPages = _ref2.nbPages,
        pages = _ref2.pages,
        isFirstPage = _ref2.isFirstPage,
        isLastPage = _ref2.isLastPage,
        refine = _ref2.refine;
    if (isFirstRendering) return;

    var setCurrentPage = function setCurrentPage(pageNumber) {
      refine(pageNumber);

      if (scrollToNode !== false) {
        scrollToNode.scrollIntoView();
      }
    };

    (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_components_Pagination_Pagination__WEBPACK_IMPORTED_MODULE_4__.default, {
      createURL: createURL,
      cssClasses: cssClasses,
      currentPage: currentRefinement,
      templates: templates,
      nbPages: nbPages,
      pages: pages,
      isFirstPage: isFirstPage,
      isLastPage: isLastPage,
      setCurrentPage: setCurrentPage,
      showFirst: showFirst,
      showLast: showLast,
      showPrevious: showPrevious,
      showNext: showNext
    }), containerNode);
  };
};

var pagination = function pagination(widgetParams) {
  var _ref3 = widgetParams || {},
      container = _ref3.container,
      _ref3$templates = _ref3.templates,
      userTemplates = _ref3$templates === void 0 ? {} : _ref3$templates,
      _ref3$cssClasses = _ref3.cssClasses,
      userCssClasses = _ref3$cssClasses === void 0 ? {} : _ref3$cssClasses,
      totalPages = _ref3.totalPages,
      padding = _ref3.padding,
      _ref3$showFirst = _ref3.showFirst,
      showFirst = _ref3$showFirst === void 0 ? true : _ref3$showFirst,
      _ref3$showLast = _ref3.showLast,
      showLast = _ref3$showLast === void 0 ? true : _ref3$showLast,
      _ref3$showPrevious = _ref3.showPrevious,
      showPrevious = _ref3$showPrevious === void 0 ? true : _ref3$showPrevious,
      _ref3$showNext = _ref3.showNext,
      showNext = _ref3$showNext === void 0 ? true : _ref3$showNext,
      _ref3$scrollTo = _ref3.scrollTo,
      userScrollTo = _ref3$scrollTo === void 0 ? 'body' : _ref3$scrollTo;

  if (!container) {
    throw new Error(withUsage('The `container` option is required.'));
  }

  var containerNode = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.default)(container);
  var scrollTo = userScrollTo === true ? 'body' : userScrollTo;
  var scrollToNode = scrollTo !== false ? (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.default)(scrollTo) : false;
  var cssClasses = {
    root: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit(), userCssClasses.root),
    noRefinementRoot: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      modifierName: 'noRefinement'
    }), userCssClasses.noRefinementRoot),
    list: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'list'
    }), userCssClasses.list),
    item: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item'
    }), userCssClasses.item),
    firstPageItem: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item',
      modifierName: 'firstPage'
    }), userCssClasses.firstPageItem),
    lastPageItem: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item',
      modifierName: 'lastPage'
    }), userCssClasses.lastPageItem),
    previousPageItem: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item',
      modifierName: 'previousPage'
    }), userCssClasses.previousPageItem),
    nextPageItem: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item',
      modifierName: 'nextPage'
    }), userCssClasses.nextPageItem),
    pageItem: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item',
      modifierName: 'page'
    }), userCssClasses.pageItem),
    selectedItem: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item',
      modifierName: 'selected'
    }), userCssClasses.selectedItem),
    disabledItem: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'item',
      modifierName: 'disabled'
    }), userCssClasses.disabledItem),
    link: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'link'
    }), userCssClasses.link)
  };

  var templates = _objectSpread(_objectSpread({}, defaultTemplates), userTemplates);

  var specializedRenderer = renderer({
    containerNode: containerNode,
    cssClasses: cssClasses,
    templates: templates,
    showFirst: showFirst,
    showLast: showLast,
    showPrevious: showPrevious,
    showNext: showNext,
    scrollToNode: scrollToNode
  });
  var makeWidget = (0,_connectors_pagination_connectPagination__WEBPACK_IMPORTED_MODULE_6__.default)(specializedRenderer, function () {
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null, containerNode);
  });
  return _objectSpread(_objectSpread({}, makeWidget({
    totalPages: totalPages,
    padding: padding
  })), {}, {
    $$widgetType: 'ais.pagination'
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pagination);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/widgets/search-box/defaultTemplates.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/widgets/search-box/defaultTemplates.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var defaultTemplate = {
  reset: "\n<svg class=\"{{cssClasses.resetIcon}}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" width=\"10\" height=\"10\">\n  <path d=\"M8.114 10L.944 2.83 0 1.885 1.886 0l.943.943L10 8.113l7.17-7.17.944-.943L20 1.886l-.943.943-7.17 7.17 7.17 7.17.943.944L18.114 20l-.943-.943-7.17-7.17-7.17 7.17-.944.943L0 18.114l.943-.943L8.113 10z\"></path>\n</svg>\n  ",
  submit: "\n<svg class=\"{{cssClasses.submitIcon}}\" xmlns=\"http://www.w3.org/2000/svg\" width=\"10\" height=\"10\" viewBox=\"0 0 40 40\">\n  <path d=\"M26.804 29.01c-2.832 2.34-6.465 3.746-10.426 3.746C7.333 32.756 0 25.424 0 16.378 0 7.333 7.333 0 16.378 0c9.046 0 16.378 7.333 16.378 16.378 0 3.96-1.406 7.594-3.746 10.426l10.534 10.534c.607.607.61 1.59-.004 2.202-.61.61-1.597.61-2.202.004L26.804 29.01zm-10.426.627c7.323 0 13.26-5.936 13.26-13.26 0-7.32-5.937-13.257-13.26-13.257C9.056 3.12 3.12 9.056 3.12 16.378c0 7.323 5.936 13.26 13.258 13.26z\"></path>\n</svg>\n  ",
  loadingIndicator: "\n<svg class=\"{{cssClasses.loadingIcon}}\" width=\"16\" height=\"16\" viewBox=\"0 0 38 38\" xmlns=\"http://www.w3.org/2000/svg\" stroke=\"#444\">\n  <g fill=\"none\" fillRule=\"evenodd\">\n    <g transform=\"translate(1 1)\" strokeWidth=\"2\">\n      <circle strokeOpacity=\".5\" cx=\"18\" cy=\"18\" r=\"18\" />\n      <path d=\"M36 18c0-9.94-8.06-18-18-18\">\n        <animateTransform\n          attributeName=\"transform\"\n          type=\"rotate\"\n          from=\"0 18 18\"\n          to=\"360 18 18\"\n          dur=\"1s\"\n          repeatCount=\"indefinite\"\n        />\n      </path>\n    </g>\n  </g>\n</svg>\n  "
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaultTemplate);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/widgets/search-box/search-box.js":
/*!***************************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/widgets/search-box/search-box.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getContainerNode.js");
/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/suit */ "./node_modules/instantsearch.js/es/lib/suit.js");
/* harmony import */ var _connectors_search_box_connectSearchBox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../connectors/search-box/connectSearchBox */ "./node_modules/instantsearch.js/es/connectors/search-box/connectSearchBox.js");
/* harmony import */ var _components_SearchBox_SearchBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/SearchBox/SearchBox */ "./node_modules/instantsearch.js/es/components/SearchBox/SearchBox.js");
/* harmony import */ var _defaultTemplates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./defaultTemplates */ "./node_modules/instantsearch.js/es/widgets/search-box/defaultTemplates.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** @jsx h */







var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.createDocumentationMessageGenerator)({
  name: 'search-box'
});
var suit = (0,_lib_suit__WEBPACK_IMPORTED_MODULE_3__.component)('SearchBox');

var renderer = function renderer(_ref) {
  var containerNode = _ref.containerNode,
      cssClasses = _ref.cssClasses,
      placeholder = _ref.placeholder,
      templates = _ref.templates,
      autofocus = _ref.autofocus,
      searchAsYouType = _ref.searchAsYouType,
      showReset = _ref.showReset,
      showSubmit = _ref.showSubmit,
      showLoadingIndicator = _ref.showLoadingIndicator;
  return function (_ref2) {
    var refine = _ref2.refine,
        query = _ref2.query,
        isSearchStalled = _ref2.isSearchStalled;
    (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_components_SearchBox_SearchBox__WEBPACK_IMPORTED_MODULE_4__.default, {
      query: query,
      placeholder: placeholder,
      autofocus: autofocus,
      refine: refine,
      searchAsYouType: searchAsYouType,
      templates: templates,
      showSubmit: showSubmit,
      showReset: showReset,
      showLoadingIndicator: showLoadingIndicator,
      isSearchStalled: isSearchStalled,
      cssClasses: cssClasses
    }), containerNode);
  };
};
/**
 * The searchbox widget is used to let the user set a text based query.
 *
 * This is usually the  main entry point to start the search in an instantsearch context. For that
 * reason is usually placed on top, and not hidden so that the user can start searching right
 * away.
 *
 */


var searchBox = function searchBox(widgetParams) {
  var _ref3 = widgetParams || {},
      container = _ref3.container,
      _ref3$placeholder = _ref3.placeholder,
      placeholder = _ref3$placeholder === void 0 ? '' : _ref3$placeholder,
      _ref3$cssClasses = _ref3.cssClasses,
      userCssClasses = _ref3$cssClasses === void 0 ? {} : _ref3$cssClasses,
      _ref3$autofocus = _ref3.autofocus,
      autofocus = _ref3$autofocus === void 0 ? false : _ref3$autofocus,
      _ref3$searchAsYouType = _ref3.searchAsYouType,
      searchAsYouType = _ref3$searchAsYouType === void 0 ? true : _ref3$searchAsYouType,
      _ref3$showReset = _ref3.showReset,
      showReset = _ref3$showReset === void 0 ? true : _ref3$showReset,
      _ref3$showSubmit = _ref3.showSubmit,
      showSubmit = _ref3$showSubmit === void 0 ? true : _ref3$showSubmit,
      _ref3$showLoadingIndi = _ref3.showLoadingIndicator,
      showLoadingIndicator = _ref3$showLoadingIndi === void 0 ? true : _ref3$showLoadingIndi,
      queryHook = _ref3.queryHook,
      _ref3$templates = _ref3.templates,
      userTemplates = _ref3$templates === void 0 ? {} : _ref3$templates;

  if (!container) {
    throw new Error(withUsage('The `container` option is required.'));
  }

  var containerNode = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_5__.default)(container);
  var cssClasses = {
    root: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit(), userCssClasses.root),
    form: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'form'
    }), userCssClasses.form),
    input: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'input'
    }), userCssClasses.input),
    submit: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'submit'
    }), userCssClasses.submit),
    submitIcon: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'submitIcon'
    }), userCssClasses.submitIcon),
    reset: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'reset'
    }), userCssClasses.reset),
    resetIcon: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'resetIcon'
    }), userCssClasses.resetIcon),
    loadingIndicator: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'loadingIndicator'
    }), userCssClasses.loadingIndicator),
    loadingIcon: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'loadingIcon'
    }), userCssClasses.loadingIcon)
  };

  var templates = _objectSpread(_objectSpread({}, _defaultTemplates__WEBPACK_IMPORTED_MODULE_6__.default), userTemplates);

  var specializedRenderer = renderer({
    containerNode: containerNode,
    cssClasses: cssClasses,
    placeholder: placeholder,
    templates: templates,
    autofocus: autofocus,
    searchAsYouType: searchAsYouType,
    showReset: showReset,
    showSubmit: showSubmit,
    showLoadingIndicator: showLoadingIndicator
  });
  var makeWidget = (0,_connectors_search_box_connectSearchBox__WEBPACK_IMPORTED_MODULE_7__.default)(specializedRenderer, function () {
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null, containerNode);
  });
  return _objectSpread(_objectSpread({}, makeWidget({
    queryHook: queryHook
  })), {}, {
    $$widgetType: 'ais.searchBox'
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (searchBox);

/***/ }),

/***/ "./node_modules/instantsearch.js/es/widgets/stats/stats.js":
/*!*****************************************************************!*\
  !*** ./node_modules/instantsearch.js/es/widgets/stats/stats.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultTemplates": () => (/* binding */ defaultTemplates),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Stats_Stats__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/Stats/Stats */ "./node_modules/instantsearch.js/es/components/Stats/Stats.js");
/* harmony import */ var _connectors_stats_connectStats__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../connectors/stats/connectStats */ "./node_modules/instantsearch.js/es/connectors/stats/connectStats.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/documentation.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/prepareTemplateProps.js");
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/utils */ "./node_modules/instantsearch.js/es/lib/utils/getContainerNode.js");
/* harmony import */ var _lib_suit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/suit */ "./node_modules/instantsearch.js/es/lib/suit.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** @jsx h */






var withUsage = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_2__.createDocumentationMessageGenerator)({
  name: 'stats'
});
var suit = (0,_lib_suit__WEBPACK_IMPORTED_MODULE_3__.component)('Stats');
var defaultTemplates = {
  text: "\n    {{#areHitsSorted}}\n      {{#hasNoSortedResults}}No relevant results{{/hasNoSortedResults}}\n      {{#hasOneSortedResults}}1 relevant result{{/hasOneSortedResults}}\n      {{#hasManySortedResults}}{{#helpers.formatNumber}}{{nbSortedHits}}{{/helpers.formatNumber}} relevant results{{/hasManySortedResults}}\n      sorted out of {{#helpers.formatNumber}}{{nbHits}}{{/helpers.formatNumber}}\n    {{/areHitsSorted}}\n    {{^areHitsSorted}}\n      {{#hasNoResults}}No results{{/hasNoResults}}\n      {{#hasOneResult}}1 result{{/hasOneResult}}\n      {{#hasManyResults}}{{#helpers.formatNumber}}{{nbHits}}{{/helpers.formatNumber}} results{{/hasManyResults}}\n    {{/areHitsSorted}}\n    found in {{processingTimeMS}}ms"
};

var renderer = function renderer(_ref) {
  var renderState = _ref.renderState,
      cssClasses = _ref.cssClasses,
      containerNode = _ref.containerNode,
      templates = _ref.templates;
  return function (_ref2, isFirstRendering) {
    var hitsPerPage = _ref2.hitsPerPage,
        nbHits = _ref2.nbHits,
        nbSortedHits = _ref2.nbSortedHits,
        areHitsSorted = _ref2.areHitsSorted,
        nbPages = _ref2.nbPages,
        page = _ref2.page,
        processingTimeMS = _ref2.processingTimeMS,
        query = _ref2.query,
        instantSearchInstance = _ref2.instantSearchInstance;

    if (isFirstRendering) {
      renderState.templateProps = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.default)({
        defaultTemplates: defaultTemplates,
        templatesConfig: instantSearchInstance.templatesConfig,
        templates: templates
      });
      return;
    }

    (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_components_Stats_Stats__WEBPACK_IMPORTED_MODULE_5__.default, {
      cssClasses: cssClasses,
      hitsPerPage: hitsPerPage,
      nbHits: nbHits,
      nbSortedHits: nbSortedHits,
      areHitsSorted: areHitsSorted,
      nbPages: nbPages,
      page: page,
      processingTimeMS: processingTimeMS,
      query: query,
      templateProps: renderState.templateProps
    }), containerNode);
  };
};
/**
 * The `stats` widget is used to display useful insights about the current results.
 *
 * By default, it will display the **number of hits** and the time taken to compute the
 * results inside the engine.
 */


var stats = function stats(widgetParams) {
  var _ref3 = widgetParams || {},
      container = _ref3.container,
      _ref3$cssClasses = _ref3.cssClasses,
      userCssClasses = _ref3$cssClasses === void 0 ? {} : _ref3$cssClasses,
      _ref3$templates = _ref3.templates,
      templates = _ref3$templates === void 0 ? {} : _ref3$templates;

  if (!container) {
    throw new Error(withUsage('The `container` option is required.'));
  }

  var containerNode = (0,_lib_utils__WEBPACK_IMPORTED_MODULE_6__.default)(container);
  var cssClasses = {
    root: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit(), userCssClasses.root),
    text: classnames__WEBPACK_IMPORTED_MODULE_1___default()(suit({
      descendantName: 'text'
    }), userCssClasses.text)
  };
  var specializedRenderer = renderer({
    containerNode: containerNode,
    cssClasses: cssClasses,
    templates: templates,
    renderState: {}
  });
  var makeWidget = (0,_connectors_stats_connectStats__WEBPACK_IMPORTED_MODULE_7__.default)(specializedRenderer, function () {
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null, containerNode);
  });
  return _objectSpread(_objectSpread({}, makeWidget({})), {}, {
    $$widgetType: 'ais.stats'
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stats);

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ S),
/* harmony export */   "hydrate": () => (/* binding */ q),
/* harmony export */   "createElement": () => (/* binding */ v),
/* harmony export */   "h": () => (/* binding */ v),
/* harmony export */   "Fragment": () => (/* binding */ d),
/* harmony export */   "createRef": () => (/* binding */ p),
/* harmony export */   "isValidElement": () => (/* binding */ i),
/* harmony export */   "Component": () => (/* binding */ _),
/* harmony export */   "cloneElement": () => (/* binding */ B),
/* harmony export */   "createContext": () => (/* binding */ D),
/* harmony export */   "toChildArray": () => (/* binding */ A),
/* harmony export */   "options": () => (/* binding */ l)
/* harmony export */ });
var n,l,u,i,t,o,r,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(l,u,i){var t,o,r,f={};for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return y(l,f,t,o,null)}function y(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u:r};return null!=l.vnode&&l.vnode(f),f}function p(){return{current:null}}function d(n){return n.children}function _(n,l){this.props=n,this.context=l}function k(n,l){if(null==l)return n.__?k(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?k(n):null}function b(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return b(n)}}function m(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g.__r++||r!==l.debounceRendering)&&((r=l.debounceRendering)||o)(g)}function g(){for(var n;g.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=a({},t)).__v=t.__v+1,j(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?k(t):o,t.__h),z(u,t),t.__e!=o&&b(t)))})}function w(n,l,u,i,t,o,r,f,s,a){var h,v,p,_,b,m,g,w=i&&i.__k||c,A=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(_=u.__k[h]=null==(_=l[h])||"boolean"==typeof _?null:"string"==typeof _||"number"==typeof _||"bigint"==typeof _?y(null,_,null,null,_):Array.isArray(_)?y(d,{children:_},null,null,null):_.__b>0?y(_.type,_.props,_.key,null,_.__v):_)){if(_.__=u,_.__b=u.__b+1,null===(p=w[h])||p&&_.key==p.key&&_.type===p.type)w[h]=void 0;else for(v=0;v<A;v++){if((p=w[v])&&_.key==p.key&&_.type===p.type){w[v]=void 0;break}p=null}j(n,_,p=p||e,t,o,r,f,s,a),b=_.__e,(v=_.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,_),g.push(v,_.__c||b,_)),null!=b?(null==m&&(m=b),"function"==typeof _.type&&null!=_.__k&&_.__k===p.__k?_.__d=s=x(_,s,n):s=P(n,_,p,w,b,s),a||"option"!==u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&p.__e==s&&s.parentNode!=n&&(s=k(p))}for(u.__e=m,h=A;h--;)null!=w[h]&&("function"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=k(i,h+1)),N(w[h],w[h]));if(g)for(h=0;h<g.length;h++)M(g[h],g[++h],g[++h])}function x(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,l="function"==typeof t.type?x(t,l,u):P(u,t,t,n.__k,t.__e,l));return l}function A(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){A(n,l)}):l.push(n)),l}function P(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else{for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o}return void 0!==r?r:t.nextSibling}function C(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||H(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||H(n,o,l[o],u[o],i)}function $(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||s.test(l)?u:u+"px"}function H(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||$(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l])}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T:I,o):n.removeEventListener(l,o?T:I,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function I(n){this.l[n.type+!1](l.event?l.event(n):n)}function T(n){this.l[n.type+!0](l.event?l.event(n):n)}function j(n,u,i,t,o,r,f,e,c){var s,h,v,y,p,k,b,m,g,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(s=l.__b)&&s(u);try{n:if("function"==typeof P){if(m=u.props,g=(s=P.contextType)&&t[s.__c],x=s?g?g.props.value:s.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:("prototype"in P&&P.prototype.render?u.__c=h=new P(m,x):(u.__c=h=new _(m,x),h.constructor=P,h.render=O),g&&g.sub(h),h.props=m,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=a({},h.__s)),a(h.__s,P.getDerivedStateFromProps(m,h.__s))),y=h.props,p=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,x)||u.__v===i.__v){h.props=m,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,p,k)})}h.context=x,h.props=m,h.state=h.__s,(s=l.__r)&&s(u),h.__d=!1,h.__v=u,h.__P=n,s=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=a(a({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,p)),A=null!=s&&s.type===d&&null==s.key?s.props.children:s,w(n,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,o,r,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l.__e(n,u,i)}}function z(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function L(l,u,i,t,o,r,f,c){var s,a,v,y=i.props,p=u.props,d=u.type,_=0;if("svg"===d&&(o=!0),null!=r)for(;_<r.length;_++)if((s=r[_])&&(s===l||(d?s.localName==d:3==s.nodeType))){l=s,r[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),r=null,c=!1}if(null===d)y===p||c&&l.data===p||(l.data=p);else{if(r=r&&n.call(l.childNodes),a=(y=i.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(v||a)&&(v&&(a&&v.__html==a.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||""))}if(C(l,p,y,o,c),v)u.__k=[];else if(_=u.props.children,w(l,Array.isArray(_)?_:[_],u,i,t,o&&"foreignObject"!==d,r,f,r?r[0]:i.__k&&k(i,0),c),null!=r)for(_=r.length;_--;)null!=r[_]&&h(r[_]);c||("value"in p&&void 0!==(_=p.value)&&(_!==l.value||"progress"===d&&!_)&&H(l,"value",_,y.value,!1),"checked"in p&&void 0!==(_=p.checked)&&_!==l.checked&&H(l,"checked",_,y.checked,!1))}return l}function M(n,u,i){try{"function"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function N(n,u,i){var t,o;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,"function"!=typeof n.type);i||null==n.__e||h(n.__e),n.__e=n.__d=void 0}function O(n,l,u){return this.constructor(n,u)}function S(u,i,t){var o,r,f;l.__&&l.__(u,i),r=(o="function"==typeof t)?null:t&&t.__k||i.__k,f=[],j(i,u=(!o&&t||i).__k=v(d,null,[u]),r||e,e,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,f,!o&&t?t:r?r.__e:i.firstChild,o),z(f,u)}function q(n,l){S(n,l,q)}function B(l,u,i){var t,o,r,f=a({},l.props);for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),y(l.type,f,t||l.key,o||l.ref,null)}function D(n,l){var u={__c:l="__cC"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(m)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=c.slice,l={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l}throw n}},u=0,i=function(n){return null!=n&&void 0===n.constructor},_.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),"function"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),m(this))},_.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m(this))},_.prototype.render=d,t=[],o="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,f=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = typeof key === 'object' && key.value !== undefined ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix
            : prefix + (allowDots ? '.' + key : '[' + key + ']');

        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./src/js/search.js ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_find_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.find.js */ "./node_modules/core-js/modules/es.array.find.js");
/* harmony import */ var core_js_modules_es_array_find_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.regexp.exec.js */ "./node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_string_search_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.string.search.js */ "./node_modules/core-js/modules/es.string.search.js");
/* harmony import */ var core_js_modules_es_string_search_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_search_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ "./node_modules/core-js/modules/es.string.replace.js");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var algoliasearch_lite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! algoliasearch/lite */ "./node_modules/algoliasearch/dist/algoliasearch-lite.umd.js");
/* harmony import */ var algoliasearch_lite__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(algoliasearch_lite__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var instantsearch_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! instantsearch.js */ "./node_modules/instantsearch.js/es/index.js");
/* harmony import */ var instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! instantsearch.js/es/widgets */ "./node_modules/instantsearch.js/es/widgets/configure/configure.js");
/* harmony import */ var instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! instantsearch.js/es/widgets */ "./node_modules/instantsearch.js/es/widgets/search-box/search-box.js");
/* harmony import */ var instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! instantsearch.js/es/widgets */ "./node_modules/instantsearch.js/es/widgets/hits/hits.js");
/* harmony import */ var instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! instantsearch.js/es/widgets */ "./node_modules/instantsearch.js/es/widgets/stats/stats.js");
/* harmony import */ var instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! instantsearch.js/es/widgets */ "./node_modules/instantsearch.js/es/widgets/pagination/pagination.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/js/util.js");




// special thanks to https://blog.naaln.com/2016/07/hexo-with-algolia/





var initAlgolia = function initAlgolia() {
  $(document).ready(function () {
    var algoliaSettings = algolia;
    var isAlgoliaSettingsValid = algoliaSettings.applicationID && algoliaSettings.apiKey && algoliaSettings.indexName;

    if (!isAlgoliaSettingsValid) {
      window.console.error('Algolia Settings are invalid. Check docs: https://github.com/fi3ework/hexo-theme-archer/wiki/%E5%90%AF%E7%94%A8-Algolia-%E6%90%9C%E7%B4%A2#%E8%8E%B7%E5%8F%96-keys');
      return;
    }

    var searchClient = algoliasearch_lite__WEBPACK_IMPORTED_MODULE_5___default()(algoliaSettings.applicationID, algoliaSettings.apiKey);
    var search = (0,instantsearch_js__WEBPACK_IMPORTED_MODULE_6__.default)({
      indexName: algoliaSettings.indexName,
      searchClient: searchClient,
      searchFunction: function searchFunction(helper) {
        var searchInput = $('#algolia-search-input').find('input');
        var container = document.querySelector('.algolia-results');
        container.style.display = helper.state.query === '' ? 'none' : '';

        if (searchInput.val()) {
          helper.search();
        }
      },
      stalledSearchDelay: 500
    }); // Registering Widgets

    search.addWidgets([(0,instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_7__.default)({
      hitsPerPage: algoliaSettings.hits.per_page || 10
    }), (0,instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_8__.default)({
      container: '#algolia-search-input',
      placeholder: algoliaSettings.labels.input_placeholder,
      showSubmit: false,
      showReset: false,
      showLoadingIndicator: false
    }), (0,instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_9__.default)({
      container: '#algolia-hits',
      templates: {
        item: function item(data) {
          var link = data.permalink ? data.permalink : siteMeta.root + data.path;
          return '<a href="' + link + '" class="algolia-hit-item-link">' + instantsearch_js__WEBPACK_IMPORTED_MODULE_6__.default.highlight({
            attribute: 'title',
            hit: data,
            highlightedTagName: 'em'
          }) + '</a>';
        },
        empty: function empty(data) {
          return '<i class="fas fa-drafting-compass fa-10x"></i>' + '<div class="algolia-hit-empty-label">' + algoliaSettings.labels.hits_empty.replace(/\$\{query\}/, data.query) + '</div>';
        }
      },
      cssClasses: {
        item: 'algolia-hit-item',
        list: 'algolia-hit-list',
        root: 'algolia-hit',
        emptyRoot: 'algolia-hit-empty'
      }
    }), (0,instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_10__.default)({
      container: '#algolia-stats',
      templates: {
        text: function text(data) {
          var stats = algoliaSettings.labels.hits_stats.replace(/\$\{hits\}/, data.nbHits).replace(/\$\{time\}/, data.processingTimeMS);
          return stats + '<span class="algolia-powered">' + '  <img src="' + siteMeta.root + 'assets/algolia_logo.svg" alt="Algolia" />' + '</span>' + '<hr />';
        }
      },
      cssClasses: {
        root: 'algolia-stat-root'
      }
    }), (0,instantsearch_js_es_widgets__WEBPACK_IMPORTED_MODULE_11__.default)({
      container: '#algolia-pagination',
      scrollTo: false,
      templates: {
        first: '<i class="fa fa-angle-double-left"></i>',
        last: '<i class="fa fa-angle-double-right"></i>',
        previous: '<i class="fa fa-angle-left"></i>',
        next: '<i class="fa fa-angle-right"></i>'
      }
    })]);
    search.start();
    $('.popup-trigger').on('click', function (e) {
      e.stopPropagation();
      $('body').prepend('<div class="search-popup-overlay algolia-pop-overlay"></div>').css('overflow', 'hidden');
      $('.popup').toggle();
      $('#algolia-search-input').find('input').focus();
      _util__WEBPACK_IMPORTED_MODULE_4__.default.stopBodyScroll(true);
    });

    var hidePopup = function hidePopup() {
      $('.ais-SearchBox-form').trigger('reset');
      $('.popup').hide();
      $('.algolia-pop-overlay').remove();
      $('body').css('overflow', '');
      _util__WEBPACK_IMPORTED_MODULE_4__.default.stopBodyScroll(false);
    };

    $('.popup-btn-close').click(function () {
      hidePopup();
    });
    $(document).on('keydown', '.ais-SearchBox-form', function (event) {
      if (event.key === 'Escape') {
        hidePopup();
      }
    });
    $('.site-search').removeClass('site-search-loading');
  });
};

initAlgolia();
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFTOztBQUVUOztBQUVBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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Q0FBcUMsbUJBQU8sQ0FBQyxnR0FBeUI7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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S0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFCQUFxQixnQkFBZ0I7O0FBRXJDLHFCQUFxQixrQkFBa0IsZUFBZSxXQUFXOztBQUVqRTtB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LCtFQUFtQztBQUNuRDtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0hBQW9IO0FBQ3BIO0FBQ0E7QUFDQTtB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LENBQUMsQ0FBQyxRQUFELENBQUQsQ0FBWWdHLE1BQVo7QUFDQWhHLE1BQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCa0QsSUFBM0IsQ0FBZ0MsT0FBaEMsRUFBeUMrQyxLQUF6QztBQUNBekksTUFBQUEseURBQUEsQ0FBMEIsSUFBMUI7QUFDRCxLQVJEOztBQVVBLFFBQU0wSSxTQUFTLEdBQUcsU0FBWkEsU0FBWSxHQUFNO0FBQ3RCbEcsTUFBQUEsQ0FBQyxDQUFDLHFCQUFELENBQUQsQ0FBeUJtRyxPQUF6QixDQUFpQyxPQUFqQztBQUNBbkcsTUFBQUEsQ0FBQyxDQUFDLFFBQUQsQ0FBRCxDQUFZb0csSUFBWjtBQUNBcEcsTUFBQUEsQ0FBQyxDQUFDLHNCQUFELENBQUQsQ0FBMEJxRyxNQUExQjtBQUNBckcsTUFBQUEsQ0FBQyxDQUFDLE1BQUQsQ0FBRCxDQUFVQyxHQUFWLENBQWMsVUFBZCxFQUEwQixFQUExQjtBQUNBekMsTUFBQUEseURBQUEsQ0FBMEIsS0FBMUI7QUFDRCxLQU5EOztBQVFBd0MsSUFBQUEsQ0FBQyxDQUFDLGtCQUFELENBQUQsQ0FBc0JzRyxLQUF0QixDQUE0QixZQUFZO0FBQ3RDSixNQUFBQSxTQUFTO0FBQ1YsS0FGRDtBQUlBbEcsSUFBQUEsQ0FBQyxDQUFDOUMsUUFBRCxDQUFELENBQVkySSxFQUFaLENBQWUsU0FBZixFQUEwQixxQkFBMUIsRUFBaUQsVUFBVW5JLEtBQVYsRUFBaUI7QUFDaEUsVUFBSUEsS0FBSyxDQUFDNkksR0FBTixLQUFjLFFBQWxCLEVBQTRCO0FBQzFCTCxRQUFBQSxTQUFTO0FBQ1Y7QUFDRixLQUpEO0FBTUFsRyxJQUFBQSxDQUFDLENBQUMsY0FBRCxDQUFELENBQWtCd0csV0FBbEIsQ0FBOEIscUJBQTlCO0FBQ0QsR0F0SkQ7QUF1SkQsQ0F4SkQ7O0FBMEpBckUsV0FBVyxHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL0Rlcml2ZWRIZWxwZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL1NlYXJjaFBhcmFtZXRlcnMvUmVmaW5lbWVudExpc3QuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL1NlYXJjaFBhcmFtZXRlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL1NlYXJjaFJlc3VsdHMvZ2VuZXJhdGUtaGllcmFyY2hpY2FsLXRyZWUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL1NlYXJjaFJlc3VsdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL2FsZ29saWFzZWFyY2guaGVscGVyLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2FsZ29saWFzZWFyY2gtaGVscGVyL3NyYy9mdW5jdGlvbnMvY29tcGFjdC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9hbGdvbGlhc2VhcmNoLWhlbHBlci9zcmMvZnVuY3Rpb25zL2RlZmF1bHRzUHVyZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9hbGdvbGlhc2VhcmNoLWhlbHBlci9zcmMvZnVuY3Rpb25zL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL2Z1bmN0aW9ucy9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL2Z1bmN0aW9ucy9mb3JtYXRTb3J0LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2FsZ29saWFzZWFyY2gtaGVscGVyL3NyYy9mdW5jdGlvbnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL2Z1bmN0aW9ucy9pbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL2Z1bmN0aW9ucy9tZXJnZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9hbGdvbGlhc2VhcmNoLWhlbHBlci9zcmMvZnVuY3Rpb25zL29iamVjdEhhc0tleXMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC1oZWxwZXIvc3JjL2Z1bmN0aW9ucy9vbWl0LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2FsZ29saWFzZWFyY2gtaGVscGVyL3NyYy9mdW5jdGlvbnMvb3JkZXJCeS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9hbGdvbGlhc2VhcmNoLWhlbHBlci9zcmMvZnVuY3Rpb25zL3ZhbFRvTnVtYmVyLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2FsZ29saWFzZWFyY2gtaGVscGVyL3NyYy9yZXF1ZXN0QnVpbGRlci5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9hbGdvbGlhc2VhcmNoLWhlbHBlci9zcmMvdXRpbHMvaXNWYWxpZFVzZXJUb2tlbi5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9hbGdvbGlhc2VhcmNoLWhlbHBlci9zcmMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9hbGdvbGlhc2VhcmNoL2Rpc3QvYWxnb2xpYXNlYXJjaC1saXRlLnVtZC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL3NyYy9qcy91dGlsLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1zdWJzdGl0dXRpb24uanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbnVtYmVyLXBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1zdGlja3ktaGVscGVycy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtdW5zdXBwb3J0ZWQtZG90LWFsbC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtdW5zdXBwb3J0ZWQtbmNnLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zYW1lLXZhbHVlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXRyaW0uanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93aGl0ZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtaW50LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2hvZ2FuLmpzL2xpYi9jb21waWxlci5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9ob2dhbi5qcy9saWIvaG9nYW4uanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaG9nYW4uanMvbGliL3RlbXBsYXRlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvY29tcG9uZW50cy9IaXRzL0hpdHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9jb21wb25lbnRzL1BhZ2luYXRpb24vUGFnaW5hdGlvbi5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2NvbXBvbmVudHMvUGFnaW5hdGlvbi9QYWdpbmF0aW9uTGluay5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2NvbXBvbmVudHMvU2VhcmNoQm94L1NlYXJjaEJveC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2NvbXBvbmVudHMvU3RhdHMvU3RhdHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9jb21wb25lbnRzL1RlbXBsYXRlL1RlbXBsYXRlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvY29ubmVjdG9ycy9jb25maWd1cmUvY29ubmVjdENvbmZpZ3VyZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2Nvbm5lY3RvcnMvaGl0cy9jb25uZWN0SGl0cy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2Nvbm5lY3RvcnMvcGFnaW5hdGlvbi9QYWdpbmF0b3IuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9jb25uZWN0b3JzL3BhZ2luYXRpb24vY29ubmVjdFBhZ2luYXRpb24uanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9jb25uZWN0b3JzL3NlYXJjaC1ib3gvY29ubmVjdFNlYXJjaEJveC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2Nvbm5lY3RvcnMvc3RhdHMvY29ubmVjdFN0YXRzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvaGVscGVycy9nZXQtaW5zaWdodHMtYW5vbnltb3VzLXVzZXItdG9rZW4uanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9oZWxwZXJzL2hpZ2hsaWdodC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2hlbHBlcnMvaW5zaWdodHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9oZWxwZXJzL3JldmVyc2VIaWdobGlnaHQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9oZWxwZXJzL3JldmVyc2VTbmlwcGV0LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvaGVscGVycy9zbmlwcGV0LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvSW5zdGFudFNlYXJjaC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi9jcmVhdGVIZWxwZXJzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL2luZmluaXRlSGl0c0NhY2hlL3Nlc3Npb25TdG9yYWdlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL2luc2lnaHRzL2NsaWVudC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi9pbnNpZ2h0cy9saXN0ZW5lci5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi9yb3V0ZXJzL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvc3RhdGVNYXBwaW5ncy9zaW1wbGUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvc3VpdC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy9jYXBpdGFsaXplLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2NoZWNrSW5kZXhVaVN0YXRlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2NoZWNrUmVuZGVyaW5nLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2NvbmNhdEhpZ2hsaWdodGVkUGFydHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvY3JlYXRlU2VuZEV2ZW50Rm9ySGl0cy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy9kZWZlci5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy9kb2N1bWVudGF0aW9uLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2VzY2FwZS1oaWdobGlnaHQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvZXNjYXBlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvZmluZEluZGV4LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2dldENvbnRhaW5lck5vZGUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvZ2V0SGlnaGxpZ2h0RnJvbVNpYmxpbmdzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2dldEhpZ2hsaWdodGVkUGFydHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvZ2V0T2JqZWN0VHlwZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy9nZXRQcm9wZXJ0eUJ5UGF0aC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy9oaXRzLWFic29sdXRlLXBvc2l0aW9uLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2hpdHMtcXVlcnktaWQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvaXNEb21FbGVtZW50LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL2lzRXF1YWwuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy9pc1NwZWNpYWxDbGljay5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvbWVyZ2VTZWFyY2hQYXJhbWV0ZXJzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3V0aWxzL25vb3AuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvcHJlcGFyZVRlbXBsYXRlUHJvcHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvcmVuZGVyVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvcmVzb2x2ZVNlYXJjaFBhcmFtZXRlcnMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvcmV2ZXJzZUhpZ2hsaWdodGVkUGFydHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9saWIvdXRpbHMvc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy90eXBlZE9iamVjdC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy91bmVzY2FwZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL2xpYi91dGlscy91bmlxLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvbGliL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9taWRkbGV3YXJlcy9jcmVhdGVNZXRhZGF0YU1pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy9taWRkbGV3YXJlcy9jcmVhdGVSb3V0ZXJNaWRkbGV3YXJlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvdHlwZXMvYWxnb2xpYXNlYXJjaC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3R5cGVzL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3R5cGVzL2Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3R5cGVzL2luZGV4LmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvdHlwZXMvaW5zaWdodHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy90eXBlcy9pbnN0YW50c2VhcmNoLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvdHlwZXMvbWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3R5cGVzL3JlbmRlci1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3R5cGVzL3Jlc3VsdHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy90eXBlcy9yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy90eXBlcy90ZW1wbGF0ZXMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy90eXBlcy91aS1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3R5cGVzL3V0aWxzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvdHlwZXMvd2lkZ2V0LWZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy90eXBlcy93aWRnZXQuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy93aWRnZXRzL2NvbmZpZ3VyZS9jb25maWd1cmUuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy93aWRnZXRzL2hpdHMvZGVmYXVsdFRlbXBsYXRlcy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3dpZGdldHMvaGl0cy9oaXRzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvd2lkZ2V0cy9pbmRleC9pbmRleC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3dpZGdldHMvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL2luc3RhbnRzZWFyY2guanMvZXMvd2lkZ2V0cy9zZWFyY2gtYm94L2RlZmF1bHRUZW1wbGF0ZXMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvaW5zdGFudHNlYXJjaC5qcy9lcy93aWRnZXRzL3NlYXJjaC1ib3gvc2VhcmNoLWJveC5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9pbnN0YW50c2VhcmNoLmpzL2VzL3dpZGdldHMvc3RhdHMvc3RhdHMuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL25vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2hleG8tdGhlbWUtYXJjaGVyL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vaGV4by10aGVtZS1hcmNoZXIvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9oZXhvLXRoZW1lLWFyY2hlci8uL3NyYy9qcy9zZWFyY2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWxnb2xpYVNlYXJjaEhlbHBlciA9IHJlcXVpcmUoJy4vc3JjL2FsZ29saWFzZWFyY2guaGVscGVyJyk7XG5cbnZhciBTZWFyY2hQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9zcmMvU2VhcmNoUGFyYW1ldGVycycpO1xudmFyIFNlYXJjaFJlc3VsdHMgPSByZXF1aXJlKCcuL3NyYy9TZWFyY2hSZXN1bHRzJyk7XG5cbi8qKlxuICogVGhlIGFsZ29saWFzZWFyY2hIZWxwZXIgbW9kdWxlIGlzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgbGV0IGl0c1xuICogY29udGFpbnMgZXZlcnl0aGluZyBuZWVkZWQgdG8gdXNlIHRoZSBBbGdvbGlhc2VhcmNoXG4gKiBIZWxwZXIuIEl0IGlzIGEgYWxzbyBhIGZ1bmN0aW9uIHRoYXQgaW5zdGFuY2lhdGUgdGhlIGhlbHBlci5cbiAqIFRvIHVzZSB0aGUgaGVscGVyLCB5b3UgYWxzbyBuZWVkIHRoZSBBbGdvbGlhIEpTIGNsaWVudCB2My5cbiAqIEBleGFtcGxlXG4gKiAvL3VzaW5nIHRoZSBVTUQgYnVpbGRcbiAqIHZhciBjbGllbnQgPSBhbGdvbGlhc2VhcmNoKCdsYXRlbmN5JywgJzZiZTA1NzZmZjYxYzA1M2Q1ZjlhMzIyNWUyYTkwZjc2Jyk7XG4gKiB2YXIgaGVscGVyID0gYWxnb2xpYXNlYXJjaEhlbHBlcihjbGllbnQsICdiZXN0YnV5Jywge1xuICogICBmYWNldHM6IFsnc2hpcHBpbmcnXSxcbiAqICAgZGlzanVuY3RpdmVGYWNldHM6IFsnY2F0ZWdvcnknXVxuICogfSk7XG4gKiBoZWxwZXIub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgIGNvbnNvbGUubG9nKGV2ZW50LnJlc3VsdHMpO1xuICogfSk7XG4gKiBoZWxwZXJcbiAqICAgLnRvZ2dsZUZhY2V0UmVmaW5lbWVudCgnY2F0ZWdvcnknLCAnTW92aWVzICYgVFYgU2hvd3MnKVxuICogICAudG9nZ2xlRmFjZXRSZWZpbmVtZW50KCdzaGlwcGluZycsICdGcmVlIHNoaXBwaW5nJylcbiAqICAgLnNlYXJjaCgpO1xuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBoZWxwZXIgaXMgYW4gZXZlbnQgZW1pdHRlciB1c2luZyB0aGUgbm9kZSBBUElcbiAqIGhlbHBlci5vbigncmVzdWx0JywgdXBkYXRlVGhlUmVzdWx0cyk7XG4gKiBoZWxwZXIub25jZSgncmVzdWx0JywgdXBkYXRlVGhlUmVzdWx0cyk7XG4gKiBoZWxwZXIucmVtb3ZlTGlzdGVuZXIoJ3Jlc3VsdCcsIHVwZGF0ZVRoZVJlc3VsdHMpO1xuICogaGVscGVyLnJlbW92ZUFsbExpc3RlbmVycygncmVzdWx0Jyk7XG4gKiBAbW9kdWxlIGFsZ29saWFzZWFyY2hIZWxwZXJcbiAqIEBwYXJhbSAge0FsZ29saWFTZWFyY2h9IGNsaWVudCBhbiBBbGdvbGlhU2VhcmNoIGNsaWVudFxuICogQHBhcmFtICB7c3RyaW5nfSBpbmRleCB0aGUgbmFtZSBvZiB0aGUgaW5kZXggdG8gcXVlcnlcbiAqIEBwYXJhbSAge1NlYXJjaFBhcmFtZXRlcnN8b2JqZWN0fSBvcHRzIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgaW5pdGlhbCBjb25maWcgb2YgdGhlIHNlYXJjaC4gSXQgZG9lc24ndCBoYXZlIHRvIGJlIGEge1NlYXJjaFBhcmFtZXRlcnN9LCBqdXN0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIHlvdSBuZWVkIGZyb20gaXQuXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICovXG5mdW5jdGlvbiBhbGdvbGlhc2VhcmNoSGVscGVyKGNsaWVudCwgaW5kZXgsIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBBbGdvbGlhU2VhcmNoSGVscGVyKGNsaWVudCwgaW5kZXgsIG9wdHMpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIGN1cnJlbnRseSB1c2VkXG4gKiBAbWVtYmVyIG1vZHVsZTphbGdvbGlhc2VhcmNoSGVscGVyLnZlcnNpb25cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmFsZ29saWFzZWFyY2hIZWxwZXIudmVyc2lvbiA9IHJlcXVpcmUoJy4vc3JjL3ZlcnNpb24uanMnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhlIEhlbHBlci5cbiAqIEBtZW1iZXIgbW9kdWxlOmFsZ29saWFzZWFyY2hIZWxwZXIuQWxnb2xpYVNlYXJjaEhlbHBlclxuICogQHR5cGUge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKi9cbmFsZ29saWFzZWFyY2hIZWxwZXIuQWxnb2xpYVNlYXJjaEhlbHBlciA9IEFsZ29saWFTZWFyY2hIZWxwZXI7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIHRoZSBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIHNlYXJjaC5cbiAqIEBtZW1iZXIgbW9kdWxlOmFsZ29saWFzZWFyY2hIZWxwZXIuU2VhcmNoUGFyYW1ldGVyc1xuICogQHR5cGUge1NlYXJjaFBhcmFtZXRlcnN9XG4gKi9cbmFsZ29saWFzZWFyY2hIZWxwZXIuU2VhcmNoUGFyYW1ldGVycyA9IFNlYXJjaFBhcmFtZXRlcnM7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIHRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiB0aGUgc2VhcmNoLlxuICogQG1lbWJlciBtb2R1bGU6YWxnb2xpYXNlYXJjaEhlbHBlci5TZWFyY2hSZXN1bHRzXG4gKiBAdHlwZSB7U2VhcmNoUmVzdWx0c31cbiAqL1xuYWxnb2xpYXNlYXJjaEhlbHBlci5TZWFyY2hSZXN1bHRzID0gU2VhcmNoUmVzdWx0cztcblxubW9kdWxlLmV4cG9ydHMgPSBhbGdvbGlhc2VhcmNoSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvaW5oZXJpdHMnKTtcblxuLyoqXG4gKiBBIERlcml2ZWRIZWxwZXIgaXMgYSB3YXkgdG8gY3JlYXRlIHN1YiByZXF1ZXN0cyB0b1xuICogQWxnb2xpYSBmcm9tIGEgbWFpbiBoZWxwZXIuXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgVGhlIERlcml2ZWRIZWxwZXIgcHJvdmlkZXMgYW4gZXZlbnQgYmFzZWQgaW50ZXJmYWNlIGZvciBzZWFyY2ggY2FsbGJhY2tzOlxuICogIC0gc2VhcmNoOiB3aGVuIGEgc2VhcmNoIGlzIHRyaWdnZXJlZCB1c2luZyB0aGUgYHNlYXJjaCgpYCBtZXRob2QuXG4gKiAgLSByZXN1bHQ6IHdoZW4gdGhlIHJlc3BvbnNlIGlzIHJldHJpZXZlZCBmcm9tIEFsZ29saWEgYW5kIGlzIHByb2Nlc3NlZC5cbiAqICAgIFRoaXMgZXZlbnQgY29udGFpbnMgYSB7QGxpbmsgU2VhcmNoUmVzdWx0c30gb2JqZWN0IGFuZCB0aGVcbiAqICAgIHtAbGluayBTZWFyY2hQYXJhbWV0ZXJzfSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYW5zd2VyLlxuICovXG5mdW5jdGlvbiBEZXJpdmVkSGVscGVyKG1haW5IZWxwZXIsIGZuKSB7XG4gIHRoaXMubWFpbiA9IG1haW5IZWxwZXI7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5sYXN0UmVzdWx0cyA9IG51bGw7XG59XG5cbmluaGVyaXRzKERlcml2ZWRIZWxwZXIsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIERldGFjaCB0aGlzIGhlbHBlciBmcm9tIHRoZSBtYWluIGhlbHBlclxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgZGVyaXZlZCBoZWxwZXIgaXMgYWxyZWFkeSBkZXRhY2hlZFxuICovXG5EZXJpdmVkSGVscGVyLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5tYWluLmRldGFjaERlcml2ZWRIZWxwZXIodGhpcyk7XG59O1xuXG5EZXJpdmVkSGVscGVyLnByb3RvdHlwZS5nZXRNb2RpZmllZFN0YXRlID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICByZXR1cm4gdGhpcy5mbihwYXJhbWV0ZXJzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVyaXZlZEhlbHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBGdW5jdGlvbnMgdG8gbWFuaXB1bGF0ZSByZWZpbmVtZW50IGxpc3RzXG4gKlxuICogVGhlIFJlZmluZW1lbnRMaXN0IGlzIG5vdCBmb3JtYWxseSBkZWZpbmVkIHRocm91Z2ggYSBwcm90b3R5cGUgYnV0IGlzIGJhc2VkXG4gKiBvbiBhIHNwZWNpZmljIHN0cnVjdHVyZS5cbiAqXG4gKiBAbW9kdWxlIFNlYXJjaFBhcmFtZXRlcnMucmVmaW5lbWVudExpc3RcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nW119IFNlYXJjaFBhcmFtZXRlcnMucmVmaW5lbWVudExpc3QuUmVmaW5lbWVudHNcbiAqIEB0eXBlZGVmIHtPYmplY3QuPHN0cmluZywgU2VhcmNoUGFyYW1ldGVycy5yZWZpbmVtZW50TGlzdC5SZWZpbmVtZW50cz59IFNlYXJjaFBhcmFtZXRlcnMucmVmaW5lbWVudExpc3QuUmVmaW5lbWVudExpc3RcbiAqL1xuXG52YXIgZGVmYXVsdHNQdXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2RlZmF1bHRzUHVyZScpO1xudmFyIG9taXQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvb21pdCcpO1xudmFyIG9iamVjdEhhc0tleXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvb2JqZWN0SGFzS2V5cycpO1xuXG52YXIgbGliID0ge1xuICAvKipcbiAgICogQWRkcyBhIHJlZmluZW1lbnQgdG8gYSBSZWZpbmVtZW50TGlzdFxuICAgKiBAcGFyYW0ge1JlZmluZW1lbnRMaXN0fSByZWZpbmVtZW50TGlzdCB0aGUgaW5pdGlhbCBsaXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgdGhlIGF0dHJpYnV0ZSB0byByZWZpbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRoZSB2YWx1ZSBvZiB0aGUgcmVmaW5lbWVudCwgaWYgdGhlIHZhbHVlIGlzIG5vdCBhIHN0cmluZyBpdCB3aWxsIGJlIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtSZWZpbmVtZW50TGlzdH0gYSBuZXcgYW5kIHVwZGF0ZWQgcmVmaW5lbWVudCBsaXN0XG4gICAqL1xuICBhZGRSZWZpbmVtZW50OiBmdW5jdGlvbiBhZGRSZWZpbmVtZW50KHJlZmluZW1lbnRMaXN0LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgaWYgKGxpYi5pc1JlZmluZWQocmVmaW5lbWVudExpc3QsIGF0dHJpYnV0ZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gcmVmaW5lbWVudExpc3Q7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlQXNTdHJpbmcgPSAnJyArIHZhbHVlO1xuXG4gICAgdmFyIGZhY2V0UmVmaW5lbWVudCA9ICFyZWZpbmVtZW50TGlzdFthdHRyaWJ1dGVdID9cbiAgICAgIFt2YWx1ZUFzU3RyaW5nXSA6XG4gICAgICByZWZpbmVtZW50TGlzdFthdHRyaWJ1dGVdLmNvbmNhdCh2YWx1ZUFzU3RyaW5nKTtcblxuICAgIHZhciBtb2QgPSB7fTtcblxuICAgIG1vZFthdHRyaWJ1dGVdID0gZmFjZXRSZWZpbmVtZW50O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRzUHVyZSh7fSwgbW9kLCByZWZpbmVtZW50TGlzdCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmVzIHJlZmluZW1lbnQocykgZm9yIGFuIGF0dHJpYnV0ZTpcbiAgICogIC0gaWYgdGhlIHZhbHVlIGlzIHNwZWNpZmllZCByZW1vdmVzIHRoZSByZWZpbmVtZW50IGZvciB0aGUgdmFsdWUgb24gdGhlIGF0dHJpYnV0ZVxuICAgKiAgLSBpZiBubyB2YWx1ZSBpcyBzcGVjaWZpZWQgcmVtb3ZlcyBhbGwgdGhlIHJlZmluZW1lbnRzIGZvciB0aGlzIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0ge1JlZmluZW1lbnRMaXN0fSByZWZpbmVtZW50TGlzdCB0aGUgaW5pdGlhbCBsaXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgdGhlIGF0dHJpYnV0ZSB0byByZWZpbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gdGhlIHZhbHVlIG9mIHRoZSByZWZpbmVtZW50XG4gICAqIEByZXR1cm4ge1JlZmluZW1lbnRMaXN0fSBhIG5ldyBhbmQgdXBkYXRlZCByZWZpbmVtZW50IGxzdFxuICAgKi9cbiAgcmVtb3ZlUmVmaW5lbWVudDogZnVuY3Rpb24gcmVtb3ZlUmVmaW5lbWVudChyZWZpbmVtZW50TGlzdCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB3ZSB1c2UgdGhlIFwiZmlsdGVyXCIgZm9ybSBvZiBjbGVhclJlZmluZW1lbnQsIHNpbmNlIGl0IGxlYXZlcyBlbXB0eSB2YWx1ZXMgYXMtaXNcbiAgICAgIC8vIHRoZSBmb3JtIHdpdGggYSBzdHJpbmcgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBjb21wbGV0ZWx5XG4gICAgICByZXR1cm4gbGliLmNsZWFyUmVmaW5lbWVudChyZWZpbmVtZW50TGlzdCwgZnVuY3Rpb24odiwgZikge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlID09PSBmO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlQXNTdHJpbmcgPSAnJyArIHZhbHVlO1xuXG4gICAgcmV0dXJuIGxpYi5jbGVhclJlZmluZW1lbnQocmVmaW5lbWVudExpc3QsIGZ1bmN0aW9uKHYsIGYpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGUgPT09IGYgJiYgdmFsdWVBc1N0cmluZyA9PT0gdjtcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHJlZmluZW1lbnQgdmFsdWUgZm9yIGFuIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHtSZWZpbmVtZW50TGlzdH0gcmVmaW5lbWVudExpc3QgdGhlIGluaXRpYWwgbGlzdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIHRoZSBhdHRyaWJ1dGUgdG8gcmVmaW5lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIHJlZmluZW1lbnRcbiAgICogQHJldHVybiB7UmVmaW5lbWVudExpc3R9IGEgbmV3IGFuZCB1cGRhdGVkIGxpc3RcbiAgICovXG4gIHRvZ2dsZVJlZmluZW1lbnQ6IGZ1bmN0aW9uIHRvZ2dsZVJlZmluZW1lbnQocmVmaW5lbWVudExpc3QsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCd0b2dnbGVSZWZpbmVtZW50IHNob3VsZCBiZSB1c2VkIHdpdGggYSB2YWx1ZScpO1xuXG4gICAgaWYgKGxpYi5pc1JlZmluZWQocmVmaW5lbWVudExpc3QsIGF0dHJpYnV0ZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gbGliLnJlbW92ZVJlZmluZW1lbnQocmVmaW5lbWVudExpc3QsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBsaWIuYWRkUmVmaW5lbWVudChyZWZpbmVtZW50TGlzdCwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb3IgcGFydHMgb2YgYSBSZWZpbmVtZW50TGlzdC4gRGVwZW5kaW5nIG9uIHRoZSBhcmd1bWVudHMsIHRocmVlXG4gICAqIGtpbmRzIG9mIGJlaGF2aW9yIGNhbiBoYXBwZW46XG4gICAqICAtIGlmIG5vIGF0dHJpYnV0ZSBpcyBwcm92aWRlZDogY2xlYXJzIHRoZSB3aG9sZSBsaXN0XG4gICAqICAtIGlmIGFuIGF0dHJpYnV0ZSBpcyBwcm92aWRlZCBhcyBhIHN0cmluZzogY2xlYXJzIHRoZSBsaXN0IGZvciB0aGUgc3BlY2lmaWMgYXR0cmlidXRlXG4gICAqICAtIGlmIGFuIGF0dHJpYnV0ZSBpcyBwcm92aWRlZCBhcyBhIGZ1bmN0aW9uOiBkaXNjYXJkcyB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWVcbiAgICogQHBhcmFtIHtSZWZpbmVtZW50TGlzdH0gcmVmaW5lbWVudExpc3QgdGhlIGluaXRpYWwgbGlzdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2F0dHJpYnV0ZV0gdGhlIGF0dHJpYnV0ZSBvciBmdW5jdGlvbiB0byBkaXNjYXJkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVmaW5lbWVudFR5cGVdIG9wdGlvbmFsIHBhcmFtZXRlciB0byBnaXZlIG1vcmUgY29udGV4dCB0byB0aGUgYXR0cmlidXRlIGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge1JlZmluZW1lbnRMaXN0fSBhIG5ldyBhbmQgdXBkYXRlZCByZWZpbmVtZW50IGxpc3RcbiAgICovXG4gIGNsZWFyUmVmaW5lbWVudDogZnVuY3Rpb24gY2xlYXJSZWZpbmVtZW50KHJlZmluZW1lbnRMaXN0LCBhdHRyaWJ1dGUsIHJlZmluZW1lbnRUeXBlKSB7XG4gICAgaWYgKGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIW9iamVjdEhhc0tleXMocmVmaW5lbWVudExpc3QpKSB7XG4gICAgICAgIHJldHVybiByZWZpbmVtZW50TGlzdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb21pdChyZWZpbmVtZW50TGlzdCwgW2F0dHJpYnV0ZV0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIG5ld1JlZmluZW1lbnRMaXN0ID0gT2JqZWN0LmtleXMocmVmaW5lbWVudExpc3QpLnJlZHVjZShmdW5jdGlvbihtZW1vLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHJlZmluZW1lbnRMaXN0W2tleV0gfHwgW107XG4gICAgICAgIHZhciBmYWNldExpc3QgPSB2YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuICFhdHRyaWJ1dGUodmFsdWUsIGtleSwgcmVmaW5lbWVudFR5cGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZmFjZXRMaXN0Lmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG1lbW9ba2V5XSA9IGZhY2V0TGlzdDtcblxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHt9KTtcblxuICAgICAgaWYgKGhhc0NoYW5nZWQpIHJldHVybiBuZXdSZWZpbmVtZW50TGlzdDtcbiAgICAgIHJldHVybiByZWZpbmVtZW50TGlzdDtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSByZWZpbmVtZW50IHZhbHVlIGlzIHVzZWQgZm9yIHRoZSBhdHRyaWJ1dGUuIElmIG5vIHJlZmluZW1lbnQgdmFsdWVcbiAgICogaXMgcHJvdmlkZWQsIHRlc3QgaWYgdGhlIHJlZmluZW1lbnRMaXN0IGNvbnRhaW5zIGFueSByZWZpbmVtZW50IGZvciB0aGVcbiAgICogZ2l2ZW4gYXR0cmlidXRlLlxuICAgKiBAcGFyYW0ge1JlZmluZW1lbnRMaXN0fSByZWZpbmVtZW50TGlzdCB0aGUgbGlzdCBvZiByZWZpbmVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVmaW5lbWVudFZhbHVlXSB2YWx1ZSBvZiB0aGUgZmlsdGVyL3JlZmluZW1lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUmVmaW5lZDogZnVuY3Rpb24gaXNSZWZpbmVkKHJlZmluZW1lbnRMaXN0LCBhdHRyaWJ1dGUsIHJlZmluZW1lbnRWYWx1ZSkge1xuICAgIHZhciBjb250YWluc1JlZmluZW1lbnRzID0gISFyZWZpbmVtZW50TGlzdFthdHRyaWJ1dGVdICYmXG4gICAgICByZWZpbmVtZW50TGlzdFthdHRyaWJ1dGVdLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAocmVmaW5lbWVudFZhbHVlID09PSB1bmRlZmluZWQgfHwgIWNvbnRhaW5zUmVmaW5lbWVudHMpIHtcbiAgICAgIHJldHVybiBjb250YWluc1JlZmluZW1lbnRzO1xuICAgIH1cblxuICAgIHZhciByZWZpbmVtZW50VmFsdWVBc1N0cmluZyA9ICcnICsgcmVmaW5lbWVudFZhbHVlO1xuXG4gICAgcmV0dXJuIHJlZmluZW1lbnRMaXN0W2F0dHJpYnV0ZV0uaW5kZXhPZihyZWZpbmVtZW50VmFsdWVBc1N0cmluZykgIT09IC0xO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxpYjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1lcmdlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL21lcmdlJyk7XG52YXIgZGVmYXVsdHNQdXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2RlZmF1bHRzUHVyZScpO1xudmFyIGludGVyc2VjdGlvbiA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9pbnRlcnNlY3Rpb24nKTtcbnZhciBmaW5kID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2ZpbmQnKTtcbnZhciB2YWxUb051bWJlciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy92YWxUb051bWJlcicpO1xudmFyIG9taXQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvb21pdCcpO1xudmFyIG9iamVjdEhhc0tleXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvb2JqZWN0SGFzS2V5cycpO1xudmFyIGlzVmFsaWRVc2VyVG9rZW4gPSByZXF1aXJlKCcuLi91dGlscy9pc1ZhbGlkVXNlclRva2VuJyk7XG5cbnZhciBSZWZpbmVtZW50TGlzdCA9IHJlcXVpcmUoJy4vUmVmaW5lbWVudExpc3QnKTtcblxuLyoqXG4gKiBpc0VxdWFsLCBidXQgb25seSBmb3IgbnVtZXJpYyByZWZpbmVtZW50IHZhbHVlcywgcG9zc2libGUgdmFsdWVzOlxuICogLSA1XG4gKiAtIFs1XVxuICogLSBbWzVdXVxuICogLSBbWzUsNV0sWzRdXVxuICovXG5mdW5jdGlvbiBpc0VxdWFsTnVtZXJpY1JlZmluZW1lbnQoYSwgYikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxuICAgICAgYS5ldmVyeShmdW5jdGlvbihlbCwgaSkge1xuICAgICAgICByZXR1cm4gaXNFcXVhbE51bWVyaWNSZWZpbmVtZW50KGJbaV0sIGVsKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuLyoqXG4gKiBsaWtlIF8uZmluZCBidXQgdXNpbmcgZGVlcCBlcXVhbGl0eSB0byBiZSBhYmxlIHRvIHVzZSBpdFxuICogdG8gZmluZCBhcnJheXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHthbnlbXX0gYXJyYXkgYXJyYXkgdG8gc2VhcmNoIGludG8gKGVsZW1lbnRzIGFyZSBiYXNlIG9yIGFycmF5IG9mIGJhc2UpXG4gKiBAcGFyYW0ge2FueX0gc2VhcmNoZWRWYWx1ZSB0aGUgdmFsdWUgd2UncmUgbG9va2luZyBmb3IgKGJhc2Ugb3IgYXJyYXkgb2YgYmFzZSlcbiAqIEByZXR1cm4ge2FueX0gdGhlIHNlYXJjaGVkIHZhbHVlIG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBmaW5kQXJyYXkoYXJyYXksIHNlYXJjaGVkVmFsdWUpIHtcbiAgcmV0dXJuIGZpbmQoYXJyYXksIGZ1bmN0aW9uKGN1cnJlbnRWYWx1ZSkge1xuICAgIHJldHVybiBpc0VxdWFsTnVtZXJpY1JlZmluZW1lbnQoY3VycmVudFZhbHVlLCBzZWFyY2hlZFZhbHVlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIGZhY2V0IGxpc3QgaXMgdGhlIHN0cnVjdHVyZSB1c2VkIHRvIHN0b3JlIHRoZSBsaXN0IG9mIHZhbHVlcyB1c2VkIHRvXG4gKiBmaWx0ZXIgYSBzaW5nbGUgYXR0cmlidXRlLlxuICogQHR5cGVkZWYge3N0cmluZ1tdfSBTZWFyY2hQYXJhbWV0ZXJzLkZhY2V0TGlzdFxuICovXG5cbi8qKlxuICogU3RydWN0dXJlIHRvIHN0b3JlIG51bWVyaWMgZmlsdGVycyB3aXRoIHRoZSBvcGVyYXRvciBhcyB0aGUga2V5LiBUaGUgc3VwcG9ydGVkIG9wZXJhdG9yc1xuICogYXJlIGA9YCwgYD5gLCBgPGAsIGA+PWAsIGA8PWAgYW5kIGAhPWAuXG4gKiBAdHlwZWRlZiB7T2JqZWN0LjxzdHJpbmcsIEFycmF5LjxudW1iZXJ8bnVtYmVyW10+Pn0gU2VhcmNoUGFyYW1ldGVycy5PcGVyYXRvckxpc3RcbiAqL1xuXG4vKipcbiAqIFNlYXJjaFBhcmFtZXRlcnMgaXMgdGhlIGRhdGEgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgYWxsIHRoZSBpbmZvcm1hdGlvblxuICogdXNhYmxlIGZvciBtYWtpbmcgYSBzZWFyY2ggdG8gQWxnb2xpYSBBUEkuIEl0IGRvZXNuJ3QgZG8gdGhlIHNlYXJjaCBpdHNlbGYsXG4gKiBub3IgZG9lcyBpdCBjb250YWlucyBsb2dpYyBhYm91dCB0aGUgcGFyYW1ldGVycy5cbiAqIEl0IGlzIGFuIGltbXV0YWJsZSBvYmplY3QsIHRoZXJlZm9yZSBpdCBoYXMgYmVlbiBjcmVhdGVkIGluIGEgd2F5IHRoYXQgZWFjaFxuICogY2hhbmdlcyBkb2VzIG5vdCBjaGFuZ2UgdGhlIG9iamVjdCBpdHNlbGYgYnV0IHJldHVybnMgYSBjb3B5IHdpdGggdGhlXG4gKiBtb2RpZmljYXRpb24uXG4gKiBUaGlzIG9iamVjdCBzaG91bGQgcHJvYmFibHkgbm90IGJlIGluc3RhbnRpYXRlZCBvdXRzaWRlIG9mIHRoZSBoZWxwZXIuIEl0IHdpbGxcbiAqIGJlIHByb3ZpZGVkIHdoZW4gbmVlZGVkLiBUaGlzIG9iamVjdCBpcyBkb2N1bWVudGVkIGZvciByZWZlcmVuY2UgYXMgeW91J2xsXG4gKiBnZXQgaXQgZnJvbSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRoZSB7QGxpbmsgQWxnb2xpYVNlYXJjaEhlbHBlcn0uXG4gKiBJZiBuZWVkIGJlLCBpbnN0YW50aWF0ZSB0aGUgSGVscGVyIGZyb20gdGhlIGZhY3RvcnkgZnVuY3Rpb24ge0BsaW5rIFNlYXJjaFBhcmFtZXRlcnMubWFrZX1cbiAqIEBjb25zdHJ1Y3RvclxuICogQGNsYXNzZGVzYyBjb250YWlucyBhbGwgdGhlIHBhcmFtZXRlcnMgb2YgYSBzZWFyY2hcbiAqIEBwYXJhbSB7b2JqZWN0fFNlYXJjaFBhcmFtZXRlcnN9IG5ld1BhcmFtZXRlcnMgZXhpc3RpbmcgcGFyYW1ldGVycyBvciBwYXJ0aWFsIG9iamVjdFxuICogZm9yIHRoZSBwcm9wZXJ0aWVzIG9mIGEgbmV3IFNlYXJjaFBhcmFtZXRlcnNcbiAqIEBzZWUgU2VhcmNoUGFyYW1ldGVycy5tYWtlXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZWFyY2hQYXJhbWV0ZXJzIG9mIHRoZSBmaXJzdCBxdWVyeSBpblxuICogICA8YSBocmVmPVwiaHR0cDovL2RlbW9zLmFsZ29saWEuY29tL2luc3RhbnQtc2VhcmNoLWRlbW8vXCI+dGhlIGluc3RhbnQgc2VhcmNoIGRlbW88L2E+PC9jYXB0aW9uPlxue1xuICAgXCJxdWVyeVwiOiBcIlwiLFxuICAgXCJkaXNqdW5jdGl2ZUZhY2V0c1wiOiBbXG4gICAgICBcImN1c3RvbWVyUmV2aWV3Q291bnRcIixcbiAgICAgIFwiY2F0ZWdvcnlcIixcbiAgICAgIFwic2FsZVByaWNlX3JhbmdlXCIsXG4gICAgICBcIm1hbnVmYWN0dXJlclwiXG4gIF0sXG4gICBcIm1heFZhbHVlc1BlckZhY2V0XCI6IDMwLFxuICAgXCJwYWdlXCI6IDAsXG4gICBcImhpdHNQZXJQYWdlXCI6IDEwLFxuICAgXCJmYWNldHNcIjogW1xuICAgICAgXCJ0eXBlXCIsXG4gICAgICBcInNoaXBwaW5nXCJcbiAgXVxufVxuICovXG5mdW5jdGlvbiBTZWFyY2hQYXJhbWV0ZXJzKG5ld1BhcmFtZXRlcnMpIHtcbiAgdmFyIHBhcmFtcyA9IG5ld1BhcmFtZXRlcnMgPyBTZWFyY2hQYXJhbWV0ZXJzLl9wYXJzZU51bWJlcnMobmV3UGFyYW1ldGVycykgOiB7fTtcblxuICBpZiAocGFyYW1zLnVzZXJUb2tlbiAhPT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkVXNlclRva2VuKHBhcmFtcy51c2VyVG9rZW4pKSB7XG4gICAgY29uc29sZS53YXJuKCdbYWxnb2xpYXNlYXJjaC1oZWxwZXJdIFRoZSBgdXNlclRva2VuYCBwYXJhbWV0ZXIgaXMgaW52YWxpZC4gVGhpcyBjYW4gbGVhZCB0byB3cm9uZyBhbmFseXRpY3MuXFxuICAtIEZvcm1hdDogW2EtekEtWjAtOV8tXXsxLDY0fScpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGF0dHJpYnV0ZSBjb250YWlucyB0aGUgbGlzdCBvZiBhbGwgdGhlIGNvbmp1bmN0aXZlIGZhY2V0c1xuICAgKiB1c2VkLiBUaGlzIGxpc3Qgd2lsbCBiZSBhZGRlZCB0byByZXF1ZXN0ZWQgZmFjZXRzIGluIHRoZVxuICAgKiBbZmFjZXRzIGF0dHJpYnV0ZV0oaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3QtYXBpL3NlYXJjaCNwYXJhbS1mYWNldHMpIHNlbnQgdG8gYWxnb2xpYS5cbiAgICogQG1lbWJlciB7c3RyaW5nW119XG4gICAqL1xuICB0aGlzLmZhY2V0cyA9IHBhcmFtcy5mYWNldHMgfHwgW107XG4gIC8qKlxuICAgKiBUaGlzIGF0dHJpYnV0ZSBjb250YWlucyB0aGUgbGlzdCBvZiBhbGwgdGhlIGRpc2p1bmN0aXZlIGZhY2V0c1xuICAgKiB1c2VkLiBUaGlzIGxpc3Qgd2lsbCBiZSBhZGRlZCB0byByZXF1ZXN0ZWQgZmFjZXRzIGluIHRoZVxuICAgKiBbZmFjZXRzIGF0dHJpYnV0ZV0oaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3QtYXBpL3NlYXJjaCNwYXJhbS1mYWNldHMpIHNlbnQgdG8gYWxnb2xpYS5cbiAgICogQG1lbWJlciB7c3RyaW5nW119XG4gICAqL1xuICB0aGlzLmRpc2p1bmN0aXZlRmFjZXRzID0gcGFyYW1zLmRpc2p1bmN0aXZlRmFjZXRzIHx8IFtdO1xuICAvKipcbiAgICogVGhpcyBhdHRyaWJ1dGUgY29udGFpbnMgdGhlIGxpc3Qgb2YgYWxsIHRoZSBoaWVyYXJjaGljYWwgZmFjZXRzXG4gICAqIHVzZWQuIFRoaXMgbGlzdCB3aWxsIGJlIGFkZGVkIHRvIHJlcXVlc3RlZCBmYWNldHMgaW4gdGhlXG4gICAqIFtmYWNldHMgYXR0cmlidXRlXShodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdC1hcGkvc2VhcmNoI3BhcmFtLWZhY2V0cykgc2VudCB0byBhbGdvbGlhLlxuICAgKiBIaWVyYXJjaGljYWwgZmFjZXRzIGFyZSBhIHN1YiB0eXBlIG9mIGRpc2p1bmN0aXZlIGZhY2V0cyB0aGF0XG4gICAqIGxldCB5b3UgZmlsdGVyIGZhY2V0ZWQgYXR0cmlidXRlcyBoaWVyYXJjaGljYWxseS5cbiAgICogQG1lbWJlciB7c3RyaW5nW118b2JqZWN0W119XG4gICAqL1xuICB0aGlzLmhpZXJhcmNoaWNhbEZhY2V0cyA9IHBhcmFtcy5oaWVyYXJjaGljYWxGYWNldHMgfHwgW107XG5cbiAgLy8gUmVmaW5lbWVudHNcbiAgLyoqXG4gICAqIFRoaXMgYXR0cmlidXRlIGNvbnRhaW5zIGFsbCB0aGUgZmlsdGVycyB0aGF0IG5lZWQgdG8gYmVcbiAgICogYXBwbGllZCBvbiB0aGUgY29uanVuY3RpdmUgZmFjZXRzLiBFYWNoIGZhY2V0IG11c3QgYmUgcHJvcGVybHlcbiAgICogZGVmaW5lZCBpbiB0aGUgYGZhY2V0c2AgYXR0cmlidXRlLlxuICAgKlxuICAgKiBUaGUga2V5IGlzIHRoZSBuYW1lIG9mIHRoZSBmYWNldCwgYW5kIHRoZSBgRmFjZXRMaXN0YCBjb250YWlucyBhbGxcbiAgICogZmlsdGVycyBzZWxlY3RlZCBmb3IgdGhlIGFzc29jaWF0ZWQgZmFjZXQgbmFtZS5cbiAgICpcbiAgICogV2hlbiBxdWVyeWluZyBhbGdvbGlhLCB0aGUgdmFsdWVzIHN0b3JlZCBpbiB0aGlzIGF0dHJpYnV0ZSB3aWxsXG4gICAqIGJlIHRyYW5zbGF0ZWQgaW50byB0aGUgYGZhY2V0RmlsdGVyc2AgYXR0cmlidXRlLlxuICAgKiBAbWVtYmVyIHtPYmplY3QuPHN0cmluZywgU2VhcmNoUGFyYW1ldGVycy5GYWNldExpc3Q+fVxuICAgKi9cbiAgdGhpcy5mYWNldHNSZWZpbmVtZW50cyA9IHBhcmFtcy5mYWNldHNSZWZpbmVtZW50cyB8fCB7fTtcbiAgLyoqXG4gICAqIFRoaXMgYXR0cmlidXRlIGNvbnRhaW5zIGFsbCB0aGUgZmlsdGVycyB0aGF0IG5lZWQgdG8gYmVcbiAgICogZXhjbHVkZWQgZnJvbSB0aGUgY29uanVuY3RpdmUgZmFjZXRzLiBFYWNoIGZhY2V0IG11c3QgYmUgcHJvcGVybHlcbiAgICogZGVmaW5lZCBpbiB0aGUgYGZhY2V0c2AgYXR0cmlidXRlLlxuICAgKlxuICAgKiBUaGUga2V5IGlzIHRoZSBuYW1lIG9mIHRoZSBmYWNldCwgYW5kIHRoZSBgRmFjZXRMaXN0YCBjb250YWlucyBhbGxcbiAgICogZmlsdGVycyBleGNsdWRlZCBmb3IgdGhlIGFzc29jaWF0ZWQgZmFjZXQgbmFtZS5cbiAgICpcbiAgICogV2hlbiBxdWVyeWluZyBhbGdvbGlhLCB0aGUgdmFsdWVzIHN0b3JlZCBpbiB0aGlzIGF0dHJpYnV0ZSB3aWxsXG4gICAqIGJlIHRyYW5zbGF0ZWQgaW50byB0aGUgYGZhY2V0RmlsdGVyc2AgYXR0cmlidXRlLlxuICAgKiBAbWVtYmVyIHtPYmplY3QuPHN0cmluZywgU2VhcmNoUGFyYW1ldGVycy5GYWNldExpc3Q+fVxuICAgKi9cbiAgdGhpcy5mYWNldHNFeGNsdWRlcyA9IHBhcmFtcy5mYWNldHNFeGNsdWRlcyB8fCB7fTtcbiAgLyoqXG4gICAqIFRoaXMgYXR0cmlidXRlIGNvbnRhaW5zIGFsbCB0aGUgZmlsdGVycyB0aGF0IG5lZWQgdG8gYmVcbiAgICogYXBwbGllZCBvbiB0aGUgZGlzanVuY3RpdmUgZmFjZXRzLiBFYWNoIGZhY2V0IG11c3QgYmUgcHJvcGVybHlcbiAgICogZGVmaW5lZCBpbiB0aGUgYGRpc2p1bmN0aXZlRmFjZXRzYCBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIFRoZSBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIGZhY2V0LCBhbmQgdGhlIGBGYWNldExpc3RgIGNvbnRhaW5zIGFsbFxuICAgKiBmaWx0ZXJzIHNlbGVjdGVkIGZvciB0aGUgYXNzb2NpYXRlZCBmYWNldCBuYW1lLlxuICAgKlxuICAgKiBXaGVuIHF1ZXJ5aW5nIGFsZ29saWEsIHRoZSB2YWx1ZXMgc3RvcmVkIGluIHRoaXMgYXR0cmlidXRlIHdpbGxcbiAgICogYmUgdHJhbnNsYXRlZCBpbnRvIHRoZSBgZmFjZXRGaWx0ZXJzYCBhdHRyaWJ1dGUuXG4gICAqIEBtZW1iZXIge09iamVjdC48c3RyaW5nLCBTZWFyY2hQYXJhbWV0ZXJzLkZhY2V0TGlzdD59XG4gICAqL1xuICB0aGlzLmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMgPSBwYXJhbXMuZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cyB8fCB7fTtcbiAgLyoqXG4gICAqIFRoaXMgYXR0cmlidXRlIGNvbnRhaW5zIGFsbCB0aGUgZmlsdGVycyB0aGF0IG5lZWQgdG8gYmVcbiAgICogYXBwbGllZCBvbiB0aGUgbnVtZXJpYyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGUga2V5IGlzIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUsIGFuZCB0aGUgdmFsdWUgaXMgdGhlXG4gICAqIGZpbHRlcnMgdG8gYXBwbHkgdG8gdGhpcyBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIFdoZW4gcXVlcnlpbmcgYWxnb2xpYSwgdGhlIHZhbHVlcyBzdG9yZWQgaW4gdGhpcyBhdHRyaWJ1dGUgd2lsbFxuICAgKiBiZSB0cmFuc2xhdGVkIGludG8gdGhlIGBudW1lcmljRmlsdGVyc2AgYXR0cmlidXRlLlxuICAgKiBAbWVtYmVyIHtPYmplY3QuPHN0cmluZywgU2VhcmNoUGFyYW1ldGVycy5PcGVyYXRvckxpc3Q+fVxuICAgKi9cbiAgdGhpcy5udW1lcmljUmVmaW5lbWVudHMgPSBwYXJhbXMubnVtZXJpY1JlZmluZW1lbnRzIHx8IHt9O1xuICAvKipcbiAgICogVGhpcyBhdHRyaWJ1dGUgY29udGFpbnMgYWxsIHRoZSB0YWdzIHVzZWQgdG8gcmVmaW5lIHRoZSBxdWVyeS5cbiAgICpcbiAgICogV2hlbiBxdWVyeWluZyBhbGdvbGlhLCB0aGUgdmFsdWVzIHN0b3JlZCBpbiB0aGlzIGF0dHJpYnV0ZSB3aWxsXG4gICAqIGJlIHRyYW5zbGF0ZWQgaW50byB0aGUgYHRhZ0ZpbHRlcnNgIGF0dHJpYnV0ZS5cbiAgICogQG1lbWJlciB7c3RyaW5nW119XG4gICAqL1xuICB0aGlzLnRhZ1JlZmluZW1lbnRzID0gcGFyYW1zLnRhZ1JlZmluZW1lbnRzIHx8IFtdO1xuICAvKipcbiAgICogVGhpcyBhdHRyaWJ1dGUgY29udGFpbnMgYWxsIHRoZSBmaWx0ZXJzIHRoYXQgbmVlZCB0byBiZVxuICAgKiBhcHBsaWVkIG9uIHRoZSBoaWVyYXJjaGljYWwgZmFjZXRzLiBFYWNoIGZhY2V0IG11c3QgYmUgcHJvcGVybHlcbiAgICogZGVmaW5lZCBpbiB0aGUgYGhpZXJhcmNoaWNhbEZhY2V0c2AgYXR0cmlidXRlLlxuICAgKlxuICAgKiBUaGUga2V5IGlzIHRoZSBuYW1lIG9mIHRoZSBmYWNldCwgYW5kIHRoZSBgRmFjZXRMaXN0YCBjb250YWlucyBhbGxcbiAgICogZmlsdGVycyBzZWxlY3RlZCBmb3IgdGhlIGFzc29jaWF0ZWQgZmFjZXQgbmFtZS4gVGhlIEZhY2V0TGlzdCB2YWx1ZXNcbiAgICogYXJlIHN0cnVjdHVyZWQgYXMgYSBzdHJpbmcgdGhhdCBjb250YWluIHRoZSB2YWx1ZXMgZm9yIGVhY2ggbGV2ZWxcbiAgICogc2VwYXJhdGVkIGJ5IHRoZSBjb25maWd1cmVkIHNlcGFyYXRvci5cbiAgICpcbiAgICogV2hlbiBxdWVyeWluZyBhbGdvbGlhLCB0aGUgdmFsdWVzIHN0b3JlZCBpbiB0aGlzIGF0dHJpYnV0ZSB3aWxsXG4gICAqIGJlIHRyYW5zbGF0ZWQgaW50byB0aGUgYGZhY2V0RmlsdGVyc2AgYXR0cmlidXRlLlxuICAgKiBAbWVtYmVyIHtPYmplY3QuPHN0cmluZywgU2VhcmNoUGFyYW1ldGVycy5GYWNldExpc3Q+fVxuICAgKi9cbiAgdGhpcy5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50cyA9IHBhcmFtcy5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50cyB8fCB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbihwYXJhbU5hbWUpIHtcbiAgICB2YXIgaXNLZXlLbm93biA9IFNlYXJjaFBhcmFtZXRlcnMuUEFSQU1FVEVSUy5pbmRleE9mKHBhcmFtTmFtZSkgIT09IC0xO1xuICAgIHZhciBpc1ZhbHVlRGVmaW5lZCA9IHBhcmFtc1twYXJhbU5hbWVdICE9PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIWlzS2V5S25vd24gJiYgaXNWYWx1ZURlZmluZWQpIHtcbiAgICAgIHNlbGZbcGFyYW1OYW1lXSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTGlzdCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gU2VhcmNoUGFyYW1ldGVycyBhbmQgdGhlcmVmb3JlIGFsbCB0aGUga25vd24gQWxnb2xpYSBwcm9wZXJ0aWVzXG4gKiBUaGlzIGRvZXNuJ3QgY29udGFpbiBhbnkgYmV0YS9oaWRkZW4gZmVhdHVyZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5TZWFyY2hQYXJhbWV0ZXJzLlBBUkFNRVRFUlMgPSBPYmplY3Qua2V5cyhuZXcgU2VhcmNoUGFyYW1ldGVycygpKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBmdWxsIG9yIHBhcnQgb2YgYSBzdGF0ZVxuICogQHJldHVybiB7b2JqZWN0fSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgbnVtYmVyIGtleXMgYXMgbnVtYmVyXG4gKi9cblNlYXJjaFBhcmFtZXRlcnMuX3BhcnNlTnVtYmVycyA9IGZ1bmN0aW9uKHBhcnRpYWxTdGF0ZSkge1xuICAvLyBEbyBub3QgcmVwYXJzZSBudW1iZXJzIGluIFNlYXJjaFBhcmFtZXRlcnMsIHRoZXkgb3VnaHQgdG8gYmUgcGFyc2VkIGFscmVhZHlcbiAgaWYgKHBhcnRpYWxTdGF0ZSBpbnN0YW5jZW9mIFNlYXJjaFBhcmFtZXRlcnMpIHJldHVybiBwYXJ0aWFsU3RhdGU7XG5cbiAgdmFyIG51bWJlcnMgPSB7fTtcblxuICB2YXIgbnVtYmVyS2V5cyA9IFtcbiAgICAnYXJvdW5kUHJlY2lzaW9uJyxcbiAgICAnYXJvdW5kUmFkaXVzJyxcbiAgICAnZ2V0UmFua2luZ0luZm8nLFxuICAgICdtaW5Xb3JkU2l6ZWZvcjJUeXBvcycsXG4gICAgJ21pbldvcmRTaXplZm9yMVR5cG8nLFxuICAgICdwYWdlJyxcbiAgICAnbWF4VmFsdWVzUGVyRmFjZXQnLFxuICAgICdkaXN0aW5jdCcsXG4gICAgJ21pbmltdW1Bcm91bmRSYWRpdXMnLFxuICAgICdoaXRzUGVyUGFnZScsXG4gICAgJ21pblByb3hpbWl0eSdcbiAgXTtcblxuICBudW1iZXJLZXlzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciB2YWx1ZSA9IHBhcnRpYWxTdGF0ZVtrXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAvLyBnbG9iYWwgaXNOYU4gaXMgb2sgdG8gdXNlIGhlcmUsIHZhbHVlIGlzIG9ubHkgbnVtYmVyIG9yIE5hTlxuICAgICAgbnVtYmVyc1trXSA9IGlzTmFOKHBhcnNlZFZhbHVlKSA/IHZhbHVlIDogcGFyc2VkVmFsdWU7XG4gICAgfVxuICB9KTtcblxuICAvLyB0aGVyZSdzIHR3byBmb3JtYXRzIG9mIGluc2lkZUJvdW5kaW5nQm94LCB3ZSBuZWVkIHRvIHBhcnNlXG4gIC8vIHRoZSBvbmUgd2hpY2ggaXMgYW4gYXJyYXkgb2YgZmxvYXQgZ2VvIHJlY3RhbmdsZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkocGFydGlhbFN0YXRlLmluc2lkZUJvdW5kaW5nQm94KSkge1xuICAgIG51bWJlcnMuaW5zaWRlQm91bmRpbmdCb3ggPSBwYXJ0aWFsU3RhdGUuaW5zaWRlQm91bmRpbmdCb3gubWFwKGZ1bmN0aW9uKGdlb1JlY3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGdlb1JlY3QpKSB7XG4gICAgICAgIHJldHVybiBnZW9SZWN0Lm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VvUmVjdDtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXJ0aWFsU3RhdGUubnVtZXJpY1JlZmluZW1lbnRzKSB7XG4gICAgdmFyIG51bWVyaWNSZWZpbmVtZW50cyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHBhcnRpYWxTdGF0ZS5udW1lcmljUmVmaW5lbWVudHMpLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICB2YXIgb3BlcmF0b3JzID0gcGFydGlhbFN0YXRlLm51bWVyaWNSZWZpbmVtZW50c1thdHRyaWJ1dGVdIHx8IHt9O1xuICAgICAgbnVtZXJpY1JlZmluZW1lbnRzW2F0dHJpYnV0ZV0gPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKG9wZXJhdG9ycykuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvcikge1xuICAgICAgICB2YXIgdmFsdWVzID0gb3BlcmF0b3JzW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHBhcnNlZFZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdi5tYXAoZnVuY3Rpb24odlByaW1lKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdlByaW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZQcmltZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHZQcmltZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgICAgICBudW1lcmljUmVmaW5lbWVudHNbYXR0cmlidXRlXVtvcGVyYXRvcl0gPSBwYXJzZWRWYWx1ZXM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBudW1iZXJzLm51bWVyaWNSZWZpbmVtZW50cyA9IG51bWVyaWNSZWZpbmVtZW50cztcbiAgfVxuXG4gIHJldHVybiBtZXJnZSh7fSwgcGFydGlhbFN0YXRlLCBudW1iZXJzKTtcbn07XG5cbi8qKlxuICogRmFjdG9yeSBmb3IgU2VhcmNoUGFyYW1ldGVyc1xuICogQHBhcmFtIHtvYmplY3R8U2VhcmNoUGFyYW1ldGVyc30gbmV3UGFyYW1ldGVycyBleGlzdGluZyBwYXJhbWV0ZXJzIG9yIHBhcnRpYWxcbiAqIG9iamVjdCBmb3IgdGhlIHByb3BlcnRpZXMgb2YgYSBuZXcgU2VhcmNoUGFyYW1ldGVyc1xuICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc30gZnJvemVuIGluc3RhbmNlIG9mIFNlYXJjaFBhcmFtZXRlcnNcbiAqL1xuU2VhcmNoUGFyYW1ldGVycy5tYWtlID0gZnVuY3Rpb24gbWFrZVNlYXJjaFBhcmFtZXRlcnMobmV3UGFyYW1ldGVycykge1xuICB2YXIgaW5zdGFuY2UgPSBuZXcgU2VhcmNoUGFyYW1ldGVycyhuZXdQYXJhbWV0ZXJzKTtcblxuICB2YXIgaGllcmFyY2hpY2FsRmFjZXRzID0gbmV3UGFyYW1ldGVycy5oaWVyYXJjaGljYWxGYWNldHMgfHwgW107XG4gIGhpZXJhcmNoaWNhbEZhY2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGZhY2V0KSB7XG4gICAgaWYgKGZhY2V0LnJvb3RQYXRoKSB7XG4gICAgICB2YXIgY3VycmVudFJlZmluZW1lbnQgPSBpbnN0YW5jZS5nZXRIaWVyYXJjaGljYWxSZWZpbmVtZW50KGZhY2V0Lm5hbWUpO1xuXG4gICAgICBpZiAoY3VycmVudFJlZmluZW1lbnQubGVuZ3RoID4gMCAmJiBjdXJyZW50UmVmaW5lbWVudFswXS5pbmRleE9mKGZhY2V0LnJvb3RQYXRoKSAhPT0gMCkge1xuICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlLmNsZWFyUmVmaW5lbWVudHMoZmFjZXQubmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBpdCBhZ2FpbiBpbiBjYXNlIGl0IGhhcyBiZWVuIGNsZWFyZWRcbiAgICAgIGN1cnJlbnRSZWZpbmVtZW50ID0gaW5zdGFuY2UuZ2V0SGllcmFyY2hpY2FsUmVmaW5lbWVudChmYWNldC5uYW1lKTtcbiAgICAgIGlmIChjdXJyZW50UmVmaW5lbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZS50b2dnbGVIaWVyYXJjaGljYWxGYWNldFJlZmluZW1lbnQoZmFjZXQubmFtZSwgZmFjZXQucm9vdFBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG5ldyBwYXJhbWV0ZXJzIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBzdGF0ZVxuICogQHBhcmFtIHtTZWFyY2hQYXJhbWV0ZXJzfSBjdXJyZW50U3RhdGUgdGhlIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fFNlYXJjaFBhcmFtZXRlcnN9IHBhcmFtZXRlcnMgdGhlIG5ldyBwYXJhbWV0ZXJzIHRvIHNldFxuICogQHJldHVybiB7RXJyb3J8bnVsbH0gRXJyb3IgaWYgdGhlIG1vZGlmaWNhdGlvbiBpcyBpbnZhbGlkLCBudWxsIG90aGVyd2lzZVxuICovXG5TZWFyY2hQYXJhbWV0ZXJzLnZhbGlkYXRlID0gZnVuY3Rpb24oY3VycmVudFN0YXRlLCBwYXJhbWV0ZXJzKSB7XG4gIHZhciBwYXJhbXMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gIGlmIChjdXJyZW50U3RhdGUudGFnRmlsdGVycyAmJiBwYXJhbXMudGFnUmVmaW5lbWVudHMgJiYgcGFyYW1zLnRhZ1JlZmluZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgJ1tUYWdzXSBDYW5ub3Qgc3dpdGNoIGZyb20gdGhlIG1hbmFnZWQgdGFnIEFQSSB0byB0aGUgYWR2YW5jZWQgQVBJLiBJdCBpcyBwcm9iYWJseSAnICtcbiAgICAgICdhbiBlcnJvciwgaWYgaXQgaXMgcmVhbGx5IHdoYXQgeW91IHdhbnQsIHlvdSBzaG91bGQgZmlyc3QgY2xlYXIgdGhlIHRhZ3Mgd2l0aCBjbGVhclRhZ3MgbWV0aG9kLicpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRTdGF0ZS50YWdSZWZpbmVtZW50cy5sZW5ndGggPiAwICYmIHBhcmFtcy50YWdGaWx0ZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICdbVGFnc10gQ2Fubm90IHN3aXRjaCBmcm9tIHRoZSBhZHZhbmNlZCB0YWcgQVBJIHRvIHRoZSBtYW5hZ2VkIEFQSS4gSXQgaXMgcHJvYmFibHkgJyArXG4gICAgICAnYW4gZXJyb3IsIGlmIGl0IGlzIG5vdCwgeW91IHNob3VsZCBmaXJzdCBjbGVhciB0aGUgdGFncyB3aXRoIGNsZWFyVGFncyBtZXRob2QuJyk7XG4gIH1cblxuICBpZiAoXG4gICAgY3VycmVudFN0YXRlLm51bWVyaWNGaWx0ZXJzICYmXG4gICAgcGFyYW1zLm51bWVyaWNSZWZpbmVtZW50cyAmJlxuICAgIG9iamVjdEhhc0tleXMocGFyYW1zLm51bWVyaWNSZWZpbmVtZW50cylcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgIFwiW051bWVyaWMgZmlsdGVyc10gQ2FuJ3Qgc3dpdGNoIGZyb20gdGhlIGFkdmFuY2VkIHRvIHRoZSBtYW5hZ2VkIEFQSS4gSXRcIiArXG4gICAgICAgICcgaXMgcHJvYmFibHkgYW4gZXJyb3IsIGlmIHRoaXMgaXMgcmVhbGx5IHdoYXQgeW91IHdhbnQsIHlvdSBoYXZlIHRvIGZpcnN0JyArXG4gICAgICAgICcgY2xlYXIgdGhlIG51bWVyaWMgZmlsdGVycy4nXG4gICAgKTtcbiAgfVxuXG4gIGlmIChvYmplY3RIYXNLZXlzKGN1cnJlbnRTdGF0ZS5udW1lcmljUmVmaW5lbWVudHMpICYmIHBhcmFtcy5udW1lcmljRmlsdGVycykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICBcIltOdW1lcmljIGZpbHRlcnNdIENhbid0IHN3aXRjaCBmcm9tIHRoZSBtYW5hZ2VkIEFQSSB0byB0aGUgYWR2YW5jZWQuIEl0XCIgK1xuICAgICAgJyBpcyBwcm9iYWJseSBhbiBlcnJvciwgaWYgdGhpcyBpcyByZWFsbHkgd2hhdCB5b3Ugd2FudCwgeW91IGhhdmUgdG8gZmlyc3QnICtcbiAgICAgICcgY2xlYXIgdGhlIG51bWVyaWMgZmlsdGVycy4nKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuU2VhcmNoUGFyYW1ldGVycy5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZWFyY2hQYXJhbWV0ZXJzLFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHJlZmluZW1lbnRzIChkaXNqdW5jdGl2ZSArIGNvbmp1bmN0aXZlICsgZXhjbHVkZXMgKyBudW1lcmljIGZpbHRlcnMpXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHt1bmRlZmluZWR8c3RyaW5nfFNlYXJjaFBhcmFtZXRlcnMuY2xlYXJDYWxsYmFja30gW2F0dHJpYnV0ZV0gb3B0aW9uYWwgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gICAqIC0gSWYgbm90IGdpdmVuLCBtZWFucyB0byBjbGVhciBhbGwgdGhlIGZpbHRlcnMuXG4gICAqIC0gSWYgYHN0cmluZ2AsIG1lYW5zIHRvIGNsZWFyIGFsbCByZWZpbmVtZW50cyBmb3IgdGhlIGBhdHRyaWJ1dGVgIG5hbWVkIGZpbHRlci5cbiAgICogLSBJZiBgZnVuY3Rpb25gLCBtZWFucyB0byBjbGVhciBhbGwgdGhlIHJlZmluZW1lbnRzIHRoYXQgcmV0dXJuIHRydXRoeSB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICBjbGVhclJlZmluZW1lbnRzOiBmdW5jdGlvbiBjbGVhclJlZmluZW1lbnRzKGF0dHJpYnV0ZSkge1xuICAgIHZhciBwYXRjaCA9IHtcbiAgICAgIG51bWVyaWNSZWZpbmVtZW50czogdGhpcy5fY2xlYXJOdW1lcmljUmVmaW5lbWVudHMoYXR0cmlidXRlKSxcbiAgICAgIGZhY2V0c1JlZmluZW1lbnRzOiBSZWZpbmVtZW50TGlzdC5jbGVhclJlZmluZW1lbnQoXG4gICAgICAgIHRoaXMuZmFjZXRzUmVmaW5lbWVudHMsXG4gICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgJ2Nvbmp1bmN0aXZlRmFjZXQnXG4gICAgICApLFxuICAgICAgZmFjZXRzRXhjbHVkZXM6IFJlZmluZW1lbnRMaXN0LmNsZWFyUmVmaW5lbWVudChcbiAgICAgICAgdGhpcy5mYWNldHNFeGNsdWRlcyxcbiAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAnZXhjbHVkZSdcbiAgICAgICksXG4gICAgICBkaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzOiBSZWZpbmVtZW50TGlzdC5jbGVhclJlZmluZW1lbnQoXG4gICAgICAgIHRoaXMuZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cyxcbiAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAnZGlzanVuY3RpdmVGYWNldCdcbiAgICAgICksXG4gICAgICBoaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50czogUmVmaW5lbWVudExpc3QuY2xlYXJSZWZpbmVtZW50KFxuICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzLFxuICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICdoaWVyYXJjaGljYWxGYWNldCdcbiAgICAgIClcbiAgICB9O1xuICAgIGlmIChcbiAgICAgIHBhdGNoLm51bWVyaWNSZWZpbmVtZW50cyA9PT0gdGhpcy5udW1lcmljUmVmaW5lbWVudHMgJiZcbiAgICAgIHBhdGNoLmZhY2V0c1JlZmluZW1lbnRzID09PSB0aGlzLmZhY2V0c1JlZmluZW1lbnRzICYmXG4gICAgICBwYXRjaC5mYWNldHNFeGNsdWRlcyA9PT0gdGhpcy5mYWNldHNFeGNsdWRlcyAmJlxuICAgICAgcGF0Y2guZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cyA9PT0gdGhpcy5kaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzICYmXG4gICAgICBwYXRjaC5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50cyA9PT0gdGhpcy5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50c1xuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyhwYXRjaCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHRoZSByZWZpbmVkIHRhZ3MgZnJvbSB0aGUgU2VhcmNoUGFyYW1ldGVyc1xuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICBjbGVhclRhZ3M6IGZ1bmN0aW9uIGNsZWFyVGFncygpIHtcbiAgICBpZiAodGhpcy50YWdGaWx0ZXJzID09PSB1bmRlZmluZWQgJiYgdGhpcy50YWdSZWZpbmVtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIHRhZ0ZpbHRlcnM6IHVuZGVmaW5lZCxcbiAgICAgIHRhZ1JlZmluZW1lbnRzOiBbXVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogU2V0IHRoZSBpbmRleC5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5kZXggdGhlIGluZGV4IG5hbWVcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc31cbiAgICovXG4gIHNldEluZGV4OiBmdW5jdGlvbiBzZXRJbmRleChpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdGhpcy5pbmRleCkgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBRdWVyeSBzZXR0ZXJcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UXVlcnkgdmFsdWUgZm9yIHRoZSBuZXcgcXVlcnlcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc31cbiAgICovXG4gIHNldFF1ZXJ5OiBmdW5jdGlvbiBzZXRRdWVyeShuZXdRdWVyeSkge1xuICAgIGlmIChuZXdRdWVyeSA9PT0gdGhpcy5xdWVyeSkgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgcXVlcnk6IG5ld1F1ZXJ5XG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBQYWdlIHNldHRlclxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdQYWdlIG5ldyBwYWdlIG51bWJlclxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgc2V0UGFnZTogZnVuY3Rpb24gc2V0UGFnZShuZXdQYWdlKSB7XG4gICAgaWYgKG5ld1BhZ2UgPT09IHRoaXMucGFnZSkgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgcGFnZTogbmV3UGFnZVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogRmFjZXRzIHNldHRlclxuICAgKiBUaGUgZmFjZXRzIGFyZSB0aGUgc2ltcGxlIGZhY2V0cywgdXNlZCBmb3IgY29uanVuY3RpdmUgKGFuZCkgZmFjZXRpbmcuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmFjZXRzIGFsbCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgYWxnb2xpYSByZWNvcmRzIHVzZWQgZm9yIGNvbmp1bmN0aXZlIGZhY2V0aW5nXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICBzZXRGYWNldHM6IGZ1bmN0aW9uIHNldEZhY2V0cyhmYWNldHMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgZmFjZXRzOiBmYWNldHNcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIERpc2p1bmN0aXZlIGZhY2V0cyBzZXR0ZXJcbiAgICogQ2hhbmdlIHRoZSBsaXN0IG9mIGRpc2p1bmN0aXZlIChvcikgZmFjZXRzIHRoZSBoZWxwZXIgY2hhbiBoYW5kbGUuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmFjZXRzIGFsbCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgYWxnb2xpYSByZWNvcmRzIHVzZWQgZm9yIGRpc2p1bmN0aXZlIGZhY2V0aW5nXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICBzZXREaXNqdW5jdGl2ZUZhY2V0czogZnVuY3Rpb24gc2V0RGlzanVuY3RpdmVGYWNldHMoZmFjZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIGRpc2p1bmN0aXZlRmFjZXRzOiBmYWNldHNcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIEhpdHNQZXJQYWdlIHNldHRlclxuICAgKiBIaXRzIHBlciBwYWdlIHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiBoaXRzIHJldHJpZXZlZCBmb3IgdGhpcyBxdWVyeVxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIG51bWJlciBvZiBoaXRzIHJldHJpZXZlZCBwZXIgcGFnZSBvZiByZXN1bHRzXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICBzZXRIaXRzUGVyUGFnZTogZnVuY3Rpb24gc2V0SGl0c1BlclBhZ2Uobikge1xuICAgIGlmICh0aGlzLmhpdHNQZXJQYWdlID09PSBuKSByZXR1cm4gdGhpcztcblxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICBoaXRzUGVyUGFnZTogblxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogdHlwb1RvbGVyYW5jZSBzZXR0ZXJcbiAgICogU2V0IHRoZSB2YWx1ZSBvZiB0eXBvVG9sZXJhbmNlXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cG9Ub2xlcmFuY2UgbmV3IHZhbHVlIG9mIHR5cG9Ub2xlcmFuY2UgKFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwibWluXCIgb3IgXCJzdHJpY3RcIilcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc31cbiAgICovXG4gIHNldFR5cG9Ub2xlcmFuY2U6IGZ1bmN0aW9uIHNldFR5cG9Ub2xlcmFuY2UodHlwb1RvbGVyYW5jZSkge1xuICAgIGlmICh0aGlzLnR5cG9Ub2xlcmFuY2UgPT09IHR5cG9Ub2xlcmFuY2UpIHJldHVybiB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIHR5cG9Ub2xlcmFuY2U6IHR5cG9Ub2xlcmFuY2VcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIEFkZCBhIG51bWVyaWMgZmlsdGVyIGZvciBhIGdpdmVuIGF0dHJpYnV0ZVxuICAgKiBXaGVuIHZhbHVlIGlzIGFuIGFycmF5LCB0aGV5IGFyZSBjb21iaW5lZCB3aXRoIE9SXG4gICAqIFdoZW4gdmFsdWUgaXMgYSBzaW5nbGUgdmFsdWUsIGl0IHdpbGwgY29tYmluZWQgd2l0aCBBTkRcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIGF0dHJpYnV0ZSB0byBzZXQgdGhlIGZpbHRlciBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Igb3BlcmF0b3Igb2YgdGhlIGZpbHRlciAocG9zc2libGUgdmFsdWVzOiA9LCA+LCA+PSwgPCwgPD0sICE9KVxuICAgKiBAcGFyYW0ge251bWJlciB8IG51bWJlcltdfSB2YWx1ZSB2YWx1ZSBvZiB0aGUgZmlsdGVyXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGZvciBwcmljZSA9IDUwIG9yIDQwXG4gICAqIHNlYXJjaHBhcmFtZXRlci5hZGROdW1lcmljUmVmaW5lbWVudCgncHJpY2UnLCAnPScsIFs1MCwgNDBdKTtcbiAgICogQGV4YW1wbGVcbiAgICogLy8gZm9yIHNpemUgPSAzOCBhbmQgNDBcbiAgICogc2VhcmNocGFyYW1ldGVyLmFkZE51bWVyaWNSZWZpbmVtZW50KCdzaXplJywgJz0nLCAzOCk7XG4gICAqIHNlYXJjaHBhcmFtZXRlci5hZGROdW1lcmljUmVmaW5lbWVudCgnc2l6ZScsICc9JywgNDApO1xuICAgKi9cbiAgYWRkTnVtZXJpY1JlZmluZW1lbnQ6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgb3BlcmF0b3IsIHYpIHtcbiAgICB2YXIgdmFsdWUgPSB2YWxUb051bWJlcih2KTtcblxuICAgIGlmICh0aGlzLmlzTnVtZXJpY1JlZmluZWQoYXR0cmlidXRlLCBvcGVyYXRvciwgdmFsdWUpKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBtb2QgPSBtZXJnZSh7fSwgdGhpcy5udW1lcmljUmVmaW5lbWVudHMpO1xuXG4gICAgbW9kW2F0dHJpYnV0ZV0gPSBtZXJnZSh7fSwgbW9kW2F0dHJpYnV0ZV0pO1xuXG4gICAgaWYgKG1vZFthdHRyaWJ1dGVdW29wZXJhdG9yXSkge1xuICAgICAgLy8gQXJyYXkgY29weVxuICAgICAgbW9kW2F0dHJpYnV0ZV1bb3BlcmF0b3JdID0gbW9kW2F0dHJpYnV0ZV1bb3BlcmF0b3JdLnNsaWNlKCk7XG4gICAgICAvLyBBZGQgdGhlIGVsZW1lbnQuIENvbmNhdCBjYW4ndCBiZSB1c2VkIGhlcmUgYmVjYXVzZSB2YWx1ZSBjYW4gYmUgYW4gYXJyYXkuXG4gICAgICBtb2RbYXR0cmlidXRlXVtvcGVyYXRvcl0ucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZFthdHRyaWJ1dGVdW29wZXJhdG9yXSA9IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIG51bWVyaWNSZWZpbmVtZW50czogbW9kXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgY29uanVuY3RpdmUgcmVmaW5lbWVudHMgZm9yIGEgc2luZ2xlIGZhY2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldE5hbWUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHVzZWQgZm9yIGZhY2V0aW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfSBsaXN0IG9mIHJlZmluZW1lbnRzXG4gICAqL1xuICBnZXRDb25qdW5jdGl2ZVJlZmluZW1lbnRzOiBmdW5jdGlvbihmYWNldE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25qdW5jdGl2ZUZhY2V0KGZhY2V0TmFtZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmFjZXRzUmVmaW5lbWVudHNbZmFjZXROYW1lXSB8fCBbXTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBkaXNqdW5jdGl2ZSByZWZpbmVtZW50cyBmb3IgYSBzaW5nbGUgZmFjZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0TmFtZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdXNlZCBmb3IgZmFjZXRpbmdcbiAgICogQHJldHVybiB7c3RyaW5nW119IGxpc3Qgb2YgcmVmaW5lbWVudHNcbiAgICovXG4gIGdldERpc2p1bmN0aXZlUmVmaW5lbWVudHM6IGZ1bmN0aW9uKGZhY2V0TmFtZSkge1xuICAgIGlmICghdGhpcy5pc0Rpc2p1bmN0aXZlRmFjZXQoZmFjZXROYW1lKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzW2ZhY2V0TmFtZV0gfHwgW107XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgaGllcmFyY2hpY2FsIHJlZmluZW1lbnRzIGZvciBhIHNpbmdsZSBmYWNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXROYW1lIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIGZvciBmYWNldGluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gbGlzdCBvZiByZWZpbmVtZW50c1xuICAgKi9cbiAgZ2V0SGllcmFyY2hpY2FsUmVmaW5lbWVudDogZnVuY3Rpb24oZmFjZXROYW1lKSB7XG4gICAgLy8gd2Ugc2VuZCBhbiBhcnJheSBidXQgd2UgY3VycmVudGx5IGRvIG5vdCBzdXBwb3J0IG11bHRpcGxlXG4gICAgLy8gaGllcmFyY2hpY2FsUmVmaW5lbWVudHMgZm9yIGEgaGllcmFyY2hpY2FsRmFjZXRcbiAgICByZXR1cm4gdGhpcy5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50c1tmYWNldE5hbWVdIHx8IFtdO1xuICB9LFxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIGV4Y2x1ZGUgcmVmaW5lbWVudHMgZm9yIGEgc2luZ2xlIGZhY2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldE5hbWUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHVzZWQgZm9yIGZhY2V0aW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfSBsaXN0IG9mIHJlZmluZW1lbnRzXG4gICAqL1xuICBnZXRFeGNsdWRlUmVmaW5lbWVudHM6IGZ1bmN0aW9uKGZhY2V0TmFtZSkge1xuICAgIGlmICghdGhpcy5pc0Nvbmp1bmN0aXZlRmFjZXQoZmFjZXROYW1lKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mYWNldHNFeGNsdWRlc1tmYWNldE5hbWVdIHx8IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHRoZSBudW1lcmljIGZpbHRlciBmb3IgYSBnaXZlbiAoYXR0cmlidXRlLCBvcGVyYXRvcilcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIGF0dHJpYnV0ZSB0byBzZXQgdGhlIGZpbHRlciBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wZXJhdG9yXSBvcGVyYXRvciBvZiB0aGUgZmlsdGVyIChwb3NzaWJsZSB2YWx1ZXM6ID0sID4sID49LCA8LCA8PSwgIT0pXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbnVtYmVyXSB0aGUgdmFsdWUgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgcmVtb3ZlTnVtZXJpY1JlZmluZW1lbnQ6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgb3BlcmF0b3IsIHBhcmFtVmFsdWUpIHtcbiAgICBpZiAocGFyYW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMuaXNOdW1lcmljUmVmaW5lZChhdHRyaWJ1dGUsIG9wZXJhdG9yLCBwYXJhbVZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICAgIG51bWVyaWNSZWZpbmVtZW50czogdGhpcy5fY2xlYXJOdW1lcmljUmVmaW5lbWVudHMoZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBrZXkgPT09IGF0dHJpYnV0ZSAmJlxuICAgICAgICAgICAgdmFsdWUub3AgPT09IG9wZXJhdG9yICYmXG4gICAgICAgICAgICBpc0VxdWFsTnVtZXJpY1JlZmluZW1lbnQodmFsdWUudmFsLCB2YWxUb051bWJlcihwYXJhbVZhbHVlKSlcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMuaXNOdW1lcmljUmVmaW5lZChhdHRyaWJ1dGUsIG9wZXJhdG9yKSkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgICBudW1lcmljUmVmaW5lbWVudHM6IHRoaXMuX2NsZWFyTnVtZXJpY1JlZmluZW1lbnRzKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ID09PSBhdHRyaWJ1dGUgJiYgdmFsdWUub3AgPT09IG9wZXJhdG9yO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzTnVtZXJpY1JlZmluZWQoYXR0cmlidXRlKSkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIG51bWVyaWNSZWZpbmVtZW50czogdGhpcy5fY2xlYXJOdW1lcmljUmVmaW5lbWVudHMoZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID09PSBhdHRyaWJ1dGU7XG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIG51bWVyaWMgcmVmaW5lbWVudHMgZm9yIGEgc2luZ2xlIGZhY2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldE5hbWUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHVzZWQgZm9yIGZhY2V0aW5nXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnMuT3BlcmF0b3JMaXN0fSBsaXN0IG9mIHJlZmluZW1lbnRzXG4gICAqL1xuICBnZXROdW1lcmljUmVmaW5lbWVudHM6IGZ1bmN0aW9uKGZhY2V0TmFtZSkge1xuICAgIHJldHVybiB0aGlzLm51bWVyaWNSZWZpbmVtZW50c1tmYWNldE5hbWVdIHx8IHt9O1xuICB9LFxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHJlZmluZW1lbnQgZm9yIHRoZSAoYXR0cmlidXRlLCBvcGVyYXRvcilcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBhdHRyaWJ1dGUgaW4gdGhlIHJlY29yZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Igb3BlcmF0b3IgYXBwbGllZCBvbiB0aGUgcmVmaW5lZCB2YWx1ZXNcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcnxudW1iZXJbXT59IHJlZmluZWQgdmFsdWVzXG4gICAqL1xuICBnZXROdW1lcmljUmVmaW5lbWVudDogZnVuY3Rpb24oYXR0cmlidXRlLCBvcGVyYXRvcikge1xuICAgIHJldHVybiB0aGlzLm51bWVyaWNSZWZpbmVtZW50c1thdHRyaWJ1dGVdICYmIHRoaXMubnVtZXJpY1JlZmluZW1lbnRzW2F0dHJpYnV0ZV1bb3BlcmF0b3JdO1xuICB9LFxuICAvKipcbiAgICogQ2xlYXIgbnVtZXJpYyBmaWx0ZXJzLlxuICAgKiBAbWV0aG9kXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfFNlYXJjaFBhcmFtZXRlcnMuY2xlYXJDYWxsYmFja30gW2F0dHJpYnV0ZV0gb3B0aW9uYWwgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gICAqIC0gSWYgbm90IGdpdmVuLCBtZWFucyB0byBjbGVhciBhbGwgdGhlIGZpbHRlcnMuXG4gICAqIC0gSWYgYHN0cmluZ2AsIG1lYW5zIHRvIGNsZWFyIGFsbCByZWZpbmVtZW50cyBmb3IgdGhlIGBhdHRyaWJ1dGVgIG5hbWVkIGZpbHRlci5cbiAgICogLSBJZiBgZnVuY3Rpb25gLCBtZWFucyB0byBjbGVhciBhbGwgdGhlIHJlZmluZW1lbnRzIHRoYXQgcmV0dXJuIHRydXRoeSB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBPcGVyYXRvckxpc3Q+fVxuICAgKi9cbiAgX2NsZWFyTnVtZXJpY1JlZmluZW1lbnRzOiBmdW5jdGlvbiBfY2xlYXJOdW1lcmljUmVmaW5lbWVudHMoYXR0cmlidXRlKSB7XG4gICAgaWYgKGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIW9iamVjdEhhc0tleXModGhpcy5udW1lcmljUmVmaW5lbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bWVyaWNSZWZpbmVtZW50cztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb21pdCh0aGlzLm51bWVyaWNSZWZpbmVtZW50cywgW2F0dHJpYnV0ZV0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBudW1lcmljUmVmaW5lbWVudHMgPSB0aGlzLm51bWVyaWNSZWZpbmVtZW50cztcbiAgICAgIHZhciBuZXdOdW1lcmljUmVmaW5lbWVudHMgPSBPYmplY3Qua2V5cyhudW1lcmljUmVmaW5lbWVudHMpLnJlZHVjZShmdW5jdGlvbihtZW1vLCBrZXkpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9ycyA9IG51bWVyaWNSZWZpbmVtZW50c1trZXldO1xuICAgICAgICB2YXIgb3BlcmF0b3JMaXN0ID0ge307XG5cbiAgICAgICAgb3BlcmF0b3JzID0gb3BlcmF0b3JzIHx8IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvcGVyYXRvcnMpLmZvckVhY2goZnVuY3Rpb24ob3BlcmF0b3IpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gb3BlcmF0b3JzW29wZXJhdG9yXSB8fCBbXTtcbiAgICAgICAgICB2YXIgb3V0VmFsdWVzID0gW107XG4gICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGVSZXN1bHQgPSBhdHRyaWJ1dGUoe3ZhbDogdmFsdWUsIG9wOiBvcGVyYXRvcn0sIGtleSwgJ251bWVyaWMnKTtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlUmVzdWx0KSBvdXRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG91dFZhbHVlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcGVyYXRvckxpc3Rbb3BlcmF0b3JdID0gb3V0VmFsdWVzO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZW1vW2tleV0gPSBvcGVyYXRvckxpc3Q7XG5cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIGlmIChoYXNDaGFuZ2VkKSByZXR1cm4gbmV3TnVtZXJpY1JlZmluZW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMubnVtZXJpY1JlZmluZW1lbnRzO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEFkZCBhIGZhY2V0IHRvIHRoZSBmYWNldHMgYXR0cmlidXRlIG9mIHRoZSBoZWxwZXIgY29uZmlndXJhdGlvbiwgaWYgaXRcbiAgICogaXNuJ3QgYWxyZWFkeSBwcmVzZW50LlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldCBmYWNldCBuYW1lIHRvIGFkZFxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgYWRkRmFjZXQ6IGZ1bmN0aW9uIGFkZEZhY2V0KGZhY2V0KSB7XG4gICAgaWYgKHRoaXMuaXNDb25qdW5jdGl2ZUZhY2V0KGZhY2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIGZhY2V0czogdGhpcy5mYWNldHMuY29uY2F0KFtmYWNldF0pXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBBZGQgYSBkaXNqdW5jdGl2ZSBmYWNldCB0byB0aGUgZGlzanVuY3RpdmVGYWNldHMgYXR0cmlidXRlIG9mIHRoZSBoZWxwZXJcbiAgICogY29uZmlndXJhdGlvbiwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBwcmVzZW50LlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldCBkaXNqdW5jdGl2ZSBmYWNldCBuYW1lIHRvIGFkZFxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgYWRkRGlzanVuY3RpdmVGYWNldDogZnVuY3Rpb24gYWRkRGlzanVuY3RpdmVGYWNldChmYWNldCkge1xuICAgIGlmICh0aGlzLmlzRGlzanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICBkaXNqdW5jdGl2ZUZhY2V0czogdGhpcy5kaXNqdW5jdGl2ZUZhY2V0cy5jb25jYXQoW2ZhY2V0XSlcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIEFkZCBhIGhpZXJhcmNoaWNhbCBmYWNldCB0byB0aGUgaGllcmFyY2hpY2FsRmFjZXRzIGF0dHJpYnV0ZSBvZiB0aGUgaGVscGVyXG4gICAqIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtvYmplY3R9IGhpZXJhcmNoaWNhbEZhY2V0IGhpZXJhcmNoaWNhbCBmYWNldCB0byBhZGRcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc31cbiAgICogQHRocm93cyB3aWxsIHRocm93IGFuIGVycm9yIGlmIGEgaGllcmFyY2hpY2FsIGZhY2V0IHdpdGggdGhlIHNhbWUgbmFtZSB3YXMgYWxyZWFkeSBkZWNsYXJlZFxuICAgKi9cbiAgYWRkSGllcmFyY2hpY2FsRmFjZXQ6IGZ1bmN0aW9uIGFkZEhpZXJhcmNoaWNhbEZhY2V0KGhpZXJhcmNoaWNhbEZhY2V0KSB7XG4gICAgaWYgKHRoaXMuaXNIaWVyYXJjaGljYWxGYWNldChoaWVyYXJjaGljYWxGYWNldC5uYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IGRlY2xhcmUgdHdvIGhpZXJhcmNoaWNhbCBmYWNldHMgd2l0aCB0aGUgc2FtZSBuYW1lOiBgJyArIGhpZXJhcmNoaWNhbEZhY2V0Lm5hbWUgKyAnYCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICBoaWVyYXJjaGljYWxGYWNldHM6IHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzLmNvbmNhdChbaGllcmFyY2hpY2FsRmFjZXRdKVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQWRkIGEgcmVmaW5lbWVudCBvbiBhIFwibm9ybWFsXCIgZmFjZXRcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgYXR0cmlidXRlIHRvIGFwcGx5IHRoZSBmYWNldGluZyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSAod2lsbCBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5nKVxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgYWRkRmFjZXRSZWZpbmVtZW50OiBmdW5jdGlvbiBhZGRGYWNldFJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29uanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYWNldCArICcgaXMgbm90IGRlZmluZWQgaW4gdGhlIGZhY2V0cyBhdHRyaWJ1dGUgb2YgdGhlIGhlbHBlciBjb25maWd1cmF0aW9uJyk7XG4gICAgfVxuICAgIGlmIChSZWZpbmVtZW50TGlzdC5pc1JlZmluZWQodGhpcy5mYWNldHNSZWZpbmVtZW50cywgZmFjZXQsIHZhbHVlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgZmFjZXRzUmVmaW5lbWVudHM6IFJlZmluZW1lbnRMaXN0LmFkZFJlZmluZW1lbnQodGhpcy5mYWNldHNSZWZpbmVtZW50cywgZmFjZXQsIHZhbHVlKVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogRXhjbHVkZSBhIHZhbHVlIGZyb20gYSBcIm5vcm1hbFwiIGZhY2V0XG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IGF0dHJpYnV0ZSB0byBhcHBseSB0aGUgZXhjbHVzaW9uIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlICh3aWxsIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcpXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICBhZGRFeGNsdWRlUmVmaW5lbWVudDogZnVuY3Rpb24gYWRkRXhjbHVkZVJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29uanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYWNldCArICcgaXMgbm90IGRlZmluZWQgaW4gdGhlIGZhY2V0cyBhdHRyaWJ1dGUgb2YgdGhlIGhlbHBlciBjb25maWd1cmF0aW9uJyk7XG4gICAgfVxuICAgIGlmIChSZWZpbmVtZW50TGlzdC5pc1JlZmluZWQodGhpcy5mYWNldHNFeGNsdWRlcywgZmFjZXQsIHZhbHVlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgZmFjZXRzRXhjbHVkZXM6IFJlZmluZW1lbnRMaXN0LmFkZFJlZmluZW1lbnQodGhpcy5mYWNldHNFeGNsdWRlcywgZmFjZXQsIHZhbHVlKVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQWRkcyBhIHJlZmluZW1lbnQgb24gYSBkaXNqdW5jdGl2ZSBmYWNldC5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgYXR0cmlidXRlIHRvIGFwcGx5IHRoZSBmYWNldGluZyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSAod2lsbCBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5nKVxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgYWRkRGlzanVuY3RpdmVGYWNldFJlZmluZW1lbnQ6IGZ1bmN0aW9uIGFkZERpc2p1bmN0aXZlRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5pc0Rpc2p1bmN0aXZlRmFjZXQoZmFjZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGZhY2V0ICsgJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgZGlzanVuY3RpdmVGYWNldHMgYXR0cmlidXRlIG9mIHRoZSBoZWxwZXIgY29uZmlndXJhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChSZWZpbmVtZW50TGlzdC5pc1JlZmluZWQodGhpcy5kaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzLCBmYWNldCwgdmFsdWUpKSByZXR1cm4gdGhpcztcblxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICBkaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzOiBSZWZpbmVtZW50TGlzdC5hZGRSZWZpbmVtZW50KFxuICAgICAgICB0aGlzLmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMsIGZhY2V0LCB2YWx1ZSlcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIGFkZFRhZ1JlZmluZW1lbnQgYWRkcyBhIHRhZyB0byB0aGUgbGlzdCB1c2VkIHRvIGZpbHRlciB0aGUgcmVzdWx0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIHRhZyB0byBiZSBhZGRlZFxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgYWRkVGFnUmVmaW5lbWVudDogZnVuY3Rpb24gYWRkVGFnUmVmaW5lbWVudCh0YWcpIHtcbiAgICBpZiAodGhpcy5pc1RhZ1JlZmluZWQodGFnKSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbW9kaWZpY2F0aW9uID0ge1xuICAgICAgdGFnUmVmaW5lbWVudHM6IHRoaXMudGFnUmVmaW5lbWVudHMuY29uY2F0KHRhZylcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKG1vZGlmaWNhdGlvbik7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmYWNldCBmcm9tIHRoZSBmYWNldHMgYXR0cmlidXRlIG9mIHRoZSBoZWxwZXIgY29uZmlndXJhdGlvbiwgaWYgaXRcbiAgICogaXMgcHJlc2VudC5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgZmFjZXQgbmFtZSB0byByZW1vdmVcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc31cbiAgICovXG4gIHJlbW92ZUZhY2V0OiBmdW5jdGlvbiByZW1vdmVGYWNldChmYWNldCkge1xuICAgIGlmICghdGhpcy5pc0Nvbmp1bmN0aXZlRmFjZXQoZmFjZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jbGVhclJlZmluZW1lbnRzKGZhY2V0KS5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgZmFjZXRzOiB0aGlzLmZhY2V0cy5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZiAhPT0gZmFjZXQ7XG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogUmVtb3ZlIGEgZGlzanVuY3RpdmUgZmFjZXQgZnJvbSB0aGUgZGlzanVuY3RpdmVGYWNldHMgYXR0cmlidXRlIG9mIHRoZVxuICAgKiBoZWxwZXIgY29uZmlndXJhdGlvbiwgaWYgaXQgaXMgcHJlc2VudC5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgZGlzanVuY3RpdmUgZmFjZXQgbmFtZSB0byByZW1vdmVcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc31cbiAgICovXG4gIHJlbW92ZURpc2p1bmN0aXZlRmFjZXQ6IGZ1bmN0aW9uIHJlbW92ZURpc2p1bmN0aXZlRmFjZXQoZmFjZXQpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNqdW5jdGl2ZUZhY2V0KGZhY2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2xlYXJSZWZpbmVtZW50cyhmYWNldCkuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIGRpc2p1bmN0aXZlRmFjZXRzOiB0aGlzLmRpc2p1bmN0aXZlRmFjZXRzLmZpbHRlcihmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmICE9PSBmYWNldDtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBoaWVyYXJjaGljYWwgZmFjZXQgZnJvbSB0aGUgaGllcmFyY2hpY2FsRmFjZXRzIGF0dHJpYnV0ZSBvZiB0aGVcbiAgICogaGVscGVyIGNvbmZpZ3VyYXRpb24sIGlmIGl0IGlzIHByZXNlbnQuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IGhpZXJhcmNoaWNhbCBmYWNldCBuYW1lIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgcmVtb3ZlSGllcmFyY2hpY2FsRmFjZXQ6IGZ1bmN0aW9uIHJlbW92ZUhpZXJhcmNoaWNhbEZhY2V0KGZhY2V0KSB7XG4gICAgaWYgKCF0aGlzLmlzSGllcmFyY2hpY2FsRmFjZXQoZmFjZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jbGVhclJlZmluZW1lbnRzKGZhY2V0KS5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgaGllcmFyY2hpY2FsRmFjZXRzOiB0aGlzLmhpZXJhcmNoaWNhbEZhY2V0cy5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZi5uYW1lICE9PSBmYWNldDtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmUgYSByZWZpbmVtZW50IHNldCBvbiBmYWNldC4gSWYgYSB2YWx1ZSBpcyBwcm92aWRlZCwgaXQgd2lsbCBjbGVhciB0aGVcbiAgICogcmVmaW5lbWVudCBmb3IgdGhlIGdpdmVuIHZhbHVlLCBvdGhlcndpc2UgaXQgd2lsbCBjbGVhciBhbGwgdGhlIHJlZmluZW1lbnRcbiAgICogdmFsdWVzIGZvciB0aGUgZmFjZXRlZCBhdHRyaWJ1dGUuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIGZvciBmYWNldGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSB2YWx1ZSB1c2VkIHRvIGZpbHRlclxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgcmVtb3ZlRmFjZXRSZWZpbmVtZW50OiBmdW5jdGlvbiByZW1vdmVGYWNldFJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29uanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYWNldCArICcgaXMgbm90IGRlZmluZWQgaW4gdGhlIGZhY2V0cyBhdHRyaWJ1dGUgb2YgdGhlIGhlbHBlciBjb25maWd1cmF0aW9uJyk7XG4gICAgfVxuICAgIGlmICghUmVmaW5lbWVudExpc3QuaXNSZWZpbmVkKHRoaXMuZmFjZXRzUmVmaW5lbWVudHMsIGZhY2V0LCB2YWx1ZSkpIHJldHVybiB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIGZhY2V0c1JlZmluZW1lbnRzOiBSZWZpbmVtZW50TGlzdC5yZW1vdmVSZWZpbmVtZW50KHRoaXMuZmFjZXRzUmVmaW5lbWVudHMsIGZhY2V0LCB2YWx1ZSlcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZSBhIG5lZ2F0aXZlIHJlZmluZW1lbnQgb24gYSBmYWNldFxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldCBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdXNlZCBmb3IgZmFjZXRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHZhbHVlIHVzZWQgdG8gZmlsdGVyXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICByZW1vdmVFeGNsdWRlUmVmaW5lbWVudDogZnVuY3Rpb24gcmVtb3ZlRXhjbHVkZVJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29uanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYWNldCArICcgaXMgbm90IGRlZmluZWQgaW4gdGhlIGZhY2V0cyBhdHRyaWJ1dGUgb2YgdGhlIGhlbHBlciBjb25maWd1cmF0aW9uJyk7XG4gICAgfVxuICAgIGlmICghUmVmaW5lbWVudExpc3QuaXNSZWZpbmVkKHRoaXMuZmFjZXRzRXhjbHVkZXMsIGZhY2V0LCB2YWx1ZSkpIHJldHVybiB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICAgIGZhY2V0c0V4Y2x1ZGVzOiBSZWZpbmVtZW50TGlzdC5yZW1vdmVSZWZpbmVtZW50KHRoaXMuZmFjZXRzRXhjbHVkZXMsIGZhY2V0LCB2YWx1ZSlcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJlZmluZW1lbnQgb24gYSBkaXNqdW5jdGl2ZSBmYWNldFxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldCBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdXNlZCBmb3IgZmFjZXRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHZhbHVlIHVzZWQgdG8gZmlsdGVyXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICByZW1vdmVEaXNqdW5jdGl2ZUZhY2V0UmVmaW5lbWVudDogZnVuY3Rpb24gcmVtb3ZlRGlzanVuY3RpdmVGYWNldFJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZmFjZXQgKyAnIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBkaXNqdW5jdGl2ZUZhY2V0cyBhdHRyaWJ1dGUgb2YgdGhlIGhlbHBlciBjb25maWd1cmF0aW9uJyk7XG4gICAgfVxuICAgIGlmICghUmVmaW5lbWVudExpc3QuaXNSZWZpbmVkKHRoaXMuZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cywgZmFjZXQsIHZhbHVlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50czogUmVmaW5lbWVudExpc3QucmVtb3ZlUmVmaW5lbWVudChcbiAgICAgICAgdGhpcy5kaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzLCBmYWNldCwgdmFsdWUpXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YWcgZnJvbSB0aGUgbGlzdCBvZiB0YWcgcmVmaW5lbWVudHNcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIHRoZSB0YWcgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqL1xuICByZW1vdmVUYWdSZWZpbmVtZW50OiBmdW5jdGlvbiByZW1vdmVUYWdSZWZpbmVtZW50KHRhZykge1xuICAgIGlmICghdGhpcy5pc1RhZ1JlZmluZWQodGFnKSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbW9kaWZpY2F0aW9uID0ge1xuICAgICAgdGFnUmVmaW5lbWVudHM6IHRoaXMudGFnUmVmaW5lbWVudHMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgIT09IHRhZztcbiAgICAgIH0pXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyhtb2RpZmljYXRpb24pO1xuICB9LFxuICAvKipcbiAgICogR2VuZXJpYyB0b2dnbGUgcmVmaW5lbWVudCBtZXRob2QgdG8gdXNlIHdpdGggZmFjZXQsIGRpc2p1bmN0aXZlIGZhY2V0c1xuICAgKiBhbmQgaGllcmFyY2hpY2FsIGZhY2V0c1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZhY2V0IHRoZSBmYWNldCB0byByZWZpbmVcbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZhY2V0IGlzIG5vdCBkZWNsYXJlZCBpbiB0aGUgc2V0dGluZ3Mgb2YgdGhlIGhlbHBlclxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMTkuMCwgc2VlIHtAbGluayBTZWFyY2hQYXJhbWV0ZXJzI3RvZ2dsZUZhY2V0UmVmaW5lbWVudH1cbiAgICovXG4gIHRvZ2dsZVJlZmluZW1lbnQ6IGZ1bmN0aW9uIHRvZ2dsZVJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZW5lcmljIHRvZ2dsZSByZWZpbmVtZW50IG1ldGhvZCB0byB1c2Ugd2l0aCBmYWNldCwgZGlzanVuY3RpdmUgZmFjZXRzXG4gICAqIGFuZCBoaWVyYXJjaGljYWwgZmFjZXRzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmFjZXQgdGhlIGZhY2V0IHRvIHJlZmluZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9XG4gICAqIEB0aHJvd3Mgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmFjZXQgaXMgbm90IGRlY2xhcmVkIGluIHRoZSBzZXR0aW5ncyBvZiB0aGUgaGVscGVyXG4gICAqL1xuICB0b2dnbGVGYWNldFJlZmluZW1lbnQ6IGZ1bmN0aW9uIHRvZ2dsZUZhY2V0UmVmaW5lbWVudChmYWNldCwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0hpZXJhcmNoaWNhbEZhY2V0KGZhY2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlSGllcmFyY2hpY2FsRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29uanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUNvbmp1bmN0aXZlRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRGlzanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvZ2dsZURpc2p1bmN0aXZlRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVmaW5lIHRoZSB1bmRlY2xhcmVkIGZhY2V0ICcgKyBmYWNldCArXG4gICAgICAnOyBpdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGhlbHBlciBvcHRpb25zIGZhY2V0cywgZGlzanVuY3RpdmVGYWNldHMgb3IgaGllcmFyY2hpY2FsRmFjZXRzJyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTd2l0Y2ggdGhlIHJlZmluZW1lbnQgYXBwbGllZCBvdmVyIGEgZmFjZXQvdmFsdWVcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHVzZWQgZm9yIGZhY2V0aW5nXG4gICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlIHZhbHVlIHVzZWQgZm9yIGZpbHRlcmluZ1xuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgdG9nZ2xlQ29uanVuY3RpdmVGYWNldFJlZmluZW1lbnQ6IGZ1bmN0aW9uIHRvZ2dsZUNvbmp1bmN0aXZlRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5pc0Nvbmp1bmN0aXZlRmFjZXQoZmFjZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZmFjZXQgKyAnIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBmYWNldHMgYXR0cmlidXRlIG9mIHRoZSBoZWxwZXIgY29uZmlndXJhdGlvbicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICBmYWNldHNSZWZpbmVtZW50czogUmVmaW5lbWVudExpc3QudG9nZ2xlUmVmaW5lbWVudCh0aGlzLmZhY2V0c1JlZmluZW1lbnRzLCBmYWNldCwgdmFsdWUpXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBTd2l0Y2ggdGhlIHJlZmluZW1lbnQgYXBwbGllZCBvdmVyIGEgZmFjZXQvdmFsdWVcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHVzZWQgZm9yIGZhY2V0aW5nXG4gICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlIHZhbHVlIHVzZWQgZm9yIGZpbHRlcmluZ1xuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgdG9nZ2xlRXhjbHVkZUZhY2V0UmVmaW5lbWVudDogZnVuY3Rpb24gdG9nZ2xlRXhjbHVkZUZhY2V0UmVmaW5lbWVudChmYWNldCwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25qdW5jdGl2ZUZhY2V0KGZhY2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZhY2V0ICsgJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgZmFjZXRzIGF0dHJpYnV0ZSBvZiB0aGUgaGVscGVyIGNvbmZpZ3VyYXRpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgZmFjZXRzRXhjbHVkZXM6IFJlZmluZW1lbnRMaXN0LnRvZ2dsZVJlZmluZW1lbnQodGhpcy5mYWNldHNFeGNsdWRlcywgZmFjZXQsIHZhbHVlKVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogU3dpdGNoIHRoZSByZWZpbmVtZW50IGFwcGxpZWQgb3ZlciBhIGZhY2V0L3ZhbHVlXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIGZvciBmYWNldGluZ1xuICAgKiBAcGFyYW0ge3ZhbHVlfSB2YWx1ZSB2YWx1ZSB1c2VkIGZvciBmaWx0ZXJpbmdcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc31cbiAgICovXG4gIHRvZ2dsZURpc2p1bmN0aXZlRmFjZXRSZWZpbmVtZW50OiBmdW5jdGlvbiB0b2dnbGVEaXNqdW5jdGl2ZUZhY2V0UmVmaW5lbWVudChmYWNldCwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNqdW5jdGl2ZUZhY2V0KGZhY2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBmYWNldCArICcgaXMgbm90IGRlZmluZWQgaW4gdGhlIGRpc2p1bmN0aXZlRmFjZXRzIGF0dHJpYnV0ZSBvZiB0aGUgaGVscGVyIGNvbmZpZ3VyYXRpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50czogUmVmaW5lbWVudExpc3QudG9nZ2xlUmVmaW5lbWVudChcbiAgICAgICAgdGhpcy5kaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzLCBmYWNldCwgdmFsdWUpXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBTd2l0Y2ggdGhlIHJlZmluZW1lbnQgYXBwbGllZCBvdmVyIGEgZmFjZXQvdmFsdWVcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHVzZWQgZm9yIGZhY2V0aW5nXG4gICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlIHZhbHVlIHVzZWQgZm9yIGZpbHRlcmluZ1xuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfVxuICAgKi9cbiAgdG9nZ2xlSGllcmFyY2hpY2FsRmFjZXRSZWZpbmVtZW50OiBmdW5jdGlvbiB0b2dnbGVIaWVyYXJjaGljYWxGYWNldFJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzSGllcmFyY2hpY2FsRmFjZXQoZmFjZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGZhY2V0ICsgJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgaGllcmFyY2hpY2FsRmFjZXRzIGF0dHJpYnV0ZSBvZiB0aGUgaGVscGVyIGNvbmZpZ3VyYXRpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgc2VwYXJhdG9yID0gdGhpcy5fZ2V0SGllcmFyY2hpY2FsRmFjZXRTZXBhcmF0b3IodGhpcy5nZXRIaWVyYXJjaGljYWxGYWNldEJ5TmFtZShmYWNldCkpO1xuXG4gICAgdmFyIG1vZCA9IHt9O1xuXG4gICAgdmFyIHVwT25lT3JNdWx0aXBsZUxldmVsID0gdGhpcy5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50c1tmYWNldF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgdGhpcy5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50c1tmYWNldF0ubGVuZ3RoID4gMCAmJiAoXG4gICAgICAvLyByZW1vdmUgY3VycmVudCByZWZpbmVtZW50OlxuICAgICAgLy8gcmVmaW5lbWVudCB3YXMgJ2JlZXIgPiBJUEEnLCBjYWxsIGlzIHRvZ2dsZVJlZmluZSgnYmVlciA+IElQQScpLCByZWZpbmVtZW50IHNob3VsZCBiZSBgYmVlcmBcbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHNbZmFjZXRdWzBdID09PSB2YWx1ZSB8fFxuICAgICAgLy8gcmVtb3ZlIGEgcGFyZW50IHJlZmluZW1lbnQgb2YgdGhlIGN1cnJlbnQgcmVmaW5lbWVudDpcbiAgICAgIC8vICAtIHJlZmluZW1lbnQgd2FzICdiZWVyID4gSVBBID4gRmx5aW5nIGRvZydcbiAgICAgIC8vICAtIGNhbGwgaXMgdG9nZ2xlUmVmaW5lKCdiZWVyID4gSVBBJylcbiAgICAgIC8vICAtIHJlZmluZW1lbnQgc2hvdWxkIGJlIGBiZWVyYFxuICAgICAgdGhpcy5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50c1tmYWNldF1bMF0uaW5kZXhPZih2YWx1ZSArIHNlcGFyYXRvcikgPT09IDBcbiAgICApO1xuXG4gICAgaWYgKHVwT25lT3JNdWx0aXBsZUxldmVsKSB7XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihzZXBhcmF0b3IpID09PSAtMSkge1xuICAgICAgICAvLyBnbyBiYWNrIHRvIHJvb3QgbGV2ZWxcbiAgICAgICAgbW9kW2ZhY2V0XSA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kW2ZhY2V0XSA9IFt2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sYXN0SW5kZXhPZihzZXBhcmF0b3IpKV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZFtmYWNldF0gPSBbdmFsdWVdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICBoaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50czogZGVmYXVsdHNQdXJlKHt9LCBtb2QsIHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHMpXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSByZWZpbmVtZW50IG9uIGEgaGllcmFyY2hpY2FsIGZhY2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgdGhlIGZhY2V0IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIGhpZXJhcmNoaWNhbCBmYWNldCBwYXRoXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcn0gdGhlIG5ldyBzdGF0ZVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBmYWNldCBpcyBub3QgZGVmaW5lZCBvciBpZiB0aGUgZmFjZXQgaXMgcmVmaW5lZFxuICAgKi9cbiAgYWRkSGllcmFyY2hpY2FsRmFjZXRSZWZpbmVtZW50OiBmdW5jdGlvbihmYWNldCwgcGF0aCkge1xuICAgIGlmICh0aGlzLmlzSGllcmFyY2hpY2FsRmFjZXRSZWZpbmVkKGZhY2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZhY2V0ICsgJyBpcyBhbHJlYWR5IHJlZmluZWQuJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0hpZXJhcmNoaWNhbEZhY2V0KGZhY2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZhY2V0ICsgJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgaGllcmFyY2hpY2FsRmFjZXRzIGF0dHJpYnV0ZSBvZiB0aGUgaGVscGVyIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgfVxuICAgIHZhciBtb2QgPSB7fTtcbiAgICBtb2RbZmFjZXRdID0gW3BhdGhdO1xuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICBoaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50czogZGVmYXVsdHNQdXJlKHt9LCBtb2QsIHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHMpXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHJlZmluZW1lbnQgc2V0IG9uIGEgaGllcmFyY2hpY2FsIGZhY2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgdGhlIGZhY2V0IG5hbWVcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyfSB0aGUgbmV3IHN0YXRlXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGZhY2V0IGlzIG5vdCBkZWZpbmVkIG9yIGlmIHRoZSBmYWNldCBpcyBub3QgcmVmaW5lZFxuICAgKi9cbiAgcmVtb3ZlSGllcmFyY2hpY2FsRmFjZXRSZWZpbmVtZW50OiBmdW5jdGlvbihmYWNldCkge1xuICAgIGlmICghdGhpcy5pc0hpZXJhcmNoaWNhbEZhY2V0UmVmaW5lZChmYWNldCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbW9kID0ge307XG4gICAgbW9kW2ZhY2V0XSA9IFtdO1xuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgICBoaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50czogZGVmYXVsdHNQdXJlKHt9LCBtb2QsIHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHMpXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBTd2l0Y2ggdGhlIHRhZyByZWZpbmVtZW50XG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyB0aGUgdGFnIHRvIHJlbW92ZSBvciBhZGRcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc31cbiAgICovXG4gIHRvZ2dsZVRhZ1JlZmluZW1lbnQ6IGZ1bmN0aW9uIHRvZ2dsZVRhZ1JlZmluZW1lbnQodGFnKSB7XG4gICAgaWYgKHRoaXMuaXNUYWdSZWZpbmVkKHRhZykpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZVRhZ1JlZmluZW1lbnQodGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hZGRUYWdSZWZpbmVtZW50KHRhZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBmYWNldCBuYW1lIGlzIGZyb20gb25lIG9mIHRoZSBkaXNqdW5jdGl2ZSBmYWNldHNcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgZmFjZXQgbmFtZSB0byB0ZXN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0Rpc2p1bmN0aXZlRmFjZXQ6IGZ1bmN0aW9uKGZhY2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzanVuY3RpdmVGYWNldHMuaW5kZXhPZihmYWNldCkgPiAtMTtcbiAgfSxcbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGZhY2V0IG5hbWUgaXMgZnJvbSBvbmUgb2YgdGhlIGhpZXJhcmNoaWNhbCBmYWNldHNcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXROYW1lIGZhY2V0IG5hbWUgdG8gdGVzdFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNIaWVyYXJjaGljYWxGYWNldDogZnVuY3Rpb24oZmFjZXROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGllcmFyY2hpY2FsRmFjZXRCeU5hbWUoZmFjZXROYW1lKSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZmFjZXQgbmFtZSBpcyBmcm9tIG9uZSBvZiB0aGUgY29uanVuY3RpdmUvbm9ybWFsIGZhY2V0c1xuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldCBmYWNldCBuYW1lIHRvIHRlc3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29uanVuY3RpdmVGYWNldDogZnVuY3Rpb24oZmFjZXQpIHtcbiAgICByZXR1cm4gdGhpcy5mYWNldHMuaW5kZXhPZihmYWNldCkgPiAtMTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmFjZXQgaXMgcmVmaW5lZCwgZWl0aGVyIGZvciBhIHNwZWNpZmljIHZhbHVlIG9yIGluXG4gICAqIGdlbmVyYWwuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBmb3IgdXNlZCBmb3IgZmFjZXRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlLCBvcHRpb25hbCB2YWx1ZS4gSWYgcGFzc2VkIHdpbGwgdGVzdCB0aGF0IHRoaXMgdmFsdWVcbiAgICogaXMgZmlsdGVyaW5nIHRoZSBnaXZlbiBmYWNldC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHJlZmluZWRcbiAgICovXG4gIGlzRmFjZXRSZWZpbmVkOiBmdW5jdGlvbiBpc0ZhY2V0UmVmaW5lZChmYWNldCwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25qdW5jdGl2ZUZhY2V0KGZhY2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gUmVmaW5lbWVudExpc3QuaXNSZWZpbmVkKHRoaXMuZmFjZXRzUmVmaW5lbWVudHMsIGZhY2V0LCB2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZhY2V0IGNvbnRhaW5zIGV4Y2x1c2lvbnMgb3IgaWYgYSBzcGVjaWZpYyB2YWx1ZSBpc1xuICAgKiBleGNsdWRlZC5cbiAgICpcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGZvciB1c2VkIGZvciBmYWNldGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSBvcHRpb25hbCB2YWx1ZS4gSWYgcGFzc2VkIHdpbGwgdGVzdCB0aGF0IHRoaXMgdmFsdWVcbiAgICogaXMgZmlsdGVyaW5nIHRoZSBnaXZlbiBmYWNldC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHJlZmluZWRcbiAgICovXG4gIGlzRXhjbHVkZVJlZmluZWQ6IGZ1bmN0aW9uIGlzRXhjbHVkZVJlZmluZWQoZmFjZXQsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29uanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmluZW1lbnRMaXN0LmlzUmVmaW5lZCh0aGlzLmZhY2V0c0V4Y2x1ZGVzLCBmYWNldCwgdmFsdWUpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmYWNldCBjb250YWlucyBhIHJlZmluZW1lbnQsIG9yIGlmIGEgdmFsdWUgcGFzc2VkIGlzIGFcbiAgICogcmVmaW5lbWVudCBmb3IgdGhlIGZhY2V0LlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldCBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgZm9yIHVzZWQgZm9yIGZhY2V0aW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBvcHRpb25hbCwgd2lsbCB0ZXN0IGlmIHRoZSB2YWx1ZSBpcyB1c2VkIGZvciByZWZpbmVtZW50XG4gICAqIGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlIHdpbGwgdGVzdCBpZiB0aGUgZmFjZXQgY29udGFpbnMgYW55IHJlZmluZW1lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRGlzanVuY3RpdmVGYWNldFJlZmluZWQ6IGZ1bmN0aW9uIGlzRGlzanVuY3RpdmVGYWNldFJlZmluZWQoZmFjZXQsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzanVuY3RpdmVGYWNldChmYWNldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmluZW1lbnRMaXN0LmlzUmVmaW5lZCh0aGlzLmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMsIGZhY2V0LCB2YWx1ZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZhY2V0IGNvbnRhaW5zIGEgcmVmaW5lbWVudCwgb3IgaWYgYSB2YWx1ZSBwYXNzZWQgaXMgYVxuICAgKiByZWZpbmVtZW50IGZvciB0aGUgZmFjZXQuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBmb3IgdXNlZCBmb3IgZmFjZXRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIG9wdGlvbmFsLCB3aWxsIHRlc3QgaWYgdGhlIHZhbHVlIGlzIHVzZWQgZm9yIHJlZmluZW1lbnRcbiAgICogaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2Ugd2lsbCB0ZXN0IGlmIHRoZSBmYWNldCBjb250YWlucyBhbnkgcmVmaW5lbWVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNIaWVyYXJjaGljYWxGYWNldFJlZmluZWQ6IGZ1bmN0aW9uIGlzSGllcmFyY2hpY2FsRmFjZXRSZWZpbmVkKGZhY2V0LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5pc0hpZXJhcmNoaWNhbEZhY2V0KGZhY2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByZWZpbmVtZW50cyA9IHRoaXMuZ2V0SGllcmFyY2hpY2FsUmVmaW5lbWVudChmYWNldCk7XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVmaW5lbWVudHMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmaW5lbWVudHMuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICB9LFxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgdHJpcGxlIChhdHRyaWJ1dGUsIG9wZXJhdG9yLCB2YWx1ZSkgaXMgYWxyZWFkeSByZWZpbmVkLlxuICAgKiBJZiBvbmx5IHRoZSBhdHRyaWJ1dGUgYW5kIHRoZSBvcGVyYXRvciBhcmUgcHJvdmlkZWQsIGl0IHRlc3RzIGlmIHRoZVxuICAgKiBjb250YWlucyBhbnkgcmVmaW5lbWVudCB2YWx1ZS5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIGF0dHJpYnV0ZSBmb3Igd2hpY2ggdGhlIHJlZmluZW1lbnQgaXMgYXBwbGllZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wZXJhdG9yXSBvcGVyYXRvciBvZiB0aGUgcmVmaW5lbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSB2YWx1ZSBvZiB0aGUgcmVmaW5lbWVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGl0IGlzIHJlZmluZWRcbiAgICovXG4gIGlzTnVtZXJpY1JlZmluZWQ6IGZ1bmN0aW9uIGlzTnVtZXJpY1JlZmluZWQoYXR0cmlidXRlLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm51bWVyaWNSZWZpbmVtZW50c1thdHRyaWJ1dGVdO1xuICAgIH1cblxuICAgIHZhciBpc09wZXJhdG9yRGVmaW5lZCA9XG4gICAgICB0aGlzLm51bWVyaWNSZWZpbmVtZW50c1thdHRyaWJ1dGVdICYmXG4gICAgICB0aGlzLm51bWVyaWNSZWZpbmVtZW50c1thdHRyaWJ1dGVdW29wZXJhdG9yXSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgIWlzT3BlcmF0b3JEZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaXNPcGVyYXRvckRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFZhbHVlID0gdmFsVG9OdW1iZXIodmFsdWUpO1xuICAgIHZhciBpc0F0dHJpYnV0ZVZhbHVlRGVmaW5lZCA9XG4gICAgICBmaW5kQXJyYXkodGhpcy5udW1lcmljUmVmaW5lbWVudHNbYXR0cmlidXRlXVtvcGVyYXRvcl0sIHBhcnNlZFZhbHVlKSAhPT1cbiAgICAgIHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBpc09wZXJhdG9yRGVmaW5lZCAmJiBpc0F0dHJpYnV0ZVZhbHVlRGVmaW5lZDtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIHJlZmluZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgdGhlIHRhZyB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNUYWdSZWZpbmVkOiBmdW5jdGlvbiBpc1RhZ1JlZmluZWQodGFnKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnUmVmaW5lbWVudHMuaW5kZXhPZih0YWcpICE9PSAtMTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGRpc2p1bmN0aXZlIGZhY2V0cyByZWZpbmVkXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIGZvciBmYWNldGluZ1xuICAgKiBAcGFyYW0ge3ZhbHVlfSB2YWx1ZSB2YWx1ZSB1c2VkIGZvciBmaWx0ZXJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nW119XG4gICAqL1xuICBnZXRSZWZpbmVkRGlzanVuY3RpdmVGYWNldHM6IGZ1bmN0aW9uIGdldFJlZmluZWREaXNqdW5jdGl2ZUZhY2V0cygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhdHRyaWJ1dGVzIHVzZWQgZm9yIG51bWVyaWMgZmlsdGVyIGNhbiBhbHNvIGJlIGRpc2p1bmN0aXZlXG4gICAgdmFyIGRpc2p1bmN0aXZlTnVtZXJpY1JlZmluZWRGYWNldHMgPSBpbnRlcnNlY3Rpb24oXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLm51bWVyaWNSZWZpbmVtZW50cykuZmlsdGVyKGZ1bmN0aW9uKGZhY2V0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzZWxmLm51bWVyaWNSZWZpbmVtZW50c1tmYWNldF0pLmxlbmd0aCA+IDA7XG4gICAgICB9KSxcbiAgICAgIHRoaXMuZGlzanVuY3RpdmVGYWNldHNcbiAgICApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cykuZmlsdGVyKGZ1bmN0aW9uKGZhY2V0KSB7XG4gICAgICByZXR1cm4gc2VsZi5kaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzW2ZhY2V0XS5sZW5ndGggPiAwO1xuICAgIH0pXG4gICAgICAuY29uY2F0KGRpc2p1bmN0aXZlTnVtZXJpY1JlZmluZWRGYWNldHMpXG4gICAgICAuY29uY2F0KHRoaXMuZ2V0UmVmaW5lZEhpZXJhcmNoaWNhbEZhY2V0cygpKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGRpc2p1bmN0aXZlIGZhY2V0cyByZWZpbmVkXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIGZvciBmYWNldGluZ1xuICAgKiBAcGFyYW0ge3ZhbHVlfSB2YWx1ZSB2YWx1ZSB1c2VkIGZvciBmaWx0ZXJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nW119XG4gICAqL1xuICBnZXRSZWZpbmVkSGllcmFyY2hpY2FsRmFjZXRzOiBmdW5jdGlvbiBnZXRSZWZpbmVkSGllcmFyY2hpY2FsRmFjZXRzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uKFxuICAgICAgLy8gZW5mb3JjZSB0aGUgb3JkZXIgYmV0d2VlbiB0aGUgdHdvIGFycmF5cyxcbiAgICAgIC8vIHNvIHRoYXQgcmVmaW5lbWVudCBuYW1lIGluZGV4ID09PSBoaWVyYXJjaGljYWwgZmFjZXQgaW5kZXhcbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzLm1hcChmdW5jdGlvbihmYWNldCkgeyByZXR1cm4gZmFjZXQubmFtZTsgfSksXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24oZmFjZXQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHNbZmFjZXRdLmxlbmd0aCA+IDA7XG4gICAgICB9KVxuICAgICk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5lZCB0aGUgbGlzdCBvZiBhbGwgZGlzanVuY3RpdmUgZmFjZXRzIG5vdCByZWZpbmVkXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7c3RyaW5nW119XG4gICAqL1xuICBnZXRVbnJlZmluZWREaXNqdW5jdGl2ZUZhY2V0czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlZmluZWRGYWNldHMgPSB0aGlzLmdldFJlZmluZWREaXNqdW5jdGl2ZUZhY2V0cygpO1xuXG4gICAgcmV0dXJuIHRoaXMuZGlzanVuY3RpdmVGYWNldHMuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiByZWZpbmVkRmFjZXRzLmluZGV4T2YoZikgPT09IC0xO1xuICAgIH0pO1xuICB9LFxuXG4gIG1hbmFnZWRQYXJhbWV0ZXJzOiBbXG4gICAgJ2luZGV4JyxcbiAgICAnZmFjZXRzJywgJ2Rpc2p1bmN0aXZlRmFjZXRzJywgJ2ZhY2V0c1JlZmluZW1lbnRzJyxcbiAgICAnZmFjZXRzRXhjbHVkZXMnLCAnZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cycsXG4gICAgJ251bWVyaWNSZWZpbmVtZW50cycsICd0YWdSZWZpbmVtZW50cycsICdoaWVyYXJjaGljYWxGYWNldHMnLCAnaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHMnXG4gIF0sXG4gIGdldFF1ZXJ5UGFyYW1zOiBmdW5jdGlvbiBnZXRRdWVyeVBhcmFtcygpIHtcbiAgICB2YXIgbWFuYWdlZFBhcmFtZXRlcnMgPSB0aGlzLm1hbmFnZWRQYXJhbWV0ZXJzO1xuXG4gICAgdmFyIHF1ZXJ5UGFyYW1zID0ge307XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihwYXJhbU5hbWUpIHtcbiAgICAgIHZhciBwYXJhbVZhbHVlID0gc2VsZltwYXJhbU5hbWVdO1xuICAgICAgaWYgKG1hbmFnZWRQYXJhbWV0ZXJzLmluZGV4T2YocGFyYW1OYW1lKSA9PT0gLTEgJiYgcGFyYW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHF1ZXJ5UGFyYW1zO1xuICB9LFxuICAvKipcbiAgICogTGV0IHRoZSB1c2VyIHNldCBhIHNwZWNpZmljIHZhbHVlIGZvciBhIGdpdmVuIHBhcmFtZXRlci4gV2lsbCByZXR1cm4gdGhlXG4gICAqIHNhbWUgaW5zdGFuY2UgaWYgdGhlIHBhcmFtZXRlciBpcyBpbnZhbGlkIG9yIGlmIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGVcbiAgICogcHJldmlvdXMgb25lLlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXIgdGhlIHBhcmFtZXRlciBuYW1lXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSB0aGUgdmFsdWUgdG8gYmUgc2V0LCBtdXN0IGJlIGNvbXBsaWFudCB3aXRoIHRoZSBkZWZpbml0aW9uXG4gICAqIG9mIHRoZSBhdHRyaWJ1dGUgb24gdGhlIG9iamVjdFxuICAgKiBAcmV0dXJuIHtTZWFyY2hQYXJhbWV0ZXJzfSB0aGUgdXBkYXRlZCBzdGF0ZVxuICAgKi9cbiAgc2V0UXVlcnlQYXJhbWV0ZXI6IGZ1bmN0aW9uIHNldFBhcmFtZXRlcihwYXJhbWV0ZXIsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXNbcGFyYW1ldGVyXSA9PT0gdmFsdWUpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIG1vZGlmaWNhdGlvbiA9IHt9O1xuXG4gICAgbW9kaWZpY2F0aW9uW3BhcmFtZXRlcl0gPSB2YWx1ZTtcblxuICAgIHJldHVybiB0aGlzLnNldFF1ZXJ5UGFyYW1ldGVycyhtb2RpZmljYXRpb24pO1xuICB9LFxuICAvKipcbiAgICogTGV0IHRoZSB1c2VyIHNldCBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgd2l0aCBhIHBsYWluIG9iamVjdC5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIGFsbCB0aGUga2V5cyBhbmQgdGhlIHZhbHVlcyB0byBiZSB1cGRhdGVkXG4gICAqIEByZXR1cm4ge1NlYXJjaFBhcmFtZXRlcnN9IGEgbmV3IHVwZGF0ZWQgaW5zdGFuY2VcbiAgICovXG4gIHNldFF1ZXJ5UGFyYW1ldGVyczogZnVuY3Rpb24gc2V0UXVlcnlQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBlcnJvciA9IFNlYXJjaFBhcmFtZXRlcnMudmFsaWRhdGUodGhpcywgcGFyYW1zKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBuZXh0V2l0aE51bWJlcnMgPSBTZWFyY2hQYXJhbWV0ZXJzLl9wYXJzZU51bWJlcnMocGFyYW1zKTtcbiAgICB2YXIgcHJldmlvdXNQbGFpbk9iamVjdCA9IE9iamVjdC5rZXlzKHRoaXMpLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgICAgYWNjW2tleV0gPSBzZWxmW2tleV07XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcblxuICAgIHZhciBuZXh0UGxhaW5PYmplY3QgPSBPYmplY3Qua2V5cyhuZXh0V2l0aE51bWJlcnMpLnJlZHVjZShcbiAgICAgIGZ1bmN0aW9uKHByZXZpb3VzLCBrZXkpIHtcbiAgICAgICAgdmFyIGlzUHJldmlvdXNWYWx1ZURlZmluZWQgPSBwcmV2aW91c1trZXldICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpc05leHRWYWx1ZURlZmluZWQgPSBuZXh0V2l0aE51bWJlcnNba2V5XSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChpc1ByZXZpb3VzVmFsdWVEZWZpbmVkICYmICFpc05leHRWYWx1ZURlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gb21pdChwcmV2aW91cywgW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmV4dFZhbHVlRGVmaW5lZCkge1xuICAgICAgICAgIHByZXZpb3VzW2tleV0gPSBuZXh0V2l0aE51bWJlcnNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICAgIH0sXG4gICAgICBwcmV2aW91c1BsYWluT2JqZWN0XG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihuZXh0UGxhaW5PYmplY3QpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIHdpdGggdGhlIHBhZ2UgcmVzZXQuIFR3byBzY2VuYXJpb3MgcG9zc2libGU6XG4gICAqIHRoZSBwYWdlIGlzIG9taXR0ZWQgLT4gcmV0dXJuIHRoZSBnaXZlbiBpbnN0YW5jZVxuICAgKiB0aGUgcGFnZSBpcyBzZXQgLT4gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHdpdGggYSBwYWdlIG9mIDBcbiAgICogQHJldHVybiB7U2VhcmNoUGFyYW1ldGVyc30gYSBuZXcgdXBkYXRlZCBpbnN0YW5jZVxuICAgKi9cbiAgcmVzZXRQYWdlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldFBhZ2UoMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGhpZXJhcmNoaWNhbEZhY2V0IHNlcGFyYXRvciBvciB0aGUgZGVmYXVsdCBvbmUgKGA+YClcbiAgICogQHBhcmFtICB7b2JqZWN0fSBoaWVyYXJjaGljYWxGYWNldFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJldHVybnMgdGhlIGhpZXJhcmNoaWNhbEZhY2V0LnNlcGFyYXRvciBvciBgPmAgYXMgZGVmYXVsdFxuICAgKi9cbiAgX2dldEhpZXJhcmNoaWNhbEZhY2V0U29ydEJ5OiBmdW5jdGlvbihoaWVyYXJjaGljYWxGYWNldCkge1xuICAgIHJldHVybiBoaWVyYXJjaGljYWxGYWNldC5zb3J0QnkgfHwgWydpc1JlZmluZWQ6ZGVzYycsICduYW1lOmFzYyddO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBoaWVyYXJjaGljYWxGYWNldCBzZXBhcmF0b3Igb3IgdGhlIGRlZmF1bHQgb25lIChgPmApXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge29iamVjdH0gaGllcmFyY2hpY2FsRmFjZXRcbiAgICogQHJldHVybiB7c3RyaW5nfSByZXR1cm5zIHRoZSBoaWVyYXJjaGljYWxGYWNldC5zZXBhcmF0b3Igb3IgYD5gIGFzIGRlZmF1bHRcbiAgICovXG4gIF9nZXRIaWVyYXJjaGljYWxGYWNldFNlcGFyYXRvcjogZnVuY3Rpb24oaGllcmFyY2hpY2FsRmFjZXQpIHtcbiAgICByZXR1cm4gaGllcmFyY2hpY2FsRmFjZXQuc2VwYXJhdG9yIHx8ICcgPiAnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBoaWVyYXJjaGljYWxGYWNldCBwcmVmaXggcGF0aCBvciBudWxsXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge29iamVjdH0gaGllcmFyY2hpY2FsRmFjZXRcbiAgICogQHJldHVybiB7c3RyaW5nfSByZXR1cm5zIHRoZSBoaWVyYXJjaGljYWxGYWNldC5yb290UGF0aCBvciBudWxsIGFzIGRlZmF1bHRcbiAgICovXG4gIF9nZXRIaWVyYXJjaGljYWxSb290UGF0aDogZnVuY3Rpb24oaGllcmFyY2hpY2FsRmFjZXQpIHtcbiAgICByZXR1cm4gaGllcmFyY2hpY2FsRmFjZXQucm9vdFBhdGggfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHdlIHNob3cgdGhlIHBhcmVudCBsZXZlbCBvZiB0aGUgaGllcmFyY2hpY2FsRmFjZXRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBoaWVyYXJjaGljYWxGYWNldFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJldHVybnMgdGhlIGhpZXJhcmNoaWNhbEZhY2V0LnNob3dQYXJlbnRMZXZlbCBvciB0cnVlIGFzIGRlZmF1bHRcbiAgICovXG4gIF9nZXRIaWVyYXJjaGljYWxTaG93UGFyZW50TGV2ZWw6IGZ1bmN0aW9uKGhpZXJhcmNoaWNhbEZhY2V0KSB7XG4gICAgaWYgKHR5cGVvZiBoaWVyYXJjaGljYWxGYWNldC5zaG93UGFyZW50TGV2ZWwgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIGhpZXJhcmNoaWNhbEZhY2V0LnNob3dQYXJlbnRMZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGhpZXJhcmNoaWNhbEZhY2V0IGJ5IGl0J3MgbmFtZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGhpZXJhcmNoaWNhbEZhY2V0TmFtZVxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGEgaGllcmFyY2hpY2FsRmFjZXRcbiAgICovXG4gIGdldEhpZXJhcmNoaWNhbEZhY2V0QnlOYW1lOiBmdW5jdGlvbihoaWVyYXJjaGljYWxGYWNldE5hbWUpIHtcbiAgICByZXR1cm4gZmluZChcbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzLFxuICAgICAgZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZi5uYW1lID09PSBoaWVyYXJjaGljYWxGYWNldE5hbWU7XG4gICAgICB9XG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGJyZWFkY3J1bWIgZm9yIGEgaGllcmFyY2hpY2FsIGZhY2V0LCBhcyBhbiBhcnJheVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZhY2V0TmFtZSBIaWVyYXJjaGljYWwgZmFjZXQgbmFtZVxuICAgKiBAcmV0dXJuIHthcnJheS48c3RyaW5nPn0gdGhlIHBhdGggYXMgYW4gYXJyYXkgb2Ygc3RyaW5nXG4gICAqL1xuICBnZXRIaWVyYXJjaGljYWxGYWNldEJyZWFkY3J1bWI6IGZ1bmN0aW9uKGZhY2V0TmFtZSkge1xuICAgIGlmICghdGhpcy5pc0hpZXJhcmNoaWNhbEZhY2V0KGZhY2V0TmFtZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgcmVmaW5lbWVudCA9IHRoaXMuZ2V0SGllcmFyY2hpY2FsUmVmaW5lbWVudChmYWNldE5hbWUpWzBdO1xuICAgIGlmICghcmVmaW5lbWVudCkgcmV0dXJuIFtdO1xuXG4gICAgdmFyIHNlcGFyYXRvciA9IHRoaXMuX2dldEhpZXJhcmNoaWNhbEZhY2V0U2VwYXJhdG9yKFxuICAgICAgdGhpcy5nZXRIaWVyYXJjaGljYWxGYWNldEJ5TmFtZShmYWNldE5hbWUpXG4gICAgKTtcbiAgICB2YXIgcGF0aCA9IHJlZmluZW1lbnQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgcmV0dXJuIHBhcnQudHJpbSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcywgbnVsbCwgMik7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgdXNlZCBmb3IgY2xlYXJSZWZpbmVtZW50IG1ldGhvZFxuICogQGNhbGxiYWNrIFNlYXJjaFBhcmFtZXRlcnMuY2xlYXJDYWxsYmFja1xuICogQHBhcmFtIHtPcGVyYXRvckxpc3R8RmFjZXRMaXN0fSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIGZpbHRlclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUgY3VycmVudCBhdHRyaWJ1dGUgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgYG51bWVyaWNgLCBgZGlzanVuY3RpdmVGYWNldGAsIGBjb25qdW5jdGl2ZUZhY2V0YCwgYGhpZXJhcmNoaWNhbEZhY2V0YCBvciBgZXhjbHVkZWBcbiAqIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBmYWNldFxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBlbGVtZW50IHNob3VsZCBiZSByZW1vdmVkLiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBTZWFyY2hQYXJhbWV0ZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlVHJlZXM7XG5cbnZhciBvcmRlckJ5ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL29yZGVyQnknKTtcbnZhciBmaW5kID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2ZpbmQnKTtcbnZhciBwcmVwYXJlSGllcmFyY2hpY2FsRmFjZXRTb3J0QnkgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZm9ybWF0U29ydCcpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRyZWVzKHN0YXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZShoaWVyYXJjaGljYWxGYWNldFJlc3VsdCwgaGllcmFyY2hpY2FsRmFjZXRJbmRleCkge1xuICAgIHZhciBoaWVyYXJjaGljYWxGYWNldCA9IHN0YXRlLmhpZXJhcmNoaWNhbEZhY2V0c1toaWVyYXJjaGljYWxGYWNldEluZGV4XTtcbiAgICB2YXIgaGllcmFyY2hpY2FsRmFjZXRSZWZpbmVtZW50ID1cbiAgICAgIChzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50c1toaWVyYXJjaGljYWxGYWNldC5uYW1lXSAmJlxuICAgICAgICBzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50c1toaWVyYXJjaGljYWxGYWNldC5uYW1lXVswXSkgfHxcbiAgICAgICcnO1xuICAgIHZhciBoaWVyYXJjaGljYWxTZXBhcmF0b3IgPSBzdGF0ZS5fZ2V0SGllcmFyY2hpY2FsRmFjZXRTZXBhcmF0b3IoXG4gICAgICBoaWVyYXJjaGljYWxGYWNldFxuICAgICk7XG4gICAgdmFyIGhpZXJhcmNoaWNhbFJvb3RQYXRoID0gc3RhdGUuX2dldEhpZXJhcmNoaWNhbFJvb3RQYXRoKFxuICAgICAgaGllcmFyY2hpY2FsRmFjZXRcbiAgICApO1xuICAgIHZhciBoaWVyYXJjaGljYWxTaG93UGFyZW50TGV2ZWwgPSBzdGF0ZS5fZ2V0SGllcmFyY2hpY2FsU2hvd1BhcmVudExldmVsKFxuICAgICAgaGllcmFyY2hpY2FsRmFjZXRcbiAgICApO1xuICAgIHZhciBzb3J0QnkgPSBwcmVwYXJlSGllcmFyY2hpY2FsRmFjZXRTb3J0QnkoXG4gICAgICBzdGF0ZS5fZ2V0SGllcmFyY2hpY2FsRmFjZXRTb3J0QnkoaGllcmFyY2hpY2FsRmFjZXQpXG4gICAgKTtcblxuICAgIHZhciByb290RXhoYXVzdGl2ZSA9IGhpZXJhcmNoaWNhbEZhY2V0UmVzdWx0LmV2ZXJ5KGZ1bmN0aW9uKGZhY2V0UmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFjZXRSZXN1bHQuZXhoYXVzdGl2ZTtcbiAgICB9KTtcblxuICAgIHZhciBnZW5lcmF0ZVRyZWVGbiA9IGdlbmVyYXRlSGllcmFyY2hpY2FsVHJlZShcbiAgICAgIHNvcnRCeSxcbiAgICAgIGhpZXJhcmNoaWNhbFNlcGFyYXRvcixcbiAgICAgIGhpZXJhcmNoaWNhbFJvb3RQYXRoLFxuICAgICAgaGllcmFyY2hpY2FsU2hvd1BhcmVudExldmVsLFxuICAgICAgaGllcmFyY2hpY2FsRmFjZXRSZWZpbmVtZW50XG4gICAgKTtcblxuICAgIHZhciByZXN1bHRzID0gaGllcmFyY2hpY2FsRmFjZXRSZXN1bHQ7XG5cbiAgICBpZiAoaGllcmFyY2hpY2FsUm9vdFBhdGgpIHtcbiAgICAgIHJlc3VsdHMgPSBoaWVyYXJjaGljYWxGYWNldFJlc3VsdC5zbGljZShcbiAgICAgICAgaGllcmFyY2hpY2FsUm9vdFBhdGguc3BsaXQoaGllcmFyY2hpY2FsU2VwYXJhdG9yKS5sZW5ndGhcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKGdlbmVyYXRlVHJlZUZuLCB7XG4gICAgICBuYW1lOiBzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHNbaGllcmFyY2hpY2FsRmFjZXRJbmRleF0ubmFtZSxcbiAgICAgIGNvdW50OiBudWxsLCAvLyByb290IGxldmVsLCBubyBjb3VudFxuICAgICAgaXNSZWZpbmVkOiB0cnVlLCAvLyByb290IGxldmVsLCBhbHdheXMgcmVmaW5lZFxuICAgICAgcGF0aDogbnVsbCwgLy8gcm9vdCBsZXZlbCwgbm8gcGF0aFxuICAgICAgZXhoYXVzdGl2ZTogcm9vdEV4aGF1c3RpdmUsXG4gICAgICBkYXRhOiBudWxsXG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSGllcmFyY2hpY2FsVHJlZShcbiAgc29ydEJ5LFxuICBoaWVyYXJjaGljYWxTZXBhcmF0b3IsXG4gIGhpZXJhcmNoaWNhbFJvb3RQYXRoLFxuICBoaWVyYXJjaGljYWxTaG93UGFyZW50TGV2ZWwsXG4gIGN1cnJlbnRSZWZpbmVtZW50XG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlVHJlZShcbiAgICBoaWVyYXJjaGljYWxUcmVlLFxuICAgIGhpZXJhcmNoaWNhbEZhY2V0UmVzdWx0LFxuICAgIGN1cnJlbnRIaWVyYXJjaGljYWxMZXZlbFxuICApIHtcbiAgICB2YXIgcGFyZW50ID0gaGllcmFyY2hpY2FsVHJlZTtcblxuICAgIGlmIChjdXJyZW50SGllcmFyY2hpY2FsTGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgbGV2ZWwgPSAwO1xuXG4gICAgICBwYXJlbnQgPSBoaWVyYXJjaGljYWxUcmVlO1xuXG4gICAgICB3aGlsZSAobGV2ZWwgPCBjdXJyZW50SGllcmFyY2hpY2FsTGV2ZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3RbXV19IGhpZXJhcmNoaWNhbCBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZGF0YSA9IHBhcmVudCAmJiBBcnJheS5pc0FycmF5KHBhcmVudC5kYXRhKSA/IHBhcmVudC5kYXRhIDogW107XG4gICAgICAgIHBhcmVudCA9IGZpbmQoZGF0YSwgZnVuY3Rpb24oc3VidHJlZSkge1xuICAgICAgICAgIHJldHVybiBzdWJ0cmVlLmlzUmVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgZm91bmQgYSByZWZpbmVkIHBhcmVudCwgbGV0J3MgYWRkIGN1cnJlbnQgbGV2ZWwgZGF0YSB1bmRlciBpdFxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIC8vIGZpbHRlciB2YWx1ZXMgaW4gY2FzZSBhbiBvYmplY3QgaGFzIG11bHRpcGxlIGNhdGVnb3JpZXM6XG4gICAgICAvLyAgIHtcbiAgICAgIC8vICAgICBjYXRlZ29yaWVzOiB7XG4gICAgICAvLyAgICAgICBsZXZlbDA6IFsnYmVlcnMnLCAnYmnDqHJlcyddLFxuICAgICAgLy8gICAgICAgbGV2ZWwxOiBbJ2JlZXJzID4gSVBBJywgJ2Jpw6hyZXMgPiBCZWxnZXMnXVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfVxuICAgICAgLy9cbiAgICAgIC8vIElmIHBhcmVudCByZWZpbmVtZW50IGlzIGBiZWVyc2AsIHRoZW4gd2UgZG8gbm90IHdhbnQgdG8gaGF2ZSBgYmnDqHJlcyA+IEJlbGdlc2BcbiAgICAgIC8vIHNob3dpbmcgdXBcblxuICAgICAgdmFyIHBpY2tlZCA9IE9iamVjdC5rZXlzKGhpZXJhcmNoaWNhbEZhY2V0UmVzdWx0LmRhdGEpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oZmFjZXRWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBbZmFjZXRWYWx1ZSwgaGllcmFyY2hpY2FsRmFjZXRSZXN1bHQuZGF0YVtmYWNldFZhbHVlXV07XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24odHVwbGUpIHtcbiAgICAgICAgICB2YXIgZmFjZXRWYWx1ZSA9IHR1cGxlWzBdO1xuICAgICAgICAgIHJldHVybiBvbmx5TWF0Y2hpbmdUcmVlKFxuICAgICAgICAgICAgZmFjZXRWYWx1ZSxcbiAgICAgICAgICAgIHBhcmVudC5wYXRoIHx8IGhpZXJhcmNoaWNhbFJvb3RQYXRoLFxuICAgICAgICAgICAgY3VycmVudFJlZmluZW1lbnQsXG4gICAgICAgICAgICBoaWVyYXJjaGljYWxTZXBhcmF0b3IsXG4gICAgICAgICAgICBoaWVyYXJjaGljYWxSb290UGF0aCxcbiAgICAgICAgICAgIGhpZXJhcmNoaWNhbFNob3dQYXJlbnRMZXZlbFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICBwYXJlbnQuZGF0YSA9IG9yZGVyQnkoXG4gICAgICAgIHBpY2tlZC5tYXAoZnVuY3Rpb24odHVwbGUpIHtcbiAgICAgICAgICB2YXIgZmFjZXRWYWx1ZSA9IHR1cGxlWzBdO1xuICAgICAgICAgIHZhciBmYWNldENvdW50ID0gdHVwbGVbMV07XG5cbiAgICAgICAgICByZXR1cm4gZm9ybWF0KFxuICAgICAgICAgICAgZmFjZXRDb3VudCxcbiAgICAgICAgICAgIGZhY2V0VmFsdWUsXG4gICAgICAgICAgICBoaWVyYXJjaGljYWxTZXBhcmF0b3IsXG4gICAgICAgICAgICBjdXJyZW50UmVmaW5lbWVudCxcbiAgICAgICAgICAgIGhpZXJhcmNoaWNhbEZhY2V0UmVzdWx0LmV4aGF1c3RpdmVcbiAgICAgICAgICApO1xuICAgICAgICB9KSxcbiAgICAgICAgc29ydEJ5WzBdLFxuICAgICAgICBzb3J0QnlbMV1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZXJhcmNoaWNhbFRyZWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9ubHlNYXRjaGluZ1RyZWUoXG4gIGZhY2V0VmFsdWUsXG4gIHBhcmVudFBhdGgsXG4gIGN1cnJlbnRSZWZpbmVtZW50LFxuICBoaWVyYXJjaGljYWxTZXBhcmF0b3IsXG4gIGhpZXJhcmNoaWNhbFJvb3RQYXRoLFxuICBoaWVyYXJjaGljYWxTaG93UGFyZW50TGV2ZWxcbikge1xuICAvLyB3ZSB3YW50IHRoZSBmYWNldFZhbHVlIGlzIGEgY2hpbGQgb2YgaGllcmFyY2hpY2FsUm9vdFBhdGhcbiAgaWYgKFxuICAgIGhpZXJhcmNoaWNhbFJvb3RQYXRoICYmXG4gICAgKGZhY2V0VmFsdWUuaW5kZXhPZihoaWVyYXJjaGljYWxSb290UGF0aCkgIT09IDAgfHxcbiAgICAgIGhpZXJhcmNoaWNhbFJvb3RQYXRoID09PSBmYWNldFZhbHVlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSBhbHdheXMgd2FudCByb290IGxldmVscyAob25seSB3aGVuIHRoZXJlIGlzIG5vIHByZWZpeCBwYXRoKVxuICByZXR1cm4gKFxuICAgICghaGllcmFyY2hpY2FsUm9vdFBhdGggJiZcbiAgICAgIGZhY2V0VmFsdWUuaW5kZXhPZihoaWVyYXJjaGljYWxTZXBhcmF0b3IpID09PSAtMSkgfHxcbiAgICAvLyBpZiB0aGVyZSBpcyBhIHJvb3RQYXRoLCBiZWluZyByb290IGxldmVsIG1lYW4gMSBsZXZlbCB1bmRlciByb290UGF0aFxuICAgIChoaWVyYXJjaGljYWxSb290UGF0aCAmJlxuICAgICAgZmFjZXRWYWx1ZS5zcGxpdChoaWVyYXJjaGljYWxTZXBhcmF0b3IpLmxlbmd0aCAtXG4gICAgICAgIGhpZXJhcmNoaWNhbFJvb3RQYXRoLnNwbGl0KGhpZXJhcmNoaWNhbFNlcGFyYXRvcikubGVuZ3RoID09PVxuICAgICAgICAxKSB8fFxuICAgIC8vIGlmIGN1cnJlbnQgcmVmaW5lbWVudCBpcyBhIHJvb3QgbGV2ZWwgYW5kIGN1cnJlbnQgZmFjZXRWYWx1ZSBpcyBhIHJvb3QgbGV2ZWwsXG4gICAgLy8ga2VlcCB0aGUgZmFjZXRWYWx1ZVxuICAgIChmYWNldFZhbHVlLmluZGV4T2YoaGllcmFyY2hpY2FsU2VwYXJhdG9yKSA9PT0gLTEgJiZcbiAgICAgIGN1cnJlbnRSZWZpbmVtZW50LmluZGV4T2YoaGllcmFyY2hpY2FsU2VwYXJhdG9yKSA9PT0gLTEpIHx8XG4gICAgLy8gY3VycmVudFJlZmluZW1lbnQgaXMgYSBjaGlsZCBvZiB0aGUgZmFjZXQgdmFsdWVcbiAgICBjdXJyZW50UmVmaW5lbWVudC5pbmRleE9mKGZhY2V0VmFsdWUpID09PSAwIHx8XG4gICAgLy8gZmFjZXRWYWx1ZSBpcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IHBhcmVudCwgYWRkIGl0XG4gICAgKGZhY2V0VmFsdWUuaW5kZXhPZihwYXJlbnRQYXRoICsgaGllcmFyY2hpY2FsU2VwYXJhdG9yKSA9PT0gMCAmJlxuICAgICAgKGhpZXJhcmNoaWNhbFNob3dQYXJlbnRMZXZlbCB8fFxuICAgICAgICBmYWNldFZhbHVlLmluZGV4T2YoY3VycmVudFJlZmluZW1lbnQpID09PSAwKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KFxuICBmYWNldENvdW50LFxuICBmYWNldFZhbHVlLFxuICBoaWVyYXJjaGljYWxTZXBhcmF0b3IsXG4gIGN1cnJlbnRSZWZpbmVtZW50LFxuICBleGhhdXN0aXZlXG4pIHtcbiAgdmFyIHBhcnRzID0gZmFjZXRWYWx1ZS5zcGxpdChoaWVyYXJjaGljYWxTZXBhcmF0b3IpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRyaW0oKSxcbiAgICBwYXRoOiBmYWNldFZhbHVlLFxuICAgIGNvdW50OiBmYWNldENvdW50LFxuICAgIGlzUmVmaW5lZDpcbiAgICAgIGN1cnJlbnRSZWZpbmVtZW50ID09PSBmYWNldFZhbHVlIHx8XG4gICAgICBjdXJyZW50UmVmaW5lbWVudC5pbmRleE9mKGZhY2V0VmFsdWUgKyBoaWVyYXJjaGljYWxTZXBhcmF0b3IpID09PSAwLFxuICAgIGV4aGF1c3RpdmU6IGV4aGF1c3RpdmUsXG4gICAgZGF0YTogbnVsbFxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbWVyZ2UnKTtcbnZhciBkZWZhdWx0c1B1cmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZGVmYXVsdHNQdXJlJyk7XG52YXIgb3JkZXJCeSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9vcmRlckJ5Jyk7XG52YXIgY29tcGFjdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYWN0Jyk7XG52YXIgZmluZCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9maW5kJyk7XG52YXIgZmluZEluZGV4ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2ZpbmRJbmRleCcpO1xudmFyIGZvcm1hdFNvcnQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZm9ybWF0U29ydCcpO1xuXG52YXIgZ2VuZXJhdGVIaWVyYXJjaGljYWxUcmVlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZS1oaWVyYXJjaGljYWwtdHJlZScpO1xuXG4vKipcbiAqIEB0eXBlZGVmIFNlYXJjaFJlc3VsdHMuRmFjZXRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgaW4gdGhlIHJlY29yZFxuICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGEgdGhlIGZhY2V0aW5nIGRhdGE6IHZhbHVlLCBudW1iZXIgb2YgZW50cmllc1xuICogQHByb3BlcnR5IHtvYmplY3R9IHN0YXRzIHVuZGVmaW5lZCB1bmxlc3MgZmFjZXRfc3RhdHMgaXMgcmV0cmlldmVkIGZyb20gYWxnb2xpYVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgU2VhcmNoUmVzdWx0cy5IaWVyYXJjaGljYWxGYWNldFxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGN1cnJlbnQgdmFsdWUgZ2l2ZW4gdGhlIGhpZXJhcmNoaWNhbCBsZXZlbCwgdHJpbW1lZC5cbiAqIElmIHJvb3Qgbm9kZSwgeW91IGdldCB0aGUgZmFjZXQgbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvdW50IG51bWJlciBvZiBvYmplY3RzIG1hdGNoaW5nIHRoaXMgaGllcmFyY2hpY2FsIHZhbHVlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aCB0aGUgY3VycmVudCBoaWVyYXJjaGljYWwgdmFsdWUgZnVsbCBwYXRoXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzUmVmaW5lZCBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgdmFsdWUgd2FzIHJlZmluZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAcHJvcGVydHkge0hpZXJhcmNoaWNhbEZhY2V0W119IGRhdGEgc3ViIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgbGV2ZWxcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFNlYXJjaFJlc3VsdHMuRmFjZXRWYWx1ZVxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIHRoZSBmYWNldCB2YWx1ZSBpdHNlbGZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb3VudCB0aW1lcyB0aGlzIGZhY2V0IGFwcGVhcnMgaW4gdGhlIHJlc3VsdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNSZWZpbmVkIGlzIHRoZSBmYWNldCBjdXJyZW50bHkgc2VsZWN0ZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFeGNsdWRlZCBpcyB0aGUgZmFjZXQgY3VycmVudGx5IGV4Y2x1ZGVkIChvbmx5IGZvciBjb25qdW5jdGl2ZSBmYWNldHMpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBSZWZpbmVtZW50XG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZmlsdGVyIHVzZWQ6XG4gKiBgbnVtZXJpY2AsIGBmYWNldGAsIGBleGNsdWRlYCwgYGRpc2p1bmN0aXZlYCwgYGhpZXJhcmNoaWNhbGBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIGZvciBmaWx0ZXJpbmdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIHRoZSB2YWx1ZSBvZiB0aGUgZmlsdGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtZXJpY1ZhbHVlIHRoZSB2YWx1ZSBhcyBhIG51bWJlci4gT25seSBmb3IgbnVtZXJpYyBmaWx0ZXJzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBvcGVyYXRvciB1c2VkLiBPbmx5IGZvciBudW1lcmljIGZpbHRlcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY291bnQgdGhlIG51bWJlciBvZiBjb21wdXRlZCBoaXRzIGZvciB0aGlzIGZpbHRlci4gT25seSBvbiBmYWNldHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGV4aGF1c3RpdmUgaWYgdGhlIGNvdW50IGlzIGV4aGF1c3RpdmVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0SW5kaWNlcyhhdHRyaWJ1dGVzKSB7XG4gIHZhciBpbmRpY2VzID0ge307XG5cbiAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaW5kaWNlc1t2YWxdID0gaWR4O1xuICB9KTtcblxuICByZXR1cm4gaW5kaWNlcztcbn1cblxuZnVuY3Rpb24gYXNzaWduRmFjZXRTdGF0cyhkZXN0LCBmYWNldFN0YXRzLCBrZXkpIHtcbiAgaWYgKGZhY2V0U3RhdHMgJiYgZmFjZXRTdGF0c1trZXldKSB7XG4gICAgZGVzdC5zdGF0cyA9IGZhY2V0U3RhdHNba2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEhpZXJhcmNoaWNhbEZhY2V0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gYXR0cmlidXRlc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtIaWVyYXJjaGljYWxGYWNldFtdfSBoaWVyYXJjaGljYWxGYWNldHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBoaWVyYXJjaGljYWxBdHRyaWJ1dGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ0hpZXJhcmNoaWNhbEZhY2V0RnJvbUF0dHJpYnV0ZU5hbWUoXG4gIGhpZXJhcmNoaWNhbEZhY2V0cyxcbiAgaGllcmFyY2hpY2FsQXR0cmlidXRlTmFtZVxuKSB7XG4gIHJldHVybiBmaW5kKGhpZXJhcmNoaWNhbEZhY2V0cywgZnVuY3Rpb24gZmFjZXRLZXlNYXRjaGVzQXR0cmlidXRlKFxuICAgIGhpZXJhcmNoaWNhbEZhY2V0XG4gICkge1xuICAgIHZhciBmYWNldE5hbWVzID0gaGllcmFyY2hpY2FsRmFjZXQuYXR0cmlidXRlcyB8fCBbXTtcbiAgICByZXR1cm4gZmFjZXROYW1lcy5pbmRleE9mKGhpZXJhcmNoaWNhbEF0dHJpYnV0ZU5hbWUpID4gLTE7XG4gIH0pO1xufVxuXG4vKmVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIENvbnN0cnVjdG9yIGZvciBTZWFyY2hSZXN1bHRzXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgU2VhcmNoUmVzdWx0cyBjb250YWlucyB0aGUgcmVzdWx0cyBvZiBhIHF1ZXJ5IHRvIEFsZ29saWEgdXNpbmcgdGhlXG4gKiB7QGxpbmsgQWxnb2xpYVNlYXJjaEhlbHBlcn0uXG4gKiBAcGFyYW0ge1NlYXJjaFBhcmFtZXRlcnN9IHN0YXRlIHN0YXRlIHRoYXQgbGVkIHRvIHRoZSByZXNwb25zZVxuICogQHBhcmFtIHthcnJheS48b2JqZWN0Pn0gcmVzdWx0cyB0aGUgcmVzdWx0cyBmcm9tIGFsZ29saWEgY2xpZW50XG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZWFyY2hSZXN1bHRzIG9mIHRoZSBmaXJzdCBxdWVyeSBpblxuICogPGEgaHJlZj1cImh0dHA6Ly9kZW1vcy5hbGdvbGlhLmNvbS9pbnN0YW50LXNlYXJjaC1kZW1vXCI+dGhlIGluc3RhbnQgc2VhcmNoIGRlbW88L2E+PC9jYXB0aW9uPlxue1xuICAgXCJoaXRzUGVyUGFnZVwiOiAxMCxcbiAgIFwicHJvY2Vzc2luZ1RpbWVNU1wiOiAyLFxuICAgXCJmYWNldHNcIjogW1xuICAgICAge1xuICAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiSGFyZEdvb2RcIjogNjYyNyxcbiAgICAgICAgICAgIFwiQmxhY2tUaWVcIjogNTUwLFxuICAgICAgICAgICAgXCJNdXNpY1wiOiA2NjUsXG4gICAgICAgICAgICBcIlNvZnR3YXJlXCI6IDEzMSxcbiAgICAgICAgICAgIFwiR2FtZVwiOiA0NTYsXG4gICAgICAgICAgICBcIk1vdmllXCI6IDE1NzFcbiAgICAgICAgIH0sXG4gICAgICAgICBcImV4aGF1c3RpdmVcIjogZmFsc2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgICBcImV4aGF1c3RpdmVcIjogZmFsc2UsXG4gICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCJGcmVlIHNoaXBwaW5nXCI6IDU1MDdcbiAgICAgICAgIH0sXG4gICAgICAgICBcIm5hbWVcIjogXCJzaGlwcGluZ1wiXG4gICAgICB9XG4gIF0sXG4gICBcImhpdHNcIjogW1xuICAgICAge1xuICAgICAgICAgXCJ0aHVtYm5haWxJbWFnZVwiOiBcImh0dHA6Ly9pbWcuYmJ5c3RhdGljLmNvbS9CZXN0QnV5X1VTL2ltYWdlcy9wcm9kdWN0cy8xNjg4LzE2ODg4MzJfNTR4MTA4X3MuZ2lmXCIsXG4gICAgICAgICBcIl9oaWdobGlnaHRSZXN1bHRcIjoge1xuICAgICAgICAgICAgXCJzaG9ydERlc2NyaXB0aW9uXCI6IHtcbiAgICAgICAgICAgICAgIFwibWF0Y2hMZXZlbFwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJTYWZlZ3VhcmQgeW91ciBQQywgTWFjLCBBbmRyb2lkIGFuZCBpT1MgZGV2aWNlcyB3aXRoIGNvbXByZWhlbnNpdmUgSW50ZXJuZXQgcHJvdGVjdGlvblwiLFxuICAgICAgICAgICAgICAgXCJtYXRjaGVkV29yZHNcIjogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNhdGVnb3J5XCI6IHtcbiAgICAgICAgICAgICAgIFwibWF0Y2hMZXZlbFwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJDb21wdXRlciBTZWN1cml0eSBTb2Z0d2FyZVwiLFxuICAgICAgICAgICAgICAgXCJtYXRjaGVkV29yZHNcIjogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm1hbnVmYWN0dXJlclwiOiB7XG4gICAgICAgICAgICAgICBcIm1hdGNoZWRXb3Jkc1wiOiBbXSxcbiAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJXZWJyb290XCIsXG4gICAgICAgICAgICAgICBcIm1hdGNoTGV2ZWxcIjogXCJub25lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIm5hbWVcIjoge1xuICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIldlYnJvb3QgU2VjdXJlQW55d2hlcmUgSW50ZXJuZXQgU2VjdXJpdHkgKDMtRGV2aWNlKSAoMS1ZZWFyIFN1YnNjcmlwdGlvbikgLSBNYWMvV2luZG93c1wiLFxuICAgICAgICAgICAgICAgXCJtYXRjaGVkV29yZHNcIjogW10sXG4gICAgICAgICAgICAgICBcIm1hdGNoTGV2ZWxcIjogXCJub25lXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0sXG4gICAgICAgICBcImltYWdlXCI6IFwiaHR0cDovL2ltZy5iYnlzdGF0aWMuY29tL0Jlc3RCdXlfVVMvaW1hZ2VzL3Byb2R1Y3RzLzE2ODgvMTY4ODgzMl8xMDV4MjEwX3NjLmpwZ1wiLFxuICAgICAgICAgXCJzaGlwcGluZ1wiOiBcIkZyZWUgc2hpcHBpbmdcIixcbiAgICAgICAgIFwiYmVzdFNlbGxpbmdSYW5rXCI6IDQsXG4gICAgICAgICBcInNob3J0RGVzY3JpcHRpb25cIjogXCJTYWZlZ3VhcmQgeW91ciBQQywgTWFjLCBBbmRyb2lkIGFuZCBpT1MgZGV2aWNlcyB3aXRoIGNvbXByZWhlbnNpdmUgSW50ZXJuZXQgcHJvdGVjdGlvblwiLFxuICAgICAgICAgXCJ1cmxcIjogXCJodHRwOi8vd3d3LmJlc3RidXkuY29tL3NpdGUvd2Vicm9vdC1zZWN1cmVhbnl3aGVyZS1pbnRlcm5ldC1zZWN1cml0eS0zLWRldmnigKZkPTEyMTkwNjA2ODc5Njkmc2t1SWQ9MTY4ODgzMiZjbXA9Uk1YJmt5PTJkM0dmRW1OSXpqQTB2a3p2ZUhkWkVCZ3BQQ3lNbkxUSlwiLFxuICAgICAgICAgXCJuYW1lXCI6IFwiV2Vicm9vdCBTZWN1cmVBbnl3aGVyZSBJbnRlcm5ldCBTZWN1cml0eSAoMy1EZXZpY2UpICgxLVllYXIgU3Vic2NyaXB0aW9uKSAtIE1hYy9XaW5kb3dzXCIsXG4gICAgICAgICBcImNhdGVnb3J5XCI6IFwiQ29tcHV0ZXIgU2VjdXJpdHkgU29mdHdhcmVcIixcbiAgICAgICAgIFwic2FsZVByaWNlX3JhbmdlXCI6IFwiMSAtIDUwXCIsXG4gICAgICAgICBcIm9iamVjdElEXCI6IFwiMTY4ODgzMlwiLFxuICAgICAgICAgXCJ0eXBlXCI6IFwiU29mdHdhcmVcIixcbiAgICAgICAgIFwiY3VzdG9tZXJSZXZpZXdDb3VudFwiOiA1OTgwLFxuICAgICAgICAgXCJzYWxlUHJpY2VcIjogNDkuOTksXG4gICAgICAgICBcIm1hbnVmYWN0dXJlclwiOiBcIldlYnJvb3RcIlxuICAgICAgfSxcbiAgICAgIC4uLi5cbiAgXSxcbiAgIFwibmJIaXRzXCI6IDEwMDAwLFxuICAgXCJkaXNqdW5jdGl2ZUZhY2V0c1wiOiBbXG4gICAgICB7XG4gICAgICAgICBcImV4aGF1c3RpdmVcIjogZmFsc2UsXG4gICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgXCI1XCI6IDE4MyxcbiAgICAgICAgICAgIFwiMTJcIjogMTEyLFxuICAgICAgICAgICAgXCI3XCI6IDE0OSxcbiAgICAgICAgICAgIC4uLlxuICAgICAgICAgfSxcbiAgICAgICAgIFwibmFtZVwiOiBcImN1c3RvbWVyUmV2aWV3Q291bnRcIixcbiAgICAgICAgIFwic3RhdHNcIjoge1xuICAgICAgICAgICAgXCJtYXhcIjogNzQ2MSxcbiAgICAgICAgICAgIFwiYXZnXCI6IDE1Ny45MzksXG4gICAgICAgICAgICBcIm1pblwiOiAxXG4gICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIFwiUHJpbnRlciBJbmtcIjogMTQyLFxuICAgICAgICAgICAgXCJXaXJlbGVzcyBTcGVha2Vyc1wiOiA2MCxcbiAgICAgICAgICAgIFwiUG9pbnQgJiBTaG9vdCBDYW1lcmFzXCI6IDQ4LFxuICAgICAgICAgICAgLi4uXG4gICAgICAgICB9LFxuICAgICAgICAgXCJuYW1lXCI6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgIFwiZXhoYXVzdGl2ZVwiOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgIFwiZXhoYXVzdGl2ZVwiOiBmYWxzZSxcbiAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcIj4gNTAwMFwiOiAyLFxuICAgICAgICAgICAgXCIxIC0gNTBcIjogNjUyNCxcbiAgICAgICAgICAgIFwiNTAxIC0gMjAwMFwiOiA1NjYsXG4gICAgICAgICAgICBcIjIwMSAtIDUwMFwiOiAxNTAxLFxuICAgICAgICAgICAgXCIxMDEgLSAyMDBcIjogMTM2MCxcbiAgICAgICAgICAgIFwiMjAwMSAtIDUwMDBcIjogNDdcbiAgICAgICAgIH0sXG4gICAgICAgICBcIm5hbWVcIjogXCJzYWxlUHJpY2VfcmFuZ2VcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICBcIkR5bmV44oSiXCI6IDIwMixcbiAgICAgICAgICAgIFwiSW5zaWduaWHihKJcIjogMjMwLFxuICAgICAgICAgICAgXCJQTllcIjogNzIsXG4gICAgICAgICAgICAuLi5cbiAgICAgICAgIH0sXG4gICAgICAgICBcIm5hbWVcIjogXCJtYW51ZmFjdHVyZXJcIixcbiAgICAgICAgIFwiZXhoYXVzdGl2ZVwiOiBmYWxzZVxuICAgICAgfVxuICBdLFxuICAgXCJxdWVyeVwiOiBcIlwiLFxuICAgXCJuYlBhZ2VzXCI6IDEwMCxcbiAgIFwicGFnZVwiOiAwLFxuICAgXCJpbmRleFwiOiBcImJlc3RidXlcIlxufVxuICoqL1xuLyplc2xpbnQtZW5hYmxlICovXG5mdW5jdGlvbiBTZWFyY2hSZXN1bHRzKHN0YXRlLCByZXN1bHRzKSB7XG4gIHZhciBtYWluU3ViUmVzcG9uc2UgPSByZXN1bHRzWzBdO1xuXG4gIHRoaXMuX3Jhd1Jlc3VsdHMgPSByZXN1bHRzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvYXBpLXJlZmVyZW5jZS9hcGktbWV0aG9kcy9zZWFyY2gvI3Jlc3BvbnNlXG4gIE9iamVjdC5rZXlzKG1haW5TdWJSZXNwb25zZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBzZWxmW2tleV0gPSBtYWluU3ViUmVzcG9uc2Vba2V5XTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIHF1ZXJ5IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHJlc3VsdHNcbiAgICogQG5hbWUgcXVlcnlcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBUaGUgcXVlcnkgYXMgcGFyc2VkIGJ5IHRoZSBlbmdpbmUgZ2l2ZW4gYWxsIHRoZSBydWxlcy5cbiAgICogQG5hbWUgcGFyc2VkUXVlcnlcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBhbGwgdGhlIHJlY29yZHMgdGhhdCBtYXRjaCB0aGUgc2VhcmNoIHBhcmFtZXRlcnMuIEVhY2ggcmVjb3JkIGlzXG4gICAqIGF1Z21lbnRlZCB3aXRoIGEgbmV3IGF0dHJpYnV0ZSBgX2hpZ2hsaWdodFJlc3VsdGBcbiAgICogd2hpY2ggaXMgYW4gb2JqZWN0IGtleWVkIGJ5IGF0dHJpYnV0ZSBhbmQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAtIGB2YWx1ZWAgOiB0aGUgdmFsdWUgb2YgdGhlIGZhY2V0IGhpZ2hsaWdodGVkIChodG1sKVxuICAgKiAgLSBgbWF0Y2hMZXZlbGA6IGZ1bGwsIHBhcnRpYWwgb3Igbm9uZSBkZXBlbmRpbmcgb24gaG93IHRoZSBxdWVyeSB0ZXJtcyBtYXRjaFxuICAgKiBAbmFtZSBoaXRzXG4gICAqIEBtZW1iZXIge29iamVjdFtdfVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBpbmRleCB3aGVyZSB0aGUgcmVzdWx0cyBjb21lIGZyb21cbiAgICogQG5hbWUgaW5kZXhcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBudW1iZXIgb2YgaGl0cyBwZXIgcGFnZSByZXF1ZXN0ZWRcbiAgICogQG5hbWUgaGl0c1BlclBhZ2VcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiB0b3RhbCBudW1iZXIgb2YgaGl0cyBvZiB0aGlzIHF1ZXJ5IG9uIHRoZSBpbmRleFxuICAgKiBAbmFtZSBuYkhpdHNcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiB0b3RhbCBudW1iZXIgb2YgcGFnZXMgd2l0aCByZXNwZWN0IHRvIHRoZSBudW1iZXIgb2YgaGl0cyBwZXIgcGFnZSBhbmQgdGhlIHRvdGFsIG51bWJlciBvZiBoaXRzXG4gICAqIEBuYW1lIG5iUGFnZXNcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBjdXJyZW50IHBhZ2VcbiAgICogQG5hbWUgcGFnZVxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBTZWFyY2hSZXN1bHRzXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBpZiB0aGUgcG9zaXRpb24gd2FzIGd1ZXNzZWQgYnkgSVAuXG4gICAqIEBuYW1lIGFyb3VuZExhdExuZ1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTZWFyY2hSZXN1bHRzXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBcIjQ4Ljg2MzcsMi4zNjE1XCIsXG4gICAqL1xuICAvKipcbiAgICogVGhlIHJhZGl1cyBjb21wdXRlZCBieSBBbGdvbGlhLlxuICAgKiBAbmFtZSBhdXRvbWF0aWNSYWRpdXNcbiAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgXCIxMjY3OTI5MjJcIixcbiAgICovXG4gIC8qKlxuICAgKiBTdHJpbmcgaWRlbnRpZnlpbmcgdGhlIHNlcnZlciB1c2VkIHRvIHNlcnZlIHRoaXMgcmVxdWVzdC5cbiAgICpcbiAgICogZ2V0UmFua2luZ0luZm8gbmVlZHMgdG8gYmUgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyB0byBiZSByZXR1cm5lZFxuICAgKlxuICAgKiBAbmFtZSBzZXJ2ZXJVc2VkXG4gICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIFNlYXJjaFJlc3VsdHNcbiAgICogQGluc3RhbmNlXG4gICAqIEBleGFtcGxlIFwiYzctdXNlLTIuYWxnb2xpYS5uZXRcIixcbiAgICovXG4gIC8qKlxuICAgKiBCb29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgY291bnRzIGRpZCB0aW1lIG91dC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQG5hbWUgdGltZW91dENvdW50c1xuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBCb29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgaGl0cyBkaWQgdGltZSBvdXQuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBuYW1lIHRpbWVvdXRIaXRzXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBTZWFyY2hSZXN1bHRzXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIGNvdW50cyBvZiB0aGUgZmFjZXRzIGlzIGV4aGF1c3RpdmVcbiAgICogQG5hbWUgZXhoYXVzdGl2ZUZhY2V0c0NvdW50XG4gICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAqIEBtZW1iZXJvZiBTZWFyY2hSZXN1bHRzXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIG51bWJlciBvZiBoaXRzIGlzIGV4aGF1c3RpdmVcbiAgICogQG5hbWUgZXhoYXVzdGl2ZU5iSGl0c1xuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2YgU2VhcmNoUmVzdWx0c1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBDb250YWlucyB0aGUgdXNlckRhdGEgaWYgdGhleSBhcmUgc2V0IGJ5IGEgW3F1ZXJ5IHJ1bGVdKGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9ndWlkZXMvcXVlcnktcnVsZXMvcXVlcnktcnVsZXMtb3ZlcnZpZXcvKS5cbiAgICogQG5hbWUgdXNlckRhdGFcbiAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAqIEBtZW1iZXJvZiBTZWFyY2hSZXN1bHRzXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIHF1ZXJ5SUQgaXMgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBxdWVyeSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjdXJyZW50IHNlYXJjaCByZXN1bHRzLlxuICAgKiBUaGlzIHZhbHVlIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHRoZSBgY2xpY2tBbmFseXRpY3NgIHNlYXJjaCBwYXJhbWV0ZXIgaXMgc2V0IHRvIGB0cnVlYC5cbiAgICogQG5hbWUgcXVlcnlJRFxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBTZWFyY2hSZXN1bHRzXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxuICAvKipcbiAgICogc3VtIG9mIHRoZSBwcm9jZXNzaW5nIHRpbWUgb2YgYWxsIHRoZSBxdWVyaWVzXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIHRoaXMucHJvY2Vzc2luZ1RpbWVNUyA9IHJlc3VsdHMucmVkdWNlKGZ1bmN0aW9uKHN1bSwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5wcm9jZXNzaW5nVGltZU1TID09PSB1bmRlZmluZWRcbiAgICAgID8gc3VtXG4gICAgICA6IHN1bSArIHJlc3VsdC5wcm9jZXNzaW5nVGltZU1TO1xuICB9LCAwKTtcblxuICAvKipcbiAgICogZGlzanVuY3RpdmUgZmFjZXRzIHJlc3VsdHNcbiAgICogQG1lbWJlciB7U2VhcmNoUmVzdWx0cy5GYWNldFtdfVxuICAgKi9cbiAgdGhpcy5kaXNqdW5jdGl2ZUZhY2V0cyA9IFtdO1xuICAvKipcbiAgICogZGlzanVuY3RpdmUgZmFjZXRzIHJlc3VsdHNcbiAgICogQG1lbWJlciB7U2VhcmNoUmVzdWx0cy5IaWVyYXJjaGljYWxGYWNldFtdfVxuICAgKi9cbiAgdGhpcy5oaWVyYXJjaGljYWxGYWNldHMgPSBzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHMubWFwKGZ1bmN0aW9uIGluaXRGdXR1cmVUcmVlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG4gIC8qKlxuICAgKiBvdGhlciBmYWNldHMgcmVzdWx0c1xuICAgKiBAbWVtYmVyIHtTZWFyY2hSZXN1bHRzLkZhY2V0W119XG4gICAqL1xuICB0aGlzLmZhY2V0cyA9IFtdO1xuXG4gIHZhciBkaXNqdW5jdGl2ZUZhY2V0cyA9IHN0YXRlLmdldFJlZmluZWREaXNqdW5jdGl2ZUZhY2V0cygpO1xuXG4gIHZhciBmYWNldHNJbmRpY2VzID0gZ2V0SW5kaWNlcyhzdGF0ZS5mYWNldHMpO1xuICB2YXIgZGlzanVuY3RpdmVGYWNldHNJbmRpY2VzID0gZ2V0SW5kaWNlcyhzdGF0ZS5kaXNqdW5jdGl2ZUZhY2V0cyk7XG4gIHZhciBuZXh0RGlzanVuY3RpdmVSZXN1bHQgPSAxO1xuXG4gIC8vIFNpbmNlIHdlIHNlbmQgcmVxdWVzdCBvbmx5IGZvciBkaXNqdW5jdGl2ZSBmYWNldHMgdGhhdCBoYXZlIGJlZW4gcmVmaW5lZCxcbiAgLy8gd2UgZ2V0IHRoZSBmYWNldHMgaW5mb3JtYXRpb24gZnJvbSB0aGUgZmlyc3QsIGdlbmVyYWwsIHJlc3BvbnNlLlxuXG4gIHZhciBtYWluRmFjZXRzID0gbWFpblN1YlJlc3BvbnNlLmZhY2V0cyB8fCB7fTtcblxuICBPYmplY3Qua2V5cyhtYWluRmFjZXRzKS5mb3JFYWNoKGZ1bmN0aW9uKGZhY2V0S2V5KSB7XG4gICAgdmFyIGZhY2V0VmFsdWVPYmplY3QgPSBtYWluRmFjZXRzW2ZhY2V0S2V5XTtcblxuICAgIHZhciBoaWVyYXJjaGljYWxGYWNldCA9IGZpbmRNYXRjaGluZ0hpZXJhcmNoaWNhbEZhY2V0RnJvbUF0dHJpYnV0ZU5hbWUoXG4gICAgICBzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHMsXG4gICAgICBmYWNldEtleVxuICAgICk7XG5cbiAgICBpZiAoaGllcmFyY2hpY2FsRmFjZXQpIHtcbiAgICAgIC8vIFBsYWNlIHRoZSBoaWVyYXJjaGljYWxGYWNldCBkYXRhIGF0IHRoZSBjb3JyZWN0IGluZGV4IGRlcGVuZGluZyBvblxuICAgICAgLy8gdGhlIGF0dHJpYnV0ZXMgb3JkZXIgdGhhdCB3YXMgZGVmaW5lZCBhdCB0aGUgaGVscGVyIGluaXRpYWxpemF0aW9uXG4gICAgICB2YXIgZmFjZXRJbmRleCA9IGhpZXJhcmNoaWNhbEZhY2V0LmF0dHJpYnV0ZXMuaW5kZXhPZihmYWNldEtleSk7XG4gICAgICB2YXIgaWR4QXR0cmlidXRlTmFtZSA9IGZpbmRJbmRleChzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHMsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGYubmFtZSA9PT0gaGllcmFyY2hpY2FsRmFjZXQubmFtZTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5oaWVyYXJjaGljYWxGYWNldHNbaWR4QXR0cmlidXRlTmFtZV1bZmFjZXRJbmRleF0gPSB7XG4gICAgICAgIGF0dHJpYnV0ZTogZmFjZXRLZXksXG4gICAgICAgIGRhdGE6IGZhY2V0VmFsdWVPYmplY3QsXG4gICAgICAgIGV4aGF1c3RpdmU6IG1haW5TdWJSZXNwb25zZS5leGhhdXN0aXZlRmFjZXRzQ291bnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc0ZhY2V0RGlzanVuY3RpdmUgPSBzdGF0ZS5kaXNqdW5jdGl2ZUZhY2V0cy5pbmRleE9mKGZhY2V0S2V5KSAhPT0gLTE7XG4gICAgICB2YXIgaXNGYWNldENvbmp1bmN0aXZlID0gc3RhdGUuZmFjZXRzLmluZGV4T2YoZmFjZXRLZXkpICE9PSAtMTtcbiAgICAgIHZhciBwb3NpdGlvbjtcblxuICAgICAgaWYgKGlzRmFjZXREaXNqdW5jdGl2ZSkge1xuICAgICAgICBwb3NpdGlvbiA9IGRpc2p1bmN0aXZlRmFjZXRzSW5kaWNlc1tmYWNldEtleV07XG4gICAgICAgIHNlbGYuZGlzanVuY3RpdmVGYWNldHNbcG9zaXRpb25dID0ge1xuICAgICAgICAgIG5hbWU6IGZhY2V0S2V5LFxuICAgICAgICAgIGRhdGE6IGZhY2V0VmFsdWVPYmplY3QsXG4gICAgICAgICAgZXhoYXVzdGl2ZTogbWFpblN1YlJlc3BvbnNlLmV4aGF1c3RpdmVGYWNldHNDb3VudFxuICAgICAgICB9O1xuICAgICAgICBhc3NpZ25GYWNldFN0YXRzKHNlbGYuZGlzanVuY3RpdmVGYWNldHNbcG9zaXRpb25dLCBtYWluU3ViUmVzcG9uc2UuZmFjZXRzX3N0YXRzLCBmYWNldEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNGYWNldENvbmp1bmN0aXZlKSB7XG4gICAgICAgIHBvc2l0aW9uID0gZmFjZXRzSW5kaWNlc1tmYWNldEtleV07XG4gICAgICAgIHNlbGYuZmFjZXRzW3Bvc2l0aW9uXSA9IHtcbiAgICAgICAgICBuYW1lOiBmYWNldEtleSxcbiAgICAgICAgICBkYXRhOiBmYWNldFZhbHVlT2JqZWN0LFxuICAgICAgICAgIGV4aGF1c3RpdmU6IG1haW5TdWJSZXNwb25zZS5leGhhdXN0aXZlRmFjZXRzQ291bnRcbiAgICAgICAgfTtcbiAgICAgICAgYXNzaWduRmFjZXRTdGF0cyhzZWxmLmZhY2V0c1twb3NpdGlvbl0sIG1haW5TdWJSZXNwb25zZS5mYWNldHNfc3RhdHMsIGZhY2V0S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBkbyBub3Qga2VlcCBob2xlcyB3aXRoaW4gdGhlIGhpZXJhcmNoaWNhbCBmYWNldHNcbiAgdGhpcy5oaWVyYXJjaGljYWxGYWNldHMgPSBjb21wYWN0KHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzKTtcblxuICAvLyBhZ2dyZWdhdGUgdGhlIHJlZmluZWQgZGlzanVuY3RpdmUgZmFjZXRzXG4gIGRpc2p1bmN0aXZlRmFjZXRzLmZvckVhY2goZnVuY3Rpb24oZGlzanVuY3RpdmVGYWNldCkge1xuICAgIHZhciByZXN1bHQgPSByZXN1bHRzW25leHREaXNqdW5jdGl2ZVJlc3VsdF07XG4gICAgdmFyIGZhY2V0cyA9IHJlc3VsdCAmJiByZXN1bHQuZmFjZXRzID8gcmVzdWx0LmZhY2V0cyA6IHt9O1xuICAgIHZhciBoaWVyYXJjaGljYWxGYWNldCA9IHN0YXRlLmdldEhpZXJhcmNoaWNhbEZhY2V0QnlOYW1lKGRpc2p1bmN0aXZlRmFjZXQpO1xuXG4gICAgLy8gVGhlcmUgc2hvdWxkIGJlIG9ubHkgaXRlbSBpbiBmYWNldHMuXG4gICAgT2JqZWN0LmtleXMoZmFjZXRzKS5mb3JFYWNoKGZ1bmN0aW9uKGRmYWNldCkge1xuICAgICAgdmFyIGZhY2V0UmVzdWx0cyA9IGZhY2V0c1tkZmFjZXRdO1xuXG4gICAgICB2YXIgcG9zaXRpb247XG5cbiAgICAgIGlmIChoaWVyYXJjaGljYWxGYWNldCkge1xuICAgICAgICBwb3NpdGlvbiA9IGZpbmRJbmRleChzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHMsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZi5uYW1lID09PSBoaWVyYXJjaGljYWxGYWNldC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZUluZGV4ID0gZmluZEluZGV4KHNlbGYuaGllcmFyY2hpY2FsRmFjZXRzW3Bvc2l0aW9uXSwgZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiBmLmF0dHJpYnV0ZSA9PT0gZGZhY2V0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBwcmV2aW91cyByZWZpbmVtZW50cyBhbmQgbm8gcmVzdWx0cyBzbyBub3QgYWJsZSB0byBmaW5kIGl0XG4gICAgICAgIGlmIChhdHRyaWJ1dGVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmhpZXJhcmNoaWNhbEZhY2V0c1twb3NpdGlvbl1bYXR0cmlidXRlSW5kZXhdLmRhdGEgPSBtZXJnZShcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzZWxmLmhpZXJhcmNoaWNhbEZhY2V0c1twb3NpdGlvbl1bYXR0cmlidXRlSW5kZXhdLmRhdGEsXG4gICAgICAgICAgZmFjZXRSZXN1bHRzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbiA9IGRpc2p1bmN0aXZlRmFjZXRzSW5kaWNlc1tkZmFjZXRdO1xuXG4gICAgICAgIHZhciBkYXRhRnJvbU1haW5SZXF1ZXN0ID0gbWFpblN1YlJlc3BvbnNlLmZhY2V0cyAmJiBtYWluU3ViUmVzcG9uc2UuZmFjZXRzW2RmYWNldF0gfHwge307XG5cbiAgICAgICAgc2VsZi5kaXNqdW5jdGl2ZUZhY2V0c1twb3NpdGlvbl0gPSB7XG4gICAgICAgICAgbmFtZTogZGZhY2V0LFxuICAgICAgICAgIGRhdGE6IGRlZmF1bHRzUHVyZSh7fSwgZmFjZXRSZXN1bHRzLCBkYXRhRnJvbU1haW5SZXF1ZXN0KSxcbiAgICAgICAgICBleGhhdXN0aXZlOiByZXN1bHQuZXhoYXVzdGl2ZUZhY2V0c0NvdW50XG4gICAgICAgIH07XG4gICAgICAgIGFzc2lnbkZhY2V0U3RhdHMoc2VsZi5kaXNqdW5jdGl2ZUZhY2V0c1twb3NpdGlvbl0sIHJlc3VsdC5mYWNldHNfc3RhdHMsIGRmYWNldCk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHNbZGZhY2V0XSkge1xuICAgICAgICAgIHN0YXRlLmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHNbZGZhY2V0XS5mb3JFYWNoKGZ1bmN0aW9uKHJlZmluZW1lbnRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBkaXNqdW5jdGl2ZSByZWZpbmVtZW50cyBpZiBpdCBpcyBubyBtb3JlIHJldHJpZXZlZFxuICAgICAgICAgICAgaWYgKCFzZWxmLmRpc2p1bmN0aXZlRmFjZXRzW3Bvc2l0aW9uXS5kYXRhW3JlZmluZW1lbnRWYWx1ZV0gJiZcbiAgICAgICAgICAgICAgc3RhdGUuZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50c1tkZmFjZXRdLmluZGV4T2YocmVmaW5lbWVudFZhbHVlKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGlzanVuY3RpdmVGYWNldHNbcG9zaXRpb25dLmRhdGFbcmVmaW5lbWVudFZhbHVlXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBuZXh0RGlzanVuY3RpdmVSZXN1bHQrKztcbiAgfSk7XG5cbiAgLy8gaWYgd2UgaGF2ZSBzb21lIHJvb3QgbGV2ZWwgdmFsdWVzIGZvciBoaWVyYXJjaGljYWwgZmFjZXRzLCBtZXJnZSB0aGVtXG4gIHN0YXRlLmdldFJlZmluZWRIaWVyYXJjaGljYWxGYWNldHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHJlZmluZWRGYWNldCkge1xuICAgIHZhciBoaWVyYXJjaGljYWxGYWNldCA9IHN0YXRlLmdldEhpZXJhcmNoaWNhbEZhY2V0QnlOYW1lKHJlZmluZWRGYWNldCk7XG4gICAgdmFyIHNlcGFyYXRvciA9IHN0YXRlLl9nZXRIaWVyYXJjaGljYWxGYWNldFNlcGFyYXRvcihoaWVyYXJjaGljYWxGYWNldCk7XG5cbiAgICB2YXIgY3VycmVudFJlZmluZW1lbnQgPSBzdGF0ZS5nZXRIaWVyYXJjaGljYWxSZWZpbmVtZW50KHJlZmluZWRGYWNldCk7XG4gICAgLy8gaWYgd2UgYXJlIGFscmVhZHkgYXQgYSByb290IHJlZmluZW1lbnQgKG9yIG5vIHJlZmluZW1lbnQgYXQgYWxsKSwgdGhlcmUgaXMgbm9cbiAgICAvLyByb290IGxldmVsIHZhbHVlcyByZXF1ZXN0XG4gICAgaWYgKGN1cnJlbnRSZWZpbmVtZW50Lmxlbmd0aCA9PT0gMCB8fCBjdXJyZW50UmVmaW5lbWVudFswXS5zcGxpdChzZXBhcmF0b3IpLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c1tuZXh0RGlzanVuY3RpdmVSZXN1bHRdO1xuICAgIHZhciBmYWNldHMgPSByZXN1bHQgJiYgcmVzdWx0LmZhY2V0c1xuICAgICAgPyByZXN1bHQuZmFjZXRzXG4gICAgICA6IHt9O1xuICAgIE9iamVjdC5rZXlzKGZhY2V0cykuZm9yRWFjaChmdW5jdGlvbihkZmFjZXQpIHtcbiAgICAgIHZhciBmYWNldFJlc3VsdHMgPSBmYWNldHNbZGZhY2V0XTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGZpbmRJbmRleChzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHMsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGYubmFtZSA9PT0gaGllcmFyY2hpY2FsRmFjZXQubmFtZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGF0dHJpYnV0ZUluZGV4ID0gZmluZEluZGV4KHNlbGYuaGllcmFyY2hpY2FsRmFjZXRzW3Bvc2l0aW9uXSwgZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZi5hdHRyaWJ1dGUgPT09IGRmYWNldDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcmV2aW91cyByZWZpbmVtZW50cyBhbmQgbm8gcmVzdWx0cyBzbyBub3QgYWJsZSB0byBmaW5kIGl0XG4gICAgICBpZiAoYXR0cmlidXRlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiB3ZSBhbHdheXMgZ2V0IHJvb3QgbGV2ZWxzLCBpZiB0aGUgaGl0cyByZWZpbmVtZW50IGlzIGBiZWVycyA+IElQQWAgKGNvdW50OiA1KSxcbiAgICAgIC8vIHRoZW4gdGhlIGRpc2p1bmN0aXZlIHZhbHVlcyB3aWxsIGJlIGBiZWVyc2AgKGNvdW50OiAxMDApLFxuICAgICAgLy8gYnV0IHdlIGRvIG5vdCB3YW50IHRvIGRpc3BsYXlcbiAgICAgIC8vICAgfCBiZWVycyAoMTAwKVxuICAgICAgLy8gICAgID4gSVBBICg1KVxuICAgICAgLy8gV2Ugd2FudFxuICAgICAgLy8gICB8IGJlZXJzICg1KVxuICAgICAgLy8gICAgID4gSVBBICg1KVxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge307XG5cbiAgICAgIGlmIChjdXJyZW50UmVmaW5lbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciByb290ID0gY3VycmVudFJlZmluZW1lbnRbMF0uc3BsaXQoc2VwYXJhdG9yKVswXTtcbiAgICAgICAgZGVmYXVsdERhdGFbcm9vdF0gPSBzZWxmLmhpZXJhcmNoaWNhbEZhY2V0c1twb3NpdGlvbl1bYXR0cmlidXRlSW5kZXhdLmRhdGFbcm9vdF07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuaGllcmFyY2hpY2FsRmFjZXRzW3Bvc2l0aW9uXVthdHRyaWJ1dGVJbmRleF0uZGF0YSA9IGRlZmF1bHRzUHVyZShcbiAgICAgICAgZGVmYXVsdERhdGEsXG4gICAgICAgIGZhY2V0UmVzdWx0cyxcbiAgICAgICAgc2VsZi5oaWVyYXJjaGljYWxGYWNldHNbcG9zaXRpb25dW2F0dHJpYnV0ZUluZGV4XS5kYXRhXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgbmV4dERpc2p1bmN0aXZlUmVzdWx0Kys7XG4gIH0pO1xuXG4gIC8vIGFkZCB0aGUgZXhjbHVkZXNcbiAgT2JqZWN0LmtleXMoc3RhdGUuZmFjZXRzRXhjbHVkZXMpLmZvckVhY2goZnVuY3Rpb24oZmFjZXROYW1lKSB7XG4gICAgdmFyIGV4Y2x1ZGVzID0gc3RhdGUuZmFjZXRzRXhjbHVkZXNbZmFjZXROYW1lXTtcbiAgICB2YXIgcG9zaXRpb24gPSBmYWNldHNJbmRpY2VzW2ZhY2V0TmFtZV07XG5cbiAgICBzZWxmLmZhY2V0c1twb3NpdGlvbl0gPSB7XG4gICAgICBuYW1lOiBmYWNldE5hbWUsXG4gICAgICBkYXRhOiBtYWluU3ViUmVzcG9uc2UuZmFjZXRzW2ZhY2V0TmFtZV0sXG4gICAgICBleGhhdXN0aXZlOiBtYWluU3ViUmVzcG9uc2UuZXhoYXVzdGl2ZUZhY2V0c0NvdW50XG4gICAgfTtcbiAgICBleGNsdWRlcy5mb3JFYWNoKGZ1bmN0aW9uKGZhY2V0VmFsdWUpIHtcbiAgICAgIHNlbGYuZmFjZXRzW3Bvc2l0aW9uXSA9IHNlbGYuZmFjZXRzW3Bvc2l0aW9uXSB8fCB7bmFtZTogZmFjZXROYW1lfTtcbiAgICAgIHNlbGYuZmFjZXRzW3Bvc2l0aW9uXS5kYXRhID0gc2VsZi5mYWNldHNbcG9zaXRpb25dLmRhdGEgfHwge307XG4gICAgICBzZWxmLmZhY2V0c1twb3NpdGlvbl0uZGF0YVtmYWNldFZhbHVlXSA9IDA7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB0aGlzLmhpZXJhcmNoaWNhbEZhY2V0cyA9IHRoaXMuaGllcmFyY2hpY2FsRmFjZXRzLm1hcChnZW5lcmF0ZUhpZXJhcmNoaWNhbFRyZWUoc3RhdGUpKTtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdGhpcy5mYWNldHMgPSBjb21wYWN0KHRoaXMuZmFjZXRzKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHRoaXMuZGlzanVuY3RpdmVGYWNldHMgPSBjb21wYWN0KHRoaXMuZGlzanVuY3RpdmVGYWNldHMpO1xuXG4gIHRoaXMuX3N0YXRlID0gc3RhdGU7XG59XG5cbi8qKlxuICogR2V0IGEgZmFjZXQgb2JqZWN0IHdpdGggaXRzIG5hbWVcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBmYWNldGVkIGF0dHJpYnV0ZVxuICogQHJldHVybiB7U2VhcmNoUmVzdWx0cy5GYWNldH0gdGhlIGZhY2V0IG9iamVjdFxuICovXG5TZWFyY2hSZXN1bHRzLnByb3RvdHlwZS5nZXRGYWNldEJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZnVuY3Rpb24gcHJlZGljYXRlKGZhY2V0KSB7XG4gICAgcmV0dXJuIGZhY2V0Lm5hbWUgPT09IG5hbWU7XG4gIH1cblxuICByZXR1cm4gZmluZCh0aGlzLmZhY2V0cywgcHJlZGljYXRlKSB8fFxuICAgIGZpbmQodGhpcy5kaXNqdW5jdGl2ZUZhY2V0cywgcHJlZGljYXRlKSB8fFxuICAgIGZpbmQodGhpcy5oaWVyYXJjaGljYWxGYWNldHMsIHByZWRpY2F0ZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmFjZXQgdmFsdWVzIG9mIGEgc3BlY2lmaWVkIGF0dHJpYnV0ZSBmcm9tIGEgU2VhcmNoUmVzdWx0cyBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTZWFyY2hSZXN1bHRzfSByZXN1bHRzIHRoZSBzZWFyY2ggcmVzdWx0cyB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgZmFjZXRlZCBhdHRyaWJ1dGUgdG8gc2VhcmNoIGZvclxuICogQHJldHVybiB7YXJyYXl8b2JqZWN0fSBmYWNldCB2YWx1ZXMuIEZvciB0aGUgaGllcmFyY2hpY2FsIGZhY2V0cyBpdCBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3ROb3JtYWxpemVkRmFjZXRWYWx1ZXMocmVzdWx0cywgYXR0cmlidXRlKSB7XG4gIGZ1bmN0aW9uIHByZWRpY2F0ZShmYWNldCkge1xuICAgIHJldHVybiBmYWNldC5uYW1lID09PSBhdHRyaWJ1dGU7XG4gIH1cblxuICBpZiAocmVzdWx0cy5fc3RhdGUuaXNDb25qdW5jdGl2ZUZhY2V0KGF0dHJpYnV0ZSkpIHtcbiAgICB2YXIgZmFjZXQgPSBmaW5kKHJlc3VsdHMuZmFjZXRzLCBwcmVkaWNhdGUpO1xuICAgIGlmICghZmFjZXQpIHJldHVybiBbXTtcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhmYWNldC5kYXRhKS5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgY291bnQ6IGZhY2V0LmRhdGFbbmFtZV0sXG4gICAgICAgIGlzUmVmaW5lZDogcmVzdWx0cy5fc3RhdGUuaXNGYWNldFJlZmluZWQoYXR0cmlidXRlLCBuYW1lKSxcbiAgICAgICAgaXNFeGNsdWRlZDogcmVzdWx0cy5fc3RhdGUuaXNFeGNsdWRlUmVmaW5lZChhdHRyaWJ1dGUsIG5hbWUpXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHJlc3VsdHMuX3N0YXRlLmlzRGlzanVuY3RpdmVGYWNldChhdHRyaWJ1dGUpKSB7XG4gICAgdmFyIGRpc2p1bmN0aXZlRmFjZXQgPSBmaW5kKHJlc3VsdHMuZGlzanVuY3RpdmVGYWNldHMsIHByZWRpY2F0ZSk7XG4gICAgaWYgKCFkaXNqdW5jdGl2ZUZhY2V0KSByZXR1cm4gW107XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlzanVuY3RpdmVGYWNldC5kYXRhKS5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgY291bnQ6IGRpc2p1bmN0aXZlRmFjZXQuZGF0YVtuYW1lXSxcbiAgICAgICAgaXNSZWZpbmVkOiByZXN1bHRzLl9zdGF0ZS5pc0Rpc2p1bmN0aXZlRmFjZXRSZWZpbmVkKGF0dHJpYnV0ZSwgbmFtZSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocmVzdWx0cy5fc3RhdGUuaXNIaWVyYXJjaGljYWxGYWNldChhdHRyaWJ1dGUpKSB7XG4gICAgcmV0dXJuIGZpbmQocmVzdWx0cy5oaWVyYXJjaGljYWxGYWNldHMsIHByZWRpY2F0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IG5vZGVzIG9mIGEgaGllcmFyY2hpY2FsIG9yIGRpc2p1bmN0aXZlIGZhY2V0IHJlc3VsdHNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzb3J0Rm5cbiAqIEBwYXJhbSB7SGllcmFyY2hpY2FsRmFjZXR8QXJyYXl9IG5vZGUgbm9kZSB1cG9uIHdoaWNoIHdlIHdhbnQgdG8gYXBwbHkgdGhlIHNvcnRcbiAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzIGF0dHJpYnV0ZSBuYW1lc1xuICogQHBhcmFtIHtudW1iZXJ9IFtsZXZlbD0wXSBjdXJyZW50IGluZGV4IGluIHRoZSBuYW1lcyBhcnJheVxuICovXG5mdW5jdGlvbiByZWNTb3J0KHNvcnRGbiwgbm9kZSwgbmFtZXMsIGxldmVsKSB7XG4gIGxldmVsID0gbGV2ZWwgfHwgMDtcblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIHJldHVybiBzb3J0Rm4obm9kZSwgbmFtZXNbbGV2ZWxdKTtcbiAgfVxuXG4gIGlmICghbm9kZS5kYXRhIHx8IG5vZGUuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuZGF0YS5tYXAoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgcmV0dXJuIHJlY1NvcnQoc29ydEZuLCBjaGlsZE5vZGUsIG5hbWVzLCBsZXZlbCArIDEpO1xuICB9KTtcbiAgdmFyIHNvcnRlZENoaWxkcmVuID0gc29ydEZuKGNoaWxkcmVuLCBuYW1lc1tsZXZlbF0pO1xuICB2YXIgbmV3Tm9kZSA9IGRlZmF1bHRzUHVyZSh7ZGF0YTogc29ydGVkQ2hpbGRyZW59LCBub2RlKTtcbiAgcmV0dXJuIG5ld05vZGU7XG59XG5cblNlYXJjaFJlc3VsdHMuREVGQVVMVF9TT1JUID0gWydpc1JlZmluZWQ6ZGVzYycsICdjb3VudDpkZXNjJywgJ25hbWU6YXNjJ107XG5cbmZ1bmN0aW9uIHZhbmlsbGFTb3J0Rm4ob3JkZXIsIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc29ydChvcmRlcik7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgRmFjZXRPcmRlcmluZ1xuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtvcmRlcl1cbiAqIEBwcm9wZXJ0eSB7J2NvdW50JyB8ICdhbHBoYScgfCAnaGlkZGVuJ30gW3NvcnRSZW1haW5pbmdCeV1cbiAqL1xuXG4vKipcbiAqIFNvcnRzIGZhY2V0IGFycmF5cyB2aWEgdGhlaXIgZmFjZXQgb3JkZXJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGZhY2V0VmFsdWVzIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB7RmFjZXRPcmRlcmluZ30gZmFjZXRPcmRlcmluZyB0aGUgb3JkZXJpbmdcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gc29ydFZpYUZhY2V0T3JkZXJpbmcoZmFjZXRWYWx1ZXMsIGZhY2V0T3JkZXJpbmcpIHtcbiAgdmFyIG9yZGVyZWRGYWNldHMgPSBbXTtcbiAgdmFyIHJlbWFpbmluZ0ZhY2V0cyA9IFtdO1xuXG4gIHZhciBvcmRlciA9IGZhY2V0T3JkZXJpbmcub3JkZXIgfHwgW107XG4gIC8qKlxuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUga2V5cyBiZWluZyB0aGUgdmFsdWVzIGluIG9yZGVyLCB0aGUgdmFsdWVzIHRoZWlyIGluZGV4OlxuICAgKiBbJ29uZScsICd0d28nXSAtPiB7IG9uZTogMCwgdHdvOiAxIH1cbiAgICovXG4gIHZhciByZXZlcnNlT3JkZXIgPSBvcmRlci5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBuYW1lLCBpKSB7XG4gICAgYWNjW25hbWVdID0gaTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgZmFjZXRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgLy8gaGllcmFyY2hpY2FsIGZhY2V0cyBnZXQgc29ydGVkIHVzaW5nIHRoZWlyIHJhdyBuYW1lXG4gICAgdmFyIG5hbWUgPSBpdGVtLnBhdGggfHwgaXRlbS5uYW1lO1xuICAgIGlmIChyZXZlcnNlT3JkZXJbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3JkZXJlZEZhY2V0c1tyZXZlcnNlT3JkZXJbbmFtZV1dID0gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtYWluaW5nRmFjZXRzLnB1c2goaXRlbSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgc29ydFJlbWFpbmluZ0J5ID0gZmFjZXRPcmRlcmluZy5zb3J0UmVtYWluaW5nQnk7XG4gIHZhciBvcmRlcmluZztcbiAgaWYgKHNvcnRSZW1haW5pbmdCeSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gb3JkZXJlZEZhY2V0cztcbiAgfSBlbHNlIGlmIChzb3J0UmVtYWluaW5nQnkgPT09ICdhbHBoYScpIHtcbiAgICBvcmRlcmluZyA9IFtbJ3BhdGgnLCAnbmFtZSddLCBbJ2FzYycsICdhc2MnXV07XG4gIH0gZWxzZSB7XG4gICAgb3JkZXJpbmcgPSBbWydjb3VudCddLCBbJ2Rlc2MnXV07XG4gIH1cblxuICByZXR1cm4gb3JkZXJlZEZhY2V0cy5jb25jYXQoXG4gICAgb3JkZXJCeShyZW1haW5pbmdGYWNldHMsIG9yZGVyaW5nWzBdLCBvcmRlcmluZ1sxXSlcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlYXJjaFJlc3VsdHN9IHJlc3VsdHMgdGhlIHNlYXJjaCByZXN1bHRzIGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIHRoZSBhdHRyaWJ1dGUgdG8gcmV0cmlldmUgb3JkZXJpbmcgb2ZcbiAqIEByZXR1cm5zIHtGYWNldE9yZGVyaW5nPX1cbiAqL1xuZnVuY3Rpb24gZ2V0RmFjZXRPcmRlcmluZyhyZXN1bHRzLCBhdHRyaWJ1dGUpIHtcbiAgcmV0dXJuIChcbiAgICByZXN1bHRzLnJlbmRlcmluZ0NvbnRlbnQgJiZcbiAgICByZXN1bHRzLnJlbmRlcmluZ0NvbnRlbnQuZmFjZXRPcmRlcmluZyAmJlxuICAgIHJlc3VsdHMucmVuZGVyaW5nQ29udGVudC5mYWNldE9yZGVyaW5nLnZhbHVlcyAmJlxuICAgIHJlc3VsdHMucmVuZGVyaW5nQ29udGVudC5mYWNldE9yZGVyaW5nLnZhbHVlc1thdHRyaWJ1dGVdXG4gICk7XG59XG5cbi8qKlxuICogR2V0IGEgdGhlIGxpc3Qgb2YgdmFsdWVzIGZvciBhIGdpdmVuIGZhY2V0IGF0dHJpYnV0ZS4gVGhvc2UgdmFsdWVzIGFyZSBzb3J0ZWRcbiAqIHJlZmluZW1lbnQgZmlyc3QsIGRlc2NlbmRpbmcgY291bnQgKGJpZ2dlciB2YWx1ZSBvbiB0b3ApLCBhbmQgbmFtZSBhc2NlbmRpbmdcbiAqIChhbHBoYWJldGljYWwgb3JkZXIpLiBUaGUgc29ydCBmb3JtdWxhIGNhbiBvdmVycmlkZGVuIHVzaW5nIGVpdGhlciBzdHJpbmcgYmFzZWRcbiAqIHByZWRpY2F0ZXMgb3IgYSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgQWxnb2xpYSBlbmdpbmUgcGx1cyBhbGxcbiAqIHRoZSB2YWx1ZXMgYWxyZWFkeSByZWZpbmVkLiBUaGlzIG1lYW5zIHRoYXQgaXQgY2FuIGhhcHBlbiB0aGF0IHRoZVxuICogYG1heFZhbHVlc1BlckZhY2V0YCBbY29uZmlndXJhdGlvbl0oaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3QtYXBpL3NlYXJjaCNwYXJhbS1tYXhWYWx1ZXNQZXJGYWNldClcbiAqIG1pZ2h0IG5vdCBiZSByZXNwZWN0ZWQgaWYgeW91IGhhdmUgZmFjZXQgdmFsdWVzIHRoYXQgYXJlIGFscmVhZHkgcmVmaW5lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgYXR0cmlidXRlIG5hbWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmFjZXRPcmRlcmluZ11cbiAqIEZvcmNlIHRoZSB1c2Ugb2YgZmFjZXRPcmRlcmluZyBmcm9tIHRoZSByZXN1bHQgaWYgYSBzb3J0QnkgaXMgcHJlc2VudC4gSWZcbiAqIHNvcnRCeSBpc24ndCBwcmVzZW50LCBmYWNldE9yZGVyaW5nIHdpbGwgYmUgdXNlZCBhdXRvbWF0aWNhbGx5LlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPiB8IGZ1bmN0aW9ufSBvcHRzLnNvcnRCeVxuICogV2hlbiB1c2luZyBzdHJpbmdzLCBpdCBjb25zaXN0cyBvZlxuICogdGhlIG5hbWUgb2YgdGhlIFtGYWNldFZhbHVlXSgjU2VhcmNoUmVzdWx0cy5GYWNldFZhbHVlKSBvciB0aGVcbiAqIFtIaWVyYXJjaGljYWxGYWNldF0oI1NlYXJjaFJlc3VsdHMuSGllcmFyY2hpY2FsRmFjZXQpIGF0dHJpYnV0ZXMgd2l0aCB0aGVcbiAqIG9yZGVyIChgYXNjYCBvciBgZGVzY2ApLiBGb3IgZXhhbXBsZSB0byBvcmRlciB0aGUgdmFsdWUgYnkgY291bnQsIHRoZVxuICogYXJndW1lbnQgd291bGQgYmUgYFsnY291bnQ6YXNjJ11gLlxuICpcbiAqIElmIG9ubHkgdGhlIGF0dHJpYnV0ZSBuYW1lIGlzIHNwZWNpZmllZCwgdGhlIG9yZGVyaW5nIGRlZmF1bHRzIHRvIHRoZSBvbmVcbiAqIHNwZWNpZmllZCBpbiB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBhdHRyaWJ1dGUuXG4gKlxuICogV2hlbiBub3Qgc3BlY2lmaWVkLCB0aGUgb3JkZXIgaXNcbiAqIGFzY2VuZGluZy4gIFRoaXMgcGFyYW1ldGVyIGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGZhY2V0XG4gKiB2YWx1ZXMgYW5kIHNob3VsZCByZXR1cm4gYSBudW1iZXIsIDAgaWYgZXF1YWwsIDEgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzXG4gKiBiaWdnZXIgb3IgLTEgb3RoZXJ3aXNlLlxuICpcbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIGF0dHJpYnV0ZSBgWydpc1JlZmluZWQ6ZGVzYycsICdjb3VudDpkZXNjJywgJ25hbWU6YXNjJ11gXG4gKiBAcmV0dXJuIHtGYWNldFZhbHVlW118SGllcmFyY2hpY2FsRmFjZXR8dW5kZWZpbmVkfSBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgZmFjZXQgb2ZcbiAqIHRoZSBhdHRyaWJ1dGUgcmVxdWVzdGVkIChoaWVyYXJjaGljYWwsIGRpc2p1bmN0aXZlIG9yIGNvbmp1bmN0aXZlKVxuICogQGV4YW1wbGVcbiAqIGhlbHBlci5vbigncmVzdWx0JywgZnVuY3Rpb24oZXZlbnQpe1xuICogICAvL2dldCB2YWx1ZXMgb3JkZXJlZCBvbmx5IGJ5IG5hbWUgYXNjZW5kaW5nIHVzaW5nIHRoZSBzdHJpbmcgcHJlZGljYXRlXG4gKiAgIGV2ZW50LnJlc3VsdHMuZ2V0RmFjZXRWYWx1ZXMoJ2NpdHknLCB7c29ydEJ5OiBbJ25hbWU6YXNjJ119KTtcbiAqICAgLy9nZXQgdmFsdWVzICBvcmRlcmVkIG9ubHkgYnkgY291bnQgYXNjZW5kaW5nIHVzaW5nIGEgZnVuY3Rpb25cbiAqICAgZXZlbnQucmVzdWx0cy5nZXRGYWNldFZhbHVlcygnY2l0eScsIHtcbiAqICAgICAvLyB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gWydjb3VudDphc2MnXVxuICogICAgIHNvcnRCeTogZnVuY3Rpb24oYSwgYikge1xuICogICAgICAgaWYgKGEuY291bnQgPT09IGIuY291bnQpIHJldHVybiAwO1xuICogICAgICAgaWYgKGEuY291bnQgPiBiLmNvdW50KSAgIHJldHVybiAxO1xuICogICAgICAgaWYgKGIuY291bnQgPiBhLmNvdW50KSAgIHJldHVybiAtMTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICogfSk7XG4gKi9cblNlYXJjaFJlc3VsdHMucHJvdG90eXBlLmdldEZhY2V0VmFsdWVzID0gZnVuY3Rpb24oYXR0cmlidXRlLCBvcHRzKSB7XG4gIHZhciBmYWNldFZhbHVlcyA9IGV4dHJhY3ROb3JtYWxpemVkRmFjZXRWYWx1ZXModGhpcywgYXR0cmlidXRlKTtcbiAgaWYgKCFmYWNldFZhbHVlcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IGRlZmF1bHRzUHVyZSh7fSwgb3B0cywge1xuICAgIHNvcnRCeTogU2VhcmNoUmVzdWx0cy5ERUZBVUxUX1NPUlQsXG4gICAgLy8gaWYgbm8gc29ydEJ5IGlzIGdpdmVuLCBhdHRlbXB0IHRvIHNvcnQgYmFzZWQgb24gZmFjZXRPcmRlcmluZ1xuICAgIC8vIGlmIGl0IGlzIGdpdmVuLCB3ZSBzdGlsbCBhbGxvdyB0byBzb3J0IHZpYSBmYWNldCBvcmRlcmluZyBmaXJzdFxuICAgIGZhY2V0T3JkZXJpbmc6ICEob3B0cyAmJiBvcHRzLnNvcnRCeSlcbiAgfSk7XG5cbiAgdmFyIHJlc3VsdHMgPSB0aGlzO1xuICB2YXIgYXR0cmlidXRlcztcbiAgaWYgKEFycmF5LmlzQXJyYXkoZmFjZXRWYWx1ZXMpKSB7XG4gICAgYXR0cmlidXRlcyA9IFthdHRyaWJ1dGVdO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb25maWcgPSByZXN1bHRzLl9zdGF0ZS5nZXRIaWVyYXJjaGljYWxGYWNldEJ5TmFtZShmYWNldFZhbHVlcy5uYW1lKTtcbiAgICBhdHRyaWJ1dGVzID0gY29uZmlnLmF0dHJpYnV0ZXM7XG4gIH1cblxuICByZXR1cm4gcmVjU29ydChmdW5jdGlvbihkYXRhLCBmYWNldE5hbWUpIHtcbiAgICBpZiAob3B0aW9ucy5mYWNldE9yZGVyaW5nKSB7XG4gICAgICB2YXIgZmFjZXRPcmRlcmluZyA9IGdldEZhY2V0T3JkZXJpbmcocmVzdWx0cywgZmFjZXROYW1lKTtcbiAgICAgIGlmIChCb29sZWFuKGZhY2V0T3JkZXJpbmcpKSB7XG4gICAgICAgIHJldHVybiBzb3J0VmlhRmFjZXRPcmRlcmluZyhkYXRhLCBmYWNldE9yZGVyaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnNvcnRCeSkpIHtcbiAgICAgIHZhciBvcmRlciA9IGZvcm1hdFNvcnQob3B0aW9ucy5zb3J0QnksIFNlYXJjaFJlc3VsdHMuREVGQVVMVF9TT1JUKTtcbiAgICAgIHJldHVybiBvcmRlckJ5KGRhdGEsIG9yZGVyWzBdLCBvcmRlclsxXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5zb3J0QnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB2YW5pbGxhU29ydEZuKG9wdGlvbnMuc29ydEJ5LCBkYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ29wdGlvbnMuc29ydEJ5IGlzIG9wdGlvbmFsIGJ1dCBpZiBkZWZpbmVkIGl0IG11c3QgYmUgJyArXG4gICAgICAgICdlaXRoZXIgYW4gYXJyYXkgb2Ygc3RyaW5nIChwcmVkaWNhdGVzKSBvciBhIHNvcnRpbmcgZnVuY3Rpb24nXG4gICAgKTtcbiAgfSwgZmFjZXRWYWx1ZXMsIGF0dHJpYnV0ZXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmYWNldCBzdGF0cyBpZiBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgdGhlIGZhY2V0IGNvbnRhaW5zIHNvbWUuXG4gKiBPdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIG5hbWUgb2YgdGhlIGZhY2V0ZWQgYXR0cmlidXRlXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBzdGF0cyBvZiB0aGUgZmFjZXRcbiAqL1xuU2VhcmNoUmVzdWx0cy5wcm90b3R5cGUuZ2V0RmFjZXRTdGF0cyA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICBpZiAodGhpcy5fc3RhdGUuaXNDb25qdW5jdGl2ZUZhY2V0KGF0dHJpYnV0ZSkpIHtcbiAgICByZXR1cm4gZ2V0RmFjZXRTdGF0c0lmQXZhaWxhYmxlKHRoaXMuZmFjZXRzLCBhdHRyaWJ1dGUpO1xuICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlLmlzRGlzanVuY3RpdmVGYWNldChhdHRyaWJ1dGUpKSB7XG4gICAgcmV0dXJuIGdldEZhY2V0U3RhdHNJZkF2YWlsYWJsZSh0aGlzLmRpc2p1bmN0aXZlRmFjZXRzLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmFjZXRMaXN0SXRlbVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmFjZXRMaXN0SXRlbVtdfSBmYWNldExpc3QgKGhhcyBtb3JlIGl0ZW1zLCBidXQgZW5vdWdoIGZvciBoZXJlKVxuICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0TmFtZVxuICovXG5mdW5jdGlvbiBnZXRGYWNldFN0YXRzSWZBdmFpbGFibGUoZmFjZXRMaXN0LCBmYWNldE5hbWUpIHtcbiAgdmFyIGRhdGEgPSBmaW5kKGZhY2V0TGlzdCwgZnVuY3Rpb24oZmFjZXQpIHtcbiAgICByZXR1cm4gZmFjZXQubmFtZSA9PT0gZmFjZXROYW1lO1xuICB9KTtcbiAgcmV0dXJuIGRhdGEgJiYgZGF0YS5zdGF0cztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCByZWZpbmVtZW50cyBmb3IgYWxsIGZpbHRlcnMgKyB0YWdzLiBJdCBhbHNvIHByb3ZpZGVzXG4gKiBhZGRpdGlvbmFsIGluZm9ybWF0aW9uOiBjb3VudCBhbmQgZXhoYXVzdGl2ZW5lc3MgZm9yIGVhY2ggZmlsdGVyLlxuICpcbiAqIFNlZSB0aGUgW3JlZmluZW1lbnQgdHlwZV0oI1JlZmluZW1lbnQpIGZvciBhbiBleGhhdXN0aXZlIHZpZXcgb2YgdGhlIGF2YWlsYWJsZVxuICogZGF0YS5cbiAqXG4gKiBOb3RlIHRoYXQgZm9yIGEgbnVtZXJpYyByZWZpbmVtZW50LCByZXN1bHRzIGFyZSBncm91cGVkIHBlciBvcGVyYXRvciwgdGhpc1xuICogbWVhbnMgdGhhdCBpdCB3aWxsIHJldHVybiByZXNwb25zZXMgZm9yIG9wZXJhdG9ycyB3aGljaCBhcmUgZW1wdHkuXG4gKlxuICogQHJldHVybiB7QXJyYXkuPFJlZmluZW1lbnQ+fSBhbGwgdGhlIHJlZmluZW1lbnRzXG4gKi9cblNlYXJjaFJlc3VsdHMucHJvdG90eXBlLmdldFJlZmluZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICB2YXIgcmVzdWx0cyA9IHRoaXM7XG4gIHZhciByZXMgPSBbXTtcblxuICBPYmplY3Qua2V5cyhzdGF0ZS5mYWNldHNSZWZpbmVtZW50cykuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGVOYW1lKSB7XG4gICAgc3RhdGUuZmFjZXRzUmVmaW5lbWVudHNbYXR0cmlidXRlTmFtZV0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXMucHVzaChnZXRSZWZpbmVtZW50KHN0YXRlLCAnZmFjZXQnLCBhdHRyaWJ1dGVOYW1lLCBuYW1lLCByZXN1bHRzLmZhY2V0cykpO1xuICAgIH0pO1xuICB9KTtcblxuICBPYmplY3Qua2V5cyhzdGF0ZS5mYWNldHNFeGNsdWRlcykuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGVOYW1lKSB7XG4gICAgc3RhdGUuZmFjZXRzRXhjbHVkZXNbYXR0cmlidXRlTmFtZV0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXMucHVzaChnZXRSZWZpbmVtZW50KHN0YXRlLCAnZXhjbHVkZScsIGF0dHJpYnV0ZU5hbWUsIG5hbWUsIHJlc3VsdHMuZmFjZXRzKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKHN0YXRlLmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMpLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlTmFtZSkge1xuICAgIHN0YXRlLmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHNbYXR0cmlidXRlTmFtZV0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXMucHVzaChnZXRSZWZpbmVtZW50KHN0YXRlLCAnZGlzanVuY3RpdmUnLCBhdHRyaWJ1dGVOYW1lLCBuYW1lLCByZXN1bHRzLmRpc2p1bmN0aXZlRmFjZXRzKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKHN0YXRlLmhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBzdGF0ZS5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50c1thdHRyaWJ1dGVOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJlcy5wdXNoKGdldEhpZXJhcmNoaWNhbFJlZmluZW1lbnQoc3RhdGUsIGF0dHJpYnV0ZU5hbWUsIG5hbWUsIHJlc3VsdHMuaGllcmFyY2hpY2FsRmFjZXRzKSk7XG4gICAgfSk7XG4gIH0pO1xuXG5cbiAgT2JqZWN0LmtleXMoc3RhdGUubnVtZXJpY1JlZmluZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICB2YXIgb3BlcmF0b3JzID0gc3RhdGUubnVtZXJpY1JlZmluZW1lbnRzW2F0dHJpYnV0ZU5hbWVdO1xuICAgIE9iamVjdC5rZXlzKG9wZXJhdG9ycykuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvcikge1xuICAgICAgb3BlcmF0b3JzW29wZXJhdG9yXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbnVtZXJpYycsXG4gICAgICAgICAgYXR0cmlidXRlTmFtZTogYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICBuYW1lOiB2YWx1ZSxcbiAgICAgICAgICBudW1lcmljVmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBzdGF0ZS50YWdSZWZpbmVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXMucHVzaCh7dHlwZTogJ3RhZycsIGF0dHJpYnV0ZU5hbWU6ICdfdGFncycsIG5hbWU6IG5hbWV9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmFjZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YVxuICogQHByb3BlcnR5IHtib29sZWFufSBleGhhdXN0aXZlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IHN0YXRlXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lXG4gKiBAcGFyYW0geyp9IG5hbWVcbiAqIEBwYXJhbSB7RmFjZXRbXX0gcmVzdWx0c0ZhY2V0c1xuICovXG5mdW5jdGlvbiBnZXRSZWZpbmVtZW50KHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVOYW1lLCBuYW1lLCByZXN1bHRzRmFjZXRzKSB7XG4gIHZhciBmYWNldCA9IGZpbmQocmVzdWx0c0ZhY2V0cywgZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmLm5hbWUgPT09IGF0dHJpYnV0ZU5hbWU7XG4gIH0pO1xuICB2YXIgY291bnQgPSBmYWNldCAmJiBmYWNldC5kYXRhICYmIGZhY2V0LmRhdGFbbmFtZV0gPyBmYWNldC5kYXRhW25hbWVdIDogMDtcbiAgdmFyIGV4aGF1c3RpdmUgPSAoZmFjZXQgJiYgZmFjZXQuZXhoYXVzdGl2ZSkgfHwgZmFsc2U7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGF0dHJpYnV0ZU5hbWU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgbmFtZTogbmFtZSxcbiAgICBjb3VudDogY291bnQsXG4gICAgZXhoYXVzdGl2ZTogZXhoYXVzdGl2ZVxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lXG4gKiBAcGFyYW0geyp9IG5hbWVcbiAqIEBwYXJhbSB7RmFjZXRbXX0gcmVzdWx0c0ZhY2V0c1xuICovXG5mdW5jdGlvbiBnZXRIaWVyYXJjaGljYWxSZWZpbmVtZW50KHN0YXRlLCBhdHRyaWJ1dGVOYW1lLCBuYW1lLCByZXN1bHRzRmFjZXRzKSB7XG4gIHZhciBmYWNldERlY2xhcmF0aW9uID0gc3RhdGUuZ2V0SGllcmFyY2hpY2FsRmFjZXRCeU5hbWUoYXR0cmlidXRlTmFtZSk7XG4gIHZhciBzZXBhcmF0b3IgPSBzdGF0ZS5fZ2V0SGllcmFyY2hpY2FsRmFjZXRTZXBhcmF0b3IoZmFjZXREZWNsYXJhdGlvbik7XG4gIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoc2VwYXJhdG9yKTtcbiAgdmFyIHJvb3RGYWNldCA9IGZpbmQocmVzdWx0c0ZhY2V0cywgZnVuY3Rpb24oZmFjZXQpIHtcbiAgICByZXR1cm4gZmFjZXQubmFtZSA9PT0gYXR0cmlidXRlTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGZhY2V0ID0gc3BsaXQucmVkdWNlKGZ1bmN0aW9uKGludGVybWVkaWF0ZUZhY2V0LCBwYXJ0KSB7XG4gICAgdmFyIG5ld0ZhY2V0ID1cbiAgICAgIGludGVybWVkaWF0ZUZhY2V0ICYmIGZpbmQoaW50ZXJtZWRpYXRlRmFjZXQuZGF0YSwgZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZi5uYW1lID09PSBwYXJ0O1xuICAgICAgfSk7XG4gICAgcmV0dXJuIG5ld0ZhY2V0ICE9PSB1bmRlZmluZWQgPyBuZXdGYWNldCA6IGludGVybWVkaWF0ZUZhY2V0O1xuICB9LCByb290RmFjZXQpO1xuXG4gIHZhciBjb3VudCA9IChmYWNldCAmJiBmYWNldC5jb3VudCkgfHwgMDtcbiAgdmFyIGV4aGF1c3RpdmUgPSAoZmFjZXQgJiYgZmFjZXQuZXhoYXVzdGl2ZSkgfHwgZmFsc2U7XG4gIHZhciBwYXRoID0gKGZhY2V0ICYmIGZhY2V0LnBhdGgpIHx8ICcnO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ2hpZXJhcmNoaWNhbCcsXG4gICAgYXR0cmlidXRlTmFtZTogYXR0cmlidXRlTmFtZSxcbiAgICBuYW1lOiBwYXRoLFxuICAgIGNvdW50OiBjb3VudCxcbiAgICBleGhhdXN0aXZlOiBleGhhdXN0aXZlXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VhcmNoUmVzdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNlYXJjaFBhcmFtZXRlcnMgPSByZXF1aXJlKCcuL1NlYXJjaFBhcmFtZXRlcnMnKTtcbnZhciBTZWFyY2hSZXN1bHRzID0gcmVxdWlyZSgnLi9TZWFyY2hSZXN1bHRzJyk7XG52YXIgRGVyaXZlZEhlbHBlciA9IHJlcXVpcmUoJy4vRGVyaXZlZEhlbHBlcicpO1xudmFyIHJlcXVlc3RCdWlsZGVyID0gcmVxdWlyZSgnLi9yZXF1ZXN0QnVpbGRlcicpO1xuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmhlcml0cycpO1xudmFyIG9iamVjdEhhc0tleXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9vYmplY3RIYXNLZXlzJyk7XG52YXIgb21pdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL29taXQnKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21lcmdlJyk7XG5cbnZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cbi8qKlxuICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBwYXJhbWV0ZXIgaXMgc2V0IG9yIHVwZGF0ZWRcbiAqIEBldmVudCBBbGdvbGlhU2VhcmNoSGVscGVyI2V2ZW50OmNoYW5nZVxuICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50XG4gKiBAcHJvcGVydHkge1NlYXJjaFBhcmFtZXRlcnN9IGV2ZW50LnN0YXRlIHRoZSBjdXJyZW50IHBhcmFtZXRlcnMgd2l0aCB0aGUgbGF0ZXN0IGNoYW5nZXMgYXBwbGllZFxuICogQHByb3BlcnR5IHtTZWFyY2hSZXN1bHRzfSBldmVudC5yZXN1bHRzIHRoZSBwcmV2aW91cyByZXN1bHRzIHJlY2VpdmVkIGZyb20gQWxnb2xpYS4gYG51bGxgIGJlZm9yZSB0aGUgZmlyc3QgcmVxdWVzdFxuICogQGV4YW1wbGVcbiAqIGhlbHBlci5vbignY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgY29uc29sZS5sb2coJ1RoZSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZCcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBhIG1haW4gc2VhcmNoIGlzIHNlbnQgdG8gQWxnb2xpYVxuICogQGV2ZW50IEFsZ29saWFTZWFyY2hIZWxwZXIjZXZlbnQ6c2VhcmNoXG4gKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnRcbiAqIEBwcm9wZXJ0eSB7U2VhcmNoUGFyYW1ldGVyc30gZXZlbnQuc3RhdGUgdGhlIHBhcmFtZXRlcnMgdXNlZCBmb3IgdGhpcyBzZWFyY2hcbiAqIEBwcm9wZXJ0eSB7U2VhcmNoUmVzdWx0c30gZXZlbnQucmVzdWx0cyB0aGUgcmVzdWx0cyBmcm9tIHRoZSBwcmV2aW91cyBzZWFyY2guIGBudWxsYCBpZiBpdCBpcyB0aGUgZmlyc3Qgc2VhcmNoLlxuICogQGV4YW1wbGVcbiAqIGhlbHBlci5vbignc2VhcmNoJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgY29uc29sZS5sb2coJ1NlYXJjaCBzZW50Jyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGEgc2VhcmNoIHVzaW5nIGBzZWFyY2hGb3JGYWNldFZhbHVlc2AgaXMgc2VudCB0byBBbGdvbGlhXG4gKiBAZXZlbnQgQWxnb2xpYVNlYXJjaEhlbHBlciNldmVudDpzZWFyY2hGb3JGYWNldFZhbHVlc1xuICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50XG4gKiBAcHJvcGVydHkge1NlYXJjaFBhcmFtZXRlcnN9IGV2ZW50LnN0YXRlIHRoZSBwYXJhbWV0ZXJzIHVzZWQgZm9yIHRoaXMgc2VhcmNoIGl0IGlzIHRoZSBmaXJzdCBzZWFyY2guXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQuZmFjZXQgdGhlIGZhY2V0IHNlYXJjaGVkIGludG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudC5xdWVyeSB0aGUgcXVlcnkgdXNlZCB0byBzZWFyY2ggaW4gdGhlIGZhY2V0c1xuICogQGV4YW1wbGVcbiAqIGhlbHBlci5vbignc2VhcmNoRm9yRmFjZXRWYWx1ZXMnLCBmdW5jdGlvbihldmVudCkge1xuICogICBjb25zb2xlLmxvZygnc2VhcmNoRm9yRmFjZXRWYWx1ZXMgc2VudCcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBhIHNlYXJjaCB1c2luZyBgc2VhcmNoT25jZWAgaXMgc2VudCB0byBBbGdvbGlhXG4gKiBAZXZlbnQgQWxnb2xpYVNlYXJjaEhlbHBlciNldmVudDpzZWFyY2hPbmNlXG4gKiBAcHJvcGVydHkge29iamVjdH0gZXZlbnRcbiAqIEBwcm9wZXJ0eSB7U2VhcmNoUGFyYW1ldGVyc30gZXZlbnQuc3RhdGUgdGhlIHBhcmFtZXRlcnMgdXNlZCBmb3IgdGhpcyBzZWFyY2ggaXQgaXMgdGhlIGZpcnN0IHNlYXJjaC5cbiAqIEBleGFtcGxlXG4gKiBoZWxwZXIub24oJ3NlYXJjaE9uY2UnLCBmdW5jdGlvbihldmVudCkge1xuICogICBjb25zb2xlLmxvZygnc2VhcmNoT25jZSBzZW50Jyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSByZXN1bHRzIGFyZSByZXRyaWV2ZWQgZnJvbSBBbGdvbGlhXG4gKiBAZXZlbnQgQWxnb2xpYVNlYXJjaEhlbHBlciNldmVudDpyZXN1bHRcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBldmVudFxuICogQHByb3BlcnR5IHtTZWFyY2hSZXN1bHRzfSBldmVudC5yZXN1bHRzIHRoZSByZXN1bHRzIHJlY2VpdmVkIGZyb20gQWxnb2xpYVxuICogQHByb3BlcnR5IHtTZWFyY2hQYXJhbWV0ZXJzfSBldmVudC5zdGF0ZSB0aGUgcGFyYW1ldGVycyB1c2VkIHRvIHF1ZXJ5IEFsZ29saWEuIFRob3NlIG1pZ2h0IGJlIGRpZmZlcmVudCBmcm9tIHRoZSBvbmUgaW4gdGhlIGhlbHBlciBpbnN0YW5jZSAoZm9yIGV4YW1wbGUgaWYgdGhlIG5ldHdvcmsgaXMgdW5yZWxpYWJsZSkuXG4gKiBAZXhhbXBsZVxuICogaGVscGVyLm9uKCdyZXN1bHQnLCBmdW5jdGlvbihldmVudCkge1xuICogICBjb25zb2xlLmxvZygnU2VhcmNoIHJlc3VsdHMgcmVjZWl2ZWQnKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gQWxnb2xpYSBzZW5kcyBiYWNrIGFuIGVycm9yLiBGb3IgZXhhbXBsZSwgaWYgYW4gdW5rbm93biBwYXJhbWV0ZXIgaXNcbiAqIHVzZWQsIHRoZSBlcnJvciBjYW4gYmUgY2F1Z2h0IHVzaW5nIHRoaXMgZXZlbnQuXG4gKiBAZXZlbnQgQWxnb2xpYVNlYXJjaEhlbHBlciNldmVudDplcnJvclxuICogQHByb3BlcnR5IHtvYmplY3R9IGV2ZW50XG4gKiBAcHJvcGVydHkge0Vycm9yfSBldmVudC5lcnJvciB0aGUgZXJyb3IgcmV0dXJuZWQgYnkgdGhlIEFsZ29saWEuXG4gKiBAZXhhbXBsZVxuICogaGVscGVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgIGNvbnNvbGUubG9nKCdIb3VzdG9uIHdlIGdvdCBhIHByb2JsZW0uJyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBxdWV1ZSBvZiBxdWVyaWVzIGhhdmUgYmVlbiBkZXBsZXRlZCAod2l0aCBhbnkgcmVzdWx0IG9yIG91dGRhdGVkIHF1ZXJpZXMpXG4gKiBAZXZlbnQgQWxnb2xpYVNlYXJjaEhlbHBlciNldmVudDpzZWFyY2hRdWV1ZUVtcHR5XG4gKiBAZXhhbXBsZVxuICogaGVscGVyLm9uKCdzZWFyY2hRdWV1ZUVtcHR5JywgZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKCdObyBtb3JlIHNlYXJjaCBwZW5kaW5nJyk7XG4gKiAgIC8vIFRoaXMgaXMgcmVjZWl2ZWQgYmVmb3JlIHRoZSByZXN1bHQgZXZlbnQgaWYgd2UncmUgbm90IGV4cGVjdGluZyBuZXcgcmVzdWx0c1xuICogfSk7XG4gKlxuICogaGVscGVyLnNlYXJjaCgpO1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBBbGdvbGlhU2VhcmNoSGVscGVyXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgVGhlIEFsZ29saWFTZWFyY2hIZWxwZXIgaXMgYSBjbGFzcyB0aGF0IGVhc2UgdGhlIG1hbmFnZW1lbnQgb2YgdGhlXG4gKiBzZWFyY2guIEl0IHByb3ZpZGVzIGFuIGV2ZW50IGJhc2VkIGludGVyZmFjZSBmb3Igc2VhcmNoIGNhbGxiYWNrczpcbiAqICAtIGNoYW5nZTogd2hlbiB0aGUgaW50ZXJuYWwgc2VhcmNoIHN0YXRlIGlzIGNoYW5nZWQuXG4gKiAgICBUaGlzIGV2ZW50IGNvbnRhaW5zIGEge0BsaW5rIFNlYXJjaFBhcmFtZXRlcnN9IG9iamVjdCBhbmQgdGhlXG4gKiAgICB7QGxpbmsgU2VhcmNoUmVzdWx0c30gb2YgdGhlIGxhc3QgcmVzdWx0IGlmIGFueS5cbiAqICAtIHNlYXJjaDogd2hlbiBhIHNlYXJjaCBpcyB0cmlnZ2VyZWQgdXNpbmcgdGhlIGBzZWFyY2goKWAgbWV0aG9kLlxuICogIC0gcmVzdWx0OiB3aGVuIHRoZSByZXNwb25zZSBpcyByZXRyaWV2ZWQgZnJvbSBBbGdvbGlhIGFuZCBpcyBwcm9jZXNzZWQuXG4gKiAgICBUaGlzIGV2ZW50IGNvbnRhaW5zIGEge0BsaW5rIFNlYXJjaFJlc3VsdHN9IG9iamVjdCBhbmQgdGhlXG4gKiAgICB7QGxpbmsgU2VhcmNoUGFyYW1ldGVyc30gY29ycmVzcG9uZGluZyB0byB0aGlzIGFuc3dlci5cbiAqICAtIGVycm9yOiB3aGVuIHRoZSByZXNwb25zZSBpcyBhbiBlcnJvci4gVGhpcyBldmVudCBjb250YWlucyB0aGUgZXJyb3IgcmV0dXJuZWQgYnkgdGhlIHNlcnZlci5cbiAqIEBwYXJhbSAge0FsZ29saWFTZWFyY2h9IGNsaWVudCBhbiBBbGdvbGlhU2VhcmNoIGNsaWVudFxuICogQHBhcmFtICB7c3RyaW5nfSBpbmRleCB0aGUgaW5kZXggbmFtZSB0byBxdWVyeVxuICogQHBhcmFtICB7U2VhcmNoUGFyYW1ldGVycyB8IG9iamVjdH0gb3B0aW9ucyBhbiBvYmplY3QgZGVmaW5pbmcgdGhlIGluaXRpYWxcbiAqIGNvbmZpZyBvZiB0aGUgc2VhcmNoLiBJdCBkb2Vzbid0IGhhdmUgdG8gYmUgYSB7U2VhcmNoUGFyYW1ldGVyc30sXG4gKiBqdXN0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIHlvdSBuZWVkIGZyb20gaXQuXG4gKi9cbmZ1bmN0aW9uIEFsZ29saWFTZWFyY2hIZWxwZXIoY2xpZW50LCBpbmRleCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGNsaWVudC5hZGRBbGdvbGlhQWdlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjbGllbnQuYWRkQWxnb2xpYUFnZW50KCdKUyBIZWxwZXIgKCcgKyB2ZXJzaW9uICsgJyknKTtcbiAgfVxuXG4gIHRoaXMuc2V0Q2xpZW50KGNsaWVudCk7XG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0cy5pbmRleCA9IGluZGV4O1xuICB0aGlzLnN0YXRlID0gU2VhcmNoUGFyYW1ldGVycy5tYWtlKG9wdHMpO1xuICB0aGlzLmxhc3RSZXN1bHRzID0gbnVsbDtcbiAgdGhpcy5fcXVlcnlJZCA9IDA7XG4gIHRoaXMuX2xhc3RRdWVyeUlkUmVjZWl2ZWQgPSAtMTtcbiAgdGhpcy5kZXJpdmVkSGVscGVycyA9IFtdO1xuICB0aGlzLl9jdXJyZW50TmJRdWVyaWVzID0gMDtcbn1cblxuaW5oZXJpdHMoQWxnb2xpYVNlYXJjaEhlbHBlciwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogU3RhcnQgdGhlIHNlYXJjaCB3aXRoIHRoZSBwYXJhbWV0ZXJzIHNldCBpbiB0aGUgc3RhdGUuIFdoZW4gdGhlXG4gKiBtZXRob2QgaXMgY2FsbGVkLCBpdCB0cmlnZ2VycyBhIGBzZWFyY2hgIGV2ZW50LiBUaGUgcmVzdWx0cyB3aWxsXG4gKiBiZSBhdmFpbGFibGUgdGhyb3VnaCB0aGUgYHJlc3VsdGAgZXZlbnQuIElmIGFuIGVycm9yIG9jY3VycywgYW5cbiAqIGBlcnJvcmAgd2lsbCBiZSBmaXJlZCBpbnN0ZWFkLlxuICogQHJldHVybiB7QWxnb2xpYVNlYXJjaEhlbHBlcn1cbiAqIEBmaXJlcyBzZWFyY2hcbiAqIEBmaXJlcyByZXN1bHRcbiAqIEBmaXJlcyBlcnJvclxuICogQGNoYWluYWJsZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc2VhcmNoKHtvbmx5V2l0aERlcml2ZWRIZWxwZXJzOiBmYWxzZX0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnNlYXJjaE9ubHlXaXRoRGVyaXZlZEhlbHBlcnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc2VhcmNoKHtvbmx5V2l0aERlcml2ZWRIZWxwZXJzOiB0cnVlfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzZWFyY2ggcXVlcnkgcGFyYW1ldGVycyB0aGF0IHdvdWxkIGJlIHNlbnQgdG8gdGhlIEFsZ29saWEgQ2xpZW50XG4gKiBmb3IgdGhlIGhpdHNcbiAqIEByZXR1cm4ge29iamVjdH0gUXVlcnkgUGFyYW1ldGVyc1xuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5nZXRRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICByZXR1cm4gcmVxdWVzdEJ1aWxkZXIuX2dldEhpdHNTZWFyY2hQYXJhbXMoc3RhdGUpO1xufTtcblxuLyoqXG4gKiBTdGFydCBhIHNlYXJjaCB1c2luZyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgc3RhdGUuIFRoaXMgbWV0aG9kIGRvZXNcbiAqIG5vdCB0cmlnZ2VyIHRoZSBoZWxwZXIgbGlmZWN5Y2xlIGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIHN0YXRlIGtlcHQgaW50ZXJuYWxseVxuICogYnkgdGhlIGhlbHBlci4gVGhpcyBzZWNvbmQgYXNwZWN0IG1lYW5zIHRoYXQgdGhlIG5leHQgc2VhcmNoIGNhbGwgd2lsbCBiZSB0aGVcbiAqIHNhbWUgYXMgYSBzZWFyY2ggY2FsbCBiZWZvcmUgY2FsbGluZyBzZWFyY2hPbmNlLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2FuIGNvbnRhaW4gYWxsIHRoZSBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlIHNldCB0byBTZWFyY2hQYXJhbWV0ZXJzXG4gKiBwbHVzIHRoZSBpbmRleFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBvcHRpb25hbCBjYWxsYmFjayBleGVjdXRlZCB3aGVuIHRoZSByZXNwb25zZSBmcm9tIHRoZVxuICogc2VydmVyIGlzIGJhY2suXG4gKiBAcmV0dXJuIHtwcm9taXNlfHVuZGVmaW5lZH0gaWYgYSBjYWxsYmFjayBpcyBwYXNzZWQgdGhlIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZFxuICogb3RoZXJ3aXNlIGl0IHJldHVybnMgYSBwcm9taXNlIGNvbnRhaW5pbmcgYW4gb2JqZWN0IHdpdGggdHdvIGtleXMgOlxuICogIC0gY29udGVudCB3aXRoIGEgU2VhcmNoUmVzdWx0c1xuICogIC0gc3RhdGUgd2l0aCB0aGUgc3RhdGUgdXNlZCBmb3IgdGhlIHF1ZXJ5IGFzIGEgU2VhcmNoUGFyYW1ldGVyc1xuICogQGV4YW1wbGVcbiAqIC8vIENoYW5naW5nIHRoZSBudW1iZXIgb2YgcmVjb3JkcyByZXR1cm5lZCBwZXIgcGFnZSB0byAxXG4gKiAvLyBUaGlzIGV4YW1wbGUgdXNlcyB0aGUgY2FsbGJhY2sgQVBJXG4gKiB2YXIgc3RhdGUgPSBoZWxwZXIuc2VhcmNoT25jZSh7aGl0c1BlclBhZ2U6IDF9LFxuICogICBmdW5jdGlvbihlcnJvciwgY29udGVudCwgc3RhdGUpIHtcbiAqICAgICAvLyBpZiBhbiBlcnJvciBvY2N1cnJlZCBpdCB3aWxsIGJlIHBhc3NlZCBpbiBlcnJvciwgb3RoZXJ3aXNlIGl0cyB2YWx1ZSBpcyBudWxsXG4gKiAgICAgLy8gY29udGVudCBjb250YWlucyB0aGUgcmVzdWx0cyBmb3JtYXR0ZWQgYXMgYSBTZWFyY2hSZXN1bHRzXG4gKiAgICAgLy8gc3RhdGUgaXMgdGhlIGluc3RhbmNlIG9mIFNlYXJjaFBhcmFtZXRlcnMgdXNlZCBmb3IgdGhpcyBzZWFyY2hcbiAqICAgfSk7XG4gKiBAZXhhbXBsZVxuICogLy8gQ2hhbmdpbmcgdGhlIG51bWJlciBvZiByZWNvcmRzIHJldHVybmVkIHBlciBwYWdlIHRvIDFcbiAqIC8vIFRoaXMgZXhhbXBsZSB1c2VzIHRoZSBwcm9taXNlIEFQSVxuICogdmFyIHN0YXRlMSA9IGhlbHBlci5zZWFyY2hPbmNlKHtoaXRzUGVyUGFnZTogMX0pXG4gKiAgICAgICAgICAgICAgICAgLnRoZW4ocHJvbWlzZUhhbmRsZXIpO1xuICpcbiAqIGZ1bmN0aW9uIHByb21pc2VIYW5kbGVyKHJlcykge1xuICogICAvLyByZXMgY29udGFpbnNcbiAqICAgLy8ge1xuICogICAvLyAgIGNvbnRlbnQgOiBTZWFyY2hSZXN1bHRzXG4gKiAgIC8vICAgc3RhdGUgICA6IFNlYXJjaFBhcmFtZXRlcnMgKHRoZSBvbmUgdXNlZCBmb3IgdGhpcyBzcGVjaWZpYyBzZWFyY2gpXG4gKiAgIC8vIH1cbiAqIH1cbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuc2VhcmNoT25jZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gIHZhciB0ZW1wU3RhdGUgPSAhb3B0aW9ucyA/IHRoaXMuc3RhdGUgOiB0aGlzLnN0YXRlLnNldFF1ZXJ5UGFyYW1ldGVycyhvcHRpb25zKTtcbiAgdmFyIHF1ZXJpZXMgPSByZXF1ZXN0QnVpbGRlci5fZ2V0UXVlcmllcyh0ZW1wU3RhdGUuaW5kZXgsIHRlbXBTdGF0ZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9jdXJyZW50TmJRdWVyaWVzKys7XG5cbiAgdGhpcy5lbWl0KCdzZWFyY2hPbmNlJywge1xuICAgIHN0YXRlOiB0ZW1wU3RhdGVcbiAgfSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgdGhpcy5jbGllbnRcbiAgICAgIC5zZWFyY2gocXVlcmllcylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgc2VsZi5fY3VycmVudE5iUXVlcmllcy0tO1xuICAgICAgICBpZiAoc2VsZi5fY3VycmVudE5iUXVlcmllcyA9PT0gMCkge1xuICAgICAgICAgIHNlbGYuZW1pdCgnc2VhcmNoUXVldWVFbXB0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IobnVsbCwgbmV3IFNlYXJjaFJlc3VsdHModGVtcFN0YXRlLCBjb250ZW50LnJlc3VsdHMpLCB0ZW1wU3RhdGUpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgc2VsZi5fY3VycmVudE5iUXVlcmllcy0tO1xuICAgICAgICBpZiAoc2VsZi5fY3VycmVudE5iUXVlcmllcyA9PT0gMCkge1xuICAgICAgICAgIHNlbGYuZW1pdCgnc2VhcmNoUXVldWVFbXB0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IoZXJyLCBudWxsLCB0ZW1wU3RhdGUpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY2xpZW50LnNlYXJjaChxdWVyaWVzKS50aGVuKGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICBzZWxmLl9jdXJyZW50TmJRdWVyaWVzLS07XG4gICAgaWYgKHNlbGYuX2N1cnJlbnROYlF1ZXJpZXMgPT09IDApIHNlbGYuZW1pdCgnc2VhcmNoUXVldWVFbXB0eScpO1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBuZXcgU2VhcmNoUmVzdWx0cyh0ZW1wU3RhdGUsIGNvbnRlbnQucmVzdWx0cyksXG4gICAgICBzdGF0ZTogdGVtcFN0YXRlLFxuICAgICAgX29yaWdpbmFsUmVzcG9uc2U6IGNvbnRlbnRcbiAgICB9O1xuICB9LCBmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5fY3VycmVudE5iUXVlcmllcy0tO1xuICAgIGlmIChzZWxmLl9jdXJyZW50TmJRdWVyaWVzID09PSAwKSBzZWxmLmVtaXQoJ3NlYXJjaFF1ZXVlRW1wdHknKTtcbiAgICB0aHJvdyBlO1xuICB9KTtcbn07XG5cbiAvKipcbiAqIFN0YXJ0IHRoZSBzZWFyY2ggZm9yIGFuc3dlcnMgd2l0aCB0aGUgcGFyYW1ldGVycyBzZXQgaW4gdGhlIHN0YXRlLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHRoZSBvcHRpb25zIGZvciBhbnN3ZXJzIEFQSSBjYWxsXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zLmF0dHJpYnV0ZXNGb3JQcmVkaWN0aW9uIC0gQXR0cmlidXRlcyB0byB1c2UgZm9yIHByZWRpY3Rpb25zLiBJZiBlbXB0eSwgYHNlYXJjaGFibGVBdHRyaWJ1dGVzYCBpcyB1c2VkIGluc3RlYWQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zLnF1ZXJ5TGFuZ3VhZ2VzIC0gVGhlIGxhbmd1YWdlcyBpbiB0aGUgcXVlcnkuIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIFsnZW4nXS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm5iSGl0cyAtIE1heGltdW0gbnVtYmVyIG9mIGFuc3dlcnMgdG8gcmV0cmlldmUgZnJvbSB0aGUgQW5zd2VycyBFbmdpbmUuIENhbm5vdCBiZSBncmVhdGVyIHRoYW4gMTAwMC5cbiAqXG4gKiBAcmV0dXJuIHtwcm9taXNlfSB0aGUgYW5zd2VyIHJlc3VsdHNcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuZmluZEFuc3dlcnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gIHZhciBkZXJpdmVkSGVscGVyID0gdGhpcy5kZXJpdmVkSGVscGVyc1swXTtcbiAgaWYgKCFkZXJpdmVkSGVscGVyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cbiAgdmFyIGRlcml2ZWRTdGF0ZSA9IGRlcml2ZWRIZWxwZXIuZ2V0TW9kaWZpZWRTdGF0ZShzdGF0ZSk7XG4gIHZhciBkYXRhID0gbWVyZ2UoXG4gICAge1xuICAgICAgYXR0cmlidXRlc0ZvclByZWRpY3Rpb246IG9wdGlvbnMuYXR0cmlidXRlc0ZvclByZWRpY3Rpb24sXG4gICAgICBuYkhpdHM6IG9wdGlvbnMubmJIaXRzXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXJhbXM6IG9taXQocmVxdWVzdEJ1aWxkZXIuX2dldEhpdHNTZWFyY2hQYXJhbXMoZGVyaXZlZFN0YXRlKSwgW1xuICAgICAgICAnYXR0cmlidXRlc1RvU25pcHBldCcsXG4gICAgICAgICdoaXRzUGVyUGFnZScsXG4gICAgICAgICdyZXN0cmljdFNlYXJjaGFibGVBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3NuaXBwZXRFbGxpcHNpc1RleHQnIC8vIEZJWE1FIHJlbW92ZSB0aGlzIGxpbmUgb25jZSB0aGUgZW5naW5lIGlzIGZpeGVkLlxuICAgICAgXSlcbiAgICB9XG4gICk7XG5cbiAgdmFyIGVycm9yTWVzc2FnZSA9ICdzZWFyY2ggZm9yIGFuc3dlcnMgd2FzIGNhbGxlZCwgYnV0IHRoaXMgY2xpZW50IGRvZXMgbm90IGhhdmUgYSBmdW5jdGlvbiBjbGllbnQuaW5pdEluZGV4KGluZGV4KS5maW5kQW5zd2Vycyc7XG4gIGlmICh0eXBlb2YgdGhpcy5jbGllbnQuaW5pdEluZGV4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbiAgdmFyIGluZGV4ID0gdGhpcy5jbGllbnQuaW5pdEluZGV4KGRlcml2ZWRTdGF0ZS5pbmRleCk7XG4gIGlmICh0eXBlb2YgaW5kZXguZmluZEFuc3dlcnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gaW5kZXguZmluZEFuc3dlcnMoZGVyaXZlZFN0YXRlLnF1ZXJ5LCBvcHRpb25zLnF1ZXJ5TGFuZ3VhZ2VzLCBkYXRhKTtcbn07XG5cbi8qKlxuICogU3RydWN0dXJlIG9mIGVhY2ggcmVzdWx0IHdoZW4gdXNpbmdcbiAqIFtgc2VhcmNoRm9yRmFjZXRWYWx1ZXMoKWBdKHJlZmVyZW5jZS5odG1sI0FsZ29saWFTZWFyY2hIZWxwZXIjc2VhcmNoRm9yRmFjZXRWYWx1ZXMpXG4gKiBAdHlwZWRlZiBGYWNldFNlYXJjaEhpdFxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSB0aGUgZmFjZXQgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoaWdobGlnaHRlZCB0aGUgZmFjZXQgdmFsdWUgaGlnaGxpZ2h0ZWQgd2l0aCB0aGUgcXVlcnkgc3RyaW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gY291bnQgbnVtYmVyIG9mIG9jY3VycmVuY2Ugb2YgdGhpcyBmYWNldCB2YWx1ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1JlZmluZWQgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSByZWZpbmVkXG4gKi9cblxuLyoqXG4gKiBTdHJ1Y3R1cmUgb2YgdGhlIGRhdGEgcmVzb2x2ZWQgYnkgdGhlXG4gKiBbYHNlYXJjaEZvckZhY2V0VmFsdWVzKClgXShyZWZlcmVuY2UuaHRtbCNBbGdvbGlhU2VhcmNoSGVscGVyI3NlYXJjaEZvckZhY2V0VmFsdWVzKVxuICogcHJvbWlzZS5cbiAqIEB0eXBlZGVmIEZhY2V0U2VhcmNoUmVzdWx0XG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtGYWNldFNlYXJjaEhpdH0gZmFjZXRIaXRzIHRoZSByZXN1bHRzIGZvciB0aGlzIHNlYXJjaCBmb3IgZmFjZXQgdmFsdWVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJvY2Vzc2luZ1RpbWVNUyB0aW1lIHRha2VuIGJ5IHRoZSBxdWVyeSBpbnNpZGUgdGhlIGVuZ2luZVxuICovXG5cbi8qKlxuICogU2VhcmNoIGZvciBmYWNldCB2YWx1ZXMgYmFzZWQgb24gYW4gcXVlcnkgYW5kIHRoZSBuYW1lIG9mIGEgZmFjZXRlZCBhdHRyaWJ1dGUuIFRoaXNcbiAqIHRyaWdnZXJzIGEgc2VhcmNoIGFuZCB3aWxsIHJldHVybiBhIHByb21pc2UuIE9uIHRvcCBvZiB1c2luZyB0aGUgcXVlcnksIGl0IGFsc28gc2VuZHNcbiAqIHRoZSBwYXJhbWV0ZXJzIGZyb20gdGhlIHN0YXRlIHNvIHRoYXQgdGhlIHNlYXJjaCBpcyBuYXJyb3dlZCBkb3duIHRvIG9ubHkgdGhlIHBvc3NpYmxlIHZhbHVlcy5cbiAqXG4gKiBTZWUgdGhlIGRlc2NyaXB0aW9uIG9mIFtGYWNldFNlYXJjaFJlc3VsdF0ocmVmZXJlbmNlLmh0bWwjRmFjZXRTZWFyY2hSZXN1bHQpXG4gKiBAcGFyYW0ge3N0cmluZ30gZmFjZXQgdGhlIG5hbWUgb2YgdGhlIGZhY2V0ZWQgYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgdGhlIHN0cmluZyBxdWVyeSBmb3IgdGhlIHNlYXJjaFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGYWNldEhpdHNdIHRoZSBtYXhpbXVtIG51bWJlciB2YWx1ZXMgcmV0dXJuZWQuIFNob3VsZCBiZSA+IDAgYW5kIDw9IDEwMFxuICogQHBhcmFtIHtvYmplY3R9IFt1c2VyU3RhdGVdIHRoZSBzZXQgb2YgY3VzdG9tIHBhcmFtZXRlcnMgdG8gdXNlIG9uIHRvcCBvZiB0aGUgY3VycmVudCBzdGF0ZS4gU2V0dGluZyBhIHByb3BlcnR5IHRvIGB1bmRlZmluZWRgIHJlbW92ZXNcbiAqIGl0IGluIHRoZSBnZW5lcmF0ZWQgcXVlcnkuXG4gKiBAcmV0dXJuIHtwcm9taXNlLjxGYWNldFNlYXJjaFJlc3VsdD59IHRoZSByZXN1bHRzIG9mIHRoZSBzZWFyY2hcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuc2VhcmNoRm9yRmFjZXRWYWx1ZXMgPSBmdW5jdGlvbihmYWNldCwgcXVlcnksIG1heEZhY2V0SGl0cywgdXNlclN0YXRlKSB7XG4gIHZhciBjbGllbnRIYXNTRkZWID0gdHlwZW9mIHRoaXMuY2xpZW50LnNlYXJjaEZvckZhY2V0VmFsdWVzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoXG4gICAgIWNsaWVudEhhc1NGRlYgJiZcbiAgICB0eXBlb2YgdGhpcy5jbGllbnQuaW5pdEluZGV4ICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdzZWFyY2ggZm9yIGZhY2V0IHZhbHVlcyAoc2VhcmNoYWJsZSkgd2FzIGNhbGxlZCwgYnV0IHRoaXMgY2xpZW50IGRvZXMgbm90IGhhdmUgYSBmdW5jdGlvbiBjbGllbnQuc2VhcmNoRm9yRmFjZXRWYWx1ZXMgb3IgY2xpZW50LmluaXRJbmRleChpbmRleCkuc2VhcmNoRm9yRmFjZXRWYWx1ZXMnXG4gICAgKTtcbiAgfVxuICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlLnNldFF1ZXJ5UGFyYW1ldGVycyh1c2VyU3RhdGUgfHwge30pO1xuICB2YXIgaXNEaXNqdW5jdGl2ZSA9IHN0YXRlLmlzRGlzanVuY3RpdmVGYWNldChmYWNldCk7XG4gIHZhciBhbGdvbGlhUXVlcnkgPSByZXF1ZXN0QnVpbGRlci5nZXRTZWFyY2hGb3JGYWNldFF1ZXJ5KGZhY2V0LCBxdWVyeSwgbWF4RmFjZXRIaXRzLCBzdGF0ZSk7XG5cbiAgdGhpcy5fY3VycmVudE5iUXVlcmllcysrO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5lbWl0KCdzZWFyY2hGb3JGYWNldFZhbHVlcycsIHtcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgZmFjZXQ6IGZhY2V0LFxuICAgIHF1ZXJ5OiBxdWVyeVxuICB9KTtcblxuICB2YXIgc2VhcmNoRm9yRmFjZXRWYWx1ZXNQcm9taXNlID0gY2xpZW50SGFzU0ZGVlxuICAgID8gdGhpcy5jbGllbnQuc2VhcmNoRm9yRmFjZXRWYWx1ZXMoW3tpbmRleE5hbWU6IHN0YXRlLmluZGV4LCBwYXJhbXM6IGFsZ29saWFRdWVyeX1dKVxuICAgIDogdGhpcy5jbGllbnQuaW5pdEluZGV4KHN0YXRlLmluZGV4KS5zZWFyY2hGb3JGYWNldFZhbHVlcyhhbGdvbGlhUXVlcnkpO1xuXG4gIHJldHVybiBzZWFyY2hGb3JGYWNldFZhbHVlc1Byb21pc2UudGhlbihmdW5jdGlvbiBhZGRJc1JlZmluZWQoY29udGVudCkge1xuICAgIHNlbGYuX2N1cnJlbnROYlF1ZXJpZXMtLTtcbiAgICBpZiAoc2VsZi5fY3VycmVudE5iUXVlcmllcyA9PT0gMCkgc2VsZi5lbWl0KCdzZWFyY2hRdWV1ZUVtcHR5Jyk7XG5cbiAgICBjb250ZW50ID0gQXJyYXkuaXNBcnJheShjb250ZW50KSA/IGNvbnRlbnRbMF0gOiBjb250ZW50O1xuXG4gICAgY29udGVudC5mYWNldEhpdHMuZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgICBmLmlzUmVmaW5lZCA9IGlzRGlzanVuY3RpdmVcbiAgICAgICAgPyBzdGF0ZS5pc0Rpc2p1bmN0aXZlRmFjZXRSZWZpbmVkKGZhY2V0LCBmLnZhbHVlKVxuICAgICAgICA6IHN0YXRlLmlzRmFjZXRSZWZpbmVkKGZhY2V0LCBmLnZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb250ZW50O1xuICB9LCBmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5fY3VycmVudE5iUXVlcmllcy0tO1xuICAgIGlmIChzZWxmLl9jdXJyZW50TmJRdWVyaWVzID09PSAwKSBzZWxmLmVtaXQoJ3NlYXJjaFF1ZXVlRW1wdHknKTtcbiAgICB0aHJvdyBlO1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdGV4dCBxdWVyeSB1c2VkIGZvciB0aGUgc2VhcmNoLlxuICpcbiAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCBwYWdlIHRvIDAuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHEgdGhlIHVzZXIgcXVlcnlcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24ocSkge1xuICB0aGlzLl9jaGFuZ2Uoe1xuICAgIHN0YXRlOiB0aGlzLnN0YXRlLnJlc2V0UGFnZSgpLnNldFF1ZXJ5KHEpLFxuICAgIGlzUGFnZVJlc2V0OiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRoZSB0eXBlcyBvZiByZWZpbmVtZW50cyBleGNlcHQgdGFncy4gQSBzdHJpbmcgY2FuIGJlIHByb3ZpZGVkIHRvIHJlbW92ZVxuICogb25seSB0aGUgcmVmaW5lbWVudHMgb2YgYSBzcGVjaWZpYyBhdHRyaWJ1dGUuIEZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlLCB5b3UgY2FuXG4gKiBwcm92aWRlIGEgZnVuY3Rpb24gaW5zdGVhZC4gVGhpcyBmdW5jdGlvbiBzaG91bGQgZm9sbG93IHRoZVxuICogW2NsZWFyQ2FsbGJhY2sgZGVmaW5pdGlvbl0oI1NlYXJjaFBhcmFtZXRlcnMuY2xlYXJDYWxsYmFjaykuXG4gKlxuICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50IHBhZ2UgdG8gMC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gb3B0aW9uYWwgbmFtZSBvZiB0aGUgZmFjZXQgLyBhdHRyaWJ1dGUgb24gd2hpY2ggd2Ugd2FudCB0byByZW1vdmUgYWxsIHJlZmluZW1lbnRzXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICogQGZpcmVzIGNoYW5nZVxuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqIC8vIFJlbW92aW5nIGFsbCB0aGUgcmVmaW5lbWVudHNcbiAqIGhlbHBlci5jbGVhclJlZmluZW1lbnRzKCkuc2VhcmNoKCk7XG4gKiBAZXhhbXBsZVxuICogLy8gUmVtb3ZpbmcgYWxsIHRoZSBmaWx0ZXJzIG9uIGEgdGhlIGNhdGVnb3J5IGF0dHJpYnV0ZS5cbiAqIGhlbHBlci5jbGVhclJlZmluZW1lbnRzKCdjYXRlZ29yeScpLnNlYXJjaCgpO1xuICogQGV4YW1wbGVcbiAqIC8vIFJlbW92aW5nIG9ubHkgdGhlIGV4Y2x1ZGUgZmlsdGVycyBvbiB0aGUgY2F0ZWdvcnkgZmFjZXQuXG4gKiBoZWxwZXIuY2xlYXJSZWZpbmVtZW50cyhmdW5jdGlvbih2YWx1ZSwgYXR0cmlidXRlLCB0eXBlKSB7XG4gKiAgIHJldHVybiB0eXBlID09PSAnZXhjbHVkZScgJiYgYXR0cmlidXRlID09PSAnY2F0ZWdvcnknO1xuICogfSkuc2VhcmNoKCk7XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmNsZWFyUmVmaW5lbWVudHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRoaXMuX2NoYW5nZSh7XG4gICAgc3RhdGU6IHRoaXMuc3RhdGUucmVzZXRQYWdlKCkuY2xlYXJSZWZpbmVtZW50cyhuYW1lKSxcbiAgICBpc1BhZ2VSZXNldDogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0aGUgdGFnIGZpbHRlcnMuXG4gKlxuICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50IHBhZ2UgdG8gMC5cbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmNsZWFyVGFncyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jaGFuZ2Uoe1xuICAgIHN0YXRlOiB0aGlzLnN0YXRlLnJlc2V0UGFnZSgpLmNsZWFyVGFncygpLFxuICAgIGlzUGFnZVJlc2V0OiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZGlzanVuY3RpdmUgZmlsdGVyIHRvIGEgZmFjZXRlZCBhdHRyaWJ1dGUgd2l0aCB0aGUgYHZhbHVlYCBwcm92aWRlZC4gSWYgdGhlXG4gKiBmaWx0ZXIgaXMgYWxyZWFkeSBzZXQsIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBmaWx0ZXJzLlxuICpcbiAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCBwYWdlIHRvIDAuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZhY2V0IHRoZSBmYWNldCB0byByZWZpbmVcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgdGhlIGFzc29jaWF0ZWQgdmFsdWUgKHdpbGwgYmUgY29udmVydGVkIHRvIHN0cmluZylcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmFkZERpc2p1bmN0aXZlRmFjZXRSZWZpbmVtZW50ID0gZnVuY3Rpb24oZmFjZXQsIHZhbHVlKSB7XG4gIHRoaXMuX2NoYW5nZSh7XG4gICAgc3RhdGU6IHRoaXMuc3RhdGUucmVzZXRQYWdlKCkuYWRkRGlzanVuY3RpdmVGYWNldFJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSxcbiAgICBpc1BhZ2VSZXNldDogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMCwgc2VlIHtAbGluayBBbGdvbGlhU2VhcmNoSGVscGVyI2FkZERpc2p1bmN0aXZlRmFjZXRSZWZpbmVtZW50fVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5hZGREaXNqdW5jdGl2ZVJlZmluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hZGREaXNqdW5jdGl2ZUZhY2V0UmVmaW5lbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgcmVmaW5lbWVudCBvbiBhIGhpZXJhcmNoaWNhbCBmYWNldC4gSXQgd2lsbCB0aHJvd1xuICogYW4gZXhjZXB0aW9uIGlmIHRoZSBmYWNldCBpcyBub3QgZGVmaW5lZCBvciBpZiB0aGUgZmFjZXRcbiAqIGlzIGFscmVhZHkgcmVmaW5lZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIGN1cnJlbnQgcGFnZSB0byAwLlxuICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IHRoZSBmYWNldCBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCB0aGUgaGllcmFyY2hpY2FsIGZhY2V0IHBhdGhcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBmYWNldCBpcyBub3QgZGVmaW5lZCBvciBpZiB0aGUgZmFjZXQgaXMgcmVmaW5lZFxuICogQGNoYWluYWJsZVxuICogQGZpcmVzIGNoYW5nZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5hZGRIaWVyYXJjaGljYWxGYWNldFJlZmluZW1lbnQgPSBmdW5jdGlvbihmYWNldCwgdmFsdWUpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZS5yZXNldFBhZ2UoKS5hZGRIaWVyYXJjaGljYWxGYWNldFJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSxcbiAgICBpc1BhZ2VSZXNldDogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGFuIG51bWVyaWMgZmlsdGVyIHRvIGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBgb3BlcmF0b3JgIGFuZCBgdmFsdWVgIHByb3ZpZGVkLiBJZiB0aGVcbiAqIGZpbHRlciBpcyBhbHJlYWR5IHNldCwgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIGZpbHRlcnMuXG4gKlxuICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50IHBhZ2UgdG8gMC5cbiAqIEBwYXJhbSAge3N0cmluZ30gYXR0cmlidXRlIHRoZSBhdHRyaWJ1dGUgb24gd2hpY2ggdGhlIG51bWVyaWMgZmlsdGVyIGFwcGxpZXNcbiAqIEBwYXJhbSAge3N0cmluZ30gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIG9mIHRoZSBmaWx0ZXJcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBmaWx0ZXJcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmFkZE51bWVyaWNSZWZpbmVtZW50ID0gZnVuY3Rpb24oYXR0cmlidXRlLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZS5yZXNldFBhZ2UoKS5hZGROdW1lcmljUmVmaW5lbWVudChhdHRyaWJ1dGUsIG9wZXJhdG9yLCB2YWx1ZSksXG4gICAgaXNQYWdlUmVzZXQ6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBmaWx0ZXIgdG8gYSBmYWNldGVkIGF0dHJpYnV0ZSB3aXRoIHRoZSBgdmFsdWVgIHByb3ZpZGVkLiBJZiB0aGVcbiAqIGZpbHRlciBpcyBhbHJlYWR5IHNldCwgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIGZpbHRlcnMuXG4gKlxuICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50IHBhZ2UgdG8gMC5cbiAqIEBwYXJhbSAge3N0cmluZ30gZmFjZXQgdGhlIGZhY2V0IHRvIHJlZmluZVxuICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSB0aGUgYXNzb2NpYXRlZCB2YWx1ZSAod2lsbCBiZSBjb252ZXJ0ZWQgdG8gc3RyaW5nKVxuICogQHJldHVybiB7QWxnb2xpYVNlYXJjaEhlbHBlcn1cbiAqIEBmaXJlcyBjaGFuZ2VcbiAqIEBjaGFpbmFibGVcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuYWRkRmFjZXRSZWZpbmVtZW50ID0gZnVuY3Rpb24oZmFjZXQsIHZhbHVlKSB7XG4gIHRoaXMuX2NoYW5nZSh7XG4gICAgc3RhdGU6IHRoaXMuc3RhdGUucmVzZXRQYWdlKCkuYWRkRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSksXG4gICAgaXNQYWdlUmVzZXQ6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjAsIHNlZSB7QGxpbmsgQWxnb2xpYVNlYXJjaEhlbHBlciNhZGRGYWNldFJlZmluZW1lbnR9XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmFkZFJlZmluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hZGRGYWNldFJlZmluZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqXG4gKiBBZGRzIGEgYW4gZXhjbHVzaW9uIGZpbHRlciB0byBhIGZhY2V0ZWQgYXR0cmlidXRlIHdpdGggdGhlIGB2YWx1ZWAgcHJvdmlkZWQuIElmIHRoZVxuICogZmlsdGVyIGlzIGFscmVhZHkgc2V0LCBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgZmlsdGVycy5cbiAqXG4gKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIGN1cnJlbnQgcGFnZSB0byAwLlxuICogQHBhcmFtICB7c3RyaW5nfSBmYWNldCB0aGUgZmFjZXQgdG8gcmVmaW5lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlICh3aWxsIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcpXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICogQGZpcmVzIGNoYW5nZVxuICogQGNoYWluYWJsZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5hZGRGYWNldEV4Y2x1c2lvbiA9IGZ1bmN0aW9uKGZhY2V0LCB2YWx1ZSkge1xuICB0aGlzLl9jaGFuZ2Uoe1xuICAgIHN0YXRlOiB0aGlzLnN0YXRlLnJlc2V0UGFnZSgpLmFkZEV4Y2x1ZGVSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSksXG4gICAgaXNQYWdlUmVzZXQ6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjAsIHNlZSB7QGxpbmsgQWxnb2xpYVNlYXJjaEhlbHBlciNhZGRGYWNldEV4Y2x1c2lvbn1cbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuYWRkRXhjbHVkZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hZGRGYWNldEV4Y2x1c2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdGFnIGZpbHRlciB3aXRoIHRoZSBgdGFnYCBwcm92aWRlZC4gSWYgdGhlXG4gKiBmaWx0ZXIgaXMgYWxyZWFkeSBzZXQsIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBmaWx0ZXJzLlxuICpcbiAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCBwYWdlIHRvIDAuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIHRoZSB0YWcgdG8gYWRkIHRvIHRoZSBmaWx0ZXJcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmFkZFRhZyA9IGZ1bmN0aW9uKHRhZykge1xuICB0aGlzLl9jaGFuZ2Uoe1xuICAgIHN0YXRlOiB0aGlzLnN0YXRlLnJlc2V0UGFnZSgpLmFkZFRhZ1JlZmluZW1lbnQodGFnKSxcbiAgICBpc1BhZ2VSZXNldDogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBudW1lcmljIGZpbHRlciB0byBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgYG9wZXJhdG9yYCBhbmQgYHZhbHVlYCBwcm92aWRlZC4gSWYgdGhlXG4gKiBmaWx0ZXIgaXMgbm90IHNldCwgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIGZpbHRlcnMuXG4gKlxuICogU29tZSBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbCwgdHJpZ2dlcmluZyBkaWZmZXJlbnQgYmVoYXZpb3I6XG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGVuIGFsbCB0aGUgbnVtZXJpYyB2YWx1ZSB3aWxsIGJlIHJlbW92ZWQgZm9yIHRoZVxuICogIHNwZWNpZmllZCBhdHRyaWJ1dGUvb3BlcmF0b3IgY291cGxlLlxuICogIC0gaWYgdGhlIG9wZXJhdG9yIGlzIG5vdCBwcm92aWRlZCBlaXRoZXIsIHRoZW4gYWxsIHRoZSBudW1lcmljIGZpbHRlciBvbiB0aGlzIGF0dHJpYnV0ZVxuICogIHdpbGwgYmUgcmVtb3ZlZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIGN1cnJlbnQgcGFnZSB0byAwLlxuICogQHBhcmFtICB7c3RyaW5nfSBhdHRyaWJ1dGUgdGhlIGF0dHJpYnV0ZSBvbiB3aGljaCB0aGUgbnVtZXJpYyBmaWx0ZXIgYXBwbGllc1xuICogQHBhcmFtICB7c3RyaW5nfSBbb3BlcmF0b3JdIHRoZSBvcGVyYXRvciBvZiB0aGUgZmlsdGVyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt2YWx1ZV0gdGhlIHZhbHVlIG9mIHRoZSBmaWx0ZXJcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnJlbW92ZU51bWVyaWNSZWZpbmVtZW50ID0gZnVuY3Rpb24oYXR0cmlidXRlLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZS5yZXNldFBhZ2UoKS5yZW1vdmVOdW1lcmljUmVmaW5lbWVudChhdHRyaWJ1dGUsIG9wZXJhdG9yLCB2YWx1ZSksXG4gICAgaXNQYWdlUmVzZXQ6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBkaXNqdW5jdGl2ZSBmaWx0ZXIgdG8gYSBmYWNldGVkIGF0dHJpYnV0ZSB3aXRoIHRoZSBgdmFsdWVgIHByb3ZpZGVkLiBJZiB0aGVcbiAqIGZpbHRlciBpcyBub3Qgc2V0LCBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgZmlsdGVycy5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgb21pdHRlZCwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHJlbW92ZSBhbGwgdGhlIGZpbHRlcnMgZm9yIHRoZVxuICogYXR0cmlidXRlLlxuICpcbiAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCBwYWdlIHRvIDAuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZhY2V0IHRoZSBmYWNldCB0byByZWZpbmVcbiAqIEBwYXJhbSAge3N0cmluZ30gW3ZhbHVlXSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICogQHJldHVybiB7QWxnb2xpYVNlYXJjaEhlbHBlcn1cbiAqIEBmaXJlcyBjaGFuZ2VcbiAqIEBjaGFpbmFibGVcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUucmVtb3ZlRGlzanVuY3RpdmVGYWNldFJlZmluZW1lbnQgPSBmdW5jdGlvbihmYWNldCwgdmFsdWUpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZS5yZXNldFBhZ2UoKS5yZW1vdmVEaXNqdW5jdGl2ZUZhY2V0UmVmaW5lbWVudChmYWNldCwgdmFsdWUpLFxuICAgIGlzUGFnZVJlc2V0OiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLCBzZWUge0BsaW5rIEFsZ29saWFTZWFyY2hIZWxwZXIjcmVtb3ZlRGlzanVuY3RpdmVGYWNldFJlZmluZW1lbnR9XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnJlbW92ZURpc2p1bmN0aXZlUmVmaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlbW92ZURpc2p1bmN0aXZlRmFjZXRSZWZpbmVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHJlZmluZW1lbnQgc2V0IG9uIGEgaGllcmFyY2hpY2FsIGZhY2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0IHRoZSBmYWNldCBuYW1lXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgZmFjZXQgaXMgbm90IGRlZmluZWQgb3IgaWYgdGhlIGZhY2V0IGlzIG5vdCByZWZpbmVkXG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnJlbW92ZUhpZXJhcmNoaWNhbEZhY2V0UmVmaW5lbWVudCA9IGZ1bmN0aW9uKGZhY2V0KSB7XG4gIHRoaXMuX2NoYW5nZSh7XG4gICAgc3RhdGU6IHRoaXMuc3RhdGUucmVzZXRQYWdlKCkucmVtb3ZlSGllcmFyY2hpY2FsRmFjZXRSZWZpbmVtZW50KGZhY2V0KSxcbiAgICBpc1BhZ2VSZXNldDogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGZpbHRlciB0byBhIGZhY2V0ZWQgYXR0cmlidXRlIHdpdGggdGhlIGB2YWx1ZWAgcHJvdmlkZWQuIElmIHRoZVxuICogZmlsdGVyIGlzIG5vdCBzZXQsIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBmaWx0ZXJzLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgcmVtb3ZlIGFsbCB0aGUgZmlsdGVycyBmb3IgdGhlXG4gKiBhdHRyaWJ1dGUuXG4gKlxuICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50IHBhZ2UgdG8gMC5cbiAqIEBwYXJhbSAge3N0cmluZ30gZmFjZXQgdGhlIGZhY2V0IHRvIHJlZmluZVxuICogQHBhcmFtICB7c3RyaW5nfSBbdmFsdWVdIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICogQGZpcmVzIGNoYW5nZVxuICogQGNoYWluYWJsZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5yZW1vdmVGYWNldFJlZmluZW1lbnQgPSBmdW5jdGlvbihmYWNldCwgdmFsdWUpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZS5yZXNldFBhZ2UoKS5yZW1vdmVGYWNldFJlZmluZW1lbnQoZmFjZXQsIHZhbHVlKSxcbiAgICBpc1BhZ2VSZXNldDogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMCwgc2VlIHtAbGluayBBbGdvbGlhU2VhcmNoSGVscGVyI3JlbW92ZUZhY2V0UmVmaW5lbWVudH1cbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUucmVtb3ZlUmVmaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlbW92ZUZhY2V0UmVmaW5lbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV4Y2x1c2lvbiBmaWx0ZXIgdG8gYSBmYWNldGVkIGF0dHJpYnV0ZSB3aXRoIHRoZSBgdmFsdWVgIHByb3ZpZGVkLiBJZiB0aGVcbiAqIGZpbHRlciBpcyBub3Qgc2V0LCBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgZmlsdGVycy5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgb21pdHRlZCwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHJlbW92ZSBhbGwgdGhlIGZpbHRlcnMgZm9yIHRoZVxuICogYXR0cmlidXRlLlxuICpcbiAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCBwYWdlIHRvIDAuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZhY2V0IHRoZSBmYWNldCB0byByZWZpbmVcbiAqIEBwYXJhbSAge3N0cmluZ30gW3ZhbHVlXSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICogQHJldHVybiB7QWxnb2xpYVNlYXJjaEhlbHBlcn1cbiAqIEBmaXJlcyBjaGFuZ2VcbiAqIEBjaGFpbmFibGVcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUucmVtb3ZlRmFjZXRFeGNsdXNpb24gPSBmdW5jdGlvbihmYWNldCwgdmFsdWUpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZS5yZXNldFBhZ2UoKS5yZW1vdmVFeGNsdWRlUmVmaW5lbWVudChmYWNldCwgdmFsdWUpLFxuICAgIGlzUGFnZVJlc2V0OiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLCBzZWUge0BsaW5rIEFsZ29saWFTZWFyY2hIZWxwZXIjcmVtb3ZlRmFjZXRFeGNsdXNpb259XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnJlbW92ZUV4Y2x1ZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlRmFjZXRFeGNsdXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHRhZyBmaWx0ZXIgd2l0aCB0aGUgYHRhZ2AgcHJvdmlkZWQuIElmIHRoZVxuICogZmlsdGVyIGlzIG5vdCBzZXQsIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBmaWx0ZXJzLlxuICpcbiAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCBwYWdlIHRvIDAuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIHRhZyB0byByZW1vdmUgZnJvbSB0aGUgZmlsdGVyXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICogQGZpcmVzIGNoYW5nZVxuICogQGNoYWluYWJsZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5yZW1vdmVUYWcgPSBmdW5jdGlvbih0YWcpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZS5yZXNldFBhZ2UoKS5yZW1vdmVUYWdSZWZpbmVtZW50KHRhZyksXG4gICAgaXNQYWdlUmVzZXQ6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhbiBleGNsdXNpb24gZmlsdGVyIHRvIGEgZmFjZXRlZCBhdHRyaWJ1dGUgd2l0aCB0aGUgYHZhbHVlYCBwcm92aWRlZC4gSWZcbiAqIHRoZSB2YWx1ZSBpcyBzZXQgdGhlbiBpdCByZW1vdmVzIGl0LCBvdGhlcndpc2UgaXQgYWRkcyB0aGUgZmlsdGVyLlxuICpcbiAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCBwYWdlIHRvIDAuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZhY2V0IHRoZSBmYWNldCB0byByZWZpbmVcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgdGhlIGFzc29jaWF0ZWQgdmFsdWVcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnRvZ2dsZUZhY2V0RXhjbHVzaW9uID0gZnVuY3Rpb24oZmFjZXQsIHZhbHVlKSB7XG4gIHRoaXMuX2NoYW5nZSh7XG4gICAgc3RhdGU6IHRoaXMuc3RhdGUucmVzZXRQYWdlKCkudG9nZ2xlRXhjbHVkZUZhY2V0UmVmaW5lbWVudChmYWNldCwgdmFsdWUpLFxuICAgIGlzUGFnZVJlc2V0OiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLCBzZWUge0BsaW5rIEFsZ29saWFTZWFyY2hIZWxwZXIjdG9nZ2xlRmFjZXRFeGNsdXNpb259XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnRvZ2dsZUV4Y2x1ZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9nZ2xlRmFjZXRFeGNsdXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgZmlsdGVyIHRvIGEgZmFjZXRlZCBhdHRyaWJ1dGUgd2l0aCB0aGUgYHZhbHVlYCBwcm92aWRlZC4gSWZcbiAqIHRoZSB2YWx1ZSBpcyBzZXQgdGhlbiBpdCByZW1vdmVzIGl0LCBvdGhlcndpc2UgaXQgYWRkcyB0aGUgZmlsdGVyLlxuICpcbiAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBjb25qdW5jdGl2ZSwgZGlzanVuY3RpdmUgYW5kIGhpZXJhcmNoaWNhbCBmaWx0ZXJzLlxuICpcbiAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudCBwYWdlIHRvIDAuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZhY2V0IHRoZSBmYWNldCB0byByZWZpbmVcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgdGhlIGFzc29jaWF0ZWQgdmFsdWVcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAdGhyb3dzIEVycm9yIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZhY2V0IGlzIG5vdCBkZWNsYXJlZCBpbiB0aGUgc2V0dGluZ3Mgb2YgdGhlIGhlbHBlclxuICogQGZpcmVzIGNoYW5nZVxuICogQGNoYWluYWJsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjE5LjAsIHNlZSB7QGxpbmsgQWxnb2xpYVNlYXJjaEhlbHBlciN0b2dnbGVGYWNldFJlZmluZW1lbnR9XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnRvZ2dsZVJlZmluZW1lbnQgPSBmdW5jdGlvbihmYWNldCwgdmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMudG9nZ2xlRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIGZpbHRlciB0byBhIGZhY2V0ZWQgYXR0cmlidXRlIHdpdGggdGhlIGB2YWx1ZWAgcHJvdmlkZWQuIElmXG4gKiB0aGUgdmFsdWUgaXMgc2V0IHRoZW4gaXQgcmVtb3ZlcyBpdCwgb3RoZXJ3aXNlIGl0IGFkZHMgdGhlIGZpbHRlci5cbiAqXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgY29uanVuY3RpdmUsIGRpc2p1bmN0aXZlIGFuZCBoaWVyYXJjaGljYWwgZmlsdGVycy5cbiAqXG4gKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIGN1cnJlbnQgcGFnZSB0byAwLlxuICogQHBhcmFtICB7c3RyaW5nfSBmYWNldCB0aGUgZmFjZXQgdG8gcmVmaW5lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICogQHRocm93cyBFcnJvciB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBmYWNldCBpcyBub3QgZGVjbGFyZWQgaW4gdGhlIHNldHRpbmdzIG9mIHRoZSBoZWxwZXJcbiAqIEBmaXJlcyBjaGFuZ2VcbiAqIEBjaGFpbmFibGVcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUudG9nZ2xlRmFjZXRSZWZpbmVtZW50ID0gZnVuY3Rpb24oZmFjZXQsIHZhbHVlKSB7XG4gIHRoaXMuX2NoYW5nZSh7XG4gICAgc3RhdGU6IHRoaXMuc3RhdGUucmVzZXRQYWdlKCkudG9nZ2xlRmFjZXRSZWZpbmVtZW50KGZhY2V0LCB2YWx1ZSksXG4gICAgaXNQYWdlUmVzZXQ6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjAsIHNlZSB7QGxpbmsgQWxnb2xpYVNlYXJjaEhlbHBlciN0b2dnbGVGYWNldFJlZmluZW1lbnR9XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnRvZ2dsZVJlZmluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2dnbGVGYWNldFJlZmluZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgdGFnIGZpbHRlciB3aXRoIHRoZSBgdmFsdWVgIHByb3ZpZGVkLiBJZlxuICogdGhlIHZhbHVlIGlzIHNldCB0aGVuIGl0IHJlbW92ZXMgaXQsIG90aGVyd2lzZSBpdCBhZGRzIHRoZSBmaWx0ZXIuXG4gKlxuICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50IHBhZ2UgdG8gMC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgdGFnIHRvIHJlbW92ZSBvciBhZGRcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnRvZ2dsZVRhZyA9IGZ1bmN0aW9uKHRhZykge1xuICB0aGlzLl9jaGFuZ2Uoe1xuICAgIHN0YXRlOiB0aGlzLnN0YXRlLnJlc2V0UGFnZSgpLnRvZ2dsZVRhZ1JlZmluZW1lbnQodGFnKSxcbiAgICBpc1BhZ2VSZXNldDogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5jcmVtZW50cyB0aGUgcGFnZSBudW1iZXIgYnkgb25lLlxuICogQHJldHVybiB7QWxnb2xpYVNlYXJjaEhlbHBlcn1cbiAqIEBmaXJlcyBjaGFuZ2VcbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiBoZWxwZXIuc2V0UGFnZSgwKS5uZXh0UGFnZSgpLmdldFBhZ2UoKTtcbiAqIC8vIHJldHVybnMgMVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5uZXh0UGFnZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFnZSA9IHRoaXMuc3RhdGUucGFnZSB8fCAwO1xuICByZXR1cm4gdGhpcy5zZXRQYWdlKHBhZ2UgKyAxKTtcbn07XG5cbi8qKlxuICogRGVjcmVtZW50cyB0aGUgcGFnZSBudW1iZXIgYnkgb25lLlxuICogQGZpcmVzIGNoYW5nZVxuICogQHJldHVybiB7QWxnb2xpYVNlYXJjaEhlbHBlcn1cbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKiBoZWxwZXIuc2V0UGFnZSgxKS5wcmV2aW91c1BhZ2UoKS5nZXRQYWdlKCk7XG4gKiAvLyByZXR1cm5zIDBcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUucHJldmlvdXNQYWdlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYWdlID0gdGhpcy5zdGF0ZS5wYWdlIHx8IDA7XG4gIHJldHVybiB0aGlzLnNldFBhZ2UocGFnZSAtIDEpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDdXJyZW50UGFnZShwYWdlKSB7XG4gIGlmIChwYWdlIDwgMCkgdGhyb3cgbmV3IEVycm9yKCdQYWdlIHJlcXVlc3RlZCBiZWxvdyAwLicpO1xuXG4gIHRoaXMuX2NoYW5nZSh7XG4gICAgc3RhdGU6IHRoaXMuc3RhdGUuc2V0UGFnZShwYWdlKSxcbiAgICBpc1BhZ2VSZXNldDogZmFsc2VcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBjdXJyZW50IHBhZ2VcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBhZ2UgVGhlIHBhZ2UgbnVtYmVyXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICogQGZpcmVzIGNoYW5nZVxuICogQGNoYWluYWJsZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5zZXRDdXJyZW50UGFnZSA9IHNldEN1cnJlbnRQYWdlO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgcGFnZS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBwYWdlIFRoZSBwYWdlIG51bWJlclxuICogQHJldHVybiB7QWxnb2xpYVNlYXJjaEhlbHBlcn1cbiAqIEBmaXJlcyBjaGFuZ2VcbiAqIEBjaGFpbmFibGVcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuc2V0UGFnZSA9IHNldEN1cnJlbnRQYWdlO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG5hbWUgb2YgdGhlIGluZGV4IHRoYXQgd2lsbCBiZSB0YXJnZXRlZCBieSB0aGUgcXVlcnkuXG4gKlxuICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50IHBhZ2UgdG8gMC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBpbmRleCBuYW1lXG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICogQGZpcmVzIGNoYW5nZVxuICogQGNoYWluYWJsZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5zZXRJbmRleCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZS5yZXNldFBhZ2UoKS5zZXRJbmRleChuYW1lKSxcbiAgICBpc1BhZ2VSZXNldDogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgcGFyYW1ldGVyIG9mIHRoZSBzZWFyY2guIFRoaXMgbWV0aG9kIHJlc2V0IHRoZSBwYWdlXG4gKlxuICogVGhlIGNvbXBsZXRlIGxpc3Qgb2YgcGFyYW1ldGVycyBpcyBhdmFpbGFibGUgb24gdGhlXG4gKiBbQWxnb2xpYSB3ZWJzaXRlXShodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdCNxdWVyeS1hbi1pbmRleCkuXG4gKiBUaGUgbW9zdCBjb21tb25seSB1c2VkIHBhcmFtZXRlcnMgaGF2ZSB0aGVpciBvd24gW3Nob3J0Y3V0c10oI3F1ZXJ5LXBhcmFtZXRlcnMtc2hvcnRjdXRzKVxuICogb3IgYmVuZWZpdCBmcm9tIGhpZ2hlci1sZXZlbCBBUElzIChhbGwgdGhlIGtpbmQgb2YgZmlsdGVycyBhbmQgZmFjZXRzIGhhdmUgdGhlaXIgb3duIEFQSSlcbiAqXG4gKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIGN1cnJlbnQgcGFnZSB0byAwLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlciBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgbmV3IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICogaGVscGVyLnNldFF1ZXJ5UGFyYW1ldGVyKCdoaXRzUGVyUGFnZScsIDIwKS5zZWFyY2goKTtcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuc2V0UXVlcnlQYXJhbWV0ZXIgPSBmdW5jdGlvbihwYXJhbWV0ZXIsIHZhbHVlKSB7XG4gIHRoaXMuX2NoYW5nZSh7XG4gICAgc3RhdGU6IHRoaXMuc3RhdGUucmVzZXRQYWdlKCkuc2V0UXVlcnlQYXJhbWV0ZXIocGFyYW1ldGVyLCB2YWx1ZSksXG4gICAgaXNQYWdlUmVzZXQ6IHRydWVcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgd2hvbGUgc3RhdGUgKHdhcm5pbmc6IHdpbGwgZXJhc2UgcHJldmlvdXMgc3RhdGUpXG4gKiBAcGFyYW0ge1NlYXJjaFBhcmFtZXRlcnN9IG5ld1N0YXRlIHRoZSB3aG9sZSBuZXcgc3RhdGVcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZmlyZXMgY2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgdGhpcy5fY2hhbmdlKHtcbiAgICBzdGF0ZTogU2VhcmNoUGFyYW1ldGVycy5tYWtlKG5ld1N0YXRlKSxcbiAgICBpc1BhZ2VSZXNldDogZmFsc2VcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGhvdXQgdHJpZ2dlcmluZyBhIGNoYW5nZSBldmVudC5cbiAqIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy4gKHNlZSB0aGUgZXhhbXBsZVxuICogZm9yIGEgbGVnaXQgdXNlIGNhc2UpXG4gKiBAcGFyYW0ge1NlYXJjaFBhcmFtZXRlcnN9IG5ld1N0YXRlIHRoZSB3aG9sZSBuZXcgc3RhdGVcbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKiBAZXhhbXBsZVxuICogIGhlbHBlci5vbignY2hhbmdlJywgZnVuY3Rpb24oc3RhdGUpe1xuICogICAgLy8gSW4gdGhpcyBmdW5jdGlvbiB5b3UgbWlnaHQgd2FudCB0byBmaW5kIGEgd2F5IHRvIHN0b3JlIHRoZSBzdGF0ZSBpbiB0aGUgdXJsL2hpc3RvcnlcbiAqICAgIHVwZGF0ZVlvdXJVUkwoc3RhdGUpXG4gKiAgfSlcbiAqICB3aW5kb3cub25wb3BzdGF0ZSA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAqICAgIC8vIFRoaXMgaXMgbmFpdmUgdGhvdWdoIGFzIHlvdSBzaG91bGQgY2hlY2sgaWYgdGhlIHN0YXRlIGlzIHJlYWxseSBkZWZpbmVkIGV0Yy5cbiAqICAgIGhlbHBlci5vdmVycmlkZVN0YXRlV2l0aG91dFRyaWdnZXJpbmdDaGFuZ2VFdmVudChldmVudC5zdGF0ZSkuc2VhcmNoKClcbiAqICB9XG4gKiBAY2hhaW5hYmxlXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLm92ZXJyaWRlU3RhdGVXaXRob3V0VHJpZ2dlcmluZ0NoYW5nZUV2ZW50ID0gZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgdGhpcy5zdGF0ZSA9IG5ldyBTZWFyY2hQYXJhbWV0ZXJzKG5ld1N0YXRlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBoYXMgYW55IG51bWVyaWMsIGNvbmp1bmN0aXZlLCBkaXNqdW5jdGl2ZSBvciBoaWVyYXJjaGljYWwgZmlsdGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXR0cmlidXRlIGlzIGZpbHRlcmVkIGJ5IGF0IGxlYXN0IG9uZSB2YWx1ZVxuICogQGV4YW1wbGVcbiAqIC8vIGhhc1JlZmluZW1lbnRzIHdvcmtzIHdpdGggbnVtZXJpYywgY29uanVuY3RpdmUsIGRpc2p1bmN0aXZlIGFuZCBoaWVyYXJjaGljYWwgZmlsdGVyc1xuICogaGVscGVyLmhhc1JlZmluZW1lbnRzKCdwcmljZScpOyAvLyBmYWxzZVxuICogaGVscGVyLmFkZE51bWVyaWNSZWZpbmVtZW50KCdwcmljZScsICc+JywgMTAwKTtcbiAqIGhlbHBlci5oYXNSZWZpbmVtZW50cygncHJpY2UnKTsgLy8gdHJ1ZVxuICpcbiAqIGhlbHBlci5oYXNSZWZpbmVtZW50cygnY29sb3InKTsgLy8gZmFsc2VcbiAqIGhlbHBlci5hZGRGYWNldFJlZmluZW1lbnQoJ2NvbG9yJywgJ2JsdWUnKTtcbiAqIGhlbHBlci5oYXNSZWZpbmVtZW50cygnY29sb3InKTsgLy8gdHJ1ZVxuICpcbiAqIGhlbHBlci5oYXNSZWZpbmVtZW50cygnbWF0ZXJpYWwnKTsgLy8gZmFsc2VcbiAqIGhlbHBlci5hZGREaXNqdW5jdGl2ZUZhY2V0UmVmaW5lbWVudCgnbWF0ZXJpYWwnLCAncGxhc3RpYycpO1xuICogaGVscGVyLmhhc1JlZmluZW1lbnRzKCdtYXRlcmlhbCcpOyAvLyB0cnVlXG4gKlxuICogaGVscGVyLmhhc1JlZmluZW1lbnRzKCdjYXRlZ29yaWVzJyk7IC8vIGZhbHNlXG4gKiBoZWxwZXIudG9nZ2xlRmFjZXRSZWZpbmVtZW50KCdjYXRlZ29yaWVzJywgJ2tpdGNoZW4gPiBrbmlmZScpO1xuICogaGVscGVyLmhhc1JlZmluZW1lbnRzKCdjYXRlZ29yaWVzJyk7IC8vIHRydWVcbiAqXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmhhc1JlZmluZW1lbnRzID0gZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gIGlmIChvYmplY3RIYXNLZXlzKHRoaXMuc3RhdGUuZ2V0TnVtZXJpY1JlZmluZW1lbnRzKGF0dHJpYnV0ZSkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc0Nvbmp1bmN0aXZlRmFjZXQoYXR0cmlidXRlKSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRmFjZXRSZWZpbmVkKGF0dHJpYnV0ZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pc0Rpc2p1bmN0aXZlRmFjZXQoYXR0cmlidXRlKSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRGlzanVuY3RpdmVGYWNldFJlZmluZWQoYXR0cmlidXRlKTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmlzSGllcmFyY2hpY2FsRmFjZXQoYXR0cmlidXRlKSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzSGllcmFyY2hpY2FsRmFjZXRSZWZpbmVkKGF0dHJpYnV0ZSk7XG4gIH1cblxuICAvLyB0aGVyZSdzIGN1cnJlbnRseSBubyB3YXkgdG8ga25vdyB0aGF0IHRoZSB1c2VyIGRpZCBjYWxsIGBhZGROdW1lcmljUmVmaW5lbWVudGAgYXQgc29tZSBwb2ludFxuICAvLyB0aHVzIHdlIGNhbm5vdCBkaXN0aW5ndWlzaCBpZiB0aGVyZSBvbmNlIHdhcyBhIG51bWVyaWMgcmVmaW5lbWVudCB0aGF0IHdhcyBjbGVhcmVkXG4gIC8vIHNvIHdlIHdpbGwgcmV0dXJuIGZhbHNlIGluIGV2ZXJ5IG90aGVyIHNpdHVhdGlvbnMgdG8gYmUgY29uc2lzdGVudFxuICAvLyB3aGlsZSB3aGF0IHdlIHNob3VsZCBkbyBoZXJlIGlzIHRocm93IGJlY2F1c2Ugd2UgZGlkIG5vdCBmaW5kIHRoZSBhdHRyaWJ1dGUgaW4gYW55IHR5cGVcbiAgLy8gb2YgcmVmaW5lbWVudFxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgZXhjbHVkZWQgZm9yIGEgc3BlY2lmaWMgZmFjZXRlZCBhdHRyaWJ1dGUuIElmIHRoZSB2YWx1ZVxuICogaXMgb21pdHRlZCB0aGVuIHRoZSBmdW5jdGlvbiBjaGVja3MgaWYgdGhlcmUgaXMgYW55IGV4Y2x1ZGluZyByZWZpbmVtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBmYWNldCBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgZm9yIHVzZWQgZm9yIGZhY2V0aW5nXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBbdmFsdWVdIG9wdGlvbmFsIHZhbHVlLiBJZiBwYXNzZWQgd2lsbCB0ZXN0IHRoYXQgdGhpcyB2YWx1ZVxuICAgKiBpcyBmaWx0ZXJpbmcgdGhlIGdpdmVuIGZhY2V0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiByZWZpbmVkXG4gKiBAZXhhbXBsZVxuICogaGVscGVyLmlzRXhjbHVkZVJlZmluZWQoJ2NvbG9yJyk7IC8vIGZhbHNlXG4gKiBoZWxwZXIuaXNFeGNsdWRlUmVmaW5lZCgnY29sb3InLCAnYmx1ZScpIC8vIGZhbHNlXG4gKiBoZWxwZXIuaXNFeGNsdWRlUmVmaW5lZCgnY29sb3InLCAncmVkJykgLy8gZmFsc2VcbiAqXG4gKiBoZWxwZXIuYWRkRmFjZXRFeGNsdXNpb24oJ2NvbG9yJywgJ3JlZCcpO1xuICpcbiAqIGhlbHBlci5pc0V4Y2x1ZGVSZWZpbmVkKCdjb2xvcicpOyAvLyB0cnVlXG4gKiBoZWxwZXIuaXNFeGNsdWRlUmVmaW5lZCgnY29sb3InLCAnYmx1ZScpIC8vIGZhbHNlXG4gKiBoZWxwZXIuaXNFeGNsdWRlUmVmaW5lZCgnY29sb3InLCAncmVkJykgLy8gdHJ1ZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5pc0V4Y2x1ZGVkID0gZnVuY3Rpb24oZmFjZXQsIHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlLmlzRXhjbHVkZVJlZmluZWQoZmFjZXQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgMi40LjAsIHNlZSB7QGxpbmsgQWxnb2xpYVNlYXJjaEhlbHBlciNoYXNSZWZpbmVtZW50c31cbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuaXNEaXNqdW5jdGl2ZVJlZmluZWQgPSBmdW5jdGlvbihmYWNldCwgdmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGUuaXNEaXNqdW5jdGl2ZUZhY2V0UmVmaW5lZChmYWNldCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgc3RyaW5nIGlzIGEgY3VycmVudGx5IGZpbHRlcmluZyB0YWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIHRhZyB0byBjaGVja1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuaGFzVGFnID0gZnVuY3Rpb24odGFnKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlLmlzVGFnUmVmaW5lZCh0YWcpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSAyLjQuMCwgc2VlIHtAbGluayBBbGdvbGlhU2VhcmNoSGVscGVyI2hhc1RhZ31cbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuaXNUYWdSZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmhhc1RhZ1JlZmluZW1lbnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgdXNlZCBpbmRleC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBleGFtcGxlXG4gKiBoZWxwZXIuc2V0SW5kZXgoJ2hpZ2hlc3RQcmljZV9wcm9kdWN0cycpLmdldEluZGV4KCk7XG4gKiAvLyByZXR1cm5zICdoaWdoZXN0UHJpY2VfcHJvZHVjdHMnXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlLmluZGV4O1xufTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFBhZ2UoKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlLnBhZ2U7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcGFnZVxuICogQGRlcHJlY2F0ZWRcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgcGFnZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5nZXRDdXJyZW50UGFnZSA9IGdldEN1cnJlbnRQYWdlO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwYWdlXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgcGFnZVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5nZXRQYWdlID0gZ2V0Q3VycmVudFBhZ2U7XG5cbi8qKlxuICogR2V0IGFsbCB0aGUgdGFncyBjdXJyZW50bHkgc2V0IHRvIGZpbHRlcnMgdGhlIHJlc3VsdHMuXG4gKlxuICogQHJldHVybiB7c3RyaW5nW119IFRoZSBsaXN0IG9mIHRhZ3MgY3VycmVudGx5IHNldC5cbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuZ2V0VGFncyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zdGF0ZS50YWdSZWZpbmVtZW50cztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIHJlZmluZW1lbnRzIGZvciBhIGdpdmVuIGF0dHJpYnV0ZS4gVGhpcyBtZXRob2Qgd29ya3Mgd2l0aFxuICogY29uanVuY3RpdmUsIGRpc2p1bmN0aXZlLCBleGNsdWRpbmcgYW5kIG51bWVyaWNhbCBmaWx0ZXJzLlxuICpcbiAqIFNlZSBhbHNvIFNlYXJjaFJlc3VsdHMjZ2V0UmVmaW5lbWVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmFjZXROYW1lIGF0dHJpYnV0ZSBuYW1lIHVzZWQgZm9yIGZhY2V0aW5nXG4gKiBAcmV0dXJuIHtBcnJheS48RmFjZXRSZWZpbmVtZW50fE51bWVyaWNSZWZpbmVtZW50Pn0gQWxsIFJlZmluZW1lbnQgYXJlIG9iamVjdHMgdGhhdCBjb250YWluIGEgdmFsdWUsIGFuZFxuICogYSB0eXBlLiBOdW1lcmljIGFsc28gY29udGFpbnMgYW4gb3BlcmF0b3IuXG4gKiBAZXhhbXBsZVxuICogaGVscGVyLmFkZE51bWVyaWNSZWZpbmVtZW50KCdwcmljZScsICc+JywgMTAwKTtcbiAqIGhlbHBlci5nZXRSZWZpbmVtZW50cygncHJpY2UnKTtcbiAqIC8vIFtcbiAqIC8vICAge1xuICogLy8gICAgIFwidmFsdWVcIjogW1xuICogLy8gICAgICAgMTAwXG4gKiAvLyAgICAgXSxcbiAqIC8vICAgICBcIm9wZXJhdG9yXCI6IFwiPlwiLFxuICogLy8gICAgIFwidHlwZVwiOiBcIm51bWVyaWNcIlxuICogLy8gICB9XG4gKiAvLyBdXG4gKiBAZXhhbXBsZVxuICogaGVscGVyLmFkZEZhY2V0UmVmaW5lbWVudCgnY29sb3InLCAnYmx1ZScpO1xuICogaGVscGVyLmFkZEZhY2V0RXhjbHVzaW9uKCdjb2xvcicsICdyZWQnKTtcbiAqIGhlbHBlci5nZXRSZWZpbmVtZW50cygnY29sb3InKTtcbiAqIC8vIFtcbiAqIC8vICAge1xuICogLy8gICAgIFwidmFsdWVcIjogXCJibHVlXCIsXG4gKiAvLyAgICAgXCJ0eXBlXCI6IFwiY29uanVuY3RpdmVcIlxuICogLy8gICB9LFxuICogLy8gICB7XG4gKiAvLyAgICAgXCJ2YWx1ZVwiOiBcInJlZFwiLFxuICogLy8gICAgIFwidHlwZVwiOiBcImV4Y2x1ZGVcIlxuICogLy8gICB9XG4gKiAvLyBdXG4gKiBAZXhhbXBsZVxuICogaGVscGVyLmFkZERpc2p1bmN0aXZlRmFjZXRSZWZpbmVtZW50KCdtYXRlcmlhbCcsICdwbGFzdGljJyk7XG4gKiAvLyBbXG4gKiAvLyAgIHtcbiAqIC8vICAgICBcInZhbHVlXCI6IFwicGxhc3RpY1wiLFxuICogLy8gICAgIFwidHlwZVwiOiBcImRpc2p1bmN0aXZlXCJcbiAqIC8vICAgfVxuICogLy8gXVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5nZXRSZWZpbmVtZW50cyA9IGZ1bmN0aW9uKGZhY2V0TmFtZSkge1xuICB2YXIgcmVmaW5lbWVudHMgPSBbXTtcblxuICBpZiAodGhpcy5zdGF0ZS5pc0Nvbmp1bmN0aXZlRmFjZXQoZmFjZXROYW1lKSkge1xuICAgIHZhciBjb25qUmVmaW5lbWVudHMgPSB0aGlzLnN0YXRlLmdldENvbmp1bmN0aXZlUmVmaW5lbWVudHMoZmFjZXROYW1lKTtcblxuICAgIGNvbmpSZWZpbmVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJlZmluZW1lbnRzLnB1c2goe1xuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgdHlwZTogJ2Nvbmp1bmN0aXZlJ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZXhjbHVkZVJlZmluZW1lbnRzID0gdGhpcy5zdGF0ZS5nZXRFeGNsdWRlUmVmaW5lbWVudHMoZmFjZXROYW1lKTtcblxuICAgIGV4Y2x1ZGVSZWZpbmVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJlZmluZW1lbnRzLnB1c2goe1xuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgdHlwZTogJ2V4Y2x1ZGUnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmlzRGlzanVuY3RpdmVGYWNldChmYWNldE5hbWUpKSB7XG4gICAgdmFyIGRpc2pSZWZpbmVtZW50cyA9IHRoaXMuc3RhdGUuZ2V0RGlzanVuY3RpdmVSZWZpbmVtZW50cyhmYWNldE5hbWUpO1xuXG4gICAgZGlzalJlZmluZW1lbnRzLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgcmVmaW5lbWVudHMucHVzaCh7XG4gICAgICAgIHZhbHVlOiByLFxuICAgICAgICB0eXBlOiAnZGlzanVuY3RpdmUnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBudW1lcmljUmVmaW5lbWVudHMgPSB0aGlzLnN0YXRlLmdldE51bWVyaWNSZWZpbmVtZW50cyhmYWNldE5hbWUpO1xuXG4gIE9iamVjdC5rZXlzKG51bWVyaWNSZWZpbmVtZW50cykuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvcikge1xuICAgIHZhciB2YWx1ZSA9IG51bWVyaWNSZWZpbmVtZW50c1tvcGVyYXRvcl07XG5cbiAgICByZWZpbmVtZW50cy5wdXNoKHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICAgIHR5cGU6ICdudW1lcmljJ1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVmaW5lbWVudHM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgY3VycmVudCByZWZpbmVtZW50IGZvciB0aGUgKGF0dHJpYnV0ZSwgb3BlcmF0b3IpXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIGF0dHJpYnV0ZSBpbiB0aGUgcmVjb3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Igb3BlcmF0b3IgYXBwbGllZCBvbiB0aGUgcmVmaW5lZCB2YWx1ZXNcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXJ8bnVtYmVyW10+fSByZWZpbmVkIHZhbHVlc1xuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5nZXROdW1lcmljUmVmaW5lbWVudCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgb3BlcmF0b3IpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGUuZ2V0TnVtZXJpY1JlZmluZW1lbnQoYXR0cmlidXRlLCBvcGVyYXRvcik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBicmVhZGNydW1iIGZvciBhIGhpZXJhcmNoaWNhbCBmYWNldCwgYXMgYW4gYXJyYXlcbiAqIEBwYXJhbSAge3N0cmluZ30gZmFjZXROYW1lIEhpZXJhcmNoaWNhbCBmYWNldCBuYW1lXG4gKiBAcmV0dXJuIHthcnJheS48c3RyaW5nPn0gdGhlIHBhdGggYXMgYW4gYXJyYXkgb2Ygc3RyaW5nXG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmdldEhpZXJhcmNoaWNhbEZhY2V0QnJlYWRjcnVtYiA9IGZ1bmN0aW9uKGZhY2V0TmFtZSkge1xuICByZXR1cm4gdGhpcy5zdGF0ZS5nZXRIaWVyYXJjaGljYWxGYWNldEJyZWFkY3J1bWIoZmFjZXROYW1lKTtcbn07XG5cbi8vIC8vLy8vLy8vLy8vIFBSSVZBVEVcblxuLyoqXG4gKiBQZXJmb3JtIHRoZSB1bmRlcmx5aW5nIHF1ZXJpZXNcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZmlyZXMgc2VhcmNoXG4gKiBAZmlyZXMgcmVzdWx0XG4gKiBAZmlyZXMgZXJyb3JcbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuX3NlYXJjaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgdmFyIHN0YXRlcyA9IFtdO1xuICB2YXIgbWFpblF1ZXJpZXMgPSBbXTtcblxuICBpZiAoIW9wdGlvbnMub25seVdpdGhEZXJpdmVkSGVscGVycykge1xuICAgIG1haW5RdWVyaWVzID0gcmVxdWVzdEJ1aWxkZXIuX2dldFF1ZXJpZXMoc3RhdGUuaW5kZXgsIHN0YXRlKTtcblxuICAgIHN0YXRlcy5wdXNoKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHF1ZXJpZXNDb3VudDogbWFpblF1ZXJpZXMubGVuZ3RoLFxuICAgICAgaGVscGVyOiB0aGlzXG4gICAgfSk7XG5cbiAgICB0aGlzLmVtaXQoJ3NlYXJjaCcsIHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHJlc3VsdHM6IHRoaXMubGFzdFJlc3VsdHNcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkZXJpdmVkUXVlcmllcyA9IHRoaXMuZGVyaXZlZEhlbHBlcnMubWFwKGZ1bmN0aW9uKGRlcml2ZWRIZWxwZXIpIHtcbiAgICB2YXIgZGVyaXZlZFN0YXRlID0gZGVyaXZlZEhlbHBlci5nZXRNb2RpZmllZFN0YXRlKHN0YXRlKTtcbiAgICB2YXIgZGVyaXZlZFN0YXRlUXVlcmllcyA9IHJlcXVlc3RCdWlsZGVyLl9nZXRRdWVyaWVzKGRlcml2ZWRTdGF0ZS5pbmRleCwgZGVyaXZlZFN0YXRlKTtcblxuICAgIHN0YXRlcy5wdXNoKHtcbiAgICAgIHN0YXRlOiBkZXJpdmVkU3RhdGUsXG4gICAgICBxdWVyaWVzQ291bnQ6IGRlcml2ZWRTdGF0ZVF1ZXJpZXMubGVuZ3RoLFxuICAgICAgaGVscGVyOiBkZXJpdmVkSGVscGVyXG4gICAgfSk7XG5cbiAgICBkZXJpdmVkSGVscGVyLmVtaXQoJ3NlYXJjaCcsIHtcbiAgICAgIHN0YXRlOiBkZXJpdmVkU3RhdGUsXG4gICAgICByZXN1bHRzOiBkZXJpdmVkSGVscGVyLmxhc3RSZXN1bHRzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVyaXZlZFN0YXRlUXVlcmllcztcbiAgfSk7XG5cbiAgdmFyIHF1ZXJpZXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KG1haW5RdWVyaWVzLCBkZXJpdmVkUXVlcmllcyk7XG4gIHZhciBxdWVyeUlkID0gdGhpcy5fcXVlcnlJZCsrO1xuXG4gIHRoaXMuX2N1cnJlbnROYlF1ZXJpZXMrKztcblxuICB0cnkge1xuICAgIHRoaXMuY2xpZW50LnNlYXJjaChxdWVyaWVzKVxuICAgICAgLnRoZW4odGhpcy5fZGlzcGF0Y2hBbGdvbGlhUmVzcG9uc2UuYmluZCh0aGlzLCBzdGF0ZXMsIHF1ZXJ5SWQpKVxuICAgICAgLmNhdGNoKHRoaXMuX2Rpc3BhdGNoQWxnb2xpYUVycm9yLmJpbmQodGhpcywgcXVlcnlJZCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIElmIHdlIHJlYWNoIHRoaXMgcGFydCwgd2UncmUgaW4gYW4gaW50ZXJuYWwgZXJyb3Igc3RhdGVcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSByZXNwb25zZXMgYXMgc2VudCBieSB0aGUgc2VydmVyIGFuZCB0cmFuc2Zvcm0gdGhlbSBpbnRvIGEgdXNlclxuICogdXNhYmxlIG9iamVjdCB0aGF0IG1lcmdlIHRoZSByZXN1bHRzIG9mIGFsbCB0aGUgYmF0Y2ggcmVxdWVzdHMuIEl0IHdpbGwgZGlzcGF0Y2hcbiAqIG92ZXIgdGhlIGRpZmZlcmVudCBoZWxwZXIgKyBkZXJpdmVkIGhlbHBlcnMgKHdoZW4gdGhlcmUgYXJlIHNvbWUpLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YXJyYXkuPHtTZWFyY2hQYXJhbWV0ZXJzLCBBbGdvbGlhUXVlcmllcywgQWxnb2xpYVNlYXJjaEhlbHBlcn0+fVxuICogIHN0YXRlIHN0YXRlIHVzZWQgZm9yIHRvIGdlbmVyYXRlIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gcXVlcnlJZCBpZCBvZiB0aGUgY3VycmVudCByZXF1ZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudCBjb250ZW50IG9mIHRoZSByZXNwb25zZVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5fZGlzcGF0Y2hBbGdvbGlhUmVzcG9uc2UgPSBmdW5jdGlvbihzdGF0ZXMsIHF1ZXJ5SWQsIGNvbnRlbnQpIHtcbiAgLy8gRklYTUUgcmVtb3ZlIHRoZSBudW1iZXIgb2Ygb3V0ZGF0ZWQgcXVlcmllcyBkaXNjYXJkZWQgaW5zdGVhZCBvZiBqdXN0IG9uZVxuXG4gIGlmIChxdWVyeUlkIDwgdGhpcy5fbGFzdFF1ZXJ5SWRSZWNlaXZlZCkge1xuICAgIC8vIE91dGRhdGVkIGFuc3dlclxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2N1cnJlbnROYlF1ZXJpZXMgLT0gKHF1ZXJ5SWQgLSB0aGlzLl9sYXN0UXVlcnlJZFJlY2VpdmVkKTtcbiAgdGhpcy5fbGFzdFF1ZXJ5SWRSZWNlaXZlZCA9IHF1ZXJ5SWQ7XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnROYlF1ZXJpZXMgPT09IDApIHRoaXMuZW1pdCgnc2VhcmNoUXVldWVFbXB0eScpO1xuXG4gIHZhciByZXN1bHRzID0gY29udGVudC5yZXN1bHRzLnNsaWNlKCk7XG5cbiAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBzdGF0ZSA9IHMuc3RhdGU7XG4gICAgdmFyIHF1ZXJpZXNDb3VudCA9IHMucXVlcmllc0NvdW50O1xuICAgIHZhciBoZWxwZXIgPSBzLmhlbHBlcjtcbiAgICB2YXIgc3BlY2lmaWNSZXN1bHRzID0gcmVzdWx0cy5zcGxpY2UoMCwgcXVlcmllc0NvdW50KTtcblxuICAgIHZhciBmb3JtYXR0ZWRSZXNwb25zZSA9IGhlbHBlci5sYXN0UmVzdWx0cyA9IG5ldyBTZWFyY2hSZXN1bHRzKHN0YXRlLCBzcGVjaWZpY1Jlc3VsdHMpO1xuXG4gICAgaGVscGVyLmVtaXQoJ3Jlc3VsdCcsIHtcbiAgICAgIHJlc3VsdHM6IGZvcm1hdHRlZFJlc3BvbnNlLFxuICAgICAgc3RhdGU6IHN0YXRlXG4gICAgfSk7XG4gIH0pO1xufTtcblxuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuX2Rpc3BhdGNoQWxnb2xpYUVycm9yID0gZnVuY3Rpb24ocXVlcnlJZCwgZXJyb3IpIHtcbiAgaWYgKHF1ZXJ5SWQgPCB0aGlzLl9sYXN0UXVlcnlJZFJlY2VpdmVkKSB7XG4gICAgLy8gT3V0ZGF0ZWQgYW5zd2VyXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY3VycmVudE5iUXVlcmllcyAtPSBxdWVyeUlkIC0gdGhpcy5fbGFzdFF1ZXJ5SWRSZWNlaXZlZDtcbiAgdGhpcy5fbGFzdFF1ZXJ5SWRSZWNlaXZlZCA9IHF1ZXJ5SWQ7XG5cbiAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICBlcnJvcjogZXJyb3JcbiAgfSk7XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnROYlF1ZXJpZXMgPT09IDApIHRoaXMuZW1pdCgnc2VhcmNoUXVldWVFbXB0eScpO1xufTtcblxuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuY29udGFpbnNSZWZpbmVtZW50ID0gZnVuY3Rpb24ocXVlcnksIGZhY2V0RmlsdGVycywgbnVtZXJpY0ZpbHRlcnMsIHRhZ0ZpbHRlcnMpIHtcbiAgcmV0dXJuIHF1ZXJ5IHx8XG4gICAgZmFjZXRGaWx0ZXJzLmxlbmd0aCAhPT0gMCB8fFxuICAgIG51bWVyaWNGaWx0ZXJzLmxlbmd0aCAhPT0gMCB8fFxuICAgIHRhZ0ZpbHRlcnMubGVuZ3RoICE9PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0IGlmIHRoZXJlIGFyZSBzb21lIGRpc2p1bmN0aXZlIHJlZmluZW1lbnRzIG9uIHRoZSBmYWNldFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYWNldCB0aGUgYXR0cmlidXRlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLl9oYXNEaXNqdW5jdGl2ZVJlZmluZW1lbnRzID0gZnVuY3Rpb24oZmFjZXQpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzanVuY3RpdmVSZWZpbmVtZW50c1tmYWNldF0gJiZcbiAgICB0aGlzLnN0YXRlLmRpc2p1bmN0aXZlUmVmaW5lbWVudHNbZmFjZXRdLmxlbmd0aCA+IDA7XG59O1xuXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5fY2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIHN0YXRlID0gZXZlbnQuc3RhdGU7XG4gIHZhciBpc1BhZ2VSZXNldCA9IGV2ZW50LmlzUGFnZVJlc2V0O1xuXG4gIGlmIChzdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge1xuICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICByZXN1bHRzOiB0aGlzLmxhc3RSZXN1bHRzLFxuICAgICAgaXNQYWdlUmVzZXQ6IGlzUGFnZVJlc2V0XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBjYWNoZSBvZiB0aGUgdW5kZXJseWluZyBBbGdvbGlhIGNsaWVudC5cbiAqIEByZXR1cm4ge0FsZ29saWFTZWFyY2hIZWxwZXJ9XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jbGllbnQuY2xlYXJDYWNoZSAmJiB0aGlzLmNsaWVudC5jbGVhckNhY2hlKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjbGllbnQgaW5zdGFuY2UuIElmIHRoZSByZWZlcmVuY2Ugb2YgdGhlIGNsaWVudHNcbiAqIGFyZSBlcXVhbCB0aGVuIG5vIHVwZGF0ZSBpcyBhY3R1YWxseSBkb25lLlxuICogQHBhcmFtICB7QWxnb2xpYVNlYXJjaH0gbmV3Q2xpZW50IGFuIEFsZ29saWFTZWFyY2ggY2xpZW50XG4gKiBAcmV0dXJuIHtBbGdvbGlhU2VhcmNoSGVscGVyfVxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5zZXRDbGllbnQgPSBmdW5jdGlvbihuZXdDbGllbnQpIHtcbiAgaWYgKHRoaXMuY2xpZW50ID09PSBuZXdDbGllbnQpIHJldHVybiB0aGlzO1xuXG4gIGlmICh0eXBlb2YgbmV3Q2xpZW50LmFkZEFsZ29saWFBZ2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5ld0NsaWVudC5hZGRBbGdvbGlhQWdlbnQoJ0pTIEhlbHBlciAoJyArIHZlcnNpb24gKyAnKScpO1xuICB9XG4gIHRoaXMuY2xpZW50ID0gbmV3Q2xpZW50O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudGx5IHVzZWQgY2xpZW50LlxuICogQHJldHVybiB7QWxnb2xpYVNlYXJjaH1cbiAqL1xuQWxnb2xpYVNlYXJjaEhlbHBlci5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBkZXJpdmVkIGluc3RhbmNlIG9mIHRoZSBIZWxwZXIuIEEgZGVyaXZlZCBoZWxwZXJcbiAqIGlzIGEgd2F5IHRvIHJlcXVlc3Qgb3RoZXIgaW5kaWNlcyBzeW5jaHJvbmlzZWQgd2l0aCB0aGUgbGlmZWN5Y2xlXG4gKiBvZiB0aGUgbWFpbiBIZWxwZXIuIFRoaXMgbWVjaGFuaXNtIHVzZXMgdGhlIG11bHRpcXVlcmllcyBmZWF0dXJlXG4gKiBvZiBBbGdvbGlhIHRvIGFnZ3JlZ2F0ZSBhbGwgdGhlIHJlcXVlc3RzIGluIGEgc2luZ2xlIG5ldHdvcmsgY2FsbC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB0YWtlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgYSBuZXcgU2VhcmNoUGFyYW1ldGVyXG4gKiB0aGF0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgcmVxdWVzdHMgdG8gQWxnb2xpYS4gVGhvc2UgbmV3IHJlcXVlc3RzXG4gKiBhcmUgY3JlYXRlZCBqdXN0IGJlZm9yZSB0aGUgYHNlYXJjaGAgZXZlbnQuIFRoZSBzaWduYXR1cmUgb2YgdGhlIGZ1bmN0aW9uXG4gKiBpcyBgU2VhcmNoUGFyYW1ldGVycyAtPiBTZWFyY2hQYXJhbWV0ZXJzYC5cbiAqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IERlcml2ZWRIZWxwZXIgd2hpY2ggaXMgYW4gRXZlbnRFbWl0dGVyXG4gKiB0aGF0IGZpcmVzIHRoZSBzYW1lIGBzZWFyY2hgLCBgcmVzdWx0YCBhbmQgYGVycm9yYCBldmVudHMuIFRob3NlXG4gKiBldmVudHMsIGhvd2V2ZXIsIHdpbGwgcmVjZWl2ZSBkYXRhIHNwZWNpZmljIHRvIHRoaXMgRGVyaXZlZEhlbHBlclxuICogYW5kIHRoZSBTZWFyY2hQYXJhbWV0ZXJzIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhlIGNhbGwgb2YgdGhlXG4gKiBwYXJhbWV0ZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBTZWFyY2hQYXJhbWV0ZXJzIC0+IFNlYXJjaFBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0Rlcml2ZWRIZWxwZXJ9XG4gKi9cbkFsZ29saWFTZWFyY2hIZWxwZXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBkZXJpdmVkSGVscGVyID0gbmV3IERlcml2ZWRIZWxwZXIodGhpcywgZm4pO1xuICB0aGlzLmRlcml2ZWRIZWxwZXJzLnB1c2goZGVyaXZlZEhlbHBlcik7XG4gIHJldHVybiBkZXJpdmVkSGVscGVyO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZXRhY2hlcyBhIGRlcml2ZWQgSGVscGVyIGZyb20gdGhlIG1haW4gb25lLiBQcmVmZXIgdXNpbmcgdGhlIG9uZSBmcm9tIHRoZVxuICogZGVyaXZlZCBoZWxwZXIgaXRzZWxmLCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVycyB0b28uXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQHRocm93cyBFcnJvclxuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5kZXRhY2hEZXJpdmVkSGVscGVyID0gZnVuY3Rpb24oZGVyaXZlZEhlbHBlcikge1xuICB2YXIgcG9zID0gdGhpcy5kZXJpdmVkSGVscGVycy5pbmRleE9mKGRlcml2ZWRIZWxwZXIpO1xuICBpZiAocG9zID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdEZXJpdmVkIGhlbHBlciBhbHJlYWR5IGRldGFjaGVkJyk7XG4gIHRoaXMuZGVyaXZlZEhlbHBlcnMuc3BsaWNlKHBvcywgMSk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYXQgbGVhc3Qgb25lIG9uLWdvaW5nIHNlYXJjaC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlcmUgaXMgYSBzZWFyY2ggcGVuZGluZ1xuICovXG5BbGdvbGlhU2VhcmNoSGVscGVyLnByb3RvdHlwZS5oYXNQZW5kaW5nUmVxdWVzdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2N1cnJlbnROYlF1ZXJpZXMgPiAwO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBBbGdvbGlhU2VhcmNoSGVscGVyLk51bWVyaWNSZWZpbmVtZW50XG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gdmFsdWUgdGhlIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBmb3IgZmlsdGVyaW5nIHRoaXMgYXR0cmlidXRlIHdpdGhcbiAqIHRoZSBvcGVyYXRvciBzcGVjaWZpZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3BlcmF0b3IgdGhlIGZhY2V0aW5nIGRhdGE6IHZhbHVlLCBudW1iZXIgb2YgZW50cmllc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgd2lsbCBiZSAnbnVtZXJpYydcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIEFsZ29saWFTZWFyY2hIZWxwZXIuRmFjZXRSZWZpbmVtZW50XG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlIHRoZSBzdHJpbmcgdXNlIHRvIGZpbHRlciB0aGUgYXR0cmlidXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiBmaWx0ZXI6ICdjb25qdW5jdGl2ZScsICdkaXNqdW5jdGl2ZScsICdleGNsdWRlJ1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQWxnb2xpYVNlYXJjaEhlbHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gYXJyYXkuZmlsdGVyKEJvb2xlYW4pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTk9URTogdGhpcyBiZWhhdmVzIGxpa2UgbG9kYXNoL2RlZmF1bHRzLCBidXQgZG9lc24ndCBtdXRhdGUgdGhlIHRhcmdldFxuLy8gaXQgYWxzbyBwcmVzZXJ2ZSBrZXlzIG9yZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzUHVyZSgpIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzb3VyY2VzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKGFjYywgc291cmNlKSB7XG4gICAgT2JqZWN0LmtleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoc291cmNlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYWNjW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZW1vdmUgaWYgYWxyZWFkeSBhZGRlZCwgc28gdGhhdCB3ZSBjYW4gYWRkIGl0IGluIGNvcnJlY3Qgb3JkZXJcbiAgICAgICAgZGVsZXRlIGFjY1trZXldO1xuICAgICAgfVxuICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBATUFKT1IgY2FuIGJlIHJlcGxhY2VkIGJ5IG5hdGl2ZSBBcnJheSNmaW5kIHdoZW4gd2UgY2hhbmdlIHN1cHBvcnRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmluZChhcnJheSwgY29tcGFyYXRvcikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiBhcnJheVtpXTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEBNQUpPUiBjYW4gYmUgcmVwbGFjZWQgYnkgbmF0aXZlIEFycmF5I2ZpbmRJbmRleCB3aGVuIHdlIGNoYW5nZSBzdXBwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmQoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmluZCA9IHJlcXVpcmUoJy4vZmluZCcpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSBzb3J0IGZvcm1hdCBmcm9tIHVzZXIgZnJpZW5kbHkgbm90YXRpb24gdG8gbG9kYXNoIGZvcm1hdFxuICogQHBhcmFtIHtzdHJpbmdbXX0gc29ydEJ5IGFycmF5IG9mIHByZWRpY2F0ZSBvZiB0aGUgZm9ybSBcImF0dHJpYnV0ZTpvcmRlclwiXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbZGVmYXVsdHNdIGFycmF5IG9mIHByZWRpY2F0ZSBvZiB0aGUgZm9ybSBcImF0dHJpYnV0ZTpvcmRlclwiXG4gKiBAcmV0dXJuIHthcnJheS48c3RyaW5nW10+fSBhcnJheSBjb250YWluaW5nIDIgZWxlbWVudHMgOiBhdHRyaWJ1dGVzLCBvcmRlcnNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXRTb3J0KHNvcnRCeSwgZGVmYXVsdHMpIHtcbiAgdmFyIGRlZmF1bHRJbnN0cnVjdGlvbnMgPSAoZGVmYXVsdHMgfHwgW10pLm1hcChmdW5jdGlvbihzb3J0KSB7XG4gICAgcmV0dXJuIHNvcnQuc3BsaXQoJzonKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNvcnRCeS5yZWR1Y2UoXG4gICAgZnVuY3Rpb24gcHJlcGFyZVByZWRpY2F0ZShvdXQsIHNvcnQpIHtcbiAgICAgIHZhciBzb3J0SW5zdHJ1Y3Rpb24gPSBzb3J0LnNwbGl0KCc6Jyk7XG5cbiAgICAgIHZhciBtYXRjaGluZ0RlZmF1bHQgPSBmaW5kKGRlZmF1bHRJbnN0cnVjdGlvbnMsIGZ1bmN0aW9uKFxuICAgICAgICBkZWZhdWx0SW5zdHJ1Y3Rpb25cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEluc3RydWN0aW9uWzBdID09PSBzb3J0SW5zdHJ1Y3Rpb25bMF07XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNvcnRJbnN0cnVjdGlvbi5sZW5ndGggPiAxIHx8ICFtYXRjaGluZ0RlZmF1bHQpIHtcbiAgICAgICAgb3V0WzBdLnB1c2goc29ydEluc3RydWN0aW9uWzBdKTtcbiAgICAgICAgb3V0WzFdLnB1c2goc29ydEluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cblxuICAgICAgb3V0WzBdLnB1c2gobWF0Y2hpbmdEZWZhdWx0WzBdKTtcbiAgICAgIG91dFsxXS5wdXNoKG1hdGNoaW5nRGVmYXVsdFsxXSk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG4gICAgW1tdLCBbXV1cbiAgKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogY3RvcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaGVyaXRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICByZXR1cm4gYXJyMS5maWx0ZXIoZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGFycjIuaW5kZXhPZih2YWx1ZSkgPiAtMSAmJlxuICAgICAgYXJyMS5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXggLyogc2tpcHMgZHVwbGljYXRlcyAqL1xuICAgICk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gX21lcmdlKEFycmF5LmlzQXJyYXkodmFsdWUpID8gW10gOiB7fSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RPckFycmF5T3JGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgKTtcbn1cblxuZnVuY3Rpb24gX21lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gIGlmICh0YXJnZXQgPT09IHNvdXJjZSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlVmFsID0gc291cmNlW2tleV07XG4gICAgdmFyIHRhcmdldFZhbCA9IHRhcmdldFtrZXldO1xuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXRWYWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzb3VyY2VWYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3RPckFycmF5T3JGdW5jdGlvbih0YXJnZXRWYWwpICYmIGlzT2JqZWN0T3JBcnJheU9yRnVuY3Rpb24oc291cmNlVmFsKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBfbWVyZ2UodGFyZ2V0VmFsLCBzb3VyY2VWYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGNsb25lKHNvdXJjZVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBPYmplY3QuYXNzaWduLCBidXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmQgaW5oZXJpdGVkXG4gKiBlbnVtZXJhYmxlIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICpcbiAqIE5PVEU6IHRoaXMgYmVoYXZlcyBsaWtlIGxvZGFzaC9tZXJnZSwgYnV0OlxuICogLSBkb2VzIG11dGF0ZSBmdW5jdGlvbnMgaWYgdGhleSBhcmUgYSBzb3VyY2VcbiAqIC0gdHJlYXRzIG5vbi1wbGFpbiBvYmplY3RzIGFzIHBsYWluXG4gKiAtIGRvZXMgbm90IHdvcmsgZm9yIGNpcmN1bGFyIG9iamVjdHNcbiAqIC0gdHJlYXRzIHNwYXJzZSBhcnJheXMgYXMgc3BhcnNlXG4gKiAtIGRvZXMgbm90IGNvbnZlcnQgQXJyYXktbGlrZSBvYmplY3RzIChBcmd1bWVudHMsIE5vZGVMaXN0cywgZXRjLikgdG8gYXJyYXlzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCkge1xuICBpZiAoIWlzT2JqZWN0T3JBcnJheU9yRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHRhcmdldCA9IHt9O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGlmIChpc09iamVjdE9yQXJyYXlPckZ1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICAgIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdEhhc0tleXMob2JqKSB7XG4gIHJldHVybiBvYmogJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdEhhc0tleXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9ibG9iLzNhYWFmYWUwNTNmYTc1ZmViYjNhYTQ1ZDQ1YjZmMDA2NDZlMzBiYTQvcGFja2FnZXMvYmFiZWwtaGVscGVycy9zcmMvaGVscGVycy5qcyNMNjA0LUw2MjBcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbDtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbDtcblxuICAgIGlmIChcbiAgICAgICghb3RoSXNOdWxsICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCkgfHxcbiAgICAgICF2YWxJc0RlZmluZWRcbiAgICApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAoIXZhbElzTnVsbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQpIHx8XG4gICAgICAhb3RoSXNEZWZpbmVkXG4gICAgKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gY29sbGVjdGlvbiBvYmplY3Qgd2l0aCBrZXlzIGluIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gaXRlcmF0ZWVzIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gb3JkZXJzIGFzYyB8IGRlc2NcbiAqL1xuZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkob3JkZXJzKSkge1xuICAgIG9yZGVycyA9IFtdO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb24ubWFwKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcml0ZXJpYTogaXRlcmF0ZWVzLm1hcChmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbaXRlcmF0ZWVdO1xuICAgICAgfSksXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICB9KTtcblxuICByZXN1bHQuc29ydChmdW5jdGlvbiBjb21wYXJlcihvYmplY3QsIG90aGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTE7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG9iamVjdC5jcml0ZXJpYS5sZW5ndGgpIHtcbiAgICAgIHZhciByZXMgPSBjb21wYXJlQXNjZW5kaW5nKG9iamVjdC5jcml0ZXJpYVtpbmRleF0sIG90aGVyLmNyaXRlcmlhW2luZGV4XSk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJzW2luZGV4XSA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgICAgcmV0dXJuIC1yZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uKHJlcykge1xuICAgIHJldHVybiByZXMudmFsdWU7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9yZGVyQnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHZhbFRvTnVtYmVyKHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHYpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gdi5tYXAodmFsVG9OdW1iZXIpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgc2hvdWxkIGJlIGEgbnVtYmVyLCBhIHBhcnNhYmxlIHN0cmluZyBvciBhbiBhcnJheSBvZiB0aG9zZS4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxUb051bWJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1lcmdlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWVyZ2UnKTtcblxudmFyIHJlcXVlc3RCdWlsZGVyID0ge1xuICAvKipcbiAgICogR2V0IGFsbCB0aGUgcXVlcmllcyB0byBzZW5kIHRvIHRoZSBjbGllbnQsIHRob3NlIHF1ZXJpZXMgY2FuIHVzZWQgZGlyZWN0bHlcbiAgICogd2l0aCB0aGUgQWxnb2xpYSBjbGllbnQuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge29iamVjdFtdfSBUaGUgcXVlcmllc1xuICAgKi9cbiAgX2dldFF1ZXJpZXM6IGZ1bmN0aW9uIGdldFF1ZXJpZXMoaW5kZXgsIHN0YXRlKSB7XG4gICAgdmFyIHF1ZXJpZXMgPSBbXTtcblxuICAgIC8vIE9uZSBxdWVyeSBmb3IgdGhlIGhpdHNcbiAgICBxdWVyaWVzLnB1c2goe1xuICAgICAgaW5kZXhOYW1lOiBpbmRleCxcbiAgICAgIHBhcmFtczogcmVxdWVzdEJ1aWxkZXIuX2dldEhpdHNTZWFyY2hQYXJhbXMoc3RhdGUpXG4gICAgfSk7XG5cbiAgICAvLyBPbmUgZm9yIGVhY2ggZGlzanVuY3RpdmUgZmFjZXRzXG4gICAgc3RhdGUuZ2V0UmVmaW5lZERpc2p1bmN0aXZlRmFjZXRzKCkuZm9yRWFjaChmdW5jdGlvbihyZWZpbmVkRmFjZXQpIHtcbiAgICAgIHF1ZXJpZXMucHVzaCh7XG4gICAgICAgIGluZGV4TmFtZTogaW5kZXgsXG4gICAgICAgIHBhcmFtczogcmVxdWVzdEJ1aWxkZXIuX2dldERpc2p1bmN0aXZlRmFjZXRTZWFyY2hQYXJhbXMoc3RhdGUsIHJlZmluZWRGYWNldClcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gbWF5YmUgbW9yZSB0byBnZXQgdGhlIHJvb3QgbGV2ZWwgb2YgaGllcmFyY2hpY2FsIGZhY2V0cyB3aGVuIGFjdGl2YXRlZFxuICAgIHN0YXRlLmdldFJlZmluZWRIaWVyYXJjaGljYWxGYWNldHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHJlZmluZWRGYWNldCkge1xuICAgICAgdmFyIGhpZXJhcmNoaWNhbEZhY2V0ID0gc3RhdGUuZ2V0SGllcmFyY2hpY2FsRmFjZXRCeU5hbWUocmVmaW5lZEZhY2V0KTtcblxuICAgICAgdmFyIGN1cnJlbnRSZWZpbmVtZW50ID0gc3RhdGUuZ2V0SGllcmFyY2hpY2FsUmVmaW5lbWVudChyZWZpbmVkRmFjZXQpO1xuICAgICAgLy8gaWYgd2UgYXJlIGRlZXBlciB0aGFuIGxldmVsIDAgKHN0YXJ0aW5nIGZyb20gYGJlZXIgPiBJUEFgKVxuICAgICAgLy8gd2Ugd2FudCB0byBnZXQgdGhlIHJvb3QgdmFsdWVzXG4gICAgICB2YXIgc2VwYXJhdG9yID0gc3RhdGUuX2dldEhpZXJhcmNoaWNhbEZhY2V0U2VwYXJhdG9yKGhpZXJhcmNoaWNhbEZhY2V0KTtcbiAgICAgIGlmIChjdXJyZW50UmVmaW5lbWVudC5sZW5ndGggPiAwICYmIGN1cnJlbnRSZWZpbmVtZW50WzBdLnNwbGl0KHNlcGFyYXRvcikubGVuZ3RoID4gMSkge1xuICAgICAgICBxdWVyaWVzLnB1c2goe1xuICAgICAgICAgIGluZGV4TmFtZTogaW5kZXgsXG4gICAgICAgICAgcGFyYW1zOiByZXF1ZXN0QnVpbGRlci5fZ2V0RGlzanVuY3RpdmVGYWNldFNlYXJjaFBhcmFtcyhzdGF0ZSwgcmVmaW5lZEZhY2V0LCB0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBxdWVyaWVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCdWlsZCBzZWFyY2ggcGFyYW1ldGVycyB1c2VkIHRvIGZldGNoIGhpdHNcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7b2JqZWN0LjxzdHJpbmcsIGFueT59XG4gICAqL1xuICBfZ2V0SGl0c1NlYXJjaFBhcmFtczogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgZmFjZXRzID0gc3RhdGUuZmFjZXRzXG4gICAgICAuY29uY2F0KHN0YXRlLmRpc2p1bmN0aXZlRmFjZXRzKVxuICAgICAgLmNvbmNhdChyZXF1ZXN0QnVpbGRlci5fZ2V0SGl0c0hpZXJhcmNoaWNhbEZhY2V0c0F0dHJpYnV0ZXMoc3RhdGUpKTtcblxuXG4gICAgdmFyIGZhY2V0RmlsdGVycyA9IHJlcXVlc3RCdWlsZGVyLl9nZXRGYWNldEZpbHRlcnMoc3RhdGUpO1xuICAgIHZhciBudW1lcmljRmlsdGVycyA9IHJlcXVlc3RCdWlsZGVyLl9nZXROdW1lcmljRmlsdGVycyhzdGF0ZSk7XG4gICAgdmFyIHRhZ0ZpbHRlcnMgPSByZXF1ZXN0QnVpbGRlci5fZ2V0VGFnRmlsdGVycyhzdGF0ZSk7XG4gICAgdmFyIGFkZGl0aW9uYWxQYXJhbXMgPSB7XG4gICAgICBmYWNldHM6IGZhY2V0cyxcbiAgICAgIHRhZ0ZpbHRlcnM6IHRhZ0ZpbHRlcnNcbiAgICB9O1xuXG4gICAgaWYgKGZhY2V0RmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBhZGRpdGlvbmFsUGFyYW1zLmZhY2V0RmlsdGVycyA9IGZhY2V0RmlsdGVycztcbiAgICB9XG5cbiAgICBpZiAobnVtZXJpY0ZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgYWRkaXRpb25hbFBhcmFtcy5udW1lcmljRmlsdGVycyA9IG51bWVyaWNGaWx0ZXJzO1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZSh7fSwgc3RhdGUuZ2V0UXVlcnlQYXJhbXMoKSwgYWRkaXRpb25hbFBhcmFtcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJ1aWxkIHNlYXJjaCBwYXJhbWV0ZXJzIHVzZWQgdG8gZmV0Y2ggYSBkaXNqdW5jdGl2ZSBmYWNldFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZhY2V0IHRoZSBhc3NvY2lhdGVkIGZhY2V0IG5hbWVcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gaGllcmFyY2hpY2FsUm9vdExldmVsID8/IEZJWE1FXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIF9nZXREaXNqdW5jdGl2ZUZhY2V0U2VhcmNoUGFyYW1zOiBmdW5jdGlvbihzdGF0ZSwgZmFjZXQsIGhpZXJhcmNoaWNhbFJvb3RMZXZlbCkge1xuICAgIHZhciBmYWNldEZpbHRlcnMgPSByZXF1ZXN0QnVpbGRlci5fZ2V0RmFjZXRGaWx0ZXJzKHN0YXRlLCBmYWNldCwgaGllcmFyY2hpY2FsUm9vdExldmVsKTtcbiAgICB2YXIgbnVtZXJpY0ZpbHRlcnMgPSByZXF1ZXN0QnVpbGRlci5fZ2V0TnVtZXJpY0ZpbHRlcnMoc3RhdGUsIGZhY2V0KTtcbiAgICB2YXIgdGFnRmlsdGVycyA9IHJlcXVlc3RCdWlsZGVyLl9nZXRUYWdGaWx0ZXJzKHN0YXRlKTtcbiAgICB2YXIgYWRkaXRpb25hbFBhcmFtcyA9IHtcbiAgICAgIGhpdHNQZXJQYWdlOiAxLFxuICAgICAgcGFnZTogMCxcbiAgICAgIGF0dHJpYnV0ZXNUb1JldHJpZXZlOiBbXSxcbiAgICAgIGF0dHJpYnV0ZXNUb0hpZ2hsaWdodDogW10sXG4gICAgICBhdHRyaWJ1dGVzVG9TbmlwcGV0OiBbXSxcbiAgICAgIHRhZ0ZpbHRlcnM6IHRhZ0ZpbHRlcnMsXG4gICAgICBhbmFseXRpY3M6IGZhbHNlLFxuICAgICAgY2xpY2tBbmFseXRpY3M6IGZhbHNlXG4gICAgfTtcblxuICAgIHZhciBoaWVyYXJjaGljYWxGYWNldCA9IHN0YXRlLmdldEhpZXJhcmNoaWNhbEZhY2V0QnlOYW1lKGZhY2V0KTtcblxuICAgIGlmIChoaWVyYXJjaGljYWxGYWNldCkge1xuICAgICAgYWRkaXRpb25hbFBhcmFtcy5mYWNldHMgPSByZXF1ZXN0QnVpbGRlci5fZ2V0RGlzanVuY3RpdmVIaWVyYXJjaGljYWxGYWNldEF0dHJpYnV0ZShcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGhpZXJhcmNoaWNhbEZhY2V0LFxuICAgICAgICBoaWVyYXJjaGljYWxSb290TGV2ZWxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZGl0aW9uYWxQYXJhbXMuZmFjZXRzID0gZmFjZXQ7XG4gICAgfVxuXG4gICAgaWYgKG51bWVyaWNGaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFkZGl0aW9uYWxQYXJhbXMubnVtZXJpY0ZpbHRlcnMgPSBudW1lcmljRmlsdGVycztcbiAgICB9XG5cbiAgICBpZiAoZmFjZXRGaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFkZGl0aW9uYWxQYXJhbXMuZmFjZXRGaWx0ZXJzID0gZmFjZXRGaWx0ZXJzO1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZSh7fSwgc3RhdGUuZ2V0UXVlcnlQYXJhbXMoKSwgYWRkaXRpb25hbFBhcmFtcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbnVtZXJpYyBmaWx0ZXJzIGluIGFuIGFsZ29saWEgcmVxdWVzdCBmYXNoaW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmFjZXROYW1lXSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIGZvciB3aGljaCB0aGUgZmlsdGVycyBzaG91bGQgYmUgZXhjbHVkZWRcbiAgICogQHJldHVybiB7c3RyaW5nW119IHRoZSBudW1lcmljIGZpbHRlcnMgaW4gdGhlIGFsZ29saWEgZm9ybWF0XG4gICAqL1xuICBfZ2V0TnVtZXJpY0ZpbHRlcnM6IGZ1bmN0aW9uKHN0YXRlLCBmYWNldE5hbWUpIHtcbiAgICBpZiAoc3RhdGUubnVtZXJpY0ZpbHRlcnMpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5udW1lcmljRmlsdGVycztcbiAgICB9XG5cbiAgICB2YXIgbnVtZXJpY0ZpbHRlcnMgPSBbXTtcblxuICAgIE9iamVjdC5rZXlzKHN0YXRlLm51bWVyaWNSZWZpbmVtZW50cykuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBvcGVyYXRvcnMgPSBzdGF0ZS5udW1lcmljUmVmaW5lbWVudHNbYXR0cmlidXRlXSB8fCB7fTtcbiAgICAgIE9iamVjdC5rZXlzKG9wZXJhdG9ycykuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvcikge1xuICAgICAgICB2YXIgdmFsdWVzID0gb3BlcmF0b3JzW29wZXJhdG9yXSB8fCBbXTtcbiAgICAgICAgaWYgKGZhY2V0TmFtZSAhPT0gYXR0cmlidXRlKSB7XG4gICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICB2YXIgdnMgPSB2YWx1ZS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGUgKyBvcGVyYXRvciArIHY7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBudW1lcmljRmlsdGVycy5wdXNoKHZzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG51bWVyaWNGaWx0ZXJzLnB1c2goYXR0cmlidXRlICsgb3BlcmF0b3IgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG51bWVyaWNGaWx0ZXJzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRhZ3MgZmlsdGVycyBkZXBlbmRpbmdcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX2dldFRhZ0ZpbHRlcnM6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnRhZ0ZpbHRlcnMpIHtcbiAgICAgIHJldHVybiBzdGF0ZS50YWdGaWx0ZXJzO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS50YWdSZWZpbmVtZW50cy5qb2luKCcsJyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQnVpbGQgZmFjZXRGaWx0ZXJzIHBhcmFtZXRlciBiYXNlZCBvbiBjdXJyZW50IHJlZmluZW1lbnRzLiBUaGUgYXJyYXkgcmV0dXJuZWRcbiAgICogY29udGFpbnMgc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIGZhY2V0IGZpbHRlcnMgaW4gdGhlIGFsZ29saWEgZm9ybWF0LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtmYWNldF0gaWYgc2V0LCB0aGUgY3VycmVudCBkaXNqdW5jdGl2ZSBmYWNldFxuICAgKiBAcmV0dXJuIHthcnJheS48c3RyaW5nPn1cbiAgICovXG4gIF9nZXRGYWNldEZpbHRlcnM6IGZ1bmN0aW9uKHN0YXRlLCBmYWNldCwgaGllcmFyY2hpY2FsUm9vdExldmVsKSB7XG4gICAgdmFyIGZhY2V0RmlsdGVycyA9IFtdO1xuXG4gICAgdmFyIGZhY2V0c1JlZmluZW1lbnRzID0gc3RhdGUuZmFjZXRzUmVmaW5lbWVudHMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZmFjZXRzUmVmaW5lbWVudHMpLmZvckVhY2goZnVuY3Rpb24oZmFjZXROYW1lKSB7XG4gICAgICB2YXIgZmFjZXRWYWx1ZXMgPSBmYWNldHNSZWZpbmVtZW50c1tmYWNldE5hbWVdIHx8IFtdO1xuICAgICAgZmFjZXRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbihmYWNldFZhbHVlKSB7XG4gICAgICAgIGZhY2V0RmlsdGVycy5wdXNoKGZhY2V0TmFtZSArICc6JyArIGZhY2V0VmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZmFjZXRzRXhjbHVkZXMgPSBzdGF0ZS5mYWNldHNFeGNsdWRlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhmYWNldHNFeGNsdWRlcykuZm9yRWFjaChmdW5jdGlvbihmYWNldE5hbWUpIHtcbiAgICAgIHZhciBmYWNldFZhbHVlcyA9IGZhY2V0c0V4Y2x1ZGVzW2ZhY2V0TmFtZV0gfHwgW107XG4gICAgICBmYWNldFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGZhY2V0VmFsdWUpIHtcbiAgICAgICAgZmFjZXRGaWx0ZXJzLnB1c2goZmFjZXROYW1lICsgJzotJyArIGZhY2V0VmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cyA9IHN0YXRlLmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cykuZm9yRWFjaChmdW5jdGlvbihmYWNldE5hbWUpIHtcbiAgICAgIHZhciBmYWNldFZhbHVlcyA9IGRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHNbZmFjZXROYW1lXSB8fCBbXTtcbiAgICAgIGlmIChmYWNldE5hbWUgPT09IGZhY2V0IHx8ICFmYWNldFZhbHVlcyB8fCBmYWNldFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9yRmlsdGVycyA9IFtdO1xuXG4gICAgICBmYWNldFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGZhY2V0VmFsdWUpIHtcbiAgICAgICAgb3JGaWx0ZXJzLnB1c2goZmFjZXROYW1lICsgJzonICsgZmFjZXRWYWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgZmFjZXRGaWx0ZXJzLnB1c2gob3JGaWx0ZXJzKTtcbiAgICB9KTtcblxuICAgIHZhciBoaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50cyA9IHN0YXRlLmhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGZhY2V0TmFtZSkge1xuICAgICAgdmFyIGZhY2V0VmFsdWVzID0gaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHNbZmFjZXROYW1lXSB8fCBbXTtcbiAgICAgIHZhciBmYWNldFZhbHVlID0gZmFjZXRWYWx1ZXNbMF07XG5cbiAgICAgIGlmIChmYWNldFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGllcmFyY2hpY2FsRmFjZXQgPSBzdGF0ZS5nZXRIaWVyYXJjaGljYWxGYWNldEJ5TmFtZShmYWNldE5hbWUpO1xuICAgICAgdmFyIHNlcGFyYXRvciA9IHN0YXRlLl9nZXRIaWVyYXJjaGljYWxGYWNldFNlcGFyYXRvcihoaWVyYXJjaGljYWxGYWNldCk7XG4gICAgICB2YXIgcm9vdFBhdGggPSBzdGF0ZS5fZ2V0SGllcmFyY2hpY2FsUm9vdFBhdGgoaGllcmFyY2hpY2FsRmFjZXQpO1xuICAgICAgdmFyIGF0dHJpYnV0ZVRvUmVmaW5lO1xuICAgICAgdmFyIGF0dHJpYnV0ZXNJbmRleDtcblxuICAgICAgLy8gd2UgYXNrIGZvciBwYXJlbnQgZmFjZXQgdmFsdWVzIG9ubHkgd2hlbiB0aGUgYGZhY2V0YCBpcyB0aGUgY3VycmVudCBoaWVyYXJjaGljYWwgZmFjZXRcbiAgICAgIGlmIChmYWNldCA9PT0gZmFjZXROYW1lKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBhdCB0aGUgcm9vdCBsZXZlbCBhbHJlYWR5LCBubyBuZWVkIHRvIGFzayBmb3IgZmFjZXQgdmFsdWVzLCB3ZSBnZXQgdGhlbSBmcm9tXG4gICAgICAgIC8vIHRoZSBoaXRzIHF1ZXJ5XG4gICAgICAgIGlmIChmYWNldFZhbHVlLmluZGV4T2Yoc2VwYXJhdG9yKSA9PT0gLTEgfHwgKCFyb290UGF0aCAmJiBoaWVyYXJjaGljYWxSb290TGV2ZWwgPT09IHRydWUpIHx8XG4gICAgICAgICAgKHJvb3RQYXRoICYmIHJvb3RQYXRoLnNwbGl0KHNlcGFyYXRvcikubGVuZ3RoID09PSBmYWNldFZhbHVlLnNwbGl0KHNlcGFyYXRvcikubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm9vdFBhdGgpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzSW5kZXggPSBmYWNldFZhbHVlLnNwbGl0KHNlcGFyYXRvcikubGVuZ3RoIC0gMjtcbiAgICAgICAgICBmYWNldFZhbHVlID0gZmFjZXRWYWx1ZS5zbGljZSgwLCBmYWNldFZhbHVlLmxhc3RJbmRleE9mKHNlcGFyYXRvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJpYnV0ZXNJbmRleCA9IHJvb3RQYXRoLnNwbGl0KHNlcGFyYXRvcikubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmYWNldFZhbHVlID0gcm9vdFBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVUb1JlZmluZSA9IGhpZXJhcmNoaWNhbEZhY2V0LmF0dHJpYnV0ZXNbYXR0cmlidXRlc0luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZXNJbmRleCA9IGZhY2V0VmFsdWUuc3BsaXQoc2VwYXJhdG9yKS5sZW5ndGggLSAxO1xuXG4gICAgICAgIGF0dHJpYnV0ZVRvUmVmaW5lID0gaGllcmFyY2hpY2FsRmFjZXQuYXR0cmlidXRlc1thdHRyaWJ1dGVzSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlVG9SZWZpbmUpIHtcbiAgICAgICAgZmFjZXRGaWx0ZXJzLnB1c2goW2F0dHJpYnV0ZVRvUmVmaW5lICsgJzonICsgZmFjZXRWYWx1ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZhY2V0RmlsdGVycztcbiAgfSxcblxuICBfZ2V0SGl0c0hpZXJhcmNoaWNhbEZhY2V0c0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuXG4gICAgcmV0dXJuIHN0YXRlLmhpZXJhcmNoaWNhbEZhY2V0cy5yZWR1Y2UoXG4gICAgICAvLyBhc2sgZm9yIGFzIG11Y2ggbGV2ZWxzIGFzIHRoZXJlJ3MgaGllcmFyY2hpY2FsIHJlZmluZW1lbnRzXG4gICAgICBmdW5jdGlvbiBnZXRIaXRzQXR0cmlidXRlc0ZvckhpZXJhcmNoaWNhbEZhY2V0KGFsbEF0dHJpYnV0ZXMsIGhpZXJhcmNoaWNhbEZhY2V0KSB7XG4gICAgICAgIHZhciBoaWVyYXJjaGljYWxSZWZpbmVtZW50ID0gc3RhdGUuZ2V0SGllcmFyY2hpY2FsUmVmaW5lbWVudChoaWVyYXJjaGljYWxGYWNldC5uYW1lKVswXTtcblxuICAgICAgICAvLyBpZiBubyByZWZpbmVtZW50LCBhc2sgZm9yIHJvb3QgbGV2ZWxcbiAgICAgICAgaWYgKCFoaWVyYXJjaGljYWxSZWZpbmVtZW50KSB7XG4gICAgICAgICAgYWxsQXR0cmlidXRlcy5wdXNoKGhpZXJhcmNoaWNhbEZhY2V0LmF0dHJpYnV0ZXNbMF0pO1xuICAgICAgICAgIHJldHVybiBhbGxBdHRyaWJ1dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IHN0YXRlLl9nZXRIaWVyYXJjaGljYWxGYWNldFNlcGFyYXRvcihoaWVyYXJjaGljYWxGYWNldCk7XG4gICAgICAgIHZhciBsZXZlbCA9IGhpZXJhcmNoaWNhbFJlZmluZW1lbnQuc3BsaXQoc2VwYXJhdG9yKS5sZW5ndGg7XG4gICAgICAgIHZhciBuZXdBdHRyaWJ1dGVzID0gaGllcmFyY2hpY2FsRmFjZXQuYXR0cmlidXRlcy5zbGljZSgwLCBsZXZlbCArIDEpO1xuXG4gICAgICAgIHJldHVybiBhbGxBdHRyaWJ1dGVzLmNvbmNhdChuZXdBdHRyaWJ1dGVzKTtcbiAgICAgIH0sIG91dCk7XG4gIH0sXG5cbiAgX2dldERpc2p1bmN0aXZlSGllcmFyY2hpY2FsRmFjZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKHN0YXRlLCBoaWVyYXJjaGljYWxGYWNldCwgcm9vdExldmVsKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IHN0YXRlLl9nZXRIaWVyYXJjaGljYWxGYWNldFNlcGFyYXRvcihoaWVyYXJjaGljYWxGYWNldCk7XG4gICAgaWYgKHJvb3RMZXZlbCA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIHJvb3RQYXRoID0gc3RhdGUuX2dldEhpZXJhcmNoaWNhbFJvb3RQYXRoKGhpZXJhcmNoaWNhbEZhY2V0KTtcbiAgICAgIHZhciBhdHRyaWJ1dGVJbmRleCA9IDA7XG5cbiAgICAgIGlmIChyb290UGF0aCkge1xuICAgICAgICBhdHRyaWJ1dGVJbmRleCA9IHJvb3RQYXRoLnNwbGl0KHNlcGFyYXRvcikubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtoaWVyYXJjaGljYWxGYWNldC5hdHRyaWJ1dGVzW2F0dHJpYnV0ZUluZGV4XV07XG4gICAgfVxuXG4gICAgdmFyIGhpZXJhcmNoaWNhbFJlZmluZW1lbnQgPSBzdGF0ZS5nZXRIaWVyYXJjaGljYWxSZWZpbmVtZW50KGhpZXJhcmNoaWNhbEZhY2V0Lm5hbWUpWzBdIHx8ICcnO1xuICAgIC8vIGlmIHJlZmluZW1lbnQgaXMgJ2JlZXJzID4gSVBBID4gRmx5aW5nIGRvZycsXG4gICAgLy8gdGhlbiB3ZSB3YW50IGBmYWNldHM6IFsnYmVlcnMgPiBJUEEnXWAgYXMgZGlzanVuY3RpdmUgZmFjZXQgKHBhcmVudCBsZXZlbCB2YWx1ZXMpXG5cbiAgICB2YXIgcGFyZW50TGV2ZWwgPSBoaWVyYXJjaGljYWxSZWZpbmVtZW50LnNwbGl0KHNlcGFyYXRvcikubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gaGllcmFyY2hpY2FsRmFjZXQuYXR0cmlidXRlcy5zbGljZSgwLCBwYXJlbnRMZXZlbCArIDEpO1xuICB9LFxuXG4gIGdldFNlYXJjaEZvckZhY2V0UXVlcnk6IGZ1bmN0aW9uKGZhY2V0TmFtZSwgcXVlcnksIG1heEZhY2V0SGl0cywgc3RhdGUpIHtcbiAgICB2YXIgc3RhdGVGb3JTZWFyY2hGb3JGYWNldFZhbHVlcyA9IHN0YXRlLmlzRGlzanVuY3RpdmVGYWNldChmYWNldE5hbWUpID9cbiAgICAgIHN0YXRlLmNsZWFyUmVmaW5lbWVudHMoZmFjZXROYW1lKSA6XG4gICAgICBzdGF0ZTtcbiAgICB2YXIgc2VhcmNoRm9yRmFjZXRTZWFyY2hQYXJhbWV0ZXJzID0ge1xuICAgICAgZmFjZXRRdWVyeTogcXVlcnksXG4gICAgICBmYWNldE5hbWU6IGZhY2V0TmFtZVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBtYXhGYWNldEhpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBzZWFyY2hGb3JGYWNldFNlYXJjaFBhcmFtZXRlcnMubWF4RmFjZXRIaXRzID0gbWF4RmFjZXRIaXRzO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2UoXG4gICAgICB7fSxcbiAgICAgIHJlcXVlc3RCdWlsZGVyLl9nZXRIaXRzU2VhcmNoUGFyYW1zKHN0YXRlRm9yU2VhcmNoRm9yRmFjZXRWYWx1ZXMpLFxuICAgICAgc2VhcmNoRm9yRmFjZXRTZWFyY2hQYXJhbWV0ZXJzXG4gICAgKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0QnVpbGRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1ZhbGlkVXNlclRva2VuKHVzZXJUb2tlbikge1xuICBpZiAodXNlclRva2VuID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAvXlthLXpBLVowLTlfLV17MSw2NH0kLy50ZXN0KHVzZXJUb2tlbik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICczLjUuNSc7XG4iLCIvKiEgYWxnb2xpYXNlYXJjaC1saXRlLnVtZC5qcyB8IDQuMTAuMyB8IMKpIEFsZ29saWEsIGluYy4gfCBodHRwczovL2dpdGh1Yi5jb20vYWxnb2xpYS9hbGdvbGlhc2VhcmNoLWNsaWVudC1qYXZhc2NyaXB0ICovXG4hZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTooZT1lfHxzZWxmKS5hbGdvbGlhc2VhcmNoPXQoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKGUsdCxyKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPXIsZX1mdW5jdGlvbiB0KGUsdCl7dmFyIHI9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYobj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxyLnB1c2guYXBwbHkocixuKX1yZXR1cm4gcn1mdW5jdGlvbiByKHIpe2Zvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3ZhciBvPW51bGwhPWFyZ3VtZW50c1tuXT9hcmd1bWVudHNbbl06e307biUyP3QoT2JqZWN0KG8pLCEwKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlKHIsdCxvW3RdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhyLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG8pKTp0KE9iamVjdChvKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sZSkpfSkpfXJldHVybiByfWZ1bmN0aW9uIG4oZSx0KXtpZihudWxsPT1lKXJldHVybnt9O3ZhciByLG4sbz1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWUpcmV0dXJue307dmFyIHIsbixvPXt9LGE9T2JqZWN0LmtleXMoZSk7Zm9yKG49MDtuPGEubGVuZ3RoO24rKylyPWFbbl0sdC5pbmRleE9mKHIpPj0wfHwob1tyXT1lW3JdKTtyZXR1cm4gb30oZSx0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO2ZvcihuPTA7bjxhLmxlbmd0aDtuKyspcj1hW25dLHQuaW5kZXhPZihyKT49MHx8T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUscikmJihvW3JdPWVbcl0pfXJldHVybiBvfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX0oZSl8fGZ1bmN0aW9uKGUsdCl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKSlyZXR1cm47dmFyIHI9W10sbj0hMCxvPSExLGE9dm9pZCAwO3RyeXtmb3IodmFyIHUsaT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKG49KHU9aS5uZXh0KCkpLmRvbmUpJiYoci5wdXNoKHUudmFsdWUpLCF0fHxyLmxlbmd0aCE9PXQpO249ITApO31jYXRjaChlKXtvPSEwLGE9ZX1maW5hbGx5e3RyeXtufHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgYX19cmV0dXJuIHJ9KGUsdCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAscj1uZXcgQXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKXJbdF09ZVt0XTtyZXR1cm4gcn19KGUpfHxmdW5jdGlvbihlKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gdShlKXt2YXIgdCxyPVwiYWxnb2xpYXNlYXJjaC1jbGllbnQtanMtXCIuY29uY2F0KGUua2V5KSxuPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PWUubG9jYWxTdG9yYWdlfHx3aW5kb3cubG9jYWxTdG9yYWdlKSx0fSxhPWZ1bmN0aW9uKCl7cmV0dXJuIEpTT04ucGFyc2UobigpLmdldEl0ZW0ocil8fFwie31cIil9O3JldHVybntnZXQ6ZnVuY3Rpb24oZSx0KXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e21pc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9fTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXt2YXIgcj1KU09OLnN0cmluZ2lmeShlKSxuPWEoKVtyXTtyZXR1cm4gUHJvbWlzZS5hbGwoW258fHQoKSx2b2lkIDAhPT1uXSl9KSkudGhlbigoZnVuY3Rpb24oZSl7dmFyIHQ9byhlLDIpLG49dFswXSxhPXRbMV07cmV0dXJuIFByb21pc2UuYWxsKFtuLGF8fHIubWlzcyhuKV0pfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBvKGUsMSlbMF19KSl9LHNldDpmdW5jdGlvbihlLHQpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3ZhciBvPWEoKTtyZXR1cm4gb1tKU09OLnN0cmluZ2lmeShlKV09dCxuKCkuc2V0SXRlbShyLEpTT04uc3RyaW5naWZ5KG8pKSx0fSkpfSxkZWxldGU6ZnVuY3Rpb24oZSl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7dmFyIHQ9YSgpO2RlbGV0ZSB0W0pTT04uc3RyaW5naWZ5KGUpXSxuKCkuc2V0SXRlbShyLEpTT04uc3RyaW5naWZ5KHQpKX0pKX0sY2xlYXI6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtuKCkucmVtb3ZlSXRlbShyKX0pKX19fWZ1bmN0aW9uIGkoZSl7dmFyIHQ9YShlLmNhY2hlcykscj10LnNoaWZ0KCk7cmV0dXJuIHZvaWQgMD09PXI/e2dldDpmdW5jdGlvbihlLHQpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7bWlzczpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKX19LG49dCgpO3JldHVybiBuLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLmFsbChbZSxyLm1pc3MoZSldKX0pKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gbyhlLDEpWzBdfSkpfSxzZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHQpfSxkZWxldGU6ZnVuY3Rpb24oZSl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfSxjbGVhcjpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKX19OntnZXQ6ZnVuY3Rpb24oZSxuKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e21pc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9fTtyZXR1cm4gci5nZXQoZSxuLG8pLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBpKHtjYWNoZXM6dH0pLmdldChlLG4sbyl9KSl9LHNldDpmdW5jdGlvbihlLG4pe3JldHVybiByLnNldChlLG4pLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBpKHtjYWNoZXM6dH0pLnNldChlLG4pfSkpfSxkZWxldGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHIuZGVsZXRlKGUpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBpKHtjYWNoZXM6dH0pLmRlbGV0ZShlKX0pKX0sY2xlYXI6ZnVuY3Rpb24oKXtyZXR1cm4gci5jbGVhcigpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBpKHtjYWNoZXM6dH0pLmNsZWFyKCl9KSl9fX1mdW5jdGlvbiBzKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOntzZXJpYWxpemFibGU6ITB9LHQ9e307cmV0dXJue2dldDpmdW5jdGlvbihyLG4pe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7bWlzczpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKX19LGE9SlNPTi5zdHJpbmdpZnkocik7aWYoYSBpbiB0KXJldHVybiBQcm9taXNlLnJlc29sdmUoZS5zZXJpYWxpemFibGU/SlNPTi5wYXJzZSh0W2FdKTp0W2FdKTt2YXIgdT1uKCksaT1vJiZvLm1pc3N8fGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfTtyZXR1cm4gdS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gaShlKX0pKS50aGVuKChmdW5jdGlvbigpe3JldHVybiB1fSkpfSxzZXQ6ZnVuY3Rpb24ocixuKXtyZXR1cm4gdFtKU09OLnN0cmluZ2lmeShyKV09ZS5zZXJpYWxpemFibGU/SlNPTi5zdHJpbmdpZnkobik6bixQcm9taXNlLnJlc29sdmUobil9LGRlbGV0ZTpmdW5jdGlvbihlKXtyZXR1cm4gZGVsZXRlIHRbSlNPTi5zdHJpbmdpZnkoZSldLFByb21pc2UucmVzb2x2ZSgpfSxjbGVhcjpmdW5jdGlvbigpe3JldHVybiB0PXt9LFByb21pc2UucmVzb2x2ZSgpfX19ZnVuY3Rpb24gYyhlKXtmb3IodmFyIHQ9ZS5sZW5ndGgtMTt0PjA7dC0tKXt2YXIgcj1NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKHQrMSkpLG49ZVt0XTtlW3RdPWVbcl0sZVtyXT1ufXJldHVybiBlfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4gdD8oT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24ocil7ZVtyXT10W3JdKGUpfSkpLGUpOmV9ZnVuY3Rpb24gZihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheSh0PjE/dC0xOjApLG49MTtuPHQ7bisrKXJbbi0xXT1hcmd1bWVudHNbbl07dmFyIG89MDtyZXR1cm4gZS5yZXBsYWNlKC8lcy9nLChmdW5jdGlvbigpe3JldHVybiBlbmNvZGVVUklDb21wb25lbnQocltvKytdKX0pKX12YXIgaD17V2l0aGluUXVlcnlQYXJhbWV0ZXJzOjAsV2l0aGluSGVhZGVyczoxfTtmdW5jdGlvbiBkKGUsdCl7dmFyIHI9ZXx8e30sbj1yLmRhdGF8fHt9O3JldHVybiBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKChmdW5jdGlvbihlKXstMT09PVtcInRpbWVvdXRcIixcImhlYWRlcnNcIixcInF1ZXJ5UGFyYW1ldGVyc1wiLFwiZGF0YVwiLFwiY2FjaGVhYmxlXCJdLmluZGV4T2YoZSkmJihuW2VdPXJbZV0pfSkpLHtkYXRhOk9iamVjdC5lbnRyaWVzKG4pLmxlbmd0aD4wP246dm9pZCAwLHRpbWVvdXQ6ci50aW1lb3V0fHx0LGhlYWRlcnM6ci5oZWFkZXJzfHx7fSxxdWVyeVBhcmFtZXRlcnM6ci5xdWVyeVBhcmFtZXRlcnN8fHt9LGNhY2hlYWJsZTpyLmNhY2hlYWJsZX19dmFyIG09e1JlYWQ6MSxXcml0ZToyLEFueTozfSxwPTEsdj0yLHk9MztmdW5jdGlvbiBnKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpwO3JldHVybiByKHIoe30sZSkse30se3N0YXR1czp0LGxhc3RVcGRhdGU6RGF0ZS5ub3coKX0pfWZ1bmN0aW9uIGIoZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/e3Byb3RvY29sOlwiaHR0cHNcIix1cmw6ZSxhY2NlcHQ6bS5Bbnl9Ontwcm90b2NvbDplLnByb3RvY29sfHxcImh0dHBzXCIsdXJsOmUudXJsLGFjY2VwdDplLmFjY2VwdHx8bS5Bbnl9fXZhciBPPVwiR0VUXCIsUD1cIlBPU1RcIjtmdW5jdGlvbiBxKGUsdCl7cmV0dXJuIFByb21pc2UuYWxsKHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZS5nZXQodCwoZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGcodCkpfSkpfSkpKS50aGVuKChmdW5jdGlvbihlKXt2YXIgcj1lLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0YXR1cz09PXB8fERhdGUubm93KCktZS5sYXN0VXBkYXRlPjEyZTR9KGUpfSkpLG49ZS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZS5zdGF0dXM9PT15JiZEYXRlLm5vdygpLWUubGFzdFVwZGF0ZTw9MTJlNH0oZSl9KSksbz1bXS5jb25jYXQoYShyKSxhKG4pKTtyZXR1cm57Z2V0VGltZW91dDpmdW5jdGlvbihlLHQpe3JldHVybigwPT09bi5sZW5ndGgmJjA9PT1lPzE6bi5sZW5ndGgrMytlKSp0fSxzdGF0ZWxlc3NIb3N0czpvLmxlbmd0aD4wP28ubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gYihlKX0pKTp0fX0pKX1mdW5jdGlvbiBqKGUsdCxuLG8pe3ZhciB1PVtdLGk9ZnVuY3Rpb24oZSx0KXtpZihlLm1ldGhvZD09PU98fHZvaWQgMD09PWUuZGF0YSYmdm9pZCAwPT09dC5kYXRhKXJldHVybjt2YXIgbj1BcnJheS5pc0FycmF5KGUuZGF0YSk/ZS5kYXRhOnIocih7fSxlLmRhdGEpLHQuZGF0YSk7cmV0dXJuIEpTT04uc3RyaW5naWZ5KG4pfShuLG8pLHM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1yKHIoe30sZS5oZWFkZXJzKSx0LmhlYWRlcnMpLG89e307cmV0dXJuIE9iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PW5bZV07b1tlLnRvTG93ZXJDYXNlKCldPXR9KSksb30oZSxvKSxjPW4ubWV0aG9kLGw9bi5tZXRob2QhPT1PP3t9OnIocih7fSxuLmRhdGEpLG8uZGF0YSksZj1yKHIocih7XCJ4LWFsZ29saWEtYWdlbnRcIjplLnVzZXJBZ2VudC52YWx1ZX0sZS5xdWVyeVBhcmFtZXRlcnMpLGwpLG8ucXVlcnlQYXJhbWV0ZXJzKSxoPTAsZD1mdW5jdGlvbiB0KHIsYSl7dmFyIGw9ci5wb3AoKTtpZih2b2lkIDA9PT1sKXRocm93e25hbWU6XCJSZXRyeUVycm9yXCIsbWVzc2FnZTpcIlVucmVhY2hhYmxlIGhvc3RzIC0geW91ciBhcHBsaWNhdGlvbiBpZCBtYXkgYmUgaW5jb3JyZWN0LiBJZiB0aGUgZXJyb3IgcGVyc2lzdHMsIGNvbnRhY3Qgc3VwcG9ydEBhbGdvbGlhLmNvbS5cIix0cmFuc3BvcnRlclN0YWNrVHJhY2U6QSh1KX07dmFyIGQ9e2RhdGE6aSxoZWFkZXJzOnMsbWV0aG9kOmMsdXJsOlMobCxuLnBhdGgsZiksY29ubmVjdFRpbWVvdXQ6YShoLGUudGltZW91dHMuY29ubmVjdCkscmVzcG9uc2VUaW1lb3V0OmEoaCxvLnRpbWVvdXQpfSxtPWZ1bmN0aW9uKGUpe3ZhciB0PXtyZXF1ZXN0OmQscmVzcG9uc2U6ZSxob3N0OmwsdHJpZXNMZWZ0OnIubGVuZ3RofTtyZXR1cm4gdS5wdXNoKHQpLHR9LHA9e29uU3VjY2VzczpmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBKU09OLnBhcnNlKGUuY29udGVudCl9Y2F0Y2godCl7dGhyb3cgZnVuY3Rpb24oZSx0KXtyZXR1cm57bmFtZTpcIkRlc2VyaWFsaXphdGlvbkVycm9yXCIsbWVzc2FnZTplLHJlc3BvbnNlOnR9fSh0Lm1lc3NhZ2UsZSl9fShlKX0sb25SZXRyeTpmdW5jdGlvbihuKXt2YXIgbz1tKG4pO3JldHVybiBuLmlzVGltZWRPdXQmJmgrKyxQcm9taXNlLmFsbChbZS5sb2dnZXIuaW5mbyhcIlJldHJ5YWJsZSBmYWlsdXJlXCIseChvKSksZS5ob3N0c0NhY2hlLnNldChsLGcobCxuLmlzVGltZWRPdXQ/eTp2KSldKS50aGVuKChmdW5jdGlvbigpe3JldHVybiB0KHIsYSl9KSl9LG9uRmFpbDpmdW5jdGlvbihlKXt0aHJvdyBtKGUpLGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5jb250ZW50LG49ZS5zdGF0dXMsbz1yO3RyeXtvPUpTT04ucGFyc2UocikubWVzc2FnZX1jYXRjaChlKXt9cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm57bmFtZTpcIkFwaUVycm9yXCIsbWVzc2FnZTplLHN0YXR1czp0LHRyYW5zcG9ydGVyU3RhY2tUcmFjZTpyfX0obyxuLHQpfShlLEEodSkpfX07cmV0dXJuIGUucmVxdWVzdGVyLnNlbmQoZCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RhdHVzO3JldHVybiBlLmlzVGltZWRPdXR8fGZ1bmN0aW9uKGUpe3ZhciB0PWUuaXNUaW1lZE91dCxyPWUuc3RhdHVzO3JldHVybiF0JiYwPT1+fnJ9KGUpfHwyIT1+fih0LzEwMCkmJjQhPX5+KHQvMTAwKX0oZSk/dC5vblJldHJ5KGUpOjI9PX5+KGUuc3RhdHVzLzEwMCk/dC5vblN1Y2Nlc3MoZSk6dC5vbkZhaWwoZSl9KGUscCl9KSl9O3JldHVybiBxKGUuaG9zdHNDYWNoZSx0KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gZChhKGUuc3RhdGVsZXNzSG9zdHMpLnJldmVyc2UoKSxlLmdldFRpbWVvdXQpfSkpfWZ1bmN0aW9uIHcoZSl7dmFyIHQ9e3ZhbHVlOlwiQWxnb2xpYSBmb3IgSmF2YVNjcmlwdCAoXCIuY29uY2F0KGUsXCIpXCIpLGFkZDpmdW5jdGlvbihlKXt2YXIgcj1cIjsgXCIuY29uY2F0KGUuc2VnbWVudCkuY29uY2F0KHZvaWQgMCE9PWUudmVyc2lvbj9cIiAoXCIuY29uY2F0KGUudmVyc2lvbixcIilcIik6XCJcIik7cmV0dXJuLTE9PT10LnZhbHVlLmluZGV4T2YocikmJih0LnZhbHVlPVwiXCIuY29uY2F0KHQudmFsdWUpLmNvbmNhdChyKSksdH19O3JldHVybiB0fWZ1bmN0aW9uIFMoZSx0LHIpe3ZhciBuPVQociksbz1cIlwiLmNvbmNhdChlLnByb3RvY29sLFwiOi8vXCIpLmNvbmNhdChlLnVybCxcIi9cIikuY29uY2F0KFwiL1wiPT09dC5jaGFyQXQoMCk/dC5zdWJzdHIoMSk6dCk7cmV0dXJuIG4ubGVuZ3RoJiYobys9XCI/XCIuY29uY2F0KG4pKSxvfWZ1bmN0aW9uIFQoZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGYoXCIlcz0lc1wiLHQsKHI9ZVt0XSxcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpfHxcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocik/SlNPTi5zdHJpbmdpZnkoZVt0XSk6ZVt0XSkpO3ZhciByfSkpLmpvaW4oXCImXCIpfWZ1bmN0aW9uIEEoZSl7cmV0dXJuIGUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4geChlKX0pKX1mdW5jdGlvbiB4KGUpe3ZhciB0PWUucmVxdWVzdC5oZWFkZXJzW1wieC1hbGdvbGlhLWFwaS1rZXlcIl0/e1wieC1hbGdvbGlhLWFwaS1rZXlcIjpcIioqKioqXCJ9Ont9O3JldHVybiByKHIoe30sZSkse30se3JlcXVlc3Q6cihyKHt9LGUucmVxdWVzdCkse30se2hlYWRlcnM6cihyKHt9LGUucmVxdWVzdC5oZWFkZXJzKSx0KX0pfSl9dmFyIE49ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hcHBJZCxuPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj17XCJ4LWFsZ29saWEtYXBpLWtleVwiOnIsXCJ4LWFsZ29saWEtYXBwbGljYXRpb24taWRcIjp0fTtyZXR1cm57aGVhZGVyczpmdW5jdGlvbigpe3JldHVybiBlPT09aC5XaXRoaW5IZWFkZXJzP246e319LHF1ZXJ5UGFyYW1ldGVyczpmdW5jdGlvbigpe3JldHVybiBlPT09aC5XaXRoaW5RdWVyeVBhcmFtZXRlcnM/bjp7fX19fSh2b2lkIDAhPT1lLmF1dGhNb2RlP2UuYXV0aE1vZGU6aC5XaXRoaW5IZWFkZXJzLHQsZS5hcGlLZXkpLGE9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ob3N0c0NhY2hlLHI9ZS5sb2dnZXIsbj1lLnJlcXVlc3RlcixhPWUucmVxdWVzdHNDYWNoZSx1PWUucmVzcG9uc2VzQ2FjaGUsaT1lLnRpbWVvdXRzLHM9ZS51c2VyQWdlbnQsYz1lLmhvc3RzLGw9ZS5xdWVyeVBhcmFtZXRlcnMsZj17aG9zdHNDYWNoZTp0LGxvZ2dlcjpyLHJlcXVlc3RlcjpuLHJlcXVlc3RzQ2FjaGU6YSxyZXNwb25zZXNDYWNoZTp1LHRpbWVvdXRzOmksdXNlckFnZW50OnMsaGVhZGVyczplLmhlYWRlcnMscXVlcnlQYXJhbWV0ZXJzOmwsaG9zdHM6Yy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBiKGUpfSkpLHJlYWQ6ZnVuY3Rpb24oZSx0KXt2YXIgcj1kKHQsZi50aW1lb3V0cy5yZWFkKSxuPWZ1bmN0aW9uKCl7cmV0dXJuIGooZixmLmhvc3RzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIDAhPShlLmFjY2VwdCZtLlJlYWQpfSkpLGUscil9O2lmKCEwIT09KHZvaWQgMCE9PXIuY2FjaGVhYmxlP3IuY2FjaGVhYmxlOmUuY2FjaGVhYmxlKSlyZXR1cm4gbigpO3ZhciBhPXtyZXF1ZXN0OmUsbWFwcGVkUmVxdWVzdE9wdGlvbnM6cix0cmFuc3BvcnRlcjp7cXVlcnlQYXJhbWV0ZXJzOmYucXVlcnlQYXJhbWV0ZXJzLGhlYWRlcnM6Zi5oZWFkZXJzfX07cmV0dXJuIGYucmVzcG9uc2VzQ2FjaGUuZ2V0KGEsKGZ1bmN0aW9uKCl7cmV0dXJuIGYucmVxdWVzdHNDYWNoZS5nZXQoYSwoZnVuY3Rpb24oKXtyZXR1cm4gZi5yZXF1ZXN0c0NhY2hlLnNldChhLG4oKSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFByb21pc2UuYWxsKFtmLnJlcXVlc3RzQ2FjaGUuZGVsZXRlKGEpLGVdKX0pLChmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5hbGwoW2YucmVxdWVzdHNDYWNoZS5kZWxldGUoYSksUHJvbWlzZS5yZWplY3QoZSldKX0pKS50aGVuKChmdW5jdGlvbihlKXt2YXIgdD1vKGUsMik7dFswXTtyZXR1cm4gdFsxXX0pKX0pKX0pLHttaXNzOmZ1bmN0aW9uKGUpe3JldHVybiBmLnJlc3BvbnNlc0NhY2hlLnNldChhLGUpfX0pfSx3cml0ZTpmdW5jdGlvbihlLHQpe3JldHVybiBqKGYsZi5ob3N0cy5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiAwIT0oZS5hY2NlcHQmbS5Xcml0ZSl9KSksZSxkKHQsZi50aW1lb3V0cy53cml0ZSkpfX07cmV0dXJuIGZ9KHIocih7aG9zdHM6W3t1cmw6XCJcIi5jb25jYXQodCxcIi1kc24uYWxnb2xpYS5uZXRcIiksYWNjZXB0Om0uUmVhZH0se3VybDpcIlwiLmNvbmNhdCh0LFwiLmFsZ29saWEubmV0XCIpLGFjY2VwdDptLldyaXRlfV0uY29uY2F0KGMoW3t1cmw6XCJcIi5jb25jYXQodCxcIi0xLmFsZ29saWFuZXQuY29tXCIpfSx7dXJsOlwiXCIuY29uY2F0KHQsXCItMi5hbGdvbGlhbmV0LmNvbVwiKX0se3VybDpcIlwiLmNvbmNhdCh0LFwiLTMuYWxnb2xpYW5ldC5jb21cIil9XSkpfSxlKSx7fSx7aGVhZGVyczpyKHIocih7fSxuLmhlYWRlcnMoKSkse1wiY29udGVudC10eXBlXCI6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIn0pLGUuaGVhZGVycykscXVlcnlQYXJhbWV0ZXJzOnIocih7fSxuLnF1ZXJ5UGFyYW1ldGVycygpKSxlLnF1ZXJ5UGFyYW1ldGVycyl9KSk7cmV0dXJuIGwoe3RyYW5zcG9ydGVyOmEsYXBwSWQ6dCxhZGRBbGdvbGlhQWdlbnQ6ZnVuY3Rpb24oZSx0KXthLnVzZXJBZ2VudC5hZGQoe3NlZ21lbnQ6ZSx2ZXJzaW9uOnR9KX0sY2xlYXJDYWNoZTpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLmFsbChbYS5yZXF1ZXN0c0NhY2hlLmNsZWFyKCksYS5yZXNwb25zZXNDYWNoZS5jbGVhcigpXSkudGhlbigoZnVuY3Rpb24oKXt9KSl9fSxlLm1ldGhvZHMpfSxDPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj17dHJhbnNwb3J0ZXI6ZS50cmFuc3BvcnRlcixhcHBJZDplLmFwcElkLGluZGV4TmFtZTp0fTtyZXR1cm4gbChuLHIubWV0aG9kcyl9fSxrPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LG4pe3ZhciBvPXQubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gcihyKHt9LGUpLHt9LHtwYXJhbXM6VChlLnBhcmFtc3x8e30pfSl9KSk7cmV0dXJuIGUudHJhbnNwb3J0ZXIucmVhZCh7bWV0aG9kOlAscGF0aDpcIjEvaW5kZXhlcy8qL3F1ZXJpZXNcIixkYXRhOntyZXF1ZXN0czpvfSxjYWNoZWFibGU6ITB9LG4pfX0sSj1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxvKXtyZXR1cm4gUHJvbWlzZS5hbGwodC5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBhPXQucGFyYW1zLHU9YS5mYWNldE5hbWUsaT1hLmZhY2V0UXVlcnkscz1uKGEsW1wiZmFjZXROYW1lXCIsXCJmYWNldFF1ZXJ5XCJdKTtyZXR1cm4gQyhlKSh0LmluZGV4TmFtZSx7bWV0aG9kczp7c2VhcmNoRm9yRmFjZXRWYWx1ZXM6Rn19KS5zZWFyY2hGb3JGYWNldFZhbHVlcyh1LGkscihyKHt9LG8pLHMpKX0pKSl9fSxFPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LHIsbil7cmV0dXJuIGUudHJhbnNwb3J0ZXIucmVhZCh7bWV0aG9kOlAscGF0aDpmKFwiMS9hbnN3ZXJzLyVzL3ByZWRpY3Rpb25cIixlLmluZGV4TmFtZSksZGF0YTp7cXVlcnk6dCxxdWVyeUxhbmd1YWdlczpyfSxjYWNoZWFibGU6ITB9LG4pfX0sST1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxyKXtyZXR1cm4gZS50cmFuc3BvcnRlci5yZWFkKHttZXRob2Q6UCxwYXRoOmYoXCIxL2luZGV4ZXMvJXMvcXVlcnlcIixlLmluZGV4TmFtZSksZGF0YTp7cXVlcnk6dH0sY2FjaGVhYmxlOiEwfSxyKX19LEY9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQscixuKXtyZXR1cm4gZS50cmFuc3BvcnRlci5yZWFkKHttZXRob2Q6UCxwYXRoOmYoXCIxL2luZGV4ZXMvJXMvZmFjZXRzLyVzL3F1ZXJ5XCIsZS5pbmRleE5hbWUsdCksZGF0YTp7ZmFjZXRRdWVyeTpyfSxjYWNoZWFibGU6ITB9LG4pfX0sUj0xLEQ9MixXPTM7ZnVuY3Rpb24gSChlLHQsbil7dmFyIG8sYT17YXBwSWQ6ZSxhcGlLZXk6dCx0aW1lb3V0czp7Y29ubmVjdDoxLHJlYWQ6Mix3cml0ZTozMH0scmVxdWVzdGVyOntzZW5kOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihlLm1ldGhvZCxlLnVybCwhMCksT2JqZWN0LmtleXMoZS5oZWFkZXJzKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gci5zZXRSZXF1ZXN0SGVhZGVyKHQsZS5oZWFkZXJzW3RdKX0pKTt2YXIgbixvPWZ1bmN0aW9uKGUsbil7cmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ci5hYm9ydCgpLHQoe3N0YXR1czowLGNvbnRlbnQ6bixpc1RpbWVkT3V0OiEwfSl9KSwxZTMqZSl9LGE9byhlLmNvbm5lY3RUaW1lb3V0LFwiQ29ubmVjdGlvbiB0aW1lb3V0XCIpO3Iub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ci5yZWFkeVN0YXRlPnIuT1BFTkVEJiZ2b2lkIDA9PT1uJiYoY2xlYXJUaW1lb3V0KGEpLG49byhlLnJlc3BvbnNlVGltZW91dCxcIlNvY2tldCB0aW1lb3V0XCIpKX0sci5vbmVycm9yPWZ1bmN0aW9uKCl7MD09PXIuc3RhdHVzJiYoY2xlYXJUaW1lb3V0KGEpLGNsZWFyVGltZW91dChuKSx0KHtjb250ZW50OnIucmVzcG9uc2VUZXh0fHxcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIixzdGF0dXM6ci5zdGF0dXMsaXNUaW1lZE91dDohMX0pKX0sci5vbmxvYWQ9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoYSksY2xlYXJUaW1lb3V0KG4pLHQoe2NvbnRlbnQ6ci5yZXNwb25zZVRleHQsc3RhdHVzOnIuc3RhdHVzLGlzVGltZWRPdXQ6ITF9KX0sci5zZW5kKGUuZGF0YSl9KSl9fSxsb2dnZXI6KG89Vyx7ZGVidWc6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gUj49byYmY29uc29sZS5kZWJ1ZyhlLHQpLFByb21pc2UucmVzb2x2ZSgpfSxpbmZvOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIEQ+PW8mJmNvbnNvbGUuaW5mbyhlLHQpLFByb21pc2UucmVzb2x2ZSgpfSxlcnJvcjpmdW5jdGlvbihlLHQpe3JldHVybiBjb25zb2xlLmVycm9yKGUsdCksUHJvbWlzZS5yZXNvbHZlKCl9fSkscmVzcG9uc2VzQ2FjaGU6cygpLHJlcXVlc3RzQ2FjaGU6cyh7c2VyaWFsaXphYmxlOiExfSksaG9zdHNDYWNoZTppKHtjYWNoZXM6W3Uoe2tleTpcIlwiLmNvbmNhdChcIjQuMTAuM1wiLFwiLVwiKS5jb25jYXQoZSl9KSxzKCldfSksdXNlckFnZW50OncoXCI0LjEwLjNcIikuYWRkKHtzZWdtZW50OlwiQnJvd3NlclwiLHZlcnNpb246XCJsaXRlXCJ9KSxhdXRoTW9kZTpoLldpdGhpblF1ZXJ5UGFyYW1ldGVyc307cmV0dXJuIE4ocihyKHIoe30sYSksbikse30se21ldGhvZHM6e3NlYXJjaDprLHNlYXJjaEZvckZhY2V0VmFsdWVzOkosbXVsdGlwbGVRdWVyaWVzOmssbXVsdGlwbGVTZWFyY2hGb3JGYWNldFZhbHVlczpKLGluaXRJbmRleDpmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIEMoZSkodCx7bWV0aG9kczp7c2VhcmNoOkksc2VhcmNoRm9yRmFjZXRWYWx1ZXM6RixmaW5kQW5zd2VyczpFfX0pfX19fSkpfXJldHVybiBILnZlcnNpb249XCI0LjEwLjNcIixIfSkpO1xuIiwiLy8gc3RvcEJvZHlTY3JvbGwg5pa55rOV5L6d6LWWXG5sZXQgYm9keUVsID0gZG9jdW1lbnQuYm9keVxubGV0IHdpbmRvd1RvcCA9IDBcbmNvbnN0IGJvZHlFbFBvc2l0aW9uID0gYm9keUVsLnN0eWxlLnBvc2l0aW9uXG5cbmNvbnN0IGFyY2hlclV0aWwgPSB7XG4gIC8vIOWbnuWIsOmhtumDqFxuICBiYWNrVG9wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgd2luZG93LnNjcm9sbFRvKHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgICB9KVxuICB9LFxuXG4gIC8vIOiOt+WPluWFg+e0oOWcqOmhtemdouS4iuebuOWvueW3puS4iuinkueahOS9jee9rlxuICBnZXRBYnNQb3NpdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICBsZXQgeCA9IGUub2Zmc2V0TGVmdCxcbiAgICAgIHkgPSBlLm9mZnNldFRvcFxuXG4gICAgbGV0IGN1cnJlbnQgPSBlLm9mZnNldFBhcmVudFxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB4ICs9IGN1cnJlbnQub2Zmc2V0TGVmdFxuICAgICAgeSArPSBjdXJyZW50Lm9mZnNldFRvcFxuICAgICAgY3VycmVudCA9IGN1cnJlbnQub2Zmc2V0UGFyZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgIH1cbiAgfSxcblxuICAvLyDmoLzlvI/ljJbml6XmnJ9cbiAgZGF0ZUZvcm1hdGVyOiBmdW5jdGlvbiAoZGF0ZSwgZm10KSB7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgICdNKyc6IGRhdGUuZ2V0TW9udGgoKSArIDEsIC8vIOaciOS7vVxuICAgICAgJ2QrJzogZGF0ZS5nZXREYXRlKCksIC8vIOaXpVxuICAgICAgJ2grJzogZGF0ZS5nZXRIb3VycygpLCAvLyDlsI/ml7ZcbiAgICAgICdtKyc6IGRhdGUuZ2V0TWludXRlcygpLCAvLyDliIZcbiAgICAgICdzKyc6IGRhdGUuZ2V0U2Vjb25kcygpLCAvLyDnp5JcbiAgICAgICdxKyc6IE1hdGguZmxvb3IoKGRhdGUuZ2V0TW9udGgoKSArIDMpIC8gMyksIC8vIOWto+W6plxuICAgICAgUzogZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgLy8g5q+r56eSXG4gICAgfVxuICAgIGlmICgvKHkrKS8udGVzdChmbXQpKSB7XG4gICAgICBmbXQgPSBmbXQucmVwbGFjZShcbiAgICAgICAgUmVnRXhwLiQxLFxuICAgICAgICBTdHJpbmcoZGF0ZS5nZXRGdWxsWWVhcigpKS5zdWJzdHIoNCAtIFJlZ0V4cC4kMS5sZW5ndGgpXG4gICAgICApXG4gICAgfVxuICAgIGZvciAoY29uc3QgayBpbiBvKSB7XG4gICAgICBpZiAobmV3IFJlZ0V4cCgnKCcgKyBrICsgJyknKS50ZXN0KGZtdCkpIHtcbiAgICAgICAgZm10ID0gZm10LnJlcGxhY2UoXG4gICAgICAgICAgUmVnRXhwLiQxLFxuICAgICAgICAgIFJlZ0V4cC4kMS5sZW5ndGggPT09IDFcbiAgICAgICAgICAgID8gb1trXVxuICAgICAgICAgICAgOiAoJzAwJyArIG9ba10pLnN1YnN0cihTdHJpbmcob1trXSkubGVuZ3RoKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbXRcbiAgfSxcblxuICAvLyDojrflj5YgMXJlbSDlr7nlupTnmoQgcHgg5YC8XG4gIHJlbTogKCkgPT4ge1xuICAgIHJldHVybiBwYXJzZUludCgkKCdodG1sJykuY3NzKCdmb250LXNpemUnKSwgMTApXG4gIH0sXG5cbiAgLy8g6K6+572u5Zyw5Z2A5qCPIGhhc2hcbiAgc2V0V2luZG93SGFzaDogKGhhc2gpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBgIy8ke2hhc2h9YClcbiAgfSxcblxuICAvLyDor7vlj5blnLDlnYDmoI8gaGFzaFxuICBnZXRXaW5kb3dIYXNoOiAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoL14jXFwvLywgJyMnKVxuICB9LFxuXG4gIC8vIHJBRiDnmoQgdGlja2luZ1xuICByYWZUaWNrOiBmdW5jdGlvbiAodGlja2luZywgdXBkYXRlRnVuYykge1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZUZ1bmMpXG4gICAgfVxuICAgIHRpY2tpbmcgPSB0cnVlXG4gIH0sXG5cbiAgLy8g5Zu65a6aIGJvZHlcbiAgLy8gc2VlOiBodHRwczovL3NlZ21lbnRmYXVsdC5jb20vYS8xMTkwMDAwMDEyMzEzMzM3XG4gIHN0b3BCb2R5U2Nyb2xsOiBmdW5jdGlvbiAoaXNGaXhlZCkge1xuICAgIGlmIChpc0ZpeGVkKSB7XG4gICAgICB3aW5kb3dUb3AgPSB3aW5kb3cuc2Nyb2xsWVxuXG4gICAgICBib2R5RWwuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgICBib2R5RWwuc3R5bGUudG9wID0gLXdpbmRvd1RvcCArICdweCdcbiAgICAgIGJvZHlFbC5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5RWwuc3R5bGUucG9zaXRpb24gPSBib2R5RWxQb3NpdGlvblxuICAgICAgYm9keUVsLnN0eWxlLnRvcCA9ICcnXG4gICAgICBib2R5RWwuc3R5bGUud2lkdGggPSAnJ1xuXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgd2luZG93VG9wKVxuICAgIH1cbiAgfSxcblxuICAvLyDlh73mlbDoioLmtYFcbiAgdGhyb3R0bGU6IGZ1bmN0aW9uIChmdW5jLCB3YWl0LCBpbW1lZGlhdGUgPSBmYWxzZSkge1xuICAgIGxldCB0aW1lclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzXG4gICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSB1bmRlZmluZWRcbiAgICAgICAgICB9LCB3YWl0KVxuICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICB9LCB3YWl0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIOWHveaVsOmYsuaKllxuICBkZWJvdW5jZTogZnVuY3Rpb24gKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSA9IGZhbHNlKSB7XG4gICAgbGV0IHRpbWVyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHNcblxuICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKVxuXG4gICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICF0aW1lciAmJiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZXIgPSB1bmRlZmluZWRcbiAgICAgICAgfSwgd2FpdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICB9LCB3YWl0KVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJjaGVyVXRpbFxuIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNoYXJBdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlJykuY2hhckF0O1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGNoYXJBdChTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iLCJ2YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbnZhciBwdXNoID0gW10ucHVzaDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgSVNfRklMVEVSX1JFSkVDVCA9IFRZUEUgPT0gNztcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoLmNhbGwodGFyZ2V0LCB2YWx1ZSk7IC8vIGZpbHRlclxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICAgICAgY2FzZSA3OiBwdXNoLmNhbGwodGFyZ2V0LCB2YWx1ZSk7IC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICBmb3JFYWNoOiBjcmVhdGVNZXRob2QoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICBzb21lOiBjcmVhdGVNZXRob2QoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kKDcpXG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsInZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChhcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbEFycmF5KSkobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzKHRhcmdldCwga2V5KSkgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICB9XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIHZlcnNpb24gPSBtYXRjaFswXSA8IDQgPyAxIDogbWF0Y2hbMF0gKyBtYXRjaFsxXTtcbn0gZWxzZSBpZiAodXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xuIiwiLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIG1vdmVkIHRvIGVudHJ5IHBvaW50c1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5yZWdleHAuZXhlYycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgRk9SQ0VELCBTSEFNKSB7XG4gIHZhciBTWU1CT0wgPSB3ZWxsS25vd25TeW1ib2woS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcblxuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFdlIGNhbid0IHVzZSByZWFsIHJlZ2V4IGhlcmUgc2luY2UgaXQgY2F1c2VzIGRlb3B0aW1pemF0aW9uXG4gICAgICAvLyBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiBpbiBWOFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMwNlxuICAgICAgcmUgPSB7fTtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICAgIHJlLmZsYWdzID0gJyc7XG4gICAgICByZVtTWU1CT0xdID0gLy4vW1NZTUJPTF07XG4gICAgfVxuXG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuXG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KTtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICBGT1JDRURcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBtZXRob2RzID0gZXhlYyhTWU1CT0wsICcnW0tFWV0sIGZ1bmN0aW9uIChuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgdmFyICRleGVjID0gcmVnZXhwLmV4ZWM7XG4gICAgICBpZiAoJGV4ZWMgPT09IHJlZ2V4cEV4ZWMgfHwgJGV4ZWMgPT09IFJlZ0V4cFByb3RvdHlwZS5leGVjKSB7XG4gICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgIH0pO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBtZXRob2RzWzBdKTtcbiAgICByZWRlZmluZShSZWdFeHBQcm90b3R5cGUsIFNZTUJPTCwgbWV0aG9kc1sxXSk7XG4gIH1cblxuICBpZiAoU0hBTSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFJlZ0V4cFByb3RvdHlwZVtTWU1CT0xdLCAnc2hhbScsIHRydWUpO1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuICAgIH07XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbiIsInZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciByZXBsYWNlID0gJycucmVwbGFjZTtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmJ2BdfFxcZHsxLDJ9fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJidgXXxcXGR7MSwyfSkvZztcblxuLy8gYEdldFN1YnN0aXR1dGlvbmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgdmFyIG0gPSBjYXB0dXJlcy5sZW5ndGg7XG4gIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lZENhcHR1cmVzID0gdG9PYmplY3QobmFtZWRDYXB0dXJlcyk7XG4gICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICB9XG4gIHJldHVybiByZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICB2YXIgY2FwdHVyZTtcbiAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICBjYXNlICcmJzogcmV0dXJuIG1hdGNoZWQ7XG4gICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gXFxkXFxkP1xuICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgaWYgKG4gPiBtKSB7XG4gICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgaWYgKGYgPD0gbSkgcmV0dXJuIGNhcHR1cmVzW2YgLSAxXSA9PT0gdW5kZWZpbmVkID8gY2guY2hhckF0KDEpIDogY2FwdHVyZXNbZiAtIDFdICsgY2guY2hhckF0KDEpO1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICB9KTtcbn07XG4iLCJ2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuIiwidmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRvT2JqZWN0KGl0KSwga2V5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aWVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICFPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XG59IDogT2JqZWN0O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG5cbi8vIG1ha2VzIHN1YmNsYXNzaW5nIHdvcmsgY29ycmVjdCBmb3Igd3JhcHBlZCBidWlsdC1pbnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xuICB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG4gIGlmIChcbiAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcbiAgICBzZXRQcm90b3R5cGVPZiAmJlxuICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcbiAgICB0eXBlb2YgKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSA9PSAnZnVuY3Rpb24nICYmXG4gICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcbiAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG4gICkgc2V0UHJvdG90eXBlT2YoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG4gIHJldHVybiAkdGhpcztcbn07XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICh0eXBlb2Ygc3RvcmUuaW5zcGVjdFNvdXJjZSAhPSAnZnVuY3Rpb24nKSB7XG4gIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZS5pbnNwZWN0U291cmNlO1xuIiwidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIG9iamVjdEhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xuICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XG4gIHZhciB3bXNldCA9IHN0b3JlLnNldDtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmICh3bWhhcy5jYWxsKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMuY2FsbChzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAob2JqZWN0SGFzKGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjbGFzc29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiB0eXBlb2YgZGV0ZWN0aW9uID09ICdmdW5jdGlvbicgPyBmYWlscyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxuLy8gYElzUmVnRXhwYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNyZWdleHBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG4gIHJldHVybiB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nICYmIE9iamVjdChpdCkgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UoV2Vha01hcCkpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgJHBhcnNlSW50ID0gZ2xvYmFsLnBhcnNlSW50O1xudmFyIGhleCA9IC9eWystXT8wW1h4XS87XG52YXIgRk9SQ0VEID0gJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzB4MTYnKSAhPT0gMjI7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxubW9kdWxlLmV4cG9ydHMgPSBGT1JDRUQgPyBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4KSB7XG4gIHZhciBTID0gdHJpbSh0b1N0cmluZyhzdHJpbmcpKTtcbiAgcmV0dXJuICRwYXJzZUludChTLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChTKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG4iLCIvKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgUHJvcGVydGllc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIXByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwidmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpbnB1dC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgdmFyIHN0YXRlO1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJyAmJiAhaGFzKHZhbHVlLCAnbmFtZScpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodmFsdWUsICduYW1lJywga2V5KTtcbiAgICB9XG4gICAgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gICAgaWYgKCFzdGF0ZS5zb3VyY2UpIHtcbiAgICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcbiAgICB9XG4gIH1cbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2Ugc2V0R2xvYmFsKGtleSwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICghdW5zYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgfSBlbHNlIGlmICghbm9UYXJnZXRHZXQgJiYgT1trZXldKSB7XG4gICAgc2ltcGxlID0gdHJ1ZTtcbiAgfVxuICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgZWxzZSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoTywga2V5LCB2YWx1ZSk7XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59KTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9jbGFzc29mLXJhdycpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL3JlZ2V4cC1leGVjJyk7XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbiAgfVxuXG4gIHJldHVybiByZWdleHBFeGVjLmNhbGwoUiwgUyk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tZW1wdHktY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAsIHJlZ2V4cC9uby1sYXp5LWVuZHMgLS0gdGVzdGluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLXVzZWxlc3MtcXVhbnRpZmllciAtLSB0ZXN0aW5nICovXG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzJyk7XG52YXIgc3RpY2t5SGVscGVycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtc3RpY2t5LWhlbHBlcnMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJykuZ2V0O1xudmFyIFVOU1VQUE9SVEVEX0RPVF9BTEwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLWRvdC1hbGwnKTtcbnZhciBVTlNVUFBPUlRFRF9OQ0cgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLW5jZycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciBuYXRpdmVSZXBsYWNlID0gc2hhcmVkKCduYXRpdmUtc3RyaW5nLXJlcGxhY2UnLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuXG52YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xuXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlMSA9IC9hLztcbiAgdmFyIHJlMiA9IC9iKi9nO1xuICBuYXRpdmVFeGVjLmNhbGwocmUxLCAnYScpO1xuICBuYXRpdmVFeGVjLmNhbGwocmUyLCAnYScpO1xuICByZXR1cm4gcmUxLmxhc3RJbmRleCAhPT0gMCB8fCByZTIubGFzdEluZGV4ICE9PSAwO1xufSkoKTtcblxudmFyIFVOU1VQUE9SVEVEX1kgPSBzdGlja3lIZWxwZXJzLlVOU1VQUE9SVEVEX1kgfHwgc3RpY2t5SGVscGVycy5CUk9LRU5fQ0FSRVQ7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kgfHwgVU5TVVBQT1JURURfRE9UX0FMTCB8fCBVTlNVUFBPUlRFRF9OQ0c7XG5cbmlmIChQQVRDSCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHMgLS0gVE9ET1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyaW5nKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHJlKTtcbiAgICB2YXIgc3RyID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICB2YXIgcmF3ID0gc3RhdGUucmF3O1xuICAgIHZhciByZXN1bHQsIHJlQ29weSwgbGFzdEluZGV4LCBtYXRjaCwgaSwgb2JqZWN0LCBncm91cDtcblxuICAgIGlmIChyYXcpIHtcbiAgICAgIHJhdy5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICByZXN1bHQgPSBwYXRjaGVkRXhlYy5jYWxsKHJhdywgc3RyKTtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJhdy5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBncm91cHMgPSBzdGF0ZS5ncm91cHM7XG4gICAgdmFyIHN0aWNreSA9IFVOU1VQUE9SVEVEX1kgJiYgcmUuc3RpY2t5O1xuICAgIHZhciBmbGFncyA9IHJlZ2V4cEZsYWdzLmNhbGwocmUpO1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2U7XG4gICAgdmFyIGNoYXJzQWRkZWQgPSAwO1xuICAgIHZhciBzdHJDb3B5ID0gc3RyO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgZmxhZ3MgPSBmbGFncy5yZXBsYWNlKCd5JywgJycpO1xuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ2cnKSA9PT0gLTEpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuICAgICAgfVxuXG4gICAgICBzdHJDb3B5ID0gc3RyLnNsaWNlKHJlLmxhc3RJbmRleCk7XG4gICAgICAvLyBTdXBwb3J0IGFuY2hvcmVkIHN0aWNreSBiZWhhdmlvci5cbiAgICAgIGlmIChyZS5sYXN0SW5kZXggPiAwICYmICghcmUubXVsdGlsaW5lIHx8IHJlLm11bHRpbGluZSAmJiBzdHIuY2hhckF0KHJlLmxhc3RJbmRleCAtIDEpICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwoc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gbWF0Y2guaW5wdXQuc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCAmJiBncm91cHMpIHtcbiAgICAgIG1hdGNoLmdyb3VwcyA9IG9iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIG9iamVjdFtncm91cFswXV0gPSBtYXRjaFtncm91cFsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJ2EnLCAneScpIC0+IC9hL3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAgPSBnbG9iYWwuUmVnRXhwO1xuXG5leHBvcnRzLlVOU1VQUE9SVEVEX1kgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJ2EnLCAneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnYWJjZCcpICE9IG51bGw7XG59KTtcblxuZXhwb3J0cy5CUk9LRU5fQ0FSRVQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuICB2YXIgcmUgPSAkUmVnRXhwKCdecicsICdneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnc3RyJykgIT0gbnVsbDtcbn0pO1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9mYWlscycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcuJywgJ3MnKSAtPiAvLi9zIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJy4nLCAncycpO1xuICByZXR1cm4gIShyZS5kb3RBbGwgJiYgcmUuZXhlYygnXFxuJykgJiYgcmUuZmxhZ3MgPT09ICdzJyk7XG59KTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4vZmFpbHMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnKD88YT5iKScsICdnJykgLT4gLyg/PGE+YikvZyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwKCcoPzxhPmIpJywgJ2cnKTtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2InKS5ncm91cHMuYSAhPT0gJ2InIHx8XG4gICAgJ2InLnJlcGxhY2UocmUsICckPGE+YycpICE9PSAnYmMnO1xufSk7XG4iLCIvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gYFNhbWVWYWx1ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNhbWV2YWx1ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1pcyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xuIiwidmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMTYuMicsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gICAgdmFyIFMgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgd2hpdGVzcGFjZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXMnKTtcblxudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcbiAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG4gIHN0YXJ0OiBjcmVhdGVNZXRob2QoMSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbVJpZ2h0LCB0cmltRW5kIH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QoMylcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwiLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcbiIsInZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYFRvSW50ZWdlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gaW5wdXRbVE9fUFJJTUlUSVZFXTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdChyZXN1bHQpIHx8IGlzU3ltYm9sKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcbiIsInZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn07XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc1N5bWJvbChhcmd1bWVudCkpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuIiwiLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbm1vZHVsZS5leHBvcnRzID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArXG4gICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5maW5kO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbnZhciBGSU5EID0gJ2ZpbmQnO1xudmFyIFNLSVBTX0hPTEVTID0gdHJ1ZTtcblxuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChGSU5EIGluIFtdKSBBcnJheSgxKVtGSU5EXShmdW5jdGlvbiAoKSB7IFNLSVBTX0hPTEVTID0gZmFsc2U7IH0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU0tJUFNfSE9MRVMgfSwge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoRklORCk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBwYXJzZUludEltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL251bWJlci1wYXJzZS1pbnQnKTtcblxuLy8gYHBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlSW50ICE9IHBhcnNlSW50SW1wbGVtZW50YXRpb24gfSwge1xuICBwYXJzZUludDogcGFyc2VJbnRJbXBsZW1lbnRhdGlvblxufSk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1yZWdleHAnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBnZXRGbGFncyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZmxhZ3MnKTtcbnZhciBzdGlja3lIZWxwZXJzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1zdGlja3ktaGVscGVycycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKS5lbmZvcmNlO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBVTlNVUFBPUlRFRF9ET1RfQUxMID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC11bnN1cHBvcnRlZC1kb3QtYWxsJyk7XG52YXIgVU5TVVBQT1JURURfTkNHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC11bnN1cHBvcnRlZC1uY2cnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xudmFyIE5hdGl2ZVJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gTmF0aXZlUmVnRXhwLnByb3RvdHlwZTtcbi8vIFRPRE86IFVzZSBvbmx5IHByb3BwZXIgUmVnRXhwSWRlbnRpZmllck5hbWVcbnZhciBJU19OQ0cgPSAvXlxcPzxbXlxcc1xcZCEjJSYqKzw9PkBeXVteXFxzISMlJiorPD0+QF5dKj4vO1xudmFyIHJlMSA9IC9hL2c7XG52YXIgcmUyID0gL2EvZztcblxuLy8gXCJuZXdcIiBzaG91bGQgY3JlYXRlIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdcbnZhciBDT1JSRUNUX05FVyA9IG5ldyBOYXRpdmVSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuVU5TVVBQT1JURURfWTtcblxudmFyIEJBU0VfRk9SQ0VEID0gREVTQ1JJUFRPUlMgJiZcbiAgKCFDT1JSRUNUX05FVyB8fCBVTlNVUFBPUlRFRF9ZIHx8IFVOU1VQUE9SVEVEX0RPVF9BTEwgfHwgVU5TVVBQT1JURURfTkNHIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICByZTJbTUFUQ0hdID0gZmFsc2U7XG4gICAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgICByZXR1cm4gTmF0aXZlUmVnRXhwKHJlMSkgIT0gcmUxIHx8IE5hdGl2ZVJlZ0V4cChyZTIpID09IHJlMiB8fCBOYXRpdmVSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbiAgfSkpO1xuXG52YXIgaGFuZGxlRG90QWxsID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgYnJhY2tldHMgPSBmYWxzZTtcbiAgdmFyIGNocjtcbiAgZm9yICg7IGluZGV4IDw9IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNociA9IHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuICAgIGlmIChjaHIgPT09ICdcXFxcJykge1xuICAgICAgcmVzdWx0ICs9IGNociArIHN0cmluZy5jaGFyQXQoKytpbmRleCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFicmFja2V0cyAmJiBjaHIgPT09ICcuJykge1xuICAgICAgcmVzdWx0ICs9ICdbXFxcXHNcXFxcU10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hyID09PSAnWycpIHtcbiAgICAgICAgYnJhY2tldHMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjaHIgPT09ICddJykge1xuICAgICAgICBicmFja2V0cyA9IGZhbHNlO1xuICAgICAgfSByZXN1bHQgKz0gY2hyO1xuICAgIH1cbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGhhbmRsZU5DRyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIG5hbWVkID0gW107XG4gIHZhciBuYW1lcyA9IHt9O1xuICB2YXIgYnJhY2tldHMgPSBmYWxzZTtcbiAgdmFyIG5jZyA9IGZhbHNlO1xuICB2YXIgZ3JvdXBpZCA9IDA7XG4gIHZhciBncm91cG5hbWUgPSAnJztcbiAgdmFyIGNocjtcbiAgZm9yICg7IGluZGV4IDw9IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNociA9IHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuICAgIGlmIChjaHIgPT09ICdcXFxcJykge1xuICAgICAgY2hyID0gY2hyICsgc3RyaW5nLmNoYXJBdCgrK2luZGV4KTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gJ10nKSB7XG4gICAgICBicmFja2V0cyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWJyYWNrZXRzKSBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgY2hyID09PSAnWyc6XG4gICAgICAgIGJyYWNrZXRzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGNociA9PT0gJygnOlxuICAgICAgICBpZiAoSVNfTkNHLnRlc3Qoc3RyaW5nLnNsaWNlKGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICBuY2cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBjaHI7XG4gICAgICAgIGdyb3VwaWQrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIGNociA9PT0gJz4nICYmIG5jZzpcbiAgICAgICAgaWYgKGdyb3VwbmFtZSA9PT0gJycgfHwgaGFzKG5hbWVzLCBncm91cG5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzW2dyb3VwbmFtZV0gPSB0cnVlO1xuICAgICAgICBuYW1lZC5wdXNoKFtncm91cG5hbWUsIGdyb3VwaWRdKTtcbiAgICAgICAgbmNnID0gZmFsc2U7XG4gICAgICAgIGdyb3VwbmFtZSA9ICcnO1xuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5jZykgZ3JvdXBuYW1lICs9IGNocjtcbiAgICBlbHNlIHJlc3VsdCArPSBjaHI7XG4gIH0gcmV0dXJuIFtyZXN1bHQsIG5hbWVkXTtcbn07XG5cbi8vIGBSZWdFeHBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC1jb25zdHJ1Y3RvclxuaWYgKGlzRm9yY2VkKCdSZWdFeHAnLCBCQVNFX0ZPUkNFRCkpIHtcbiAgdmFyIFJlZ0V4cFdyYXBwZXIgPSBmdW5jdGlvbiBSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICB2YXIgdGhpc0lzUmVnRXhwID0gdGhpcyBpbnN0YW5jZW9mIFJlZ0V4cFdyYXBwZXI7XG4gICAgdmFyIHBhdHRlcm5Jc1JlZ0V4cCA9IGlzUmVnRXhwKHBhdHRlcm4pO1xuICAgIHZhciBmbGFnc0FyZVVuZGVmaW5lZCA9IGZsYWdzID09PSB1bmRlZmluZWQ7XG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIHZhciByYXdQYXR0ZXJuID0gcGF0dGVybjtcbiAgICB2YXIgcmF3RmxhZ3MsIGRvdEFsbCwgc3RpY2t5LCBoYW5kbGVkLCByZXN1bHQsIHN0YXRlO1xuXG4gICAgaWYgKCF0aGlzSXNSZWdFeHAgJiYgcGF0dGVybklzUmVnRXhwICYmIGZsYWdzQXJlVW5kZWZpbmVkICYmIHBhdHRlcm4uY29uc3RydWN0b3IgPT09IFJlZ0V4cFdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cblxuICAgIGlmIChwYXR0ZXJuSXNSZWdFeHAgfHwgcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cFdyYXBwZXIpIHtcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNvdXJjZTtcbiAgICAgIGlmIChmbGFnc0FyZVVuZGVmaW5lZCkgZmxhZ3MgPSAnZmxhZ3MnIGluIHJhd1BhdHRlcm4gPyByYXdQYXR0ZXJuLmZsYWdzIDogZ2V0RmxhZ3MuY2FsbChyYXdQYXR0ZXJuKTtcbiAgICB9XG5cbiAgICBwYXR0ZXJuID0gcGF0dGVybiA9PT0gdW5kZWZpbmVkID8gJycgOiB0b1N0cmluZyhwYXR0ZXJuKTtcbiAgICBmbGFncyA9IGZsYWdzID09PSB1bmRlZmluZWQgPyAnJyA6IHRvU3RyaW5nKGZsYWdzKTtcbiAgICByYXdQYXR0ZXJuID0gcGF0dGVybjtcblxuICAgIGlmIChVTlNVUFBPUlRFRF9ET1RfQUxMICYmICdkb3RBbGwnIGluIHJlMSkge1xuICAgICAgZG90QWxsID0gISFmbGFncyAmJiBmbGFncy5pbmRleE9mKCdzJykgPiAtMTtcbiAgICAgIGlmIChkb3RBbGwpIGZsYWdzID0gZmxhZ3MucmVwbGFjZSgvcy9nLCAnJyk7XG4gICAgfVxuXG4gICAgcmF3RmxhZ3MgPSBmbGFncztcblxuICAgIGlmIChVTlNVUFBPUlRFRF9ZICYmICdzdGlja3knIGluIHJlMSkge1xuICAgICAgc3RpY2t5ID0gISFmbGFncyAmJiBmbGFncy5pbmRleE9mKCd5JykgPiAtMTtcbiAgICAgIGlmIChzdGlja3kpIGZsYWdzID0gZmxhZ3MucmVwbGFjZSgveS9nLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU1VQUE9SVEVEX05DRykge1xuICAgICAgaGFuZGxlZCA9IGhhbmRsZU5DRyhwYXR0ZXJuKTtcbiAgICAgIHBhdHRlcm4gPSBoYW5kbGVkWzBdO1xuICAgICAgZ3JvdXBzID0gaGFuZGxlZFsxXTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBpbmhlcml0SWZSZXF1aXJlZChOYXRpdmVSZWdFeHAocGF0dGVybiwgZmxhZ3MpLCB0aGlzSXNSZWdFeHAgPyB0aGlzIDogUmVnRXhwUHJvdG90eXBlLCBSZWdFeHBXcmFwcGVyKTtcblxuICAgIGlmIChkb3RBbGwgfHwgc3RpY2t5IHx8IGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUocmVzdWx0KTtcbiAgICAgIGlmIChkb3RBbGwpIHtcbiAgICAgICAgc3RhdGUuZG90QWxsID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucmF3ID0gUmVnRXhwV3JhcHBlcihoYW5kbGVEb3RBbGwocGF0dGVybiksIHJhd0ZsYWdzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGlja3kpIHN0YXRlLnN0aWNreSA9IHRydWU7XG4gICAgICBpZiAoZ3JvdXBzLmxlbmd0aCkgc3RhdGUuZ3JvdXBzID0gZ3JvdXBzO1xuICAgIH1cblxuICAgIGlmIChwYXR0ZXJuICE9PSByYXdQYXR0ZXJuKSB0cnkge1xuICAgICAgLy8gZmFpbHMgaW4gb2xkIGVuZ2luZXMsIGJ1dCB3ZSBoYXZlIG5vIGFsdGVybmF0aXZlcyBmb3IgdW5zdXBwb3J0ZWQgcmVnZXggc3ludGF4XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkocmVzdWx0LCAnc291cmNlJywgcmF3UGF0dGVybiA9PT0gJycgPyAnKD86KScgOiByYXdQYXR0ZXJuKTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gUmVnRXhwV3JhcHBlciB8fCBkZWZpbmVQcm9wZXJ0eShSZWdFeHBXcmFwcGVyLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmF0aXZlUmVnRXhwW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkgeyBOYXRpdmVSZWdFeHBba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlUmVnRXhwKSwgaW5kZXggPSAwOyBrZXlzLmxlbmd0aCA+IGluZGV4Oykge1xuICAgIHByb3h5KGtleXNbaW5kZXgrK10pO1xuICB9XG5cbiAgUmVnRXhwUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVnRXhwV3JhcHBlcjtcbiAgUmVnRXhwV3JhcHBlci5wcm90b3R5cGUgPSBSZWdFeHBQcm90b3R5cGU7XG4gIHJlZGVmaW5lKGdsb2JhbCwgJ1JlZ0V4cCcsIFJlZ0V4cFdyYXBwZXIpO1xufVxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAtQEBzcGVjaWVzXG5zZXRTcGVjaWVzKCdSZWdFeHAnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUuZXhlY1xuJCh7IHRhcmdldDogJ1JlZ0V4cCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IC8uLy5leGVjICE9PSBleGVjIH0sIHtcbiAgZXhlYzogZXhlY1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBmbGFncyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZmxhZ3MnKTtcblxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcbnZhciBuYXRpdmVUb1N0cmluZyA9IFJlZ0V4cFByb3RvdHlwZVtUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBuYXRpdmVUb1N0cmluZy5uYW1lICE9IFRPX1NUUklORztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoTk9UX0dFTkVSSUMgfHwgSU5DT1JSRUNUX05BTUUpIHtcbiAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwID0gJHRvU3RyaW5nKFIuc291cmNlKTtcbiAgICB2YXIgcmYgPSBSLmZsYWdzO1xuICAgIHZhciBmID0gJHRvU3RyaW5nKHJmID09PSB1bmRlZmluZWQgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlKSA/IGZsYWdzLmNhbGwoUikgOiByZik7XG4gICAgcmV0dXJuICcvJyArIHAgKyAnLycgKyBmO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgZ2V0U3Vic3RpdHV0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1zdWJzdGl0dXRpb24nKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBSRVBMQUNFID0gd2VsbEtub3duU3ltYm9sKCdyZXBsYWNlJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gSUUgPD0gMTEgcmVwbGFjZXMgJDAgd2l0aCB0aGUgd2hvbGUgbWF0Y2gsIGFzIGlmIGl0IHdhcyAkJlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjAyNDY2Ni9nZXR0aW5nLWllLXRvLXJlcGxhY2UtYS1yZWdleC13aXRoLXRoZS1saXRlcmFsLXN0cmluZy0wXG52YXIgUkVQTEFDRV9LRUVQU18kMCA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvcHJlZmVyLWVzY2FwZS1yZXBsYWNlbWVudC1kb2xsYXItY2hhciAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gJ2EnLnJlcGxhY2UoLy4vLCAnJDAnKSA9PT0gJyQwJztcbn0pKCk7XG5cbi8vIFNhZmFyaSA8PSAxMy4wLjMoPykgc3Vic3RpdHV0ZXMgbnRoIGNhcHR1cmUgd2hlcmUgbj5tIHdpdGggYW4gZW1wdHkgc3RyaW5nXG52YXIgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoLy4vW1JFUExBQ0VdKSB7XG4gICAgcmV0dXJuIC8uL1tSRVBMQUNFXSgnYScsICckMCcpID09PSAnJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSgpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tdXNlbGVzcy1kb2xsYXItcmVwbGFjZW1lbnRzIC0tIGZhbHNlIHBvc2l0aXZlXG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygncmVwbGFjZScsIGZ1bmN0aW9uIChfLCBuYXRpdmVSZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIFVOU0FGRV9TVUJTVElUVVRFID0gUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPyAnJCcgOiAnJDAnO1xuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciByZXBsYWNlciA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIHJlcGxhY2VyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXBsYWNlci5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogbmF0aXZlUmVwbGFjZS5jYWxsKHRvU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAoc3RyaW5nLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIFMgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiByZXBsYWNlVmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHJlcGxhY2VWYWx1ZS5pbmRleE9mKFVOU0FGRV9TVUJTVElUVVRFKSA9PT0gLTEgJiZcbiAgICAgICAgcmVwbGFjZVZhbHVlLmluZGV4T2YoJyQ8JykgPT09IC0xXG4gICAgICApIHtcbiAgICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVSZXBsYWNlLCByeCwgUywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gdG9TdHJpbmcocmVwbGFjZVZhbHVlKTtcblxuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuXG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIG1hdGNoU3RyID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gdG9TdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcbn0sICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyB8fCAhUkVQTEFDRV9LRUVQU18kMCB8fCBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgc2FtZVZhbHVlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NhbWUtdmFsdWUnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAc2VhcmNoIGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygnc2VhcmNoJywgZnVuY3Rpb24gKFNFQVJDSCwgbmF0aXZlU2VhcmNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zZWFyY2hcbiAgICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgc2VhcmNoZXIgPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgICByZXR1cm4gc2VhcmNoZXIgIT09IHVuZGVmaW5lZCA/IHNlYXJjaGVyLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKHRvU3RyaW5nKE8pKTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc2VhcmNoXG4gICAgZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QodGhpcyk7XG4gICAgICB2YXIgUyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVNlYXJjaCwgcngsIFMpO1xuXG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciBwcmV2aW91c0xhc3RJbmRleCA9IHJ4Lmxhc3RJbmRleDtcbiAgICAgIGlmICghc2FtZVZhbHVlKHByZXZpb3VzTGFzdEluZGV4LCAwKSkgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgIGlmICghc2FtZVZhbHVlKHJ4Lmxhc3RJbmRleCwgcHJldmlvdXNMYXN0SW5kZXgpKSByeC5sYXN0SW5kZXggPSBwcmV2aW91c0xhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyAtMSA6IHJlc3VsdC5pbmRleDtcbiAgICB9XG4gIF07XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IDIwMTEgVHdpdHRlciwgSW5jLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIChIb2dhbikge1xuICAvLyBTZXR1cCByZWdleCAgYXNzaWdubWVudHNcbiAgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIE11c3RhY2hlIHNwZWNcbiAgdmFyIHJJc1doaXRlc3BhY2UgPSAvXFxTLyxcbiAgICAgIHJRdW90ID0gL1xcXCIvZyxcbiAgICAgIHJOZXdsaW5lID0gIC9cXG4vZyxcbiAgICAgIHJDciA9IC9cXHIvZyxcbiAgICAgIHJTbGFzaCA9IC9cXFxcL2csXG4gICAgICByTGluZVNlcCA9IC9cXHUyMDI4LyxcbiAgICAgIHJQYXJhZ3JhcGhTZXAgPSAvXFx1MjAyOS87XG5cbiAgSG9nYW4udGFncyA9IHtcbiAgICAnIyc6IDEsICdeJzogMiwgJzwnOiAzLCAnJCc6IDQsXG4gICAgJy8nOiA1LCAnISc6IDYsICc+JzogNywgJz0nOiA4LCAnX3YnOiA5LFxuICAgICd7JzogMTAsICcmJzogMTEsICdfdCc6IDEyXG4gIH07XG5cbiAgSG9nYW4uc2NhbiA9IGZ1bmN0aW9uIHNjYW4odGV4dCwgZGVsaW1pdGVycykge1xuICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgSU5fVEVYVCA9IDAsXG4gICAgICAgIElOX1RBR19UWVBFID0gMSxcbiAgICAgICAgSU5fVEFHID0gMixcbiAgICAgICAgc3RhdGUgPSBJTl9URVhULFxuICAgICAgICB0YWdUeXBlID0gbnVsbCxcbiAgICAgICAgdGFnID0gbnVsbCxcbiAgICAgICAgYnVmID0gJycsXG4gICAgICAgIHRva2VucyA9IFtdLFxuICAgICAgICBzZWVuVGFnID0gZmFsc2UsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsaW5lU3RhcnQgPSAwLFxuICAgICAgICBvdGFnID0gJ3t7JyxcbiAgICAgICAgY3RhZyA9ICd9fSc7XG5cbiAgICBmdW5jdGlvbiBhZGRCdWYoKSB7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe3RhZzogJ190JywgdGV4dDogbmV3IFN0cmluZyhidWYpfSk7XG4gICAgICAgIGJ1ZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVJc1doaXRlc3BhY2UoKSB7XG4gICAgICB2YXIgaXNBbGxXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSBsaW5lU3RhcnQ7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaXNBbGxXaGl0ZXNwYWNlID1cbiAgICAgICAgICAoSG9nYW4udGFnc1t0b2tlbnNbal0udGFnXSA8IEhvZ2FuLnRhZ3NbJ192J10pIHx8XG4gICAgICAgICAgKHRva2Vuc1tqXS50YWcgPT0gJ190JyAmJiB0b2tlbnNbal0udGV4dC5tYXRjaChySXNXaGl0ZXNwYWNlKSA9PT0gbnVsbCk7XG4gICAgICAgIGlmICghaXNBbGxXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0FsbFdoaXRlc3BhY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyTGluZShoYXZlU2VlblRhZywgbm9OZXdMaW5lKSB7XG4gICAgICBhZGRCdWYoKTtcblxuICAgICAgaWYgKGhhdmVTZWVuVGFnICYmIGxpbmVJc1doaXRlc3BhY2UoKSkge1xuICAgICAgICBmb3IgKHZhciBqID0gbGluZVN0YXJ0LCBuZXh0OyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50ZXh0KSB7XG4gICAgICAgICAgICBpZiAoKG5leHQgPSB0b2tlbnNbaisxXSkgJiYgbmV4dC50YWcgPT0gJz4nKSB7XG4gICAgICAgICAgICAgIC8vIHNldCBpbmRlbnQgdG8gdG9rZW4gdmFsdWVcbiAgICAgICAgICAgICAgbmV4dC5pbmRlbnQgPSB0b2tlbnNbal0udGV4dC50b1N0cmluZygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghbm9OZXdMaW5lKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHt0YWc6J1xcbid9KTtcbiAgICAgIH1cblxuICAgICAgc2VlblRhZyA9IGZhbHNlO1xuICAgICAgbGluZVN0YXJ0ID0gdG9rZW5zLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VEZWxpbWl0ZXJzKHRleHQsIGluZGV4KSB7XG4gICAgICB2YXIgY2xvc2UgPSAnPScgKyBjdGFnLFxuICAgICAgICAgIGNsb3NlSW5kZXggPSB0ZXh0LmluZGV4T2YoY2xvc2UsIGluZGV4KSxcbiAgICAgICAgICBkZWxpbWl0ZXJzID0gdHJpbShcbiAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHRleHQuaW5kZXhPZignPScsIGluZGV4KSArIDEsIGNsb3NlSW5kZXgpXG4gICAgICAgICAgKS5zcGxpdCgnICcpO1xuXG4gICAgICBvdGFnID0gZGVsaW1pdGVyc1swXTtcbiAgICAgIGN0YWcgPSBkZWxpbWl0ZXJzW2RlbGltaXRlcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgIHJldHVybiBjbG9zZUluZGV4ICsgY2xvc2UubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBpZiAoZGVsaW1pdGVycykge1xuICAgICAgZGVsaW1pdGVycyA9IGRlbGltaXRlcnMuc3BsaXQoJyAnKTtcbiAgICAgIG90YWcgPSBkZWxpbWl0ZXJzWzBdO1xuICAgICAgY3RhZyA9IGRlbGltaXRlcnNbMV07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoc3RhdGUgPT0gSU5fVEVYVCkge1xuICAgICAgICBpZiAodGFnQ2hhbmdlKG90YWcsIHRleHQsIGkpKSB7XG4gICAgICAgICAgLS1pO1xuICAgICAgICAgIGFkZEJ1ZigpO1xuICAgICAgICAgIHN0YXRlID0gSU5fVEFHX1RZUEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09ICdcXG4nKSB7XG4gICAgICAgICAgICBmaWx0ZXJMaW5lKHNlZW5UYWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWYgKz0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09IElOX1RBR19UWVBFKSB7XG4gICAgICAgIGkgKz0gb3RhZy5sZW5ndGggLSAxO1xuICAgICAgICB0YWcgPSBIb2dhbi50YWdzW3RleHQuY2hhckF0KGkgKyAxKV07XG4gICAgICAgIHRhZ1R5cGUgPSB0YWcgPyB0ZXh0LmNoYXJBdChpICsgMSkgOiAnX3YnO1xuICAgICAgICBpZiAodGFnVHlwZSA9PSAnPScpIHtcbiAgICAgICAgICBpID0gY2hhbmdlRGVsaW1pdGVycyh0ZXh0LCBpKTtcbiAgICAgICAgICBzdGF0ZSA9IElOX1RFWFQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZSA9IElOX1RBRztcbiAgICAgICAgfVxuICAgICAgICBzZWVuVGFnID0gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0YWdDaGFuZ2UoY3RhZywgdGV4dCwgaSkpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7dGFnOiB0YWdUeXBlLCBuOiB0cmltKGJ1ZiksIG90YWc6IG90YWcsIGN0YWc6IGN0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgIGk6ICh0YWdUeXBlID09ICcvJykgPyBzZWVuVGFnIC0gb3RhZy5sZW5ndGggOiBpICsgY3RhZy5sZW5ndGh9KTtcbiAgICAgICAgICBidWYgPSAnJztcbiAgICAgICAgICBpICs9IGN0YWcubGVuZ3RoIC0gMTtcbiAgICAgICAgICBzdGF0ZSA9IElOX1RFWFQ7XG4gICAgICAgICAgaWYgKHRhZ1R5cGUgPT0gJ3snKSB7XG4gICAgICAgICAgICBpZiAoY3RhZyA9PSAnfX0nKSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsZWFuVHJpcGxlU3RhY2hlKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWx0ZXJMaW5lKHNlZW5UYWcsIHRydWUpO1xuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFuVHJpcGxlU3RhY2hlKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLm4uc3Vic3RyKHRva2VuLm4ubGVuZ3RoIC0gMSkgPT09ICd9Jykge1xuICAgICAgdG9rZW4ubiA9IHRva2VuLm4uc3Vic3RyaW5nKDAsIHRva2VuLm4ubGVuZ3RoIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpbShzKSB7XG4gICAgaWYgKHMudHJpbSkge1xuICAgICAgcmV0dXJuIHMudHJpbSgpO1xuICAgIH1cblxuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZ0NoYW5nZSh0YWcsIHRleHQsIGluZGV4KSB7XG4gICAgaWYgKHRleHQuY2hhckF0KGluZGV4KSAhPSB0YWcuY2hhckF0KDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDEsIGwgPSB0YWcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGV4dC5jaGFyQXQoaW5kZXggKyBpKSAhPSB0YWcuY2hhckF0KGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRoZSB0YWdzIGFsbG93ZWQgaW5zaWRlIHN1cGVyIHRlbXBsYXRlc1xuICB2YXIgYWxsb3dlZEluU3VwZXIgPSB7J190JzogdHJ1ZSwgJ1xcbic6IHRydWUsICckJzogdHJ1ZSwgJy8nOiB0cnVlfTtcblxuICBmdW5jdGlvbiBidWlsZFRyZWUodG9rZW5zLCBraW5kLCBzdGFjaywgY3VzdG9tVGFncykge1xuICAgIHZhciBpbnN0cnVjdGlvbnMgPSBbXSxcbiAgICAgICAgb3BlbmVyID0gbnVsbCxcbiAgICAgICAgdGFpbCA9IG51bGwsXG4gICAgICAgIHRva2VuID0gbnVsbDtcblxuICAgIHRhaWwgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblxuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblxuICAgICAgaWYgKHRhaWwgJiYgdGFpbC50YWcgPT0gJzwnICYmICEodG9rZW4udGFnIGluIGFsbG93ZWRJblN1cGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY29udGVudCBpbiA8IHN1cGVyIHRhZy4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEhvZ2FuLnRhZ3NbdG9rZW4udGFnXSA8PSBIb2dhbi50YWdzWyckJ10gfHwgaXNPcGVuZXIodG9rZW4sIGN1c3RvbVRhZ3MpKSB7XG4gICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICB0b2tlbi5ub2RlcyA9IGJ1aWxkVHJlZSh0b2tlbnMsIHRva2VuLnRhZywgc3RhY2ssIGN1c3RvbVRhZ3MpO1xuICAgICAgfSBlbHNlIGlmICh0b2tlbi50YWcgPT0gJy8nKSB7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nsb3NpbmcgdGFnIHdpdGhvdXQgb3BlbmVyOiAvJyArIHRva2VuLm4pO1xuICAgICAgICB9XG4gICAgICAgIG9wZW5lciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAodG9rZW4ubiAhPSBvcGVuZXIubiAmJiAhaXNDbG9zZXIodG9rZW4ubiwgb3BlbmVyLm4sIGN1c3RvbVRhZ3MpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXN0aW5nIGVycm9yOiAnICsgb3BlbmVyLm4gKyAnIHZzLiAnICsgdG9rZW4ubik7XG4gICAgICAgIH1cbiAgICAgICAgb3BlbmVyLmVuZCA9IHRva2VuLmk7XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnRhZyA9PSAnXFxuJykge1xuICAgICAgICB0b2tlbi5sYXN0ID0gKHRva2Vucy5sZW5ndGggPT0gMCkgfHwgKHRva2Vuc1swXS50YWcgPT0gJ1xcbicpO1xuICAgICAgfVxuXG4gICAgICBpbnN0cnVjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjbG9zaW5nIHRhZzogJyArIHN0YWNrLnBvcCgpLm4pO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBpc09wZW5lcih0b2tlbiwgdGFncykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0YWdzW2ldLm8gPT0gdG9rZW4ubikge1xuICAgICAgICB0b2tlbi50YWcgPSAnIyc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2xvc2VyKGNsb3NlLCBvcGVuLCB0YWdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRhZ3NbaV0uYyA9PSBjbG9zZSAmJiB0YWdzW2ldLm8gPT0gb3Blbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlTdWJzdGl0dXRpb25zKG9iaikge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGl0ZW1zLnB1c2goJ1wiJyArIGVzYyhrZXkpICsgJ1wiOiBmdW5jdGlvbihjLHAsdCxpKSB7JyArIG9ialtrZXldICsgJ30nKTtcbiAgICB9XG4gICAgcmV0dXJuIFwieyBcIiArIGl0ZW1zLmpvaW4oXCIsXCIpICsgXCIgfVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5UGFydGlhbHMoY29kZU9iaikge1xuICAgIHZhciBwYXJ0aWFscyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBjb2RlT2JqLnBhcnRpYWxzKSB7XG4gICAgICBwYXJ0aWFscy5wdXNoKCdcIicgKyBlc2Moa2V5KSArICdcIjp7bmFtZTpcIicgKyBlc2MoY29kZU9iai5wYXJ0aWFsc1trZXldLm5hbWUpICsgJ1wiLCAnICsgc3RyaW5naWZ5UGFydGlhbHMoY29kZU9iai5wYXJ0aWFsc1trZXldKSArIFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwicGFydGlhbHM6IHtcIiArIHBhcnRpYWxzLmpvaW4oXCIsXCIpICsgXCJ9LCBzdWJzOiBcIiArIHN0cmluZ2lmeVN1YnN0aXR1dGlvbnMoY29kZU9iai5zdWJzKTtcbiAgfVxuXG4gIEhvZ2FuLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKGNvZGVPYmosIHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gXCJ7Y29kZTogZnVuY3Rpb24gKGMscCxpKSB7IFwiICsgSG9nYW4ud3JhcE1haW4oY29kZU9iai5jb2RlKSArIFwiIH0sXCIgKyBzdHJpbmdpZnlQYXJ0aWFscyhjb2RlT2JqKSArICBcIn1cIjtcbiAgfVxuXG4gIHZhciBzZXJpYWxObyA9IDA7XG4gIEhvZ2FuLmdlbmVyYXRlID0gZnVuY3Rpb24odHJlZSwgdGV4dCwgb3B0aW9ucykge1xuICAgIHNlcmlhbE5vID0gMDtcbiAgICB2YXIgY29udGV4dCA9IHsgY29kZTogJycsIHN1YnM6IHt9LCBwYXJ0aWFsczoge30gfTtcbiAgICBIb2dhbi53YWxrKHRyZWUsIGNvbnRleHQpO1xuXG4gICAgaWYgKG9wdGlvbnMuYXNTdHJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeShjb250ZXh0LCB0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tYWtlVGVtcGxhdGUoY29udGV4dCwgdGV4dCwgb3B0aW9ucyk7XG4gIH1cblxuICBIb2dhbi53cmFwTWFpbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICByZXR1cm4gJ3ZhciB0PXRoaXM7dC5iKGk9aXx8XCJcIik7JyArIGNvZGUgKyAncmV0dXJuIHQuZmwoKTsnO1xuICB9XG5cbiAgSG9nYW4udGVtcGxhdGUgPSBIb2dhbi5UZW1wbGF0ZTtcblxuICBIb2dhbi5tYWtlVGVtcGxhdGUgPSBmdW5jdGlvbihjb2RlT2JqLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5tYWtlUGFydGlhbHMoY29kZU9iaik7XG4gICAgdGVtcGxhdGUuY29kZSA9IG5ldyBGdW5jdGlvbignYycsICdwJywgJ2knLCB0aGlzLndyYXBNYWluKGNvZGVPYmouY29kZSkpO1xuICAgIHJldHVybiBuZXcgdGhpcy50ZW1wbGF0ZSh0ZW1wbGF0ZSwgdGV4dCwgdGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBIb2dhbi5tYWtlUGFydGlhbHMgPSBmdW5jdGlvbihjb2RlT2JqKSB7XG4gICAgdmFyIGtleSwgdGVtcGxhdGUgPSB7c3Viczoge30sIHBhcnRpYWxzOiBjb2RlT2JqLnBhcnRpYWxzLCBuYW1lOiBjb2RlT2JqLm5hbWV9O1xuICAgIGZvciAoa2V5IGluIHRlbXBsYXRlLnBhcnRpYWxzKSB7XG4gICAgICB0ZW1wbGF0ZS5wYXJ0aWFsc1trZXldID0gdGhpcy5tYWtlUGFydGlhbHModGVtcGxhdGUucGFydGlhbHNba2V5XSk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIGNvZGVPYmouc3Vicykge1xuICAgICAgdGVtcGxhdGUuc3Vic1trZXldID0gbmV3IEZ1bmN0aW9uKCdjJywgJ3AnLCAndCcsICdpJywgY29kZU9iai5zdWJzW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBlc2Mocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoclNsYXNoLCAnXFxcXFxcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoclF1b3QsICdcXFxcXFxcIicpXG4gICAgICAgICAgICAucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHJDciwgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHJMaW5lU2VwLCAnXFxcXHUyMDI4JylcbiAgICAgICAgICAgIC5yZXBsYWNlKHJQYXJhZ3JhcGhTZXAsICdcXFxcdTIwMjknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNob29zZU1ldGhvZChzKSB7XG4gICAgcmV0dXJuICh+cy5pbmRleE9mKCcuJykpID8gJ2QnIDogJ2YnO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChub2RlLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZWZpeCA9IFwiPFwiICsgKGNvbnRleHQucHJlZml4IHx8IFwiXCIpO1xuICAgIHZhciBzeW0gPSBwcmVmaXggKyBub2RlLm4gKyBzZXJpYWxObysrO1xuICAgIGNvbnRleHQucGFydGlhbHNbc3ltXSA9IHtuYW1lOiBub2RlLm4sIHBhcnRpYWxzOiB7fX07XG4gICAgY29udGV4dC5jb2RlICs9ICd0LmIodC5ycChcIicgKyAgZXNjKHN5bSkgKyAnXCIsYyxwLFwiJyArIChub2RlLmluZGVudCB8fCAnJykgKyAnXCIpKTsnO1xuICAgIHJldHVybiBzeW07XG4gIH1cblxuICBIb2dhbi5jb2RlZ2VuID0ge1xuICAgICcjJzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dC5jb2RlICs9ICdpZih0LnModC4nICsgY2hvb3NlTWV0aG9kKG5vZGUubikgKyAnKFwiJyArIGVzYyhub2RlLm4pICsgJ1wiLGMscCwxKSwnICtcbiAgICAgICAgICAgICAgICAgICAgICAnYyxwLDAsJyArIG5vZGUuaSArICcsJyArIG5vZGUuZW5kICsgJyxcIicgKyBub2RlLm90YWcgKyBcIiBcIiArIG5vZGUuY3RhZyArICdcIikpeycgK1xuICAgICAgICAgICAgICAgICAgICAgICd0LnJzKGMscCwnICsgJ2Z1bmN0aW9uKGMscCx0KXsnO1xuICAgICAgSG9nYW4ud2Fsayhub2RlLm5vZGVzLCBjb250ZXh0KTtcbiAgICAgIGNvbnRleHQuY29kZSArPSAnfSk7Yy5wb3AoKTt9JztcbiAgICB9LFxuXG4gICAgJ14nOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gJ2lmKCF0LnModC4nICsgY2hvb3NlTWV0aG9kKG5vZGUubikgKyAnKFwiJyArIGVzYyhub2RlLm4pICsgJ1wiLGMscCwxKSxjLHAsMSwwLDAsXCJcIikpeyc7XG4gICAgICBIb2dhbi53YWxrKG5vZGUubm9kZXMsIGNvbnRleHQpO1xuICAgICAgY29udGV4dC5jb2RlICs9ICd9Oyc7XG4gICAgfSxcblxuICAgICc+JzogY3JlYXRlUGFydGlhbCxcbiAgICAnPCc6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjdHggPSB7cGFydGlhbHM6IHt9LCBjb2RlOiAnJywgc3Viczoge30sIGluUGFydGlhbDogdHJ1ZX07XG4gICAgICBIb2dhbi53YWxrKG5vZGUubm9kZXMsIGN0eCk7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBjb250ZXh0LnBhcnRpYWxzW2NyZWF0ZVBhcnRpYWwobm9kZSwgY29udGV4dCldO1xuICAgICAgdGVtcGxhdGUuc3VicyA9IGN0eC5zdWJzO1xuICAgICAgdGVtcGxhdGUucGFydGlhbHMgPSBjdHgucGFydGlhbHM7XG4gICAgfSxcblxuICAgICckJzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgdmFyIGN0eCA9IHtzdWJzOiB7fSwgY29kZTogJycsIHBhcnRpYWxzOiBjb250ZXh0LnBhcnRpYWxzLCBwcmVmaXg6IG5vZGUubn07XG4gICAgICBIb2dhbi53YWxrKG5vZGUubm9kZXMsIGN0eCk7XG4gICAgICBjb250ZXh0LnN1YnNbbm9kZS5uXSA9IGN0eC5jb2RlO1xuICAgICAgaWYgKCFjb250ZXh0LmluUGFydGlhbCkge1xuICAgICAgICBjb250ZXh0LmNvZGUgKz0gJ3Quc3ViKFwiJyArIGVzYyhub2RlLm4pICsgJ1wiLGMscCxpKTsnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAnXFxuJzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dC5jb2RlICs9IHdyaXRlKCdcIlxcXFxuXCInICsgKG5vZGUubGFzdCA/ICcnIDogJyArIGknKSk7XG4gICAgfSxcblxuICAgICdfdic6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuY29kZSArPSAndC5iKHQudih0LicgKyBjaG9vc2VNZXRob2Qobm9kZS5uKSArICcoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLDApKSk7JztcbiAgICB9LFxuXG4gICAgJ190JzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dC5jb2RlICs9IHdyaXRlKCdcIicgKyBlc2Mobm9kZS50ZXh0KSArICdcIicpO1xuICAgIH0sXG5cbiAgICAneyc6IHRyaXBsZVN0YWNoZSxcblxuICAgICcmJzogdHJpcGxlU3RhY2hlXG4gIH1cblxuICBmdW5jdGlvbiB0cmlwbGVTdGFjaGUobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQuY29kZSArPSAndC5iKHQudCh0LicgKyBjaG9vc2VNZXRob2Qobm9kZS5uKSArICcoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLDApKSk7JztcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlKHMpIHtcbiAgICByZXR1cm4gJ3QuYignICsgcyArICcpOyc7XG4gIH1cblxuICBIb2dhbi53YWxrID0gZnVuY3Rpb24obm9kZWxpc3QsIGNvbnRleHQpIHtcbiAgICB2YXIgZnVuYztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnVuYyA9IEhvZ2FuLmNvZGVnZW5bbm9kZWxpc3RbaV0udGFnXTtcbiAgICAgIGZ1bmMgJiYgZnVuYyhub2RlbGlzdFtpXSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgSG9nYW4ucGFyc2UgPSBmdW5jdGlvbih0b2tlbnMsIHRleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gYnVpbGRUcmVlKHRva2VucywgJycsIFtdLCBvcHRpb25zLnNlY3Rpb25UYWdzIHx8IFtdKTtcbiAgfVxuXG4gIEhvZ2FuLmNhY2hlID0ge307XG5cbiAgSG9nYW4uY2FjaGVLZXkgPSBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFt0ZXh0LCAhIW9wdGlvbnMuYXNTdHJpbmcsICEhb3B0aW9ucy5kaXNhYmxlTGFtYmRhLCBvcHRpb25zLmRlbGltaXRlcnMsICEhb3B0aW9ucy5tb2RlbEdldF0uam9pbignfHwnKTtcbiAgfVxuXG4gIEhvZ2FuLmNvbXBpbGUgPSBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGtleSA9IEhvZ2FuLmNhY2hlS2V5KHRleHQsIG9wdGlvbnMpO1xuICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuY2FjaGVba2V5XTtcblxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgdmFyIHBhcnRpYWxzID0gdGVtcGxhdGUucGFydGlhbHM7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHBhcnRpYWxzKSB7XG4gICAgICAgIGRlbGV0ZSBwYXJ0aWFsc1tuYW1lXS5pbnN0YW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICB0ZW1wbGF0ZSA9IHRoaXMuZ2VuZXJhdGUodGhpcy5wYXJzZSh0aGlzLnNjYW4odGV4dCwgb3B0aW9ucy5kZWxpbWl0ZXJzKSwgdGV4dCwgb3B0aW9ucyksIHRleHQsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNhY2hlW2tleV0gPSB0ZW1wbGF0ZTtcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IEhvZ2FuKTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IDIwMTEgVHdpdHRlciwgSW5jLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gVGhpcyBmaWxlIGlzIGZvciB1c2Ugd2l0aCBOb2RlLmpzLiBTZWUgZGlzdC8gZm9yIGJyb3dzZXIgZmlsZXMuXG5cbnZhciBIb2dhbiA9IHJlcXVpcmUoJy4vY29tcGlsZXInKTtcbkhvZ2FuLlRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpLlRlbXBsYXRlO1xuSG9nYW4udGVtcGxhdGUgPSBIb2dhbi5UZW1wbGF0ZTtcbm1vZHVsZS5leHBvcnRzID0gSG9nYW47XG4iLCIvKlxuICogIENvcHlyaWdodCAyMDExIFR3aXR0ZXIsIEluYy5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBIb2dhbiA9IHt9O1xuXG4oZnVuY3Rpb24gKEhvZ2FuKSB7XG4gIEhvZ2FuLlRlbXBsYXRlID0gZnVuY3Rpb24gKGNvZGVPYmosIHRleHQsIGNvbXBpbGVyLCBvcHRpb25zKSB7XG4gICAgY29kZU9iaiA9IGNvZGVPYmogfHwge307XG4gICAgdGhpcy5yID0gY29kZU9iai5jb2RlIHx8IHRoaXMucjtcbiAgICB0aGlzLmMgPSBjb21waWxlcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMudGV4dCA9IHRleHQgfHwgJyc7XG4gICAgdGhpcy5wYXJ0aWFscyA9IGNvZGVPYmoucGFydGlhbHMgfHwge307XG4gICAgdGhpcy5zdWJzID0gY29kZU9iai5zdWJzIHx8IHt9O1xuICAgIHRoaXMuYnVmID0gJyc7XG4gIH1cblxuICBIb2dhbi5UZW1wbGF0ZS5wcm90b3R5cGUgPSB7XG4gICAgLy8gcmVuZGVyOiByZXBsYWNlZCBieSBnZW5lcmF0ZWQgY29kZS5cbiAgICByOiBmdW5jdGlvbiAoY29udGV4dCwgcGFydGlhbHMsIGluZGVudCkgeyByZXR1cm4gJyc7IH0sXG5cbiAgICAvLyB2YXJpYWJsZSBlc2NhcGluZ1xuICAgIHY6IGhvZ2FuRXNjYXBlLFxuXG4gICAgLy8gdHJpcGxlIHN0YWNoZVxuICAgIHQ6IGNvZXJjZVRvU3RyaW5nLFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoY29udGV4dCwgcGFydGlhbHMsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHRoaXMucmkoW2NvbnRleHRdLCBwYXJ0aWFscyB8fCB7fSwgaW5kZW50KTtcbiAgICB9LFxuXG4gICAgLy8gcmVuZGVyIGludGVybmFsIC0tIGEgaG9vayBmb3Igb3ZlcnJpZGVzIHRoYXQgY2F0Y2hlcyBwYXJ0aWFscyB0b29cbiAgICByaTogZnVuY3Rpb24gKGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnIoY29udGV4dCwgcGFydGlhbHMsIGluZGVudCk7XG4gICAgfSxcblxuICAgIC8vIGVuc3VyZVBhcnRpYWxcbiAgICBlcDogZnVuY3Rpb24oc3ltYm9sLCBwYXJ0aWFscykge1xuICAgICAgdmFyIHBhcnRpYWwgPSB0aGlzLnBhcnRpYWxzW3N5bWJvbF07XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSB0aGF0IGlmIHdlJ3ZlIGluc3RhbnRpYXRlZCB0aGlzIHBhcnRpYWwgYmVmb3JlXG4gICAgICB2YXIgdGVtcGxhdGUgPSBwYXJ0aWFsc1twYXJ0aWFsLm5hbWVdO1xuICAgICAgaWYgKHBhcnRpYWwuaW5zdGFuY2UgJiYgcGFydGlhbC5iYXNlID09IHRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiBwYXJ0aWFsLmluc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghdGhpcy5jKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29tcGlsZXIgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMuYy5jb21waWxlKHRlbXBsYXRlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSB1c2UgdGhpcyB0byBjaGVjayB3aGV0aGVyIHRoZSBwYXJ0aWFscyBkaWN0aW9uYXJ5IGhhcyBjaGFuZ2VkXG4gICAgICB0aGlzLnBhcnRpYWxzW3N5bWJvbF0uYmFzZSA9IHRlbXBsYXRlO1xuXG4gICAgICBpZiAocGFydGlhbC5zdWJzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjb25zaWRlciBwYXJlbnQgdGVtcGxhdGUgbm93XG4gICAgICAgIGlmICghcGFydGlhbHMuc3RhY2tUZXh0KSBwYXJ0aWFscy5zdGFja1RleHQgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gcGFydGlhbC5zdWJzKSB7XG4gICAgICAgICAgaWYgKCFwYXJ0aWFscy5zdGFja1RleHRba2V5XSkge1xuICAgICAgICAgICAgcGFydGlhbHMuc3RhY2tUZXh0W2tleV0gPSAodGhpcy5hY3RpdmVTdWIgIT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFscy5zdGFja1RleHRbdGhpcy5hY3RpdmVTdWJdKSA/IHBhcnRpYWxzLnN0YWNrVGV4dFt0aGlzLmFjdGl2ZVN1Yl0gOiB0aGlzLnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlID0gY3JlYXRlU3BlY2lhbGl6ZWRQYXJ0aWFsKHRlbXBsYXRlLCBwYXJ0aWFsLnN1YnMsIHBhcnRpYWwucGFydGlhbHMsXG4gICAgICAgICAgdGhpcy5zdGFja1N1YnMsIHRoaXMuc3RhY2tQYXJ0aWFscywgcGFydGlhbHMuc3RhY2tUZXh0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGlhbHNbc3ltYm9sXS5pbnN0YW5jZSA9IHRlbXBsYXRlO1xuXG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfSxcblxuICAgIC8vIHRyaWVzIHRvIGZpbmQgYSBwYXJ0aWFsIGluIHRoZSBjdXJyZW50IHNjb3BlIGFuZCByZW5kZXIgaXRcbiAgICBycDogZnVuY3Rpb24oc3ltYm9sLCBjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHRoaXMuZXAoc3ltYm9sLCBwYXJ0aWFscyk7XG4gICAgICBpZiAoIXBhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFydGlhbC5yaShjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KTtcbiAgICB9LFxuXG4gICAgLy8gcmVuZGVyIGEgc2VjdGlvblxuICAgIHJzOiBmdW5jdGlvbihjb250ZXh0LCBwYXJ0aWFscywgc2VjdGlvbikge1xuICAgICAgdmFyIHRhaWwgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICghaXNBcnJheSh0YWlsKSkge1xuICAgICAgICBzZWN0aW9uKGNvbnRleHQsIHBhcnRpYWxzLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29udGV4dC5wdXNoKHRhaWxbaV0pO1xuICAgICAgICBzZWN0aW9uKGNvbnRleHQsIHBhcnRpYWxzLCB0aGlzKTtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gbWF5YmUgc3RhcnQgYSBzZWN0aW9uXG4gICAgczogZnVuY3Rpb24odmFsLCBjdHgsIHBhcnRpYWxzLCBpbnZlcnRlZCwgc3RhcnQsIGVuZCwgdGFncykge1xuICAgICAgdmFyIHBhc3M7XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsID0gdGhpcy5tcyh2YWwsIGN0eCwgcGFydGlhbHMsIGludmVydGVkLCBzdGFydCwgZW5kLCB0YWdzKTtcbiAgICAgIH1cblxuICAgICAgcGFzcyA9ICEhdmFsO1xuXG4gICAgICBpZiAoIWludmVydGVkICYmIHBhc3MgJiYgY3R4KSB7XG4gICAgICAgIGN0eC5wdXNoKCh0eXBlb2YgdmFsID09ICdvYmplY3QnKSA/IHZhbCA6IGN0eFtjdHgubGVuZ3RoIC0gMV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFzcztcbiAgICB9LFxuXG4gICAgLy8gZmluZCB2YWx1ZXMgd2l0aCBkb3R0ZWQgbmFtZXNcbiAgICBkOiBmdW5jdGlvbihrZXksIGN0eCwgcGFydGlhbHMsIHJldHVybkZvdW5kKSB7XG4gICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgbmFtZXMgPSBrZXkuc3BsaXQoJy4nKSxcbiAgICAgICAgICB2YWwgPSB0aGlzLmYobmFtZXNbMF0sIGN0eCwgcGFydGlhbHMsIHJldHVybkZvdW5kKSxcbiAgICAgICAgICBkb01vZGVsR2V0ID0gdGhpcy5vcHRpb25zLm1vZGVsR2V0LFxuICAgICAgICAgIGN4ID0gbnVsbDtcblxuICAgICAgaWYgKGtleSA9PT0gJy4nICYmIGlzQXJyYXkoY3R4W2N0eC5sZW5ndGggLSAyXSkpIHtcbiAgICAgICAgdmFsID0gY3R4W2N0eC5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmb3VuZCA9IGZpbmRJblNjb3BlKG5hbWVzW2ldLCB2YWwsIGRvTW9kZWxHZXQpO1xuICAgICAgICAgIGlmIChmb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjeCA9IHZhbDtcbiAgICAgICAgICAgIHZhbCA9IGZvdW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZvdW5kICYmICF2YWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJldHVybkZvdW5kICYmIHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjdHgucHVzaChjeCk7XG4gICAgICAgIHZhbCA9IHRoaXMubXYodmFsLCBjdHgsIHBhcnRpYWxzKTtcbiAgICAgICAgY3R4LnBvcCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICAvLyBmaW5kIHZhbHVlcyB3aXRoIG5vcm1hbCBuYW1lc1xuICAgIGY6IGZ1bmN0aW9uKGtleSwgY3R4LCBwYXJ0aWFscywgcmV0dXJuRm91bmQpIHtcbiAgICAgIHZhciB2YWwgPSBmYWxzZSxcbiAgICAgICAgICB2ID0gbnVsbCxcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICAgIGRvTW9kZWxHZXQgPSB0aGlzLm9wdGlvbnMubW9kZWxHZXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSBjdHgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdiA9IGN0eFtpXTtcbiAgICAgICAgdmFsID0gZmluZEluU2NvcGUoa2V5LCB2LCBkb01vZGVsR2V0KTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgcmV0dXJuIChyZXR1cm5Gb3VuZCkgPyBmYWxzZSA6IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmV0dXJuRm91bmQgJiYgdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbCA9IHRoaXMubXYodmFsLCBjdHgsIHBhcnRpYWxzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgLy8gaGlnaGVyIG9yZGVyIHRlbXBsYXRlc1xuICAgIGxzOiBmdW5jdGlvbihmdW5jLCBjeCwgcGFydGlhbHMsIHRleHQsIHRhZ3MpIHtcbiAgICAgIHZhciBvbGRUYWdzID0gdGhpcy5vcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgICAgIHRoaXMub3B0aW9ucy5kZWxpbWl0ZXJzID0gdGFncztcbiAgICAgIHRoaXMuYih0aGlzLmN0KGNvZXJjZVRvU3RyaW5nKGZ1bmMuY2FsbChjeCwgdGV4dCkpLCBjeCwgcGFydGlhbHMpKTtcbiAgICAgIHRoaXMub3B0aW9ucy5kZWxpbWl0ZXJzID0gb2xkVGFncztcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBjb21waWxlIHRleHRcbiAgICBjdDogZnVuY3Rpb24odGV4dCwgY3gsIHBhcnRpYWxzKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVMYW1iZGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYW1iZGEgZmVhdHVyZXMgZGlzYWJsZWQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jLmNvbXBpbGUodGV4dCwgdGhpcy5vcHRpb25zKS5yZW5kZXIoY3gsIHBhcnRpYWxzKTtcbiAgICB9LFxuXG4gICAgLy8gdGVtcGxhdGUgcmVzdWx0IGJ1ZmZlcmluZ1xuICAgIGI6IGZ1bmN0aW9uKHMpIHsgdGhpcy5idWYgKz0gczsgfSxcblxuICAgIGZsOiBmdW5jdGlvbigpIHsgdmFyIHIgPSB0aGlzLmJ1ZjsgdGhpcy5idWYgPSAnJzsgcmV0dXJuIHI7IH0sXG5cbiAgICAvLyBtZXRob2QgcmVwbGFjZSBzZWN0aW9uXG4gICAgbXM6IGZ1bmN0aW9uKGZ1bmMsIGN0eCwgcGFydGlhbHMsIGludmVydGVkLCBzdGFydCwgZW5kLCB0YWdzKSB7XG4gICAgICB2YXIgdGV4dFNvdXJjZSxcbiAgICAgICAgICBjeCA9IGN0eFtjdHgubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5jYWxsKGN4KTtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoaW52ZXJ0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0U291cmNlID0gKHRoaXMuYWN0aXZlU3ViICYmIHRoaXMuc3Vic1RleHQgJiYgdGhpcy5zdWJzVGV4dFt0aGlzLmFjdGl2ZVN1Yl0pID8gdGhpcy5zdWJzVGV4dFt0aGlzLmFjdGl2ZVN1Yl0gOiB0aGlzLnRleHQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubHMocmVzdWx0LCBjeCwgcGFydGlhbHMsIHRleHRTb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpLCB0YWdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvLyBtZXRob2QgcmVwbGFjZSB2YXJpYWJsZVxuICAgIG12OiBmdW5jdGlvbihmdW5jLCBjdHgsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgY3ggPSBjdHhbY3R4Lmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuY2FsbChjeCk7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3QoY29lcmNlVG9TdHJpbmcocmVzdWx0LmNhbGwoY3gpKSwgY3gsIHBhcnRpYWxzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgc3ViOiBmdW5jdGlvbihuYW1lLCBjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KSB7XG4gICAgICB2YXIgZiA9IHRoaXMuc3Vic1tuYW1lXTtcbiAgICAgIGlmIChmKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlU3ViID0gbmFtZTtcbiAgICAgICAgZihjb250ZXh0LCBwYXJ0aWFscywgdGhpcywgaW5kZW50KTtcbiAgICAgICAgdGhpcy5hY3RpdmVTdWIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvL0ZpbmQgYSBrZXkgaW4gYW4gb2JqZWN0XG4gIGZ1bmN0aW9uIGZpbmRJblNjb3BlKGtleSwgc2NvcGUsIGRvTW9kZWxHZXQpIHtcbiAgICB2YXIgdmFsO1xuXG4gICAgaWYgKHNjb3BlICYmIHR5cGVvZiBzY29wZSA9PSAnb2JqZWN0Jykge1xuXG4gICAgICBpZiAoc2NvcGVba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbCA9IHNjb3BlW2tleV07XG5cbiAgICAgIC8vIHRyeSBsb29rdXAgd2l0aCBnZXQgZm9yIGJhY2tib25lIG9yIHNpbWlsYXIgbW9kZWwgZGF0YVxuICAgICAgfSBlbHNlIGlmIChkb01vZGVsR2V0ICYmIHNjb3BlLmdldCAmJiB0eXBlb2Ygc2NvcGUuZ2V0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsID0gc2NvcGUuZ2V0KGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNwZWNpYWxpemVkUGFydGlhbChpbnN0YW5jZSwgc3VicywgcGFydGlhbHMsIHN0YWNrU3Vicywgc3RhY2tQYXJ0aWFscywgc3RhY2tUZXh0KSB7XG4gICAgZnVuY3Rpb24gUGFydGlhbFRlbXBsYXRlKCkge307XG4gICAgUGFydGlhbFRlbXBsYXRlLnByb3RvdHlwZSA9IGluc3RhbmNlO1xuICAgIGZ1bmN0aW9uIFN1YnN0aXR1dGlvbnMoKSB7fTtcbiAgICBTdWJzdGl0dXRpb25zLnByb3RvdHlwZSA9IGluc3RhbmNlLnN1YnM7XG4gICAgdmFyIGtleTtcbiAgICB2YXIgcGFydGlhbCA9IG5ldyBQYXJ0aWFsVGVtcGxhdGUoKTtcbiAgICBwYXJ0aWFsLnN1YnMgPSBuZXcgU3Vic3RpdHV0aW9ucygpO1xuICAgIHBhcnRpYWwuc3Vic1RleHQgPSB7fTsgIC8vaGVoZS4gc3Vic3RleHQuXG4gICAgcGFydGlhbC5idWYgPSAnJztcblxuICAgIHN0YWNrU3VicyA9IHN0YWNrU3VicyB8fCB7fTtcbiAgICBwYXJ0aWFsLnN0YWNrU3VicyA9IHN0YWNrU3VicztcbiAgICBwYXJ0aWFsLnN1YnNUZXh0ID0gc3RhY2tUZXh0O1xuICAgIGZvciAoa2V5IGluIHN1YnMpIHtcbiAgICAgIGlmICghc3RhY2tTdWJzW2tleV0pIHN0YWNrU3Vic1trZXldID0gc3Vic1trZXldO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBzdGFja1N1YnMpIHtcbiAgICAgIHBhcnRpYWwuc3Vic1trZXldID0gc3RhY2tTdWJzW2tleV07XG4gICAgfVxuXG4gICAgc3RhY2tQYXJ0aWFscyA9IHN0YWNrUGFydGlhbHMgfHwge307XG4gICAgcGFydGlhbC5zdGFja1BhcnRpYWxzID0gc3RhY2tQYXJ0aWFscztcbiAgICBmb3IgKGtleSBpbiBwYXJ0aWFscykge1xuICAgICAgaWYgKCFzdGFja1BhcnRpYWxzW2tleV0pIHN0YWNrUGFydGlhbHNba2V5XSA9IHBhcnRpYWxzW2tleV07XG4gICAgfVxuICAgIGZvciAoa2V5IGluIHN0YWNrUGFydGlhbHMpIHtcbiAgICAgIHBhcnRpYWwucGFydGlhbHNba2V5XSA9IHN0YWNrUGFydGlhbHNba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydGlhbDtcbiAgfVxuXG4gIHZhciByQW1wID0gLyYvZyxcbiAgICAgIHJMdCA9IC88L2csXG4gICAgICByR3QgPSAvPi9nLFxuICAgICAgckFwb3MgPSAvXFwnL2csXG4gICAgICByUXVvdCA9IC9cXFwiL2csXG4gICAgICBoQ2hhcnMgPSAvWyY8PlxcXCJcXCddLztcblxuICBmdW5jdGlvbiBjb2VyY2VUb1N0cmluZyh2YWwpIHtcbiAgICByZXR1cm4gU3RyaW5nKCh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpID8gJycgOiB2YWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gaG9nYW5Fc2NhcGUoc3RyKSB7XG4gICAgc3RyID0gY29lcmNlVG9TdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gaENoYXJzLnRlc3Qoc3RyKSA/XG4gICAgICBzdHJcbiAgICAgICAgLnJlcGxhY2UockFtcCwgJyZhbXA7JylcbiAgICAgICAgLnJlcGxhY2Uockx0LCAnJmx0OycpXG4gICAgICAgIC5yZXBsYWNlKHJHdCwgJyZndDsnKVxuICAgICAgICAucmVwbGFjZShyQXBvcywgJyYjMzk7JylcbiAgICAgICAgLnJlcGxhY2UoclF1b3QsICcmcXVvdDsnKSA6XG4gICAgICBzdHI7XG4gIH1cblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiBIb2dhbik7XG4iLCJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuLyoqIEBqc3ggaCAqL1xuaW1wb3J0IHsgaCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgVGVtcGxhdGUgZnJvbSAnLi4vVGVtcGxhdGUvVGVtcGxhdGUnO1xuXG52YXIgSGl0cyA9IGZ1bmN0aW9uIEhpdHMoX3JlZikge1xuICB2YXIgcmVzdWx0cyA9IF9yZWYucmVzdWx0cyxcbiAgICAgIGhpdHMgPSBfcmVmLmhpdHMsXG4gICAgICBiaW5kRXZlbnQgPSBfcmVmLmJpbmRFdmVudCxcbiAgICAgIGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICB0ZW1wbGF0ZVByb3BzID0gX3JlZi50ZW1wbGF0ZVByb3BzO1xuXG4gIGlmIChyZXN1bHRzLmhpdHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGgoVGVtcGxhdGUsIF9leHRlbmRzKHt9LCB0ZW1wbGF0ZVByb3BzLCB7XG4gICAgICB0ZW1wbGF0ZUtleTogXCJlbXB0eVwiLFxuICAgICAgcm9vdFByb3BzOiB7XG4gICAgICAgIGNsYXNzTmFtZTogY3goY3NzQ2xhc3Nlcy5yb290LCBjc3NDbGFzc2VzLmVtcHR5Um9vdClcbiAgICAgIH0sXG4gICAgICBkYXRhOiByZXN1bHRzXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGgoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY3NzQ2xhc3Nlcy5yb290XG4gIH0sIGgoXCJvbFwiLCB7XG4gICAgY2xhc3NOYW1lOiBjc3NDbGFzc2VzLmxpc3RcbiAgfSwgaGl0cy5tYXAoZnVuY3Rpb24gKGhpdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gaChUZW1wbGF0ZSwgX2V4dGVuZHMoe30sIHRlbXBsYXRlUHJvcHMsIHtcbiAgICAgIHRlbXBsYXRlS2V5OiBcIml0ZW1cIixcbiAgICAgIHJvb3RUYWdOYW1lOiBcImxpXCIsXG4gICAgICByb290UHJvcHM6IHtcbiAgICAgICAgY2xhc3NOYW1lOiBjc3NDbGFzc2VzLml0ZW1cbiAgICAgIH0sXG4gICAgICBrZXk6IGhpdC5vYmplY3RJRCxcbiAgICAgIGRhdGE6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaGl0KSwge30sIHtcbiAgICAgICAgX19oaXRJbmRleDogaW5kZXhcbiAgICAgIH0pLFxuICAgICAgYmluZEV2ZW50OiBiaW5kRXZlbnRcbiAgICB9KSk7XG4gIH0pKSk7XG59O1xuXG5IaXRzLmRlZmF1bHRQcm9wcyA9IHtcbiAgcmVzdWx0czoge1xuICAgIGhpdHM6IFtdXG4gIH0sXG4gIGhpdHM6IFtdXG59O1xuZXhwb3J0IGRlZmF1bHQgSGl0czsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKiBAanN4IGggKi9cbmltcG9ydCB7IENvbXBvbmVudCwgaCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUGFnaW5hdGlvbkxpbmsgZnJvbSAnLi9QYWdpbmF0aW9uTGluayc7XG5pbXBvcnQgeyBpc1NwZWNpYWxDbGljayB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBjdXJyZW50UGFnZTogMCxcbiAgbmJQYWdlczogMCxcbiAgcGFnZXM6IFtdXG59O1xuXG52YXIgUGFnaW5hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUGFnaW5hdGlvbiwgX0NvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQYWdpbmF0aW9uKTtcblxuICBmdW5jdGlvbiBQYWdpbmF0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYWdpbmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlQ2xpY2tcIiwgZnVuY3Rpb24gKHBhZ2VOdW1iZXIsIGV2ZW50KSB7XG4gICAgICBpZiAoaXNTcGVjaWFsQ2xpY2soZXZlbnQpKSB7XG4gICAgICAgIC8vIGRvIG5vdCBhbHRlciB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yXG4gICAgICAgIC8vIGlmIG9uZSBzcGVjaWFsIGtleSBpcyBkb3duXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgX3RoaXMucHJvcHMuc2V0Q3VycmVudFBhZ2UocGFnZU51bWJlcik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicHJldmlvdXNQYWdlTGlua1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucGFnZUxpbmsoe1xuICAgICAgICBhcmlhTGFiZWw6ICdQcmV2aW91cycsXG4gICAgICAgIGFkZGl0aW9uYWxDbGFzc05hbWU6IF90aGlzLnByb3BzLmNzc0NsYXNzZXMucHJldmlvdXNQYWdlSXRlbSxcbiAgICAgICAgaXNEaXNhYmxlZDogX3RoaXMucHJvcHMuaXNGaXJzdFBhZ2UsXG4gICAgICAgIGxhYmVsOiBfdGhpcy5wcm9wcy50ZW1wbGF0ZXMucHJldmlvdXMsXG4gICAgICAgIHBhZ2VOdW1iZXI6IF90aGlzLnByb3BzLmN1cnJlbnRQYWdlIC0gMSxcbiAgICAgICAgY3JlYXRlVVJMOiBfdGhpcy5wcm9wcy5jcmVhdGVVUkxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm5leHRQYWdlTGlua1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucGFnZUxpbmsoe1xuICAgICAgICBhcmlhTGFiZWw6ICdOZXh0JyxcbiAgICAgICAgYWRkaXRpb25hbENsYXNzTmFtZTogX3RoaXMucHJvcHMuY3NzQ2xhc3Nlcy5uZXh0UGFnZUl0ZW0sXG4gICAgICAgIGlzRGlzYWJsZWQ6IF90aGlzLnByb3BzLmlzTGFzdFBhZ2UsXG4gICAgICAgIGxhYmVsOiBfdGhpcy5wcm9wcy50ZW1wbGF0ZXMubmV4dCxcbiAgICAgICAgcGFnZU51bWJlcjogX3RoaXMucHJvcHMuY3VycmVudFBhZ2UgKyAxLFxuICAgICAgICBjcmVhdGVVUkw6IF90aGlzLnByb3BzLmNyZWF0ZVVSTFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZmlyc3RQYWdlTGlua1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucGFnZUxpbmsoe1xuICAgICAgICBhcmlhTGFiZWw6ICdGaXJzdCcsXG4gICAgICAgIGFkZGl0aW9uYWxDbGFzc05hbWU6IF90aGlzLnByb3BzLmNzc0NsYXNzZXMuZmlyc3RQYWdlSXRlbSxcbiAgICAgICAgaXNEaXNhYmxlZDogX3RoaXMucHJvcHMuaXNGaXJzdFBhZ2UsXG4gICAgICAgIGxhYmVsOiBfdGhpcy5wcm9wcy50ZW1wbGF0ZXMuZmlyc3QsXG4gICAgICAgIHBhZ2VOdW1iZXI6IDAsXG4gICAgICAgIGNyZWF0ZVVSTDogX3RoaXMucHJvcHMuY3JlYXRlVVJMXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJsYXN0UGFnZUxpbmtcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnBhZ2VMaW5rKHtcbiAgICAgICAgYXJpYUxhYmVsOiAnTGFzdCcsXG4gICAgICAgIGFkZGl0aW9uYWxDbGFzc05hbWU6IF90aGlzLnByb3BzLmNzc0NsYXNzZXMubGFzdFBhZ2VJdGVtLFxuICAgICAgICBpc0Rpc2FibGVkOiBfdGhpcy5wcm9wcy5pc0xhc3RQYWdlLFxuICAgICAgICBsYWJlbDogX3RoaXMucHJvcHMudGVtcGxhdGVzLmxhc3QsXG4gICAgICAgIHBhZ2VOdW1iZXI6IF90aGlzLnByb3BzLm5iUGFnZXMgLSAxLFxuICAgICAgICBjcmVhdGVVUkw6IF90aGlzLnByb3BzLmNyZWF0ZVVSTFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicGFnZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnBhZ2VzLm1hcChmdW5jdGlvbiAocGFnZU51bWJlcikge1xuICAgICAgICByZXR1cm4gX3RoaXMucGFnZUxpbmsoe1xuICAgICAgICAgIGFyaWFMYWJlbDogXCJcIi5jb25jYXQocGFnZU51bWJlciArIDEpLFxuICAgICAgICAgIGFkZGl0aW9uYWxDbGFzc05hbWU6IF90aGlzLnByb3BzLmNzc0NsYXNzZXMucGFnZUl0ZW0sXG4gICAgICAgICAgaXNTZWxlY3RlZDogcGFnZU51bWJlciA9PT0gX3RoaXMucHJvcHMuY3VycmVudFBhZ2UsXG4gICAgICAgICAgbGFiZWw6IFwiXCIuY29uY2F0KHBhZ2VOdW1iZXIgKyAxKSxcbiAgICAgICAgICBwYWdlTnVtYmVyOiBwYWdlTnVtYmVyLFxuICAgICAgICAgIGNyZWF0ZVVSTDogX3RoaXMucHJvcHMuY3JlYXRlVVJMXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFnaW5hdGlvbiwgW3tcbiAgICBrZXk6IFwicGFnZUxpbmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZUxpbmsoX3JlZikge1xuICAgICAgdmFyIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgICAgICBhcmlhTGFiZWwgPSBfcmVmLmFyaWFMYWJlbCxcbiAgICAgICAgICBwYWdlTnVtYmVyID0gX3JlZi5wYWdlTnVtYmVyLFxuICAgICAgICAgIF9yZWYkYWRkaXRpb25hbENsYXNzTiA9IF9yZWYuYWRkaXRpb25hbENsYXNzTmFtZSxcbiAgICAgICAgICBhZGRpdGlvbmFsQ2xhc3NOYW1lID0gX3JlZiRhZGRpdGlvbmFsQ2xhc3NOID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRhZGRpdGlvbmFsQ2xhc3NOLFxuICAgICAgICAgIF9yZWYkaXNEaXNhYmxlZCA9IF9yZWYuaXNEaXNhYmxlZCxcbiAgICAgICAgICBpc0Rpc2FibGVkID0gX3JlZiRpc0Rpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaXNEaXNhYmxlZCxcbiAgICAgICAgICBfcmVmJGlzU2VsZWN0ZWQgPSBfcmVmLmlzU2VsZWN0ZWQsXG4gICAgICAgICAgaXNTZWxlY3RlZCA9IF9yZWYkaXNTZWxlY3RlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlzU2VsZWN0ZWQsXG4gICAgICAgICAgY3JlYXRlVVJMID0gX3JlZi5jcmVhdGVVUkw7XG4gICAgICB2YXIgY3NzQ2xhc3NlcyA9IHtcbiAgICAgICAgaXRlbTogY3godGhpcy5wcm9wcy5jc3NDbGFzc2VzLml0ZW0sIGFkZGl0aW9uYWxDbGFzc05hbWUpLFxuICAgICAgICBsaW5rOiB0aGlzLnByb3BzLmNzc0NsYXNzZXMubGlua1xuICAgICAgfTtcblxuICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgY3NzQ2xhc3Nlcy5pdGVtID0gY3goY3NzQ2xhc3Nlcy5pdGVtLCB0aGlzLnByb3BzLmNzc0NsYXNzZXMuZGlzYWJsZWRJdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICBjc3NDbGFzc2VzLml0ZW0gPSBjeChjc3NDbGFzc2VzLml0ZW0sIHRoaXMucHJvcHMuY3NzQ2xhc3Nlcy5zZWxlY3RlZEl0ZW0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXJsID0gIWlzRGlzYWJsZWQgPyBjcmVhdGVVUkwocGFnZU51bWJlcikgOiAnIyc7XG4gICAgICByZXR1cm4gaChQYWdpbmF0aW9uTGluaywge1xuICAgICAgICBhcmlhTGFiZWw6IGFyaWFMYWJlbCxcbiAgICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3NlcyxcbiAgICAgICAgaGFuZGxlQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssXG4gICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgIGtleTogbGFiZWwgKyBwYWdlTnVtYmVyICsgYXJpYUxhYmVsLFxuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXIsXG4gICAgICAgIHVybDogdXJsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBoKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjeCh0aGlzLnByb3BzLmNzc0NsYXNzZXMucm9vdCwgX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLnByb3BzLmNzc0NsYXNzZXMubm9SZWZpbmVtZW50Um9vdCwgdGhpcy5wcm9wcy5uYlBhZ2VzIDw9IDEpKVxuICAgICAgfSwgaChcInVsXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNzc0NsYXNzZXMubGlzdFxuICAgICAgfSwgdGhpcy5wcm9wcy5zaG93Rmlyc3QgJiYgdGhpcy5maXJzdFBhZ2VMaW5rKCksIHRoaXMucHJvcHMuc2hvd1ByZXZpb3VzICYmIHRoaXMucHJldmlvdXNQYWdlTGluaygpLCB0aGlzLnBhZ2VzKCksIHRoaXMucHJvcHMuc2hvd05leHQgJiYgdGhpcy5uZXh0UGFnZUxpbmsoKSwgdGhpcy5wcm9wcy5zaG93TGFzdCAmJiB0aGlzLmxhc3RQYWdlTGluaygpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhZ2luYXRpb247XG59KENvbXBvbmVudCk7XG5cbl9kZWZpbmVQcm9wZXJ0eShQYWdpbmF0aW9uLCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuXG5leHBvcnQgZGVmYXVsdCBQYWdpbmF0aW9uOyIsIi8qKiBAanN4IGggKi9cbmltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuXG52YXIgUGFnaW5hdGlvbkxpbmsgPSBmdW5jdGlvbiBQYWdpbmF0aW9uTGluayhfcmVmKSB7XG4gIHZhciBjc3NDbGFzc2VzID0gX3JlZi5jc3NDbGFzc2VzLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgYXJpYUxhYmVsID0gX3JlZi5hcmlhTGFiZWwsXG4gICAgICB1cmwgPSBfcmVmLnVybCxcbiAgICAgIGlzRGlzYWJsZWQgPSBfcmVmLmlzRGlzYWJsZWQsXG4gICAgICBoYW5kbGVDbGljayA9IF9yZWYuaGFuZGxlQ2xpY2ssXG4gICAgICBwYWdlTnVtYmVyID0gX3JlZi5wYWdlTnVtYmVyO1xuXG4gIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgcmV0dXJuIGgoXCJsaVwiLCB7XG4gICAgICBjbGFzc05hbWU6IGNzc0NsYXNzZXMuaXRlbVxuICAgIH0sIGgoXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogY3NzQ2xhc3Nlcy5saW5rLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBsYWJlbFxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBoKFwibGlcIiwge1xuICAgIGNsYXNzTmFtZTogY3NzQ2xhc3Nlcy5pdGVtXG4gIH0sIGgoXCJhXCIsIHtcbiAgICBjbGFzc05hbWU6IGNzc0NsYXNzZXMubGluayxcbiAgICBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLFxuICAgIGhyZWY6IHVybCxcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICByZXR1cm4gaGFuZGxlQ2xpY2socGFnZU51bWJlciwgZXZlbnQpO1xuICAgIH0sXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogbGFiZWxcbiAgICB9XG4gIH0pKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBhZ2luYXRpb25MaW5rOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqIEBqc3ggaCAqL1xuaW1wb3J0IHsgaCwgY3JlYXRlUmVmLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgVGVtcGxhdGUgZnJvbSAnLi4vVGVtcGxhdGUvVGVtcGxhdGUnO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgcXVlcnk6ICcnLFxuICBzaG93U3VibWl0OiB0cnVlLFxuICBzaG93UmVzZXQ6IHRydWUsXG4gIHNob3dMb2FkaW5nSW5kaWNhdG9yOiB0cnVlLFxuICBhdXRvZm9jdXM6IGZhbHNlLFxuICBzZWFyY2hBc1lvdVR5cGU6IHRydWUsXG4gIGlzU2VhcmNoU3RhbGxlZDogZmFsc2UsXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgb25DaGFuZ2U6IG5vb3AsXG4gIG9uU3VibWl0OiBub29wLFxuICBvblJlc2V0OiBub29wLFxuICByZWZpbmU6IG5vb3Bcbn07XG5cbnZhciBTZWFyY2hCb3ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFNlYXJjaEJveCwgX0NvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTZWFyY2hCb3gpO1xuXG4gIGZ1bmN0aW9uIFNlYXJjaEJveCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VhcmNoQm94KTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RhdGVcIiwge1xuICAgICAgcXVlcnk6IF90aGlzLnByb3BzLnF1ZXJ5LFxuICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpbnB1dFwiLCBjcmVhdGVSZWYoKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25JbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIHNlYXJjaEFzWW91VHlwZSA9IF90aGlzJHByb3BzLnNlYXJjaEFzWW91VHlwZSxcbiAgICAgICAgICByZWZpbmUgPSBfdGhpcyRwcm9wcy5yZWZpbmUsXG4gICAgICAgICAgb25DaGFuZ2UgPSBfdGhpcyRwcm9wcy5vbkNoYW5nZTtcbiAgICAgIHZhciBxdWVyeSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblxuICAgICAgaWYgKHNlYXJjaEFzWW91VHlwZSkge1xuICAgICAgICByZWZpbmUocXVlcnkpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgfSk7XG5cbiAgICAgIG9uQ2hhbmdlKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblN1Ym1pdFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBzZWFyY2hBc1lvdVR5cGUgPSBfdGhpcyRwcm9wczIuc2VhcmNoQXNZb3VUeXBlLFxuICAgICAgICAgIHJlZmluZSA9IF90aGlzJHByb3BzMi5yZWZpbmUsXG4gICAgICAgICAgb25TdWJtaXQgPSBfdGhpcyRwcm9wczIub25TdWJtaXQ7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmIChfdGhpcy5pbnB1dC5jdXJyZW50KSB7XG4gICAgICAgIF90aGlzLmlucHV0LmN1cnJlbnQuYmx1cigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlYXJjaEFzWW91VHlwZSkge1xuICAgICAgICByZWZpbmUoX3RoaXMuc3RhdGUucXVlcnkpO1xuICAgICAgfVxuXG4gICAgICBvblN1Ym1pdChldmVudCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25SZXNldFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICByZWZpbmUgPSBfdGhpcyRwcm9wczMucmVmaW5lLFxuICAgICAgICAgIG9uUmVzZXQgPSBfdGhpcyRwcm9wczMub25SZXNldDtcbiAgICAgIHZhciBxdWVyeSA9ICcnO1xuXG4gICAgICBpZiAoX3RoaXMuaW5wdXQuY3VycmVudCkge1xuICAgICAgICBfdGhpcy5pbnB1dC5jdXJyZW50LmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIHJlZmluZShxdWVyeSk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICB9KTtcblxuICAgICAgb25SZXNldChldmVudCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25CbHVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRm9jdXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBmb2N1c2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTZWFyY2hCb3gsIFt7XG4gICAga2V5OiBcInJlc2V0SW5wdXRcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBUaGlzIHB1YmxpYyBtZXRob2QgaXMgdXNlZCBpbiB0aGUgUmVmaW5lbWVudExpc3QgU0ZGViBzZWFyY2ggYm94XG4gICAgICogdG8gcmVzZXQgdGhlIGlucHV0IHN0YXRlIHdoZW4gYW4gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBzZWUgUmVmaW5lbWVudExpc3QjY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNldElucHV0KCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHF1ZXJ5OiAnJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIC8qKlxuICAgICAgICogd2hlbiB0aGUgdXNlciBpcyB0eXBpbmcsIHdlIGRvbid0IHdhbnQgdG8gcmVwbGFjZSB0aGUgcXVlcnkgdHlwZWRcbiAgICAgICAqIGJ5IHRoZSB1c2VyIChzdGF0ZS5xdWVyeSkgd2l0aCB0aGUgcXVlcnkgZXhwb3NlZCBieSB0aGUgY29ubmVjdG9yIChwcm9wcy5xdWVyeSlcbiAgICAgICAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvaW5zdGFudHNlYXJjaC5qcy9pc3N1ZXMvNDE0MVxuICAgICAgICovXG4gICAgICBpZiAoIXRoaXMuc3RhdGUuZm9jdXNlZCAmJiBuZXh0UHJvcHMucXVlcnkgIT09IHRoaXMuc3RhdGUucXVlcnkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgcXVlcnk6IG5leHRQcm9wcy5xdWVyeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNzc0NsYXNzZXMgPSBfdGhpcyRwcm9wczQuY3NzQ2xhc3NlcyxcbiAgICAgICAgICBwbGFjZWhvbGRlciA9IF90aGlzJHByb3BzNC5wbGFjZWhvbGRlcixcbiAgICAgICAgICBhdXRvZm9jdXMgPSBfdGhpcyRwcm9wczQuYXV0b2ZvY3VzLFxuICAgICAgICAgIHNob3dTdWJtaXQgPSBfdGhpcyRwcm9wczQuc2hvd1N1Ym1pdCxcbiAgICAgICAgICBzaG93UmVzZXQgPSBfdGhpcyRwcm9wczQuc2hvd1Jlc2V0LFxuICAgICAgICAgIHNob3dMb2FkaW5nSW5kaWNhdG9yID0gX3RoaXMkcHJvcHM0LnNob3dMb2FkaW5nSW5kaWNhdG9yLFxuICAgICAgICAgIHRlbXBsYXRlcyA9IF90aGlzJHByb3BzNC50ZW1wbGF0ZXMsXG4gICAgICAgICAgaXNTZWFyY2hTdGFsbGVkID0gX3RoaXMkcHJvcHM0LmlzU2VhcmNoU3RhbGxlZDtcbiAgICAgIHJldHVybiBoKFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjc3NDbGFzc2VzLnJvb3RcbiAgICAgIH0sIGgoXCJmb3JtXCIsIHtcbiAgICAgICAgYWN0aW9uOiBcIlwiLFxuICAgICAgICByb2xlOiBcInNlYXJjaFwiLFxuICAgICAgICBjbGFzc05hbWU6IGNzc0NsYXNzZXMuZm9ybSxcbiAgICAgICAgbm9WYWxpZGF0ZTogdHJ1ZSxcbiAgICAgICAgb25TdWJtaXQ6IHRoaXMub25TdWJtaXQgLy8gQHRzLWV4cGVjdC1lcnJvciBgb25SZXNldGAgYXR0aWJ1dGUgaXMgbWlzc2luZyBpbiBwcmVhY3QgMTAuMC4wIEpTWCB0eXBlc1xuICAgICAgICAsXG4gICAgICAgIG9uUmVzZXQ6IHRoaXMub25SZXNldFxuICAgICAgfSwgaChcImlucHV0XCIsIHtcbiAgICAgICAgcmVmOiB0aGlzLmlucHV0LFxuICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5xdWVyeSxcbiAgICAgICAgZGlzYWJsZWQ6IHRoaXMucHJvcHMuZGlzYWJsZWQsXG4gICAgICAgIGNsYXNzTmFtZTogY3NzQ2xhc3Nlcy5pbnB1dCxcbiAgICAgICAgdHlwZTogXCJzZWFyY2hcIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgICBhdXRvRm9jdXM6IGF1dG9mb2N1cyxcbiAgICAgICAgYXV0b0NvbXBsZXRlOiBcIm9mZlwiLFxuICAgICAgICBhdXRvQ29ycmVjdDogXCJvZmZcIiAvLyBAdHMtZXhwZWN0LWVycm9yIGBhdXRvQ2FwaXRhbGl6ZWAgYXR0aWJ1dGUgaXMgbWlzc2luZyBpbiBwcmVhY3QgMTAuMC4wIEpTWCB0eXBlc1xuICAgICAgICAsXG4gICAgICAgIGF1dG9DYXBpdGFsaXplOiBcIm9mZlwiLFxuICAgICAgICBzcGVsbENoZWNrOiBcImZhbHNlXCIsXG4gICAgICAgIG1heExlbmd0aDogNTEyLFxuICAgICAgICBvbklucHV0OiB0aGlzLm9uSW5wdXQsXG4gICAgICAgIG9uQmx1cjogdGhpcy5vbkJsdXIsXG4gICAgICAgIG9uRm9jdXM6IHRoaXMub25Gb2N1c1xuICAgICAgfSksIGgoVGVtcGxhdGUsIHtcbiAgICAgICAgdGVtcGxhdGVLZXk6IFwic3VibWl0XCIsXG4gICAgICAgIHJvb3RUYWdOYW1lOiBcImJ1dHRvblwiLFxuICAgICAgICByb290UHJvcHM6IHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNzc0NsYXNzZXMuc3VibWl0LFxuICAgICAgICAgIHR5cGU6ICdzdWJtaXQnLFxuICAgICAgICAgIHRpdGxlOiAnU3VibWl0IHRoZSBzZWFyY2ggcXVlcnkuJyxcbiAgICAgICAgICBoaWRkZW46ICFzaG93U3VibWl0XG4gICAgICAgIH0sXG4gICAgICAgIHRlbXBsYXRlczogdGVtcGxhdGVzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3Nlc1xuICAgICAgICB9XG4gICAgICB9KSwgaChUZW1wbGF0ZSwge1xuICAgICAgICB0ZW1wbGF0ZUtleTogXCJyZXNldFwiLFxuICAgICAgICByb290VGFnTmFtZTogXCJidXR0b25cIixcbiAgICAgICAgcm9vdFByb3BzOiB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjc3NDbGFzc2VzLnJlc2V0LFxuICAgICAgICAgIHR5cGU6ICdyZXNldCcsXG4gICAgICAgICAgdGl0bGU6ICdDbGVhciB0aGUgc2VhcmNoIHF1ZXJ5LicsXG4gICAgICAgICAgaGlkZGVuOiAhKHNob3dSZXNldCAmJiB0aGlzLnN0YXRlLnF1ZXJ5LnRyaW0oKSAmJiAhaXNTZWFyY2hTdGFsbGVkKVxuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXNcbiAgICAgICAgfVxuICAgICAgfSksIHNob3dMb2FkaW5nSW5kaWNhdG9yICYmIGgoVGVtcGxhdGUsIHtcbiAgICAgICAgdGVtcGxhdGVLZXk6IFwibG9hZGluZ0luZGljYXRvclwiLFxuICAgICAgICByb290VGFnTmFtZTogXCJzcGFuXCIsXG4gICAgICAgIHJvb3RQcm9wczoge1xuICAgICAgICAgIGNsYXNzTmFtZTogY3NzQ2xhc3Nlcy5sb2FkaW5nSW5kaWNhdG9yLFxuICAgICAgICAgIGhpZGRlbjogIWlzU2VhcmNoU3RhbGxlZFxuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXNcbiAgICAgICAgfVxuICAgICAgfSkpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VhcmNoQm94O1xufShDb21wb25lbnQpO1xuXG5fZGVmaW5lUHJvcGVydHkoU2VhcmNoQm94LCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuXG5leHBvcnQgZGVmYXVsdCBTZWFyY2hCb3g7IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKiBAanN4IGggKi9cbmltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFRlbXBsYXRlIGZyb20gJy4uL1RlbXBsYXRlL1RlbXBsYXRlJztcblxudmFyIFN0YXRzID0gZnVuY3Rpb24gU3RhdHMoX3JlZikge1xuICB2YXIgbmJIaXRzID0gX3JlZi5uYkhpdHMsXG4gICAgICBuYlNvcnRlZEhpdHMgPSBfcmVmLm5iU29ydGVkSGl0cyxcbiAgICAgIGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICB0ZW1wbGF0ZVByb3BzID0gX3JlZi50ZW1wbGF0ZVByb3BzLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJuYkhpdHNcIiwgXCJuYlNvcnRlZEhpdHNcIiwgXCJjc3NDbGFzc2VzXCIsIFwidGVtcGxhdGVQcm9wc1wiXSk7XG5cbiAgcmV0dXJuIGgoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY3goY3NzQ2xhc3Nlcy5yb290KVxuICB9LCBoKFRlbXBsYXRlLCBfZXh0ZW5kcyh7fSwgdGVtcGxhdGVQcm9wcywge1xuICAgIHRlbXBsYXRlS2V5OiBcInRleHRcIixcbiAgICByb290VGFnTmFtZTogXCJzcGFuXCIsXG4gICAgcm9vdFByb3BzOiB7XG4gICAgICBjbGFzc05hbWU6IGNzc0NsYXNzZXMudGV4dFxuICAgIH0sXG4gICAgZGF0YTogX29iamVjdFNwcmVhZCh7XG4gICAgICBoYXNNYW55U29ydGVkUmVzdWx0czogbmJTb3J0ZWRIaXRzICYmIG5iU29ydGVkSGl0cyA+IDEsXG4gICAgICBoYXNOb1NvcnRlZFJlc3VsdHM6IG5iU29ydGVkSGl0cyA9PT0gMCxcbiAgICAgIGhhc09uZVNvcnRlZFJlc3VsdHM6IG5iU29ydGVkSGl0cyA9PT0gMSxcbiAgICAgIGhhc01hbnlSZXN1bHRzOiBuYkhpdHMgPiAxLFxuICAgICAgaGFzTm9SZXN1bHRzOiBuYkhpdHMgPT09IDAsXG4gICAgICBoYXNPbmVSZXN1bHQ6IG5iSGl0cyA9PT0gMSxcbiAgICAgIG5iSGl0czogbmJIaXRzLFxuICAgICAgbmJTb3J0ZWRIaXRzOiBuYlNvcnRlZEhpdHMsXG4gICAgICBjc3NDbGFzc2VzOiBjc3NDbGFzc2VzXG4gICAgfSwgcmVzdClcbiAgfSkpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRzOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqIEBqc3ggaCAqL1xuaW1wb3J0IHsgaCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHJlbmRlclRlbXBsYXRlLCBpc0VxdWFsIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGRhdGE6IHt9LFxuICByb290VGFnTmFtZTogJ2RpdicsXG4gIHVzZUN1c3RvbUNvbXBpbGVPcHRpb25zOiB7fSxcbiAgdGVtcGxhdGVzOiB7fSxcbiAgdGVtcGxhdGVzQ29uZmlnOiB7fVxufTtcblxuLy8gQFRPRE86IFRlbXBsYXRlIHNob3VsZCBiZSBhIGdlbmVyaWMgYW5kIHJlY2VpdmUgVERhdGEgdG8gcGFzcyB0byBUZW1wbGF0ZXMgKHRvIGF2b2lkIFRUZW1wbGF0ZURhdGEgdG8gYmUgc2V0IGFzIGBhbnlgKVxudmFyIFRlbXBsYXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhUZW1wbGF0ZSwgX0NvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUZW1wbGF0ZSk7XG5cbiAgZnVuY3Rpb24gVGVtcGxhdGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlbXBsYXRlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZW1wbGF0ZSwgW3tcbiAgICBrZXk6IFwic2hvdWxkQ29tcG9uZW50VXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiAhaXNFcXVhbCh0aGlzLnByb3BzLmRhdGEsIG5leHRQcm9wcy5kYXRhKSB8fCB0aGlzLnByb3BzLnRlbXBsYXRlS2V5ICE9PSBuZXh0UHJvcHMudGVtcGxhdGVLZXkgfHwgIWlzRXF1YWwodGhpcy5wcm9wcy5yb290UHJvcHMsIG5leHRQcm9wcy5yb290UHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIFJvb3RUYWdOYW1lID0gdGhpcy5wcm9wcy5yb290VGFnTmFtZTtcbiAgICAgIHZhciB1c2VDdXN0b21Db21waWxlT3B0aW9ucyA9IHRoaXMucHJvcHMudXNlQ3VzdG9tQ29tcGlsZU9wdGlvbnNbdGhpcy5wcm9wcy50ZW1wbGF0ZUtleV07XG4gICAgICB2YXIgY29tcGlsZU9wdGlvbnMgPSB1c2VDdXN0b21Db21waWxlT3B0aW9ucyA/IHRoaXMucHJvcHMudGVtcGxhdGVzQ29uZmlnLmNvbXBpbGVPcHRpb25zIDoge307XG4gICAgICB2YXIgY29udGVudCA9IHJlbmRlclRlbXBsYXRlKHtcbiAgICAgICAgdGVtcGxhdGVzOiB0aGlzLnByb3BzLnRlbXBsYXRlcyxcbiAgICAgICAgdGVtcGxhdGVLZXk6IHRoaXMucHJvcHMudGVtcGxhdGVLZXksXG4gICAgICAgIGNvbXBpbGVPcHRpb25zOiBjb21waWxlT3B0aW9ucyxcbiAgICAgICAgaGVscGVyczogdGhpcy5wcm9wcy50ZW1wbGF0ZXNDb25maWcuaGVscGVycyxcbiAgICAgICAgZGF0YTogdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICBiaW5kRXZlbnQ6IHRoaXMucHJvcHMuYmluZEV2ZW50XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQWRkcyBhIG5vc2NyaXB0IHRvIHRoZSBET00gYnV0IHZpcnR1YWwgRE9NIGlzIG51bGxcbiAgICAgICAgLy8gU2VlIGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9jb21wb25lbnQtc3BlY3MuaHRtbCNyZW5kZXJcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKFJvb3RUYWdOYW1lLCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcy5yb290UHJvcHMsIHtcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICBfX2h0bWw6IGNvbnRlbnRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZW1wbGF0ZTtcbn0oQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KFRlbXBsYXRlLCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuXG5leHBvcnQgZGVmYXVsdCBUZW1wbGF0ZTsiLCJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IGFsZ29saWFzZWFyY2hIZWxwZXIgZnJvbSAnYWxnb2xpYXNlYXJjaC1oZWxwZXInO1xuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnRhdGlvbk1lc3NhZ2VHZW5lcmF0b3IsIGlzUGxhaW5PYmplY3QsIG1lcmdlU2VhcmNoUGFyYW1ldGVycywgbm9vcCB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG4vKipcbiAqIFJlZmluZSB0aGUgZ2l2ZW4gc2VhcmNoIHBhcmFtZXRlcnMuXG4gKi9cblxudmFyIHdpdGhVc2FnZSA9IGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yKHtcbiAgbmFtZTogJ2NvbmZpZ3VyZScsXG4gIGNvbm5lY3RvcjogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxTZWFyY2hQYXJhbWV0ZXJzKHN0YXRlLCB3aWRnZXRQYXJhbXMpIHtcbiAgLy8gV2UgbGV2ZXJhZ2UgdGhlIGhlbHBlciBpbnRlcm5hbHMgdG8gcmVtb3ZlIHRoZSBgd2lkZ2V0UGFyYW1zYCBmcm9tXG4gIC8vIHRoZSBzdGF0ZS4gVGhlIGZ1bmN0aW9uIGBzZXRRdWVyeVBhcmFtZXRlcnNgIG9taXRzIHRoZSB2YWx1ZXMgdGhhdFxuICAvLyBhcmUgYHVuZGVmaW5lZGAgb24gdGhlIG5leHQgc3RhdGUuXG4gIHJldHVybiBzdGF0ZS5zZXRRdWVyeVBhcmFtZXRlcnMoT2JqZWN0LmtleXMod2lkZ2V0UGFyYW1zLnNlYXJjaFBhcmFtZXRlcnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBhY2MpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHVuZGVmaW5lZCkpO1xuICB9LCB7fSkpO1xufVxuXG52YXIgY29ubmVjdENvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbm5lY3RDb25maWd1cmUoKSB7XG4gIHZhciByZW5kZXJGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbm9vcDtcbiAgdmFyIHVubW91bnRGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgcmV0dXJuIGZ1bmN0aW9uICh3aWRnZXRQYXJhbXMpIHtcbiAgICBpZiAoIXdpZGdldFBhcmFtcyB8fCAhaXNQbGFpbk9iamVjdCh3aWRnZXRQYXJhbXMuc2VhcmNoUGFyYW1ldGVycykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgc2VhcmNoUGFyYW1ldGVyc2Agb3B0aW9uIGV4cGVjdHMgYW4gb2JqZWN0LicpKTtcbiAgICB9XG5cbiAgICB2YXIgY29ubmVjdG9yU3RhdGUgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHJlZmluZShoZWxwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc2VhcmNoUGFyYW1ldGVycykge1xuICAgICAgICAvLyBNZXJnZSBuZXcgYHNlYXJjaFBhcmFtZXRlcnNgIHdpdGggdGhlIG9uZXMgc2V0IGZyb20gb3RoZXIgd2lkZ2V0c1xuICAgICAgICB2YXIgYWN0dWFsU3RhdGUgPSBnZXRJbml0aWFsU2VhcmNoUGFyYW1ldGVycyhoZWxwZXIuc3RhdGUsIHdpZGdldFBhcmFtcyk7XG4gICAgICAgIHZhciBuZXh0U2VhcmNoUGFyYW1ldGVycyA9IG1lcmdlU2VhcmNoUGFyYW1ldGVycyhhY3R1YWxTdGF0ZSwgbmV3IGFsZ29saWFzZWFyY2hIZWxwZXIuU2VhcmNoUGFyYW1ldGVycyhzZWFyY2hQYXJhbWV0ZXJzKSk7IC8vIFVwZGF0ZSBvcmlnaW5hbCBgd2lkZ2V0UGFyYW1zLnNlYXJjaFBhcmFtZXRlcnNgIHRvIHRoZSBuZXcgcmVmaW5lZCBvbmVcblxuICAgICAgICB3aWRnZXRQYXJhbXMuc2VhcmNoUGFyYW1ldGVycyA9IHNlYXJjaFBhcmFtZXRlcnM7IC8vIFRyaWdnZXIgYSBzZWFyY2ggd2l0aCB0aGUgcmVzb2x2ZWQgc2VhcmNoIHBhcmFtZXRlcnNcblxuICAgICAgICBoZWxwZXIuc2V0U3RhdGUobmV4dFNlYXJjaFBhcmFtZXRlcnMpLnNlYXJjaCgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgJCR0eXBlOiAnYWlzLmNvbmZpZ3VyZScsXG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KGluaXRPcHRpb25zKSB7XG4gICAgICAgIHZhciBpbnN0YW50U2VhcmNoSW5zdGFuY2UgPSBpbml0T3B0aW9ucy5pbnN0YW50U2VhcmNoSW5zdGFuY2U7XG4gICAgICAgIHJlbmRlckZuKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5nZXRXaWRnZXRSZW5kZXJTdGF0ZShpbml0T3B0aW9ucykpLCB7fSwge1xuICAgICAgICAgIGluc3RhbnRTZWFyY2hJbnN0YW5jZTogaW5zdGFudFNlYXJjaEluc3RhbmNlXG4gICAgICAgIH0pLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIHZhciBpbnN0YW50U2VhcmNoSW5zdGFuY2UgPSByZW5kZXJPcHRpb25zLmluc3RhbnRTZWFyY2hJbnN0YW5jZTtcbiAgICAgICAgcmVuZGVyRm4oX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmdldFdpZGdldFJlbmRlclN0YXRlKHJlbmRlck9wdGlvbnMpKSwge30sIHtcbiAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGluc3RhbnRTZWFyY2hJbnN0YW5jZVxuICAgICAgICB9KSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoX3JlZikge1xuICAgICAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICAgICAgICB1bm1vdW50Rm4oKTtcbiAgICAgICAgcmV0dXJuIGdldEluaXRpYWxTZWFyY2hQYXJhbWV0ZXJzKHN0YXRlLCB3aWRnZXRQYXJhbXMpO1xuICAgICAgfSxcbiAgICAgIGdldFJlbmRlclN0YXRlOiBmdW5jdGlvbiBnZXRSZW5kZXJTdGF0ZShyZW5kZXJTdGF0ZSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICB2YXIgX3JlbmRlclN0YXRlJGNvbmZpZ3VyO1xuXG4gICAgICAgIHZhciB3aWRnZXRSZW5kZXJTdGF0ZSA9IHRoaXMuZ2V0V2lkZ2V0UmVuZGVyU3RhdGUocmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlbmRlclN0YXRlKSwge30sIHtcbiAgICAgICAgICBjb25maWd1cmU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgd2lkZ2V0UmVuZGVyU3RhdGUpLCB7fSwge1xuICAgICAgICAgICAgd2lkZ2V0UGFyYW1zOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHdpZGdldFJlbmRlclN0YXRlLndpZGdldFBhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICAgIHNlYXJjaFBhcmFtZXRlcnM6IG1lcmdlU2VhcmNoUGFyYW1ldGVycyhuZXcgYWxnb2xpYXNlYXJjaEhlbHBlci5TZWFyY2hQYXJhbWV0ZXJzKChfcmVuZGVyU3RhdGUkY29uZmlndXIgPSByZW5kZXJTdGF0ZS5jb25maWd1cmUpID09PSBudWxsIHx8IF9yZW5kZXJTdGF0ZSRjb25maWd1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbmRlclN0YXRlJGNvbmZpZ3VyLndpZGdldFBhcmFtcy5zZWFyY2hQYXJhbWV0ZXJzKSwgbmV3IGFsZ29saWFzZWFyY2hIZWxwZXIuU2VhcmNoUGFyYW1ldGVycyh3aWRnZXRSZW5kZXJTdGF0ZS53aWRnZXRQYXJhbXMuc2VhcmNoUGFyYW1ldGVycykpLmdldFF1ZXJ5UGFyYW1zKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0V2lkZ2V0UmVuZGVyU3RhdGU6IGZ1bmN0aW9uIGdldFdpZGdldFJlbmRlclN0YXRlKF9yZWYyKSB7XG4gICAgICAgIHZhciBoZWxwZXIgPSBfcmVmMi5oZWxwZXI7XG5cbiAgICAgICAgaWYgKCFjb25uZWN0b3JTdGF0ZS5yZWZpbmUpIHtcbiAgICAgICAgICBjb25uZWN0b3JTdGF0ZS5yZWZpbmUgPSByZWZpbmUoaGVscGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVmaW5lOiBjb25uZWN0b3JTdGF0ZS5yZWZpbmUsXG4gICAgICAgICAgd2lkZ2V0UGFyYW1zOiB3aWRnZXRQYXJhbXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRXaWRnZXRTZWFyY2hQYXJhbWV0ZXJzOiBmdW5jdGlvbiBnZXRXaWRnZXRTZWFyY2hQYXJhbWV0ZXJzKHN0YXRlLCBfcmVmMykge1xuICAgICAgICB2YXIgdWlTdGF0ZSA9IF9yZWYzLnVpU3RhdGU7XG4gICAgICAgIHJldHVybiBtZXJnZVNlYXJjaFBhcmFtZXRlcnMoc3RhdGUsIG5ldyBhbGdvbGlhc2VhcmNoSGVscGVyLlNlYXJjaFBhcmFtZXRlcnMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB1aVN0YXRlLmNvbmZpZ3VyZSksIHdpZGdldFBhcmFtcy5zZWFyY2hQYXJhbWV0ZXJzKSkpO1xuICAgICAgfSxcbiAgICAgIGdldFdpZGdldFVpU3RhdGU6IGZ1bmN0aW9uIGdldFdpZGdldFVpU3RhdGUodWlTdGF0ZSkge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB1aVN0YXRlKSwge30sIHtcbiAgICAgICAgICBjb25maWd1cmU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdWlTdGF0ZS5jb25maWd1cmUpLCB3aWRnZXRQYXJhbXMuc2VhcmNoUGFyYW1ldGVycylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RDb25maWd1cmU7IiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IGVzY2FwZUhpdHMsIFRBR19QTEFDRUhPTERFUiwgY2hlY2tSZW5kZXJpbmcsIGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yLCBhZGRBYnNvbHV0ZVBvc2l0aW9uLCBhZGRRdWVyeUlELCBjcmVhdGVTZW5kRXZlbnRGb3JIaXRzLCBjcmVhdGVCaW5kRXZlbnRGb3JIaXRzLCBub29wIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbnZhciB3aXRoVXNhZ2UgPSBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvcih7XG4gIG5hbWU6ICdoaXRzJyxcbiAgY29ubmVjdG9yOiB0cnVlXG59KTtcblxudmFyIGNvbm5lY3RIaXRzID0gZnVuY3Rpb24gY29ubmVjdEhpdHMocmVuZGVyRm4pIHtcbiAgdmFyIHVubW91bnRGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgY2hlY2tSZW5kZXJpbmcocmVuZGVyRm4sIHdpdGhVc2FnZSgpKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh3aWRnZXRQYXJhbXMpIHtcbiAgICB2YXIgX3JlZiA9IHdpZGdldFBhcmFtcyB8fCB7fSxcbiAgICAgICAgX3JlZiRlc2NhcGVIVE1MID0gX3JlZi5lc2NhcGVIVE1MLFxuICAgICAgICBlc2NhcGVIVE1MID0gX3JlZiRlc2NhcGVIVE1MID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRlc2NhcGVIVE1MLFxuICAgICAgICBfcmVmJHRyYW5zZm9ybUl0ZW1zID0gX3JlZi50cmFuc2Zvcm1JdGVtcyxcbiAgICAgICAgdHJhbnNmb3JtSXRlbXMgPSBfcmVmJHRyYW5zZm9ybUl0ZW1zID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9IDogX3JlZiR0cmFuc2Zvcm1JdGVtcztcblxuICAgIHZhciBzZW5kRXZlbnQ7XG4gICAgdmFyIGJpbmRFdmVudDtcbiAgICByZXR1cm4ge1xuICAgICAgJCR0eXBlOiAnYWlzLmhpdHMnLFxuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdChpbml0T3B0aW9ucykge1xuICAgICAgICByZW5kZXJGbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuZ2V0V2lkZ2V0UmVuZGVyU3RhdGUoaW5pdE9wdGlvbnMpKSwge30sIHtcbiAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGluaXRPcHRpb25zLmluc3RhbnRTZWFyY2hJbnN0YW5jZVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyT3B0aW9ucykge1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB0aGlzLmdldFdpZGdldFJlbmRlclN0YXRlKHJlbmRlck9wdGlvbnMpO1xuICAgICAgICByZW5kZXJTdGF0ZS5zZW5kRXZlbnQoJ3ZpZXcnLCByZW5kZXJTdGF0ZS5oaXRzKTtcbiAgICAgICAgcmVuZGVyRm4oX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZW5kZXJTdGF0ZSksIHt9LCB7XG4gICAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiByZW5kZXJPcHRpb25zLmluc3RhbnRTZWFyY2hJbnN0YW5jZVxuICAgICAgICB9KSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIGdldFJlbmRlclN0YXRlOiBmdW5jdGlvbiBnZXRSZW5kZXJTdGF0ZShyZW5kZXJTdGF0ZSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZW5kZXJTdGF0ZSksIHt9LCB7XG4gICAgICAgICAgaGl0czogdGhpcy5nZXRXaWRnZXRSZW5kZXJTdGF0ZShyZW5kZXJPcHRpb25zKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRXaWRnZXRSZW5kZXJTdGF0ZTogZnVuY3Rpb24gZ2V0V2lkZ2V0UmVuZGVyU3RhdGUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBfcmVmMi5yZXN1bHRzLFxuICAgICAgICAgICAgaGVscGVyID0gX3JlZjIuaGVscGVyLFxuICAgICAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlID0gX3JlZjIuaW5zdGFudFNlYXJjaEluc3RhbmNlO1xuXG4gICAgICAgIGlmICghc2VuZEV2ZW50KSB7XG4gICAgICAgICAgc2VuZEV2ZW50ID0gY3JlYXRlU2VuZEV2ZW50Rm9ySGl0cyh7XG4gICAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGluc3RhbnRTZWFyY2hJbnN0YW5jZSxcbiAgICAgICAgICAgIGluZGV4OiBoZWxwZXIuZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgIHdpZGdldFR5cGU6IHRoaXMuJCR0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWJpbmRFdmVudCkge1xuICAgICAgICAgIGJpbmRFdmVudCA9IGNyZWF0ZUJpbmRFdmVudEZvckhpdHMoe1xuICAgICAgICAgICAgaW5kZXg6IGhlbHBlci5nZXRJbmRleCgpLFxuICAgICAgICAgICAgd2lkZ2V0VHlwZTogdGhpcy4kJHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0cykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaXRzOiBbXSxcbiAgICAgICAgICAgIHJlc3VsdHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbmRFdmVudDogc2VuZEV2ZW50LFxuICAgICAgICAgICAgYmluZEV2ZW50OiBiaW5kRXZlbnQsXG4gICAgICAgICAgICB3aWRnZXRQYXJhbXM6IHdpZGdldFBhcmFtc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXNjYXBlSFRNTCAmJiByZXN1bHRzLmhpdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3VsdHMuaGl0cyA9IGVzY2FwZUhpdHMocmVzdWx0cy5oaXRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbml0aWFsRXNjYXBlZCA9IHJlc3VsdHMuaGl0cy5fX2VzY2FwZWQ7XG4gICAgICAgIHJlc3VsdHMuaGl0cyA9IGFkZEFic29sdXRlUG9zaXRpb24ocmVzdWx0cy5oaXRzLCByZXN1bHRzLnBhZ2UsIHJlc3VsdHMuaGl0c1BlclBhZ2UpO1xuICAgICAgICByZXN1bHRzLmhpdHMgPSBhZGRRdWVyeUlEKHJlc3VsdHMuaGl0cywgcmVzdWx0cy5xdWVyeUlEKTtcbiAgICAgICAgcmVzdWx0cy5oaXRzID0gdHJhbnNmb3JtSXRlbXMocmVzdWx0cy5oaXRzKTsgLy8gTWFrZSBzdXJlIHRoZSBlc2NhcGVkIHRhZyBzdGF5cywgZXZlbiBhZnRlciBtYXBwaW5nIG92ZXIgdGhlIGhpdHMuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgdGhlIGhpdHMgZnJvbSBiZWluZyBkb3VibGUtZXNjYXBlZCBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICAgICAgLy8gaGl0cyB3aWRnZXRzIG1vdW50ZWQgb24gdGhlIHBhZ2UuXG5cbiAgICAgICAgcmVzdWx0cy5oaXRzLl9fZXNjYXBlZCA9IGluaXRpYWxFc2NhcGVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhpdHM6IHJlc3VsdHMuaGl0cyxcbiAgICAgICAgICByZXN1bHRzOiByZXN1bHRzLFxuICAgICAgICAgIHNlbmRFdmVudDogc2VuZEV2ZW50LFxuICAgICAgICAgIGJpbmRFdmVudDogYmluZEV2ZW50LFxuICAgICAgICAgIHdpZGdldFBhcmFtczogd2lkZ2V0UGFyYW1zXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gZGlzcG9zZShfcmVmMykge1xuICAgICAgICB2YXIgc3RhdGUgPSBfcmVmMy5zdGF0ZTtcbiAgICAgICAgdW5tb3VudEZuKCk7XG5cbiAgICAgICAgaWYgKCFlc2NhcGVIVE1MKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlLnNldFF1ZXJ5UGFyYW1ldGVycyhPYmplY3Qua2V5cyhUQUdfUExBQ0VIT0xERVIpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBhY2MpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHVuZGVmaW5lZCkpO1xuICAgICAgICB9LCB7fSkpO1xuICAgICAgfSxcbiAgICAgIGdldFdpZGdldFNlYXJjaFBhcmFtZXRlcnM6IGZ1bmN0aW9uIGdldFdpZGdldFNlYXJjaFBhcmFtZXRlcnMoc3RhdGUpIHtcbiAgICAgICAgaWYgKCFlc2NhcGVIVE1MKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlLnNldFF1ZXJ5UGFyYW1ldGVycyhUQUdfUExBQ0VIT0xERVIpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0SGl0czsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcblxudmFyIFBhZ2luYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhZ2luYXRvcihwYXJhbXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFnaW5hdG9yKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImN1cnJlbnRQYWdlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3RhbFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhcmFtcy5jdXJyZW50UGFnZTtcbiAgICB0aGlzLnRvdGFsID0gcGFyYW1zLnRvdGFsO1xuICAgIHRoaXMucGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhZ2luYXRvciwgW3tcbiAgICBrZXk6IFwicGFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZXMoKSB7XG4gICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsLFxuICAgICAgICAgIGN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZSxcbiAgICAgICAgICBwYWRkaW5nID0gdGhpcy5wYWRkaW5nO1xuICAgICAgaWYgKHRvdGFsID09PSAwKSByZXR1cm4gWzBdO1xuICAgICAgdmFyIHRvdGFsRGlzcGxheWVkUGFnZXMgPSB0aGlzLm5iUGFnZXNEaXNwbGF5ZWQocGFkZGluZywgdG90YWwpO1xuXG4gICAgICBpZiAodG90YWxEaXNwbGF5ZWRQYWdlcyA9PT0gdG90YWwpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlKHtcbiAgICAgICAgICBlbmQ6IHRvdGFsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFkZGluZ0xlZnQgPSB0aGlzLmNhbGN1bGF0ZVBhZGRpbmdMZWZ0KGN1cnJlbnRQYWdlLCBwYWRkaW5nLCB0b3RhbCwgdG90YWxEaXNwbGF5ZWRQYWdlcyk7XG4gICAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gdG90YWxEaXNwbGF5ZWRQYWdlcyAtIHBhZGRpbmdMZWZ0O1xuICAgICAgdmFyIGZpcnN0ID0gY3VycmVudFBhZ2UgLSBwYWRkaW5nTGVmdDtcbiAgICAgIHZhciBsYXN0ID0gY3VycmVudFBhZ2UgKyBwYWRkaW5nUmlnaHQ7XG4gICAgICByZXR1cm4gcmFuZ2Uoe1xuICAgICAgICBzdGFydDogZmlyc3QsXG4gICAgICAgIGVuZDogbGFzdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5iUGFnZXNEaXNwbGF5ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmJQYWdlc0Rpc3BsYXllZChwYWRkaW5nLCB0b3RhbCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKDIgKiBwYWRkaW5nICsgMSwgdG90YWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVQYWRkaW5nTGVmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVQYWRkaW5nTGVmdChjdXJyZW50LCBwYWRkaW5nLCB0b3RhbCwgdG90YWxEaXNwbGF5ZWRQYWdlcykge1xuICAgICAgaWYgKGN1cnJlbnQgPD0gcGFkZGluZykge1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQgPj0gdG90YWwgLSBwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiB0b3RhbERpc3BsYXllZFBhZ2VzIC0gKHRvdGFsIC0gY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYWRkaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0xhc3RQYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTGFzdFBhZ2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFnZSA9PT0gdGhpcy50b3RhbCAtIDEgfHwgdGhpcy50b3RhbCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGaXJzdFBhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXJzdFBhZ2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFnZSA9PT0gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFnaW5hdG9yO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBQYWdpbmF0b3I7IiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IGNoZWNrUmVuZGVyaW5nLCBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvciwgbm9vcCB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgUGFnaW5hdG9yIGZyb20gJy4vUGFnaW5hdG9yJztcbnZhciB3aXRoVXNhZ2UgPSBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvcih7XG4gIG5hbWU6ICdwYWdpbmF0aW9uJyxcbiAgY29ubmVjdG9yOiB0cnVlXG59KTtcblxuLyoqXG4gKiAqKlBhZ2luYXRpb24qKiBjb25uZWN0b3IgcHJvdmlkZXMgdGhlIGxvZ2ljIHRvIGJ1aWxkIGEgd2lkZ2V0IHRoYXQgd2lsbCBsZXQgdGhlIHVzZXJcbiAqIGNob29zZSB0aGUgY3VycmVudCBwYWdlIG9mIHRoZSByZXN1bHRzLlxuICpcbiAqIFdoZW4gdXNpbmcgdGhlIHBhZ2luYXRpb24gd2l0aCBBbGdvbGlhLCB5b3Ugc2hvdWxkIGJlIGF3YXJlIHRoYXQgdGhlIGVuZ2luZSB3b24ndCBwcm92aWRlIHlvdSBwYWdlc1xuICogYmV5b25kIHRoZSAxMDAwdGggaGl0cyBieSBkZWZhdWx0LiBZb3UgY2FuIGZpbmQgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgW0FsZ29saWEgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9zZWFyY2hpbmcvcGFnaW5hdGlvbi8jcGFnaW5hdGlvbi1saW1pdGF0aW9ucykuXG4gKi9cbnZhciBjb25uZWN0UGFnaW5hdGlvbiA9IGZ1bmN0aW9uIGNvbm5lY3RQYWdpbmF0aW9uKHJlbmRlckZuKSB7XG4gIHZhciB1bm1vdW50Rm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gIGNoZWNrUmVuZGVyaW5nKHJlbmRlckZuLCB3aXRoVXNhZ2UoKSk7XG4gIHJldHVybiBmdW5jdGlvbiAod2lkZ2V0UGFyYW1zKSB7XG4gICAgdmFyIF9yZWYgPSB3aWRnZXRQYXJhbXMgfHwge30sXG4gICAgICAgIHRvdGFsUGFnZXMgPSBfcmVmLnRvdGFsUGFnZXMsXG4gICAgICAgIF9yZWYkcGFkZGluZyA9IF9yZWYucGFkZGluZyxcbiAgICAgICAgcGFkZGluZyA9IF9yZWYkcGFkZGluZyA9PT0gdm9pZCAwID8gMyA6IF9yZWYkcGFkZGluZztcblxuICAgIHZhciBwYWdlciA9IG5ldyBQYWdpbmF0b3Ioe1xuICAgICAgY3VycmVudFBhZ2U6IDAsXG4gICAgICB0b3RhbDogMCxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgY29ubmVjdG9yU3RhdGUgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldE1heFBhZ2UoX3JlZjIpIHtcbiAgICAgIHZhciBuYlBhZ2VzID0gX3JlZjIubmJQYWdlcztcbiAgICAgIHJldHVybiB0b3RhbFBhZ2VzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1pbih0b3RhbFBhZ2VzLCBuYlBhZ2VzKSA6IG5iUGFnZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICQkdHlwZTogJ2Fpcy5wYWdpbmF0aW9uJyxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoaW5pdE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGluc3RhbnRTZWFyY2hJbnN0YW5jZSA9IGluaXRPcHRpb25zLmluc3RhbnRTZWFyY2hJbnN0YW5jZTtcbiAgICAgICAgcmVuZGVyRm4oX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmdldFdpZGdldFJlbmRlclN0YXRlKGluaXRPcHRpb25zKSksIHt9LCB7XG4gICAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBpbnN0YW50U2VhcmNoSW5zdGFuY2VcbiAgICAgICAgfSksIHRydWUpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGluc3RhbnRTZWFyY2hJbnN0YW5jZSA9IHJlbmRlck9wdGlvbnMuaW5zdGFudFNlYXJjaEluc3RhbmNlO1xuICAgICAgICByZW5kZXJGbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuZ2V0V2lkZ2V0UmVuZGVyU3RhdGUocmVuZGVyT3B0aW9ucykpLCB7fSwge1xuICAgICAgICAgIGluc3RhbnRTZWFyY2hJbnN0YW5jZTogaW5zdGFudFNlYXJjaEluc3RhbmNlXG4gICAgICAgIH0pLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gZGlzcG9zZShfcmVmMykge1xuICAgICAgICB2YXIgc3RhdGUgPSBfcmVmMy5zdGF0ZTtcbiAgICAgICAgdW5tb3VudEZuKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5zZXRRdWVyeVBhcmFtZXRlcigncGFnZScsIHVuZGVmaW5lZCk7XG4gICAgICB9LFxuICAgICAgZ2V0V2lkZ2V0VWlTdGF0ZTogZnVuY3Rpb24gZ2V0V2lkZ2V0VWlTdGF0ZSh1aVN0YXRlLCBfcmVmNCkge1xuICAgICAgICB2YXIgc2VhcmNoUGFyYW1ldGVycyA9IF9yZWY0LnNlYXJjaFBhcmFtZXRlcnM7XG4gICAgICAgIHZhciBwYWdlID0gc2VhcmNoUGFyYW1ldGVycy5wYWdlIHx8IDA7XG5cbiAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgcmV0dXJuIHVpU3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB1aVN0YXRlKSwge30sIHtcbiAgICAgICAgICBwYWdlOiBwYWdlICsgMVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRXaWRnZXRTZWFyY2hQYXJhbWV0ZXJzOiBmdW5jdGlvbiBnZXRXaWRnZXRTZWFyY2hQYXJhbWV0ZXJzKHNlYXJjaFBhcmFtZXRlcnMsIF9yZWY1KSB7XG4gICAgICAgIHZhciB1aVN0YXRlID0gX3JlZjUudWlTdGF0ZTtcbiAgICAgICAgdmFyIHBhZ2UgPSB1aVN0YXRlLnBhZ2UgPyB1aVN0YXRlLnBhZ2UgLSAxIDogMDtcbiAgICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtZXRlcnMuc2V0UXVlcnlQYXJhbWV0ZXIoJ3BhZ2UnLCBwYWdlKTtcbiAgICAgIH0sXG4gICAgICBnZXRXaWRnZXRSZW5kZXJTdGF0ZTogZnVuY3Rpb24gZ2V0V2lkZ2V0UmVuZGVyU3RhdGUoX3JlZjYpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBfcmVmNi5yZXN1bHRzLFxuICAgICAgICAgICAgaGVscGVyID0gX3JlZjYuaGVscGVyLFxuICAgICAgICAgICAgY3JlYXRlVVJMID0gX3JlZjYuY3JlYXRlVVJMO1xuXG4gICAgICAgIGlmICghY29ubmVjdG9yU3RhdGUucmVmaW5lKSB7XG4gICAgICAgICAgY29ubmVjdG9yU3RhdGUucmVmaW5lID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgICAgICAgIGhlbHBlci5zZXRQYWdlKHBhZ2UpO1xuICAgICAgICAgICAgaGVscGVyLnNlYXJjaCgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbm5lY3RvclN0YXRlLmNyZWF0ZVVSTCkge1xuICAgICAgICAgIGNvbm5lY3RvclN0YXRlLmNyZWF0ZVVSTCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVUkwoc3RhdGUuc2V0UGFnZShwYWdlKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhdGUgPSBoZWxwZXIuc3RhdGU7XG4gICAgICAgIHZhciBwYWdlID0gc3RhdGUucGFnZSB8fCAwO1xuICAgICAgICB2YXIgbmJQYWdlcyA9IGdldE1heFBhZ2UocmVzdWx0cyB8fCB7XG4gICAgICAgICAgbmJQYWdlczogMFxuICAgICAgICB9KTtcbiAgICAgICAgcGFnZXIuY3VycmVudFBhZ2UgPSBwYWdlO1xuICAgICAgICBwYWdlci50b3RhbCA9IG5iUGFnZXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3JlYXRlVVJMOiBjb25uZWN0b3JTdGF0ZS5jcmVhdGVVUkwoc3RhdGUpLFxuICAgICAgICAgIHJlZmluZTogY29ubmVjdG9yU3RhdGUucmVmaW5lLFxuICAgICAgICAgIGNhblJlZmluZTogbmJQYWdlcyA+IDEsXG4gICAgICAgICAgY3VycmVudFJlZmluZW1lbnQ6IHBhZ2UsXG4gICAgICAgICAgbmJIaXRzOiAocmVzdWx0cyA9PT0gbnVsbCB8fCByZXN1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHRzLm5iSGl0cykgfHwgMCxcbiAgICAgICAgICBuYlBhZ2VzOiBuYlBhZ2VzLFxuICAgICAgICAgIHBhZ2VzOiByZXN1bHRzID8gcGFnZXIucGFnZXMoKSA6IFtdLFxuICAgICAgICAgIGlzRmlyc3RQYWdlOiBwYWdlci5pc0ZpcnN0UGFnZSgpLFxuICAgICAgICAgIGlzTGFzdFBhZ2U6IHBhZ2VyLmlzTGFzdFBhZ2UoKSxcbiAgICAgICAgICB3aWRnZXRQYXJhbXM6IHdpZGdldFBhcmFtc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdldFJlbmRlclN0YXRlOiBmdW5jdGlvbiBnZXRSZW5kZXJTdGF0ZShyZW5kZXJTdGF0ZSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZW5kZXJTdGF0ZSksIHt9LCB7XG4gICAgICAgICAgcGFnaW5hdGlvbjogdGhpcy5nZXRXaWRnZXRSZW5kZXJTdGF0ZShyZW5kZXJPcHRpb25zKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdFBhZ2luYXRpb247IiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IGNoZWNrUmVuZGVyaW5nLCBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvciwgbm9vcCB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG52YXIgd2l0aFVzYWdlID0gY3JlYXRlRG9jdW1lbnRhdGlvbk1lc3NhZ2VHZW5lcmF0b3Ioe1xuICBuYW1lOiAnc2VhcmNoLWJveCcsXG4gIGNvbm5lY3RvcjogdHJ1ZVxufSk7XG5cbi8qKlxuICogKipTZWFyY2hCb3gqKiBjb25uZWN0b3IgcHJvdmlkZXMgdGhlIGxvZ2ljIHRvIGJ1aWxkIGEgd2lkZ2V0IHRoYXQgd2lsbCBsZXQgdGhlIHVzZXIgc2VhcmNoIGZvciBhIHF1ZXJ5LlxuICpcbiAqIFRoZSBjb25uZWN0b3IgcHJvdmlkZXMgdG8gdGhlIHJlbmRlcmluZzogYHJlZmluZSgpYCB0byBzZXQgdGhlIHF1ZXJ5LiBUaGUgYmVoYXZpb3VyIG9mIHRoaXMgZnVuY3Rpb25cbiAqIG1heSBiZSBpbXBhY3RlZCBieSB0aGUgYHF1ZXJ5SG9va2Agd2lkZ2V0IHBhcmFtZXRlci5cbiAqL1xudmFyIGNvbm5lY3RTZWFyY2hCb3ggPSBmdW5jdGlvbiBjb25uZWN0U2VhcmNoQm94KHJlbmRlckZuKSB7XG4gIHZhciB1bm1vdW50Rm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gIGNoZWNrUmVuZGVyaW5nKHJlbmRlckZuLCB3aXRoVXNhZ2UoKSk7XG4gIHJldHVybiBmdW5jdGlvbiAod2lkZ2V0UGFyYW1zKSB7XG4gICAgdmFyIF9yZWYgPSB3aWRnZXRQYXJhbXMgfHwge30sXG4gICAgICAgIHF1ZXJ5SG9vayA9IF9yZWYucXVlcnlIb29rO1xuXG4gICAgZnVuY3Rpb24gY2xlYXIoaGVscGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBoZWxwZXIuc2V0UXVlcnkoJycpLnNlYXJjaCgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgX3JlZmluZTtcblxuICAgIHZhciBfY2xlYXIgPSBmdW5jdGlvbiBfY2xlYXIoKSB7fTtcblxuICAgIGZ1bmN0aW9uIF9jYWNoZWRDbGVhcigpIHtcbiAgICAgIF9jbGVhcigpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGU6ICdhaXMuc2VhcmNoQm94JyxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoaW5pdE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGluc3RhbnRTZWFyY2hJbnN0YW5jZSA9IGluaXRPcHRpb25zLmluc3RhbnRTZWFyY2hJbnN0YW5jZTtcbiAgICAgICAgcmVuZGVyRm4oX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmdldFdpZGdldFJlbmRlclN0YXRlKGluaXRPcHRpb25zKSksIHt9LCB7XG4gICAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBpbnN0YW50U2VhcmNoSW5zdGFuY2VcbiAgICAgICAgfSksIHRydWUpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGluc3RhbnRTZWFyY2hJbnN0YW5jZSA9IHJlbmRlck9wdGlvbnMuaW5zdGFudFNlYXJjaEluc3RhbmNlO1xuICAgICAgICByZW5kZXJGbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuZ2V0V2lkZ2V0UmVuZGVyU3RhdGUocmVuZGVyT3B0aW9ucykpLCB7fSwge1xuICAgICAgICAgIGluc3RhbnRTZWFyY2hJbnN0YW5jZTogaW5zdGFudFNlYXJjaEluc3RhbmNlXG4gICAgICAgIH0pLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGlzcG9zZTogZnVuY3Rpb24gZGlzcG9zZShfcmVmMikge1xuICAgICAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgICAgICAgdW5tb3VudEZuKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5zZXRRdWVyeVBhcmFtZXRlcigncXVlcnknLCB1bmRlZmluZWQpO1xuICAgICAgfSxcbiAgICAgIGdldFJlbmRlclN0YXRlOiBmdW5jdGlvbiBnZXRSZW5kZXJTdGF0ZShyZW5kZXJTdGF0ZSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZW5kZXJTdGF0ZSksIHt9LCB7XG4gICAgICAgICAgc2VhcmNoQm94OiB0aGlzLmdldFdpZGdldFJlbmRlclN0YXRlKHJlbmRlck9wdGlvbnMpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldFdpZGdldFJlbmRlclN0YXRlOiBmdW5jdGlvbiBnZXRXaWRnZXRSZW5kZXJTdGF0ZShfcmVmMykge1xuICAgICAgICB2YXIgaGVscGVyID0gX3JlZjMuaGVscGVyLFxuICAgICAgICAgICAgc2VhcmNoTWV0YWRhdGEgPSBfcmVmMy5zZWFyY2hNZXRhZGF0YTtcblxuICAgICAgICBpZiAoIV9yZWZpbmUpIHtcbiAgICAgICAgICB2YXIgc2V0UXVlcnlBbmRTZWFyY2ggPSBmdW5jdGlvbiBzZXRRdWVyeUFuZFNlYXJjaChxdWVyeSkge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5ICE9PSBoZWxwZXIuc3RhdGUucXVlcnkpIHtcbiAgICAgICAgICAgICAgaGVscGVyLnNldFF1ZXJ5KHF1ZXJ5KS5zZWFyY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3JlZmluZSA9IGZ1bmN0aW9uIF9yZWZpbmUocXVlcnkpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeUhvb2spIHtcbiAgICAgICAgICAgICAgcXVlcnlIb29rKHF1ZXJ5LCBzZXRRdWVyeUFuZFNlYXJjaCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0UXVlcnlBbmRTZWFyY2gocXVlcnkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBfY2xlYXIgPSBjbGVhcihoZWxwZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHF1ZXJ5OiBoZWxwZXIuc3RhdGUucXVlcnkgfHwgJycsXG4gICAgICAgICAgcmVmaW5lOiBfcmVmaW5lLFxuICAgICAgICAgIGNsZWFyOiBfY2FjaGVkQ2xlYXIsXG4gICAgICAgICAgd2lkZ2V0UGFyYW1zOiB3aWRnZXRQYXJhbXMsXG4gICAgICAgICAgaXNTZWFyY2hTdGFsbGVkOiBzZWFyY2hNZXRhZGF0YS5pc1NlYXJjaFN0YWxsZWRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRXaWRnZXRVaVN0YXRlOiBmdW5jdGlvbiBnZXRXaWRnZXRVaVN0YXRlKHVpU3RhdGUsIF9yZWY0KSB7XG4gICAgICAgIHZhciBzZWFyY2hQYXJhbWV0ZXJzID0gX3JlZjQuc2VhcmNoUGFyYW1ldGVycztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gc2VhcmNoUGFyYW1ldGVycy5xdWVyeSB8fCAnJztcblxuICAgICAgICBpZiAocXVlcnkgPT09ICcnIHx8IHVpU3RhdGUgJiYgdWlTdGF0ZS5xdWVyeSA9PT0gcXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gdWlTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHVpU3RhdGUpLCB7fSwge1xuICAgICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRXaWRnZXRTZWFyY2hQYXJhbWV0ZXJzOiBmdW5jdGlvbiBnZXRXaWRnZXRTZWFyY2hQYXJhbWV0ZXJzKHNlYXJjaFBhcmFtZXRlcnMsIF9yZWY1KSB7XG4gICAgICAgIHZhciB1aVN0YXRlID0gX3JlZjUudWlTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtZXRlcnMuc2V0UXVlcnlQYXJhbWV0ZXIoJ3F1ZXJ5JywgdWlTdGF0ZS5xdWVyeSB8fCAnJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RTZWFyY2hCb3g7IiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IGNoZWNrUmVuZGVyaW5nLCBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvciwgbm9vcCB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG52YXIgd2l0aFVzYWdlID0gY3JlYXRlRG9jdW1lbnRhdGlvbk1lc3NhZ2VHZW5lcmF0b3Ioe1xuICBuYW1lOiAnc3RhdHMnLFxuICBjb25uZWN0b3I6IHRydWVcbn0pO1xuLyoqXG4gKiAqKlN0YXRzKiogY29ubmVjdG9yIHByb3ZpZGVzIHRoZSBsb2dpYyB0byBidWlsZCBhIGN1c3RvbSB3aWRnZXQgdGhhdCB3aWxsIGRpc3BsYXlzXG4gKiBzZWFyY2ggc3RhdGlzdGljcyAoaGl0cyBudW1iZXIgYW5kIHByb2Nlc3NpbmcgdGltZSkuXG4gKi9cblxudmFyIGNvbm5lY3RTdGF0cyA9IGZ1bmN0aW9uIGNvbm5lY3RTdGF0cyhyZW5kZXJGbikge1xuICB2YXIgdW5tb3VudEZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICBjaGVja1JlbmRlcmluZyhyZW5kZXJGbiwgd2l0aFVzYWdlKCkpO1xuICByZXR1cm4gZnVuY3Rpb24gKHdpZGdldFBhcmFtcykge1xuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGU6ICdhaXMuc3RhdHMnLFxuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdChpbml0T3B0aW9ucykge1xuICAgICAgICB2YXIgaW5zdGFudFNlYXJjaEluc3RhbmNlID0gaW5pdE9wdGlvbnMuaW5zdGFudFNlYXJjaEluc3RhbmNlO1xuICAgICAgICByZW5kZXJGbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuZ2V0V2lkZ2V0UmVuZGVyU3RhdGUoaW5pdE9wdGlvbnMpKSwge30sIHtcbiAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGluc3RhbnRTZWFyY2hJbnN0YW5jZVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyT3B0aW9ucykge1xuICAgICAgICB2YXIgaW5zdGFudFNlYXJjaEluc3RhbmNlID0gcmVuZGVyT3B0aW9ucy5pbnN0YW50U2VhcmNoSW5zdGFuY2U7XG4gICAgICAgIHJlbmRlckZuKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5nZXRXaWRnZXRSZW5kZXJTdGF0ZShyZW5kZXJPcHRpb25zKSksIHt9LCB7XG4gICAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBpbnN0YW50U2VhcmNoSW5zdGFuY2VcbiAgICAgICAgfSksIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICB1bm1vdW50Rm4oKTtcbiAgICAgIH0sXG4gICAgICBnZXRSZW5kZXJTdGF0ZTogZnVuY3Rpb24gZ2V0UmVuZGVyU3RhdGUocmVuZGVyU3RhdGUsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVuZGVyU3RhdGUpLCB7fSwge1xuICAgICAgICAgIHN0YXRzOiB0aGlzLmdldFdpZGdldFJlbmRlclN0YXRlKHJlbmRlck9wdGlvbnMpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldFdpZGdldFJlbmRlclN0YXRlOiBmdW5jdGlvbiBnZXRXaWRnZXRSZW5kZXJTdGF0ZShfcmVmKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gX3JlZi5yZXN1bHRzLFxuICAgICAgICAgICAgaGVscGVyID0gX3JlZi5oZWxwZXI7XG5cbiAgICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhpdHNQZXJQYWdlOiBoZWxwZXIuc3RhdGUuaGl0c1BlclBhZ2UsXG4gICAgICAgICAgICBuYkhpdHM6IDAsXG4gICAgICAgICAgICBuYlNvcnRlZEhpdHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZUhpdHNTb3J0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbmJQYWdlczogMCxcbiAgICAgICAgICAgIHBhZ2U6IGhlbHBlci5zdGF0ZS5wYWdlIHx8IDAsXG4gICAgICAgICAgICBwcm9jZXNzaW5nVGltZU1TOiAtMSxcbiAgICAgICAgICAgIHF1ZXJ5OiBoZWxwZXIuc3RhdGUucXVlcnkgfHwgJycsXG4gICAgICAgICAgICB3aWRnZXRQYXJhbXM6IHdpZGdldFBhcmFtc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhpdHNQZXJQYWdlOiByZXN1bHRzLmhpdHNQZXJQYWdlLFxuICAgICAgICAgIG5iSGl0czogcmVzdWx0cy5uYkhpdHMsXG4gICAgICAgICAgbmJTb3J0ZWRIaXRzOiByZXN1bHRzLm5iU29ydGVkSGl0cyxcbiAgICAgICAgICBhcmVIaXRzU29ydGVkOiB0eXBlb2YgcmVzdWx0cy5hcHBsaWVkUmVsZXZhbmN5U3RyaWN0bmVzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVzdWx0cy5hcHBsaWVkUmVsZXZhbmN5U3RyaWN0bmVzcyA+IDAgJiYgcmVzdWx0cy5uYlNvcnRlZEhpdHMgIT09IHJlc3VsdHMubmJIaXRzLFxuICAgICAgICAgIG5iUGFnZXM6IHJlc3VsdHMubmJQYWdlcyxcbiAgICAgICAgICBwYWdlOiByZXN1bHRzLnBhZ2UsXG4gICAgICAgICAgcHJvY2Vzc2luZ1RpbWVNUzogcmVzdWx0cy5wcm9jZXNzaW5nVGltZU1TLFxuICAgICAgICAgIHF1ZXJ5OiByZXN1bHRzLnF1ZXJ5LFxuICAgICAgICAgIHdpZGdldFBhcmFtczogd2lkZ2V0UGFyYW1zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RTdGF0czsiLCJpbXBvcnQgeyB3YXJuaW5nIH0gZnJvbSAnLi4vbGliL3V0aWxzJztcbmV4cG9ydCB2YXIgQU5PTllNT1VTX1RPS0VOX0NPT0tJRV9LRVkgPSAnX0FMR09MSUEnO1xuXG5mdW5jdGlvbiBnZXRDb29raWUobmFtZSkge1xuICB2YXIgcHJlZml4ID0gXCJcIi5jb25jYXQobmFtZSwgXCI9XCIpO1xuICB2YXIgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29va2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb29raWUgPSBjb29raWVzW2ldO1xuXG4gICAgd2hpbGUgKGNvb2tpZS5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgY29va2llID0gY29va2llLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBpZiAoY29va2llLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvb2tpZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCwgY29va2llLmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluc2lnaHRzQW5vbnltb3VzVXNlclRva2VuSW50ZXJuYWwoKSB7XG4gIHJldHVybiBnZXRDb29raWUoQU5PTllNT1VTX1RPS0VOX0NPT0tJRV9LRVkpO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgc3RpbGwgc3VwcG9ydGVkIGluIDQueCByZWxlYXNlcywgYnV0IG5vdCBmdXJ0aGVyLiBJdCBpcyByZXBsYWNlZCBieSB0aGUgYGluc2lnaHRzYCBtaWRkbGV3YXJlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9nZXR0aW5nLWluc2lnaHRzLWFuZC1hbmFseXRpY3Mvc2VhcmNoLWFuYWx5dGljcy9jbGljay10aHJvdWdoLWFuZC1jb252ZXJzaW9ucy9ob3ctdG8vc2VuZC1jbGljay1hbmQtY29udmVyc2lvbi1ldmVudHMtd2l0aC1pbnN0YW50c2VhcmNoL2pzL1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEluc2lnaHRzQW5vbnltb3VzVXNlclRva2VuKCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHdhcm5pbmcoZmFsc2UsIFwiYGdldEluc2lnaHRzQW5vbnltb3VzVXNlclRva2VuYCBmdW5jdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBJdCBpcyBzdGlsbCBzdXBwb3J0ZWQgaW4gNC54IHJlbGVhc2VzLCBidXQgbm90IGZ1cnRoZXIuIEl0IGlzIHJlcGxhY2VkIGJ5IHRoZSBgaW5zaWdodHNgIG1pZGRsZXdhcmUuXFxuXFxuRm9yIG1vcmUgaW5mb3JtYXRpb24sIHZpc2l0IGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9ndWlkZXMvZ2V0dGluZy1pbnNpZ2h0cy1hbmQtYW5hbHl0aWNzL3NlYXJjaC1hbmFseXRpY3MvY2xpY2stdGhyb3VnaC1hbmQtY29udmVyc2lvbnMvaG93LXRvL3NlbmQtY2xpY2stYW5kLWNvbnZlcnNpb24tZXZlbnRzLXdpdGgtaW5zdGFudHNlYXJjaC9qcy9cIikgOiB2b2lkIDA7XG4gIHJldHVybiBnZXRJbnNpZ2h0c0Fub255bW91c1VzZXJUb2tlbkludGVybmFsKCk7XG59IiwiaW1wb3J0IHsgY29tcG9uZW50IH0gZnJvbSAnLi4vbGliL3N1aXQnO1xuaW1wb3J0IHsgZ2V0UHJvcGVydHlCeVBhdGgsIFRBR19SRVBMQUNFTUVOVCB9IGZyb20gJy4uL2xpYi91dGlscyc7XG52YXIgc3VpdCA9IGNvbXBvbmVudCgnSGlnaGxpZ2h0Jyk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoaWdobGlnaHQoX3JlZikge1xuICB2YXIgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGUsXG4gICAgICBfcmVmJGhpZ2hsaWdodGVkVGFnTmEgPSBfcmVmLmhpZ2hsaWdodGVkVGFnTmFtZSxcbiAgICAgIGhpZ2hsaWdodGVkVGFnTmFtZSA9IF9yZWYkaGlnaGxpZ2h0ZWRUYWdOYSA9PT0gdm9pZCAwID8gJ21hcmsnIDogX3JlZiRoaWdobGlnaHRlZFRhZ05hLFxuICAgICAgaGl0ID0gX3JlZi5oaXQsXG4gICAgICBfcmVmJGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICBjc3NDbGFzc2VzID0gX3JlZiRjc3NDbGFzc2VzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkY3NzQ2xhc3NlcztcblxuICB2YXIgX3JlZjIgPSBnZXRQcm9wZXJ0eUJ5UGF0aChoaXQuX2hpZ2hsaWdodFJlc3VsdCwgYXR0cmlidXRlKSB8fCB7fSxcbiAgICAgIF9yZWYyJHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9IF9yZWYyJHZhbHVlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYyJHZhbHVlOyAvLyBjeCBpcyBub3QgdXNlZCwgc2luY2UgaXQgd291bGQgYmUgYnVuZGxlZCBhcyBhIGRlcGVuZGVuY3kgZm9yIFZ1ZSAmIEFuZ3VsYXJcblxuXG4gIHZhciBjbGFzc05hbWUgPSBzdWl0KHtcbiAgICBkZXNjZW5kYW50TmFtZTogJ2hpZ2hsaWdodGVkJ1xuICB9KSArIChjc3NDbGFzc2VzLmhpZ2hsaWdodGVkID8gXCIgXCIuY29uY2F0KGNzc0NsYXNzZXMuaGlnaGxpZ2h0ZWQpIDogJycpO1xuICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKFRBR19SRVBMQUNFTUVOVC5oaWdobGlnaHRQcmVUYWcsICdnJyksIFwiPFwiLmNvbmNhdChoaWdobGlnaHRlZFRhZ05hbWUsIFwiIGNsYXNzPVxcXCJcIikuY29uY2F0KGNsYXNzTmFtZSwgXCJcXFwiPlwiKSkucmVwbGFjZShuZXcgUmVnRXhwKFRBR19SRVBMQUNFTUVOVC5oaWdobGlnaHRQb3N0VGFnLCAnZycpLCBcIjwvXCIuY29uY2F0KGhpZ2hsaWdodGVkVGFnTmFtZSwgXCI+XCIpKTtcbn0iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmltcG9ydCB7IHdhcm5pbmcsIHNlcmlhbGl6ZVBheWxvYWQsIGRlc2VyaWFsaXplUGF5bG9hZCB9IGZyb20gJy4uL2xpYi91dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gcmVhZERhdGFBdHRyaWJ1dGVzKGRvbUVsZW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluc2lnaHRzLW1ldGhvZCcpO1xuICB2YXIgc2VyaWFsaXplZFBheWxvYWQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pbnNpZ2h0cy1wYXlsb2FkJyk7XG5cbiAgaWYgKHR5cGVvZiBzZXJpYWxpemVkUGF5bG9hZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbnNpZ2h0cyBoZWxwZXIgZXhwZWN0cyBgZGF0YS1pbnNpZ2h0cy1wYXlsb2FkYCB0byBiZSBhIGJhc2U2NC1lbmNvZGVkIEpTT04gc3RyaW5nLicpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgcGF5bG9hZCA9IGRlc2VyaWFsaXplUGF5bG9hZChzZXJpYWxpemVkUGF5bG9hZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5zaWdodHMgaGVscGVyIHdhcyB1bmFibGUgdG8gcGFyc2UgYGRhdGEtaW5zaWdodHMtcGF5bG9hZGAuJyk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNEYXRhQXR0cmlidXRlcyhkb21FbGVtZW50KSB7XG4gIHJldHVybiBkb21FbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1pbnNpZ2h0cy1tZXRob2QnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZURhdGFBdHRyaWJ1dGVzKF9yZWYpIHtcbiAgdmFyIG1ldGhvZCA9IF9yZWYubWV0aG9kLFxuICAgICAgcGF5bG9hZCA9IF9yZWYucGF5bG9hZDtcblxuICBpZiAoX3R5cGVvZihwYXlsb2FkKSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaW5zaWdodHMgaGVscGVyIGV4cGVjdHMgdGhlIHBheWxvYWQgdG8gYmUgYW4gb2JqZWN0LlwiKTtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGF5bG9hZDtcblxuICB0cnkge1xuICAgIHNlcmlhbGl6ZWRQYXlsb2FkID0gc2VyaWFsaXplUGF5bG9hZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgSlNPTiBzZXJpYWxpemUgdGhlIHBheWxvYWQgb2JqZWN0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBcImRhdGEtaW5zaWdodHMtbWV0aG9kPVxcXCJcIi5jb25jYXQobWV0aG9kLCBcIlxcXCIgZGF0YS1pbnNpZ2h0cy1wYXlsb2FkPVxcXCJcIikuY29uY2F0KHNlcmlhbGl6ZWRQYXlsb2FkLCBcIlxcXCJcIik7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdGlsbCBzdXBwb3J0ZWQgaW4gNC54IHJlbGVhc2VzLCBidXQgbm90IGZ1cnRoZXIuIEl0IGlzIHJlcGxhY2VkIGJ5IHRoZSBgaW5zaWdodHNgIG1pZGRsZXdhcmUuIEZvciBtb3JlIGluZm9ybWF0aW9uLCB2aXNpdCBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvZ3VpZGVzL2dldHRpbmctaW5zaWdodHMtYW5kLWFuYWx5dGljcy9zZWFyY2gtYW5hbHl0aWNzL2NsaWNrLXRocm91Z2gtYW5kLWNvbnZlcnNpb25zL2hvdy10by9zZW5kLWNsaWNrLWFuZC1jb252ZXJzaW9uLWV2ZW50cy13aXRoLWluc3RhbnRzZWFyY2gvanMvXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5zaWdodHMobWV0aG9kLCBwYXlsb2FkKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gd2FybmluZyhmYWxzZSwgXCJgaW5zaWdodHNgIGZ1bmN0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIEl0IGlzIHN0aWxsIHN1cHBvcnRlZCBpbiA0LnggcmVsZWFzZXMsIGJ1dCBub3QgZnVydGhlci4gSXQgaXMgcmVwbGFjZWQgYnkgdGhlIGBpbnNpZ2h0c2AgbWlkZGxld2FyZS5cXG5cXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9nZXR0aW5nLWluc2lnaHRzLWFuZC1hbmFseXRpY3Mvc2VhcmNoLWFuYWx5dGljcy9jbGljay10aHJvdWdoLWFuZC1jb252ZXJzaW9ucy9ob3ctdG8vc2VuZC1jbGljay1hbmQtY29udmVyc2lvbi1ldmVudHMtd2l0aC1pbnN0YW50c2VhcmNoL2pzL1wiKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHdyaXRlRGF0YUF0dHJpYnV0ZXMoe1xuICAgIG1ldGhvZDogbWV0aG9kLFxuICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgfSk7XG59IiwiaW1wb3J0IHsgVEFHX1JFUExBQ0VNRU5ULCBnZXRQcm9wZXJ0eUJ5UGF0aCwgZ2V0SGlnaGxpZ2h0ZWRQYXJ0cywgcmV2ZXJzZUhpZ2hsaWdodGVkUGFydHMsIGNvbmNhdEhpZ2hsaWdodGVkUGFydHMgfSBmcm9tICcuLi9saWIvdXRpbHMnO1xuaW1wb3J0IHsgY29tcG9uZW50IH0gZnJvbSAnLi4vbGliL3N1aXQnO1xudmFyIHN1aXQgPSBjb21wb25lbnQoJ1JldmVyc2VIaWdobGlnaHQnKTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJldmVyc2VIaWdobGlnaHQoX3JlZikge1xuICB2YXIgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGUsXG4gICAgICBfcmVmJGhpZ2hsaWdodGVkVGFnTmEgPSBfcmVmLmhpZ2hsaWdodGVkVGFnTmFtZSxcbiAgICAgIGhpZ2hsaWdodGVkVGFnTmFtZSA9IF9yZWYkaGlnaGxpZ2h0ZWRUYWdOYSA9PT0gdm9pZCAwID8gJ21hcmsnIDogX3JlZiRoaWdobGlnaHRlZFRhZ05hLFxuICAgICAgaGl0ID0gX3JlZi5oaXQsXG4gICAgICBfcmVmJGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICBjc3NDbGFzc2VzID0gX3JlZiRjc3NDbGFzc2VzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkY3NzQ2xhc3NlcztcblxuICB2YXIgX3JlZjIgPSBnZXRQcm9wZXJ0eUJ5UGF0aChoaXQuX2hpZ2hsaWdodFJlc3VsdCwgYXR0cmlidXRlKSB8fCB7fSxcbiAgICAgIF9yZWYyJHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9IF9yZWYyJHZhbHVlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYyJHZhbHVlOyAvLyBjeCBpcyBub3QgdXNlZCwgc2luY2UgaXQgd291bGQgYmUgYnVuZGxlZCBhcyBhIGRlcGVuZGVuY3kgZm9yIFZ1ZSAmIEFuZ3VsYXJcblxuXG4gIHZhciBjbGFzc05hbWUgPSBzdWl0KHtcbiAgICBkZXNjZW5kYW50TmFtZTogJ2hpZ2hsaWdodGVkJ1xuICB9KSArIChjc3NDbGFzc2VzLmhpZ2hsaWdodGVkID8gXCIgXCIuY29uY2F0KGNzc0NsYXNzZXMuaGlnaGxpZ2h0ZWQpIDogJycpO1xuICB2YXIgcmV2ZXJzZUhpZ2hsaWdodGVkVmFsdWUgPSBjb25jYXRIaWdobGlnaHRlZFBhcnRzKHJldmVyc2VIaWdobGlnaHRlZFBhcnRzKGdldEhpZ2hsaWdodGVkUGFydHMoYXR0cmlidXRlVmFsdWUpKSk7XG4gIHJldHVybiByZXZlcnNlSGlnaGxpZ2h0ZWRWYWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoVEFHX1JFUExBQ0VNRU5ULmhpZ2hsaWdodFByZVRhZywgJ2cnKSwgXCI8XCIuY29uY2F0KGhpZ2hsaWdodGVkVGFnTmFtZSwgXCIgY2xhc3M9XFxcIlwiKS5jb25jYXQoY2xhc3NOYW1lLCBcIlxcXCI+XCIpKS5yZXBsYWNlKG5ldyBSZWdFeHAoVEFHX1JFUExBQ0VNRU5ULmhpZ2hsaWdodFBvc3RUYWcsICdnJyksIFwiPC9cIi5jb25jYXQoaGlnaGxpZ2h0ZWRUYWdOYW1lLCBcIj5cIikpO1xufSIsImltcG9ydCB7IFRBR19SRVBMQUNFTUVOVCwgZ2V0UHJvcGVydHlCeVBhdGgsIGdldEhpZ2hsaWdodGVkUGFydHMsIHJldmVyc2VIaWdobGlnaHRlZFBhcnRzLCBjb25jYXRIaWdobGlnaHRlZFBhcnRzIH0gZnJvbSAnLi4vbGliL3V0aWxzJztcbmltcG9ydCB7IGNvbXBvbmVudCB9IGZyb20gJy4uL2xpYi9zdWl0JztcbnZhciBzdWl0ID0gY29tcG9uZW50KCdSZXZlcnNlU25pcHBldCcpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmV2ZXJzZVNuaXBwZXQoX3JlZikge1xuICB2YXIgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGUsXG4gICAgICBfcmVmJGhpZ2hsaWdodGVkVGFnTmEgPSBfcmVmLmhpZ2hsaWdodGVkVGFnTmFtZSxcbiAgICAgIGhpZ2hsaWdodGVkVGFnTmFtZSA9IF9yZWYkaGlnaGxpZ2h0ZWRUYWdOYSA9PT0gdm9pZCAwID8gJ21hcmsnIDogX3JlZiRoaWdobGlnaHRlZFRhZ05hLFxuICAgICAgaGl0ID0gX3JlZi5oaXQsXG4gICAgICBfcmVmJGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICBjc3NDbGFzc2VzID0gX3JlZiRjc3NDbGFzc2VzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkY3NzQ2xhc3NlcztcblxuICB2YXIgX3JlZjIgPSBnZXRQcm9wZXJ0eUJ5UGF0aChoaXQuX3NuaXBwZXRSZXN1bHQsIGF0dHJpYnV0ZSkgfHwge30sXG4gICAgICBfcmVmMiR2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgYXR0cmlidXRlVmFsdWUgPSBfcmVmMiR2YWx1ZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmMiR2YWx1ZTsgLy8gY3ggaXMgbm90IHVzZWQsIHNpbmNlIGl0IHdvdWxkIGJlIGJ1bmRsZWQgYXMgYSBkZXBlbmRlbmN5IGZvciBWdWUgJiBBbmd1bGFyXG5cblxuICB2YXIgY2xhc3NOYW1lID0gc3VpdCh7XG4gICAgZGVzY2VuZGFudE5hbWU6ICdoaWdobGlnaHRlZCdcbiAgfSkgKyAoY3NzQ2xhc3Nlcy5oaWdobGlnaHRlZCA/IFwiIFwiLmNvbmNhdChjc3NDbGFzc2VzLmhpZ2hsaWdodGVkKSA6ICcnKTtcbiAgdmFyIHJldmVyc2VIaWdobGlnaHRlZFZhbHVlID0gY29uY2F0SGlnaGxpZ2h0ZWRQYXJ0cyhyZXZlcnNlSGlnaGxpZ2h0ZWRQYXJ0cyhnZXRIaWdobGlnaHRlZFBhcnRzKGF0dHJpYnV0ZVZhbHVlKSkpO1xuICByZXR1cm4gcmV2ZXJzZUhpZ2hsaWdodGVkVmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKFRBR19SRVBMQUNFTUVOVC5oaWdobGlnaHRQcmVUYWcsICdnJyksIFwiPFwiLmNvbmNhdChoaWdobGlnaHRlZFRhZ05hbWUsIFwiIGNsYXNzPVxcXCJcIikuY29uY2F0KGNsYXNzTmFtZSwgXCJcXFwiPlwiKSkucmVwbGFjZShuZXcgUmVnRXhwKFRBR19SRVBMQUNFTUVOVC5oaWdobGlnaHRQb3N0VGFnLCAnZycpLCBcIjwvXCIuY29uY2F0KGhpZ2hsaWdodGVkVGFnTmFtZSwgXCI+XCIpKTtcbn0iLCJpbXBvcnQgeyBjb21wb25lbnQgfSBmcm9tICcuLi9saWIvc3VpdCc7XG5pbXBvcnQgeyBUQUdfUkVQTEFDRU1FTlQsIGdldFByb3BlcnR5QnlQYXRoIH0gZnJvbSAnLi4vbGliL3V0aWxzJztcbnZhciBzdWl0ID0gY29tcG9uZW50KCdTbmlwcGV0Jyk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzbmlwcGV0KF9yZWYpIHtcbiAgdmFyIGF0dHJpYnV0ZSA9IF9yZWYuYXR0cmlidXRlLFxuICAgICAgX3JlZiRoaWdobGlnaHRlZFRhZ05hID0gX3JlZi5oaWdobGlnaHRlZFRhZ05hbWUsXG4gICAgICBoaWdobGlnaHRlZFRhZ05hbWUgPSBfcmVmJGhpZ2hsaWdodGVkVGFnTmEgPT09IHZvaWQgMCA/ICdtYXJrJyA6IF9yZWYkaGlnaGxpZ2h0ZWRUYWdOYSxcbiAgICAgIGhpdCA9IF9yZWYuaGl0LFxuICAgICAgX3JlZiRjc3NDbGFzc2VzID0gX3JlZi5jc3NDbGFzc2VzLFxuICAgICAgY3NzQ2xhc3NlcyA9IF9yZWYkY3NzQ2xhc3NlcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJGNzc0NsYXNzZXM7XG5cbiAgdmFyIF9yZWYyID0gZ2V0UHJvcGVydHlCeVBhdGgoaGl0Ll9zbmlwcGV0UmVzdWx0LCBhdHRyaWJ1dGUpIHx8IHt9LFxuICAgICAgX3JlZjIkdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gX3JlZjIkdmFsdWUgPT09IHZvaWQgMCA/ICcnIDogX3JlZjIkdmFsdWU7IC8vIGN4IGlzIG5vdCB1c2VkLCBzaW5jZSBpdCB3b3VsZCBiZSBidW5kbGVkIGFzIGEgZGVwZW5kZW5jeSBmb3IgVnVlICYgQW5ndWxhclxuXG5cbiAgdmFyIGNsYXNzTmFtZSA9IHN1aXQoe1xuICAgIGRlc2NlbmRhbnROYW1lOiAnaGlnaGxpZ2h0ZWQnXG4gIH0pICsgKGNzc0NsYXNzZXMuaGlnaGxpZ2h0ZWQgPyBcIiBcIi5jb25jYXQoY3NzQ2xhc3Nlcy5oaWdobGlnaHRlZCkgOiAnJyk7XG4gIHJldHVybiBhdHRyaWJ1dGVWYWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoVEFHX1JFUExBQ0VNRU5ULmhpZ2hsaWdodFByZVRhZywgJ2cnKSwgXCI8XCIuY29uY2F0KGhpZ2hsaWdodGVkVGFnTmFtZSwgXCIgY2xhc3M9XFxcIlwiKS5jb25jYXQoY2xhc3NOYW1lLCBcIlxcXCI+XCIpKS5yZXBsYWNlKG5ldyBSZWdFeHAoVEFHX1JFUExBQ0VNRU5ULmhpZ2hsaWdodFBvc3RUYWcsICdnJyksIFwiPC9cIi5jb25jYXQoaGlnaGxpZ2h0ZWRUYWdOYW1lLCBcIj5cIikpO1xufSIsImltcG9ydCBJbnN0YW50U2VhcmNoIGZyb20gJy4vbGliL0luc3RhbnRTZWFyY2gnO1xuaW1wb3J0IHZlcnNpb24gZnJvbSAnLi9saWIvdmVyc2lvbic7XG5pbXBvcnQgeyBzbmlwcGV0LCByZXZlcnNlU25pcHBldCwgaGlnaGxpZ2h0LCByZXZlcnNlSGlnaGxpZ2h0LCBpbnNpZ2h0cywgZ2V0SW5zaWdodHNBbm9ueW1vdXNVc2VyVG9rZW4gfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgY3JlYXRlSW5maW5pdGVIaXRzU2Vzc2lvblN0b3JhZ2VDYWNoZSB9IGZyb20gJy4vbGliL2luZmluaXRlSGl0c0NhY2hlJztcbmltcG9ydCB7IGRlcHJlY2F0ZSB9IGZyb20gJy4vbGliL3V0aWxzJztcblxuLyoqXG4gKiBJbnN0YW50U2VhcmNoIGlzIHRoZSBtYWluIGNvbXBvbmVudCBvZiBJbnN0YW50U2VhcmNoLmpzLiBUaGlzIG9iamVjdFxuICogbWFuYWdlcyB0aGUgd2lkZ2V0IGFuZCBsZXRzIHlvdSBhZGQgbmV3IG9uZXMuXG4gKlxuICogVHdvIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkIHRvIGdldCB5b3Ugc3RhcnRlZCB3aXRoIEluc3RhbnRTZWFyY2guanM6XG4gKiAgLSBgaW5kZXhOYW1lYDogdGhlIG1haW4gaW5kZXggdGhhdCB5b3Ugd2lsbCB1c2UgZm9yIHlvdXIgbmV3IHNlYXJjaCBVSVxuICogIC0gYHNlYXJjaENsaWVudGA6IHRoZSBzZWFyY2ggY2xpZW50IHRvIHBsdWcgdG8gSW5zdGFudFNlYXJjaC5qc1xuICpcbiAqIFRoZSBbc2VhcmNoIGNsaWVudCBwcm92aWRlZCBieSBBbGdvbGlhXShhbGdvbGlhLmNvbS9kb2MvYXBpLWNsaWVudC9nZXR0aW5nLXN0YXJ0ZWQvd2hhdC1pcy10aGUtYXBpLWNsaWVudC9qYXZhc2NyaXB0LylcbiAqIG5lZWRzIGFuIGBhcHBJZGAgYW5kIGFuIGBhcGlLZXlgLiBUaG9zZSBwYXJhbWV0ZXJzIGNhbiBiZSBmb3VuZCBpbiB5b3VyXG4gKiBbQWxnb2xpYSBkYXNoYm9hcmRdKGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2FwaS1rZXlzKS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBnZXQgdXAgYW5kIHJ1bm5pbmcgcXVpY2tseSB3aXRoIEluc3RhbnRTZWFyY2guanMsIGhhdmUgYVxuICogbG9vayBhdCB0aGUgW2dldHRpbmcgc3RhcnRlZF0oaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9idWlsZGluZy1zZWFyY2gtdWkvZ2V0dGluZy1zdGFydGVkL2pzLykuXG4gKi9cbnZhciBpbnN0YW50c2VhcmNoID0gZnVuY3Rpb24gaW5zdGFudHNlYXJjaChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSW5zdGFudFNlYXJjaChvcHRpb25zKTtcbn07XG5cbmluc3RhbnRzZWFyY2gudmVyc2lvbiA9IHZlcnNpb247XG5pbnN0YW50c2VhcmNoLmNyZWF0ZUluZmluaXRlSGl0c1Nlc3Npb25TdG9yYWdlQ2FjaGUgPSBkZXByZWNhdGUoY3JlYXRlSW5maW5pdGVIaXRzU2Vzc2lvblN0b3JhZ2VDYWNoZSwgXCJpbXBvcnQgeyBjcmVhdGVJbmZpbml0ZUhpdHNTZXNzaW9uU3RvcmFnZUNhY2hlIH0gZnJvbSAnaW5zdGFudHNlYXJjaC5qcy9lcy9oZWxwZXJzJ1wiKTtcbmluc3RhbnRzZWFyY2guaGlnaGxpZ2h0ID0gZGVwcmVjYXRlKGhpZ2hsaWdodCwgXCJpbXBvcnQgeyBoaWdobGlnaHQgfSBmcm9tICdpbnN0YW50c2VhcmNoLmpzL2VzL2hlbHBlcnMnXCIpO1xuaW5zdGFudHNlYXJjaC5yZXZlcnNlSGlnaGxpZ2h0ID0gZGVwcmVjYXRlKHJldmVyc2VIaWdobGlnaHQsIFwiaW1wb3J0IHsgcmV2ZXJzZUhpZ2hsaWdodCB9IGZyb20gJ2luc3RhbnRzZWFyY2guanMvZXMvaGVscGVycydcIik7XG5pbnN0YW50c2VhcmNoLnNuaXBwZXQgPSBkZXByZWNhdGUoc25pcHBldCwgXCJpbXBvcnQgeyBzbmlwcGV0IH0gZnJvbSAnaW5zdGFudHNlYXJjaC5qcy9lcy9oZWxwZXJzJ1wiKTtcbmluc3RhbnRzZWFyY2gucmV2ZXJzZVNuaXBwZXQgPSBkZXByZWNhdGUocmV2ZXJzZVNuaXBwZXQsIFwiaW1wb3J0IHsgcmV2ZXJzZVNuaXBwZXQgfSBmcm9tICdpbnN0YW50c2VhcmNoLmpzL2VzL2hlbHBlcnMnXCIpO1xuaW5zdGFudHNlYXJjaC5pbnNpZ2h0cyA9IGluc2lnaHRzO1xuaW5zdGFudHNlYXJjaC5nZXRJbnNpZ2h0c0Fub255bW91c1VzZXJUb2tlbiA9IGdldEluc2lnaHRzQW5vbnltb3VzVXNlclRva2VuO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbnRzZWFyY2gsICd3aWRnZXRzJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJcXFwiaW5zdGFudHNlYXJjaC53aWRnZXRzXFxcIiBhcmUgbm90IGF2YWlsYWJsZSBmcm9tIHRoZSBFUyBidWlsZC5cXG5cXG5UbyBpbXBvcnQgdGhlIHdpZGdldHM6XFxuXFxuaW1wb3J0IHsgc2VhcmNoQm94IH0gZnJvbSAnaW5zdGFudHNlYXJjaC5qcy9lcy93aWRnZXRzJ1wiKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFudHNlYXJjaCwgJ2Nvbm5lY3RvcnMnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIlxcXCJpbnN0YW50c2VhcmNoLmNvbm5lY3RvcnNcXFwiIGFyZSBub3QgYXZhaWxhYmxlIGZyb20gdGhlIEVTIGJ1aWxkLlxcblxcblRvIGltcG9ydCB0aGUgY29ubmVjdG9yczpcXG5cXG5pbXBvcnQgeyBjb25uZWN0U2VhcmNoQm94IH0gZnJvbSAnaW5zdGFudHNlYXJjaC5qcy9lcy9jb25uZWN0b3JzJ1wiKTtcbiAgfVxufSk7XG5leHBvcnQgZGVmYXVsdCBpbnN0YW50c2VhcmNoO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG4iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgYWxnb2xpYXNlYXJjaEhlbHBlciBmcm9tICdhbGdvbGlhc2VhcmNoLWhlbHBlcic7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgaW5kZXgsIHsgaXNJbmRleFdpZGdldCB9IGZyb20gJy4uL3dpZGdldHMvaW5kZXgvaW5kZXgnO1xuaW1wb3J0IHZlcnNpb24gZnJvbSAnLi92ZXJzaW9uJztcbmltcG9ydCBjcmVhdGVIZWxwZXJzIGZyb20gJy4vY3JlYXRlSGVscGVycyc7XG5pbXBvcnQgeyBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvciwgY3JlYXRlRG9jdW1lbnRhdGlvbkxpbmssIGRlZmVyLCBub29wLCB3YXJuaW5nLCBjaGVja0luZGV4VWlTdGF0ZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyTWlkZGxld2FyZSB9IGZyb20gJy4uL21pZGRsZXdhcmVzL2NyZWF0ZVJvdXRlck1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgY3JlYXRlTWV0YWRhdGFNaWRkbGV3YXJlLCBpc01ldGFkYXRhRW5hYmxlZCB9IGZyb20gJy4uL21pZGRsZXdhcmVzL2NyZWF0ZU1ldGFkYXRhTWlkZGxld2FyZSc7XG52YXIgd2l0aFVzYWdlID0gY3JlYXRlRG9jdW1lbnRhdGlvbk1lc3NhZ2VHZW5lcmF0b3Ioe1xuICBuYW1lOiAnaW5zdGFudHNlYXJjaCdcbn0pO1xuXG5mdW5jdGlvbiBkZWZhdWx0Q3JlYXRlVVJMKCkge1xuICByZXR1cm4gJyMnO1xufVxuLyoqXG4gKiBHbG9iYWwgb3B0aW9ucyBmb3IgYW4gSW5zdGFudFNlYXJjaCBpbnN0YW5jZS5cbiAqL1xuXG5cbi8qKlxuICogVGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSW5zdGFudFNlYXJjaC4gVGhpcyBpc1xuICogY3JlYXRlZCB1c2luZyB0aGUgYGluc3RhbnRzZWFyY2hgIGZhY3RvcnkgZnVuY3Rpb24uXG4gKiBJdCBlbWl0cyB0aGUgJ3JlbmRlcicgZXZlbnQgZXZlcnkgdGltZSBhIHNlYXJjaCBpcyBkb25lXG4gKi9cbnZhciBJbnN0YW50U2VhcmNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhJbnN0YW50U2VhcmNoLCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEluc3RhbnRTZWFyY2gpO1xuXG4gIGZ1bmN0aW9uIEluc3RhbnRTZWFyY2gob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnN0YW50U2VhcmNoKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2xpZW50XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaW5kZXhOYW1lXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaW5zaWdodHNDbGllbnRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblN0YXRlQ2hhbmdlXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhlbHBlclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm1haW5IZWxwZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJtYWluSW5kZXhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGFydGVkXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidGVtcGxhdGVzQ29uZmlnXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicmVuZGVyU3RhdGVcIiwge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9zdGFsbGVkU2VhcmNoRGVsYXlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfc2VhcmNoU3RhbGxlZFRpbWVyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2lzU2VhcmNoU3RhbGxlZFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9pbml0aWFsVWlTdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9jcmVhdGVVUkxcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfc2VhcmNoRnVuY3Rpb25cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfbWFpbkhlbHBlclNlYXJjaFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm1pZGRsZXdhcmVcIiwgW10pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNlbmRFdmVudFRvSW5zaWdodHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzY2hlZHVsZVNlYXJjaFwiLCBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuc3RhcnRlZCkge1xuICAgICAgICBfdGhpcy5tYWluSGVscGVyLnNlYXJjaCgpO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzY2hlZHVsZVJlbmRlclwiLCBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLm1haW5IZWxwZXIuaGFzUGVuZGluZ1JlcXVlc3RzKCkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9zZWFyY2hTdGFsbGVkVGltZXIpO1xuICAgICAgICBfdGhpcy5fc2VhcmNoU3RhbGxlZFRpbWVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2lzU2VhcmNoU3RhbGxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5tYWluSW5kZXgucmVuZGVyKHtcbiAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKVxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLmVtaXQoJ3JlbmRlcicpO1xuICAgIH0pKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkludGVybmFsU3RhdGVDaGFuZ2VcIiwgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5leHRVaVN0YXRlID0gX3RoaXMubWFpbkluZGV4LmdldFdpZGdldFVpU3RhdGUoe30pO1xuXG4gICAgICBfdGhpcy5taWRkbGV3YXJlLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2Uub25TdGF0ZUNoYW5nZSh7XG4gICAgICAgICAgdWlTdGF0ZTogbmV4dFVpU3RhdGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KSk7XG5cbiAgICB2YXIgX29wdGlvbnMkaW5kZXhOYW1lID0gb3B0aW9ucy5pbmRleE5hbWUsXG4gICAgICAgIGluZGV4TmFtZSA9IF9vcHRpb25zJGluZGV4TmFtZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zJGluZGV4TmFtZSxcbiAgICAgICAgbnVtYmVyTG9jYWxlID0gb3B0aW9ucy5udW1iZXJMb2NhbGUsXG4gICAgICAgIF9vcHRpb25zJGluaXRpYWxVaVN0YSA9IG9wdGlvbnMuaW5pdGlhbFVpU3RhdGUsXG4gICAgICAgIGluaXRpYWxVaVN0YXRlID0gX29wdGlvbnMkaW5pdGlhbFVpU3RhID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zJGluaXRpYWxVaVN0YSxcbiAgICAgICAgX29wdGlvbnMkcm91dGluZyA9IG9wdGlvbnMucm91dGluZyxcbiAgICAgICAgcm91dGluZyA9IF9vcHRpb25zJHJvdXRpbmcgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9ucyRyb3V0aW5nLFxuICAgICAgICBzZWFyY2hGdW5jdGlvbiA9IG9wdGlvbnMuc2VhcmNoRnVuY3Rpb24sXG4gICAgICAgIF9vcHRpb25zJHN0YWxsZWRTZWFyYyA9IG9wdGlvbnMuc3RhbGxlZFNlYXJjaERlbGF5LFxuICAgICAgICBzdGFsbGVkU2VhcmNoRGVsYXkgPSBfb3B0aW9ucyRzdGFsbGVkU2VhcmMgPT09IHZvaWQgMCA/IDIwMCA6IF9vcHRpb25zJHN0YWxsZWRTZWFyYyxcbiAgICAgICAgX29wdGlvbnMkc2VhcmNoQ2xpZW50ID0gb3B0aW9ucy5zZWFyY2hDbGllbnQsXG4gICAgICAgIHNlYXJjaENsaWVudCA9IF9vcHRpb25zJHNlYXJjaENsaWVudCA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zJHNlYXJjaENsaWVudCxcbiAgICAgICAgX29wdGlvbnMkaW5zaWdodHNDbGllID0gb3B0aW9ucy5pbnNpZ2h0c0NsaWVudCxcbiAgICAgICAgaW5zaWdodHNDbGllbnQgPSBfb3B0aW9ucyRpbnNpZ2h0c0NsaWUgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9ucyRpbnNpZ2h0c0NsaWUsXG4gICAgICAgIF9vcHRpb25zJG9uU3RhdGVDaGFuZyA9IG9wdGlvbnMub25TdGF0ZUNoYW5nZSxcbiAgICAgICAgb25TdGF0ZUNoYW5nZSA9IF9vcHRpb25zJG9uU3RhdGVDaGFuZyA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zJG9uU3RhdGVDaGFuZztcblxuICAgIGlmIChpbmRleE5hbWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgaW5kZXhOYW1lYCBvcHRpb24gaXMgcmVxdWlyZWQuJykpO1xuICAgIH1cblxuICAgIGlmIChzZWFyY2hDbGllbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgc2VhcmNoQ2xpZW50YCBvcHRpb24gaXMgcmVxdWlyZWQuJykpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2VhcmNoQ2xpZW50LnNlYXJjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBzZWFyY2hDbGllbnRgIG11c3QgaW1wbGVtZW50IGEgYHNlYXJjaGAgbWV0aG9kLlxcblxcblNlZTogaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9idWlsZGluZy1zZWFyY2gtdWkvZ29pbmctZnVydGhlci9iYWNrZW5kLXNlYXJjaC9pbi1kZXB0aC9iYWNrZW5kLWluc3RhbnRzZWFyY2gvanMvXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2VhcmNoQ2xpZW50LmFkZEFsZ29saWFBZ2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VhcmNoQ2xpZW50LmFkZEFsZ29saWFBZ2VudChcImluc3RhbnRzZWFyY2guanMgKFwiLmNvbmNhdCh2ZXJzaW9uLCBcIilcIikpO1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gd2FybmluZyhpbnNpZ2h0c0NsaWVudCA9PT0gbnVsbCwgXCJgaW5zaWdodHNDbGllbnRgIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIEl0IGlzIHN0aWxsIHN1cHBvcnRlZCBpbiA0LnggcmVsZWFzZXMsIGJ1dCBub3QgZnVydGhlci4gSXQgaXMgcmVwbGFjZWQgYnkgdGhlIGBpbnNpZ2h0c2AgbWlkZGxld2FyZS5cXG5cXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9nZXR0aW5nLWluc2lnaHRzLWFuZC1hbmFseXRpY3Mvc2VhcmNoLWFuYWx5dGljcy9jbGljay10aHJvdWdoLWFuZC1jb252ZXJzaW9ucy9ob3ctdG8vc2VuZC1jbGljay1hbmQtY29udmVyc2lvbi1ldmVudHMtd2l0aC1pbnN0YW50c2VhcmNoL2pzL1wiKSA6IHZvaWQgMDtcblxuICAgIGlmIChpbnNpZ2h0c0NsaWVudCAmJiB0eXBlb2YgaW5zaWdodHNDbGllbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgaW5zaWdodHNDbGllbnRgIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbi4nKSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyB3YXJuaW5nKCFvcHRpb25zLnNlYXJjaFBhcmFtZXRlcnMsIFwiVGhlIGBzZWFyY2hQYXJhbWV0ZXJzYCBvcHRpb24gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIEluc3RhbnRTZWFyY2guanMgNC54LlxcblxcbllvdSBjYW4gcmVwbGFjZSBpdCB3aXRoIHRoZSBgY29uZmlndXJlYCB3aWRnZXQ6XFxuXFxuYGBgXFxuc2VhcmNoLmFkZFdpZGdldHMoW1xcbiAgY29uZmlndXJlKFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShvcHRpb25zLnNlYXJjaFBhcmFtZXRlcnMsIG51bGwsIDIpLCBcIilcXG5dKTtcXG5gYGBcXG5cXG5TZWUgXCIpLmNvbmNhdChjcmVhdGVEb2N1bWVudGF0aW9uTGluayh7XG4gICAgICBuYW1lOiAnY29uZmlndXJlJ1xuICAgIH0pKSkgOiB2b2lkIDA7XG4gICAgX3RoaXMuY2xpZW50ID0gc2VhcmNoQ2xpZW50O1xuICAgIF90aGlzLmluc2lnaHRzQ2xpZW50ID0gaW5zaWdodHNDbGllbnQ7XG4gICAgX3RoaXMuaW5kZXhOYW1lID0gaW5kZXhOYW1lO1xuICAgIF90aGlzLmhlbHBlciA9IG51bGw7XG4gICAgX3RoaXMubWFpbkhlbHBlciA9IG51bGw7XG4gICAgX3RoaXMubWFpbkluZGV4ID0gaW5kZXgoe1xuICAgICAgaW5kZXhOYW1lOiBpbmRleE5hbWVcbiAgICB9KTtcbiAgICBfdGhpcy5vblN0YXRlQ2hhbmdlID0gb25TdGF0ZUNoYW5nZTtcbiAgICBfdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgX3RoaXMudGVtcGxhdGVzQ29uZmlnID0ge1xuICAgICAgaGVscGVyczogY3JlYXRlSGVscGVycyh7XG4gICAgICAgIG51bWJlckxvY2FsZTogbnVtYmVyTG9jYWxlXG4gICAgICB9KSxcbiAgICAgIGNvbXBpbGVPcHRpb25zOiB7fVxuICAgIH07XG4gICAgX3RoaXMuX3N0YWxsZWRTZWFyY2hEZWxheSA9IHN0YWxsZWRTZWFyY2hEZWxheTtcbiAgICBfdGhpcy5fc2VhcmNoU3RhbGxlZFRpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5faXNTZWFyY2hTdGFsbGVkID0gZmFsc2U7XG4gICAgX3RoaXMuX2NyZWF0ZVVSTCA9IGRlZmF1bHRDcmVhdGVVUkw7XG4gICAgX3RoaXMuX2luaXRpYWxVaVN0YXRlID0gaW5pdGlhbFVpU3RhdGU7XG5cbiAgICBpZiAoc2VhcmNoRnVuY3Rpb24pIHtcbiAgICAgIF90aGlzLl9zZWFyY2hGdW5jdGlvbiA9IHNlYXJjaEZ1bmN0aW9uO1xuICAgIH1cblxuICAgIF90aGlzLnNlbmRFdmVudFRvSW5zaWdodHMgPSBub29wO1xuXG4gICAgaWYgKHJvdXRpbmcpIHtcbiAgICAgIHZhciByb3V0ZXJPcHRpb25zID0gdHlwZW9mIHJvdXRpbmcgPT09ICdib29sZWFuJyA/IHVuZGVmaW5lZCA6IHJvdXRpbmc7XG5cbiAgICAgIF90aGlzLnVzZShjcmVhdGVSb3V0ZXJNaWRkbGV3YXJlKHJvdXRlck9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNZXRhZGF0YUVuYWJsZWQoKSkge1xuICAgICAgX3RoaXMudXNlKGNyZWF0ZU1ldGFkYXRhTWlkZGxld2FyZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEhvb2tzIGEgbWlkZGxld2FyZSBpbnRvIHRoZSBJbnN0YW50U2VhcmNoIGxpZmVjeWNsZS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSW5zdGFudFNlYXJjaCwgW3tcbiAgICBrZXk6IFwidXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVzZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZSA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgbWlkZGxld2FyZVtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld01pZGRsZXdhcmVMaXN0ID0gbWlkZGxld2FyZS5tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBuZXdNaWRkbGV3YXJlID0gX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgc3Vic2NyaWJlOiBub29wLFxuICAgICAgICAgIHVuc3Vic2NyaWJlOiBub29wLFxuICAgICAgICAgIG9uU3RhdGVDaGFuZ2U6IG5vb3BcbiAgICAgICAgfSwgZm4oe1xuICAgICAgICAgIGluc3RhbnRTZWFyY2hJbnN0YW5jZTogX3RoaXMyXG4gICAgICAgIH0pKTtcblxuICAgICAgICBfdGhpczIubWlkZGxld2FyZS5wdXNoKHtcbiAgICAgICAgICBjcmVhdG9yOiBmbixcbiAgICAgICAgICBpbnN0YW5jZTogbmV3TWlkZGxld2FyZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3TWlkZGxld2FyZTtcbiAgICAgIH0pOyAvLyBJZiB0aGUgaW5zdGFuY2UgaGFzIGFscmVhZHkgc3RhcnRlZCwgd2UgZGlyZWN0bHkgc3Vic2NyaWJlIHRoZVxuICAgICAgLy8gbWlkZGxld2FyZSBzbyB0aGV5J3JlIG5vdGlmaWVkIG9mIGNoYW5nZXMuXG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgbmV3TWlkZGxld2FyZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIG0uc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIG1pZGRsZXdhcmUgZnJvbSB0aGUgSW5zdGFudFNlYXJjaCBsaWZlY3ljbGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnVzZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZVRvVW51c2UgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgbWlkZGxld2FyZVRvVW51c2VbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5taWRkbGV3YXJlLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZVRvVW51c2UuaW5jbHVkZXMobS5jcmVhdG9yKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG0uaW5zdGFuY2UudW5zdWJzY3JpYmUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5taWRkbGV3YXJlID0gdGhpcy5taWRkbGV3YXJlLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gIW1pZGRsZXdhcmVUb1VudXNlLmluY2x1ZGVzKG0uY3JlYXRvcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gQG1ham9yIHdlIHNoaXBwZWQgd2l0aCBFWFBFUklNRU5UQUxfdXNlLCBidXQgaGF2ZSBjaGFuZ2VkIHRoYXQgdG8ganVzdCBgdXNlYCBub3dcblxuICB9LCB7XG4gICAga2V5OiBcIkVYUEVSSU1FTlRBTF91c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gRVhQRVJJTUVOVEFMX3VzZSgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gd2FybmluZyhmYWxzZSwgJ1RoZSBtaWRkbGV3YXJlIEFQSSBpcyBub3cgY29uc2lkZXJlZCBzdGFibGUsIHNvIHdlIHJlY29tbWVuZCByZXBsYWNpbmcgYEVYUEVSSU1FTlRBTF91c2VgIHdpdGggYHVzZWAgYmVmb3JlIHVwZ3JhZGluZyB0byB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMudXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB3aWRnZXQgdG8gdGhlIHNlYXJjaCBpbnN0YW5jZS5cbiAgICAgKiBBIHdpZGdldCBjYW4gYmUgYWRkZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciBJbnN0YW50U2VhcmNoIGhhcyBzdGFydGVkLlxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byBhZGQgdG8gSW5zdGFudFNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIHdpbGwgc3RpbGwgYmUgc3VwcG9ydGVkIGluIDQueCByZWxlYXNlcywgYnV0IG5vdCBmdXJ0aGVyLiBJdCBpcyByZXBsYWNlZCBieSBgYWRkV2lkZ2V0cyhbd2lkZ2V0XSlgLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkV2lkZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFdpZGdldCh3aWRnZXQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gd2FybmluZyhmYWxzZSwgJ2FkZFdpZGdldCB3aWxsIHN0aWxsIGJlIHN1cHBvcnRlZCBpbiA0LnggcmVsZWFzZXMsIGJ1dCBub3QgZnVydGhlci4gSXQgaXMgcmVwbGFjZWQgYnkgYGFkZFdpZGdldHMoW3dpZGdldF0pYCcpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkV2lkZ2V0cyhbd2lkZ2V0XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbXVsdGlwbGUgd2lkZ2V0cyB0byB0aGUgc2VhcmNoIGluc3RhbmNlLlxuICAgICAqIFdpZGdldHMgY2FuIGJlIGFkZGVkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgSW5zdGFudFNlYXJjaCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcGFyYW0gd2lkZ2V0cyBUaGUgYXJyYXkgb2Ygd2lkZ2V0cyB0byBhZGQgdG8gSW5zdGFudFNlYXJjaC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFdpZGdldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkV2lkZ2V0cyh3aWRnZXRzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkod2lkZ2V0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdpdGhVc2FnZSgnVGhlIGBhZGRXaWRnZXRzYCBtZXRob2QgZXhwZWN0cyBhbiBhcnJheSBvZiB3aWRnZXRzLiBQbGVhc2UgdXNlIGBhZGRXaWRnZXRgLicpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpZGdldHMuc29tZShmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygd2lkZ2V0LmluaXQgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHdpZGdldC5yZW5kZXIgIT09ICdmdW5jdGlvbic7XG4gICAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod2l0aFVzYWdlKCdUaGUgd2lkZ2V0IGRlZmluaXRpb24gZXhwZWN0cyBhIGByZW5kZXJgIGFuZC9vciBhbiBgaW5pdGAgbWV0aG9kLicpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYWluSW5kZXguYWRkV2lkZ2V0cyh3aWRnZXRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgd2lkZ2V0IGZyb20gdGhlIHNlYXJjaCBpbnN0YW5jZS5cbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCB3aWxsIHN0aWxsIGJlIHN1cHBvcnRlZCBpbiA0LnggcmVsZWFzZXMsIGJ1dCBub3QgZnVydGhlci4gSXQgaXMgcmVwbGFjZWQgYnkgYHJlbW92ZVdpZGdldHMoW3dpZGdldF0pYFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCBpbnN0YW5jZSB0byByZW1vdmUgZnJvbSBJbnN0YW50U2VhcmNoLlxuICAgICAqXG4gICAgICogVGhlIHdpZGdldCBtdXN0IGltcGxlbWVudCBhIGBkaXNwb3NlKClgIG1ldGhvZCB0byBjbGVhciBpdHMgc3RhdGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVXaWRnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlV2lkZ2V0KHdpZGdldCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyB3YXJuaW5nKGZhbHNlLCAncmVtb3ZlV2lkZ2V0IHdpbGwgc3RpbGwgYmUgc3VwcG9ydGVkIGluIDQueCByZWxlYXNlcywgYnV0IG5vdCBmdXJ0aGVyLiBJdCBpcyByZXBsYWNlZCBieSBgcmVtb3ZlV2lkZ2V0cyhbd2lkZ2V0XSlgJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVXaWRnZXRzKFt3aWRnZXRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBtdWx0aXBsZSB3aWRnZXRzIGZyb20gdGhlIHNlYXJjaCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gd2lkZ2V0cyBBcnJheSBvZiB3aWRnZXRzIGluc3RhbmNlcyB0byByZW1vdmUgZnJvbSBJbnN0YW50U2VhcmNoLlxuICAgICAqXG4gICAgICogVGhlIHdpZGdldHMgbXVzdCBpbXBsZW1lbnQgYSBgZGlzcG9zZSgpYCBtZXRob2QgdG8gY2xlYXIgdGhlaXIgc3RhdGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlV2lkZ2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVXaWRnZXRzKHdpZGdldHMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3aWRnZXRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod2l0aFVzYWdlKCdUaGUgYHJlbW92ZVdpZGdldHNgIG1ldGhvZCBleHBlY3RzIGFuIGFycmF5IG9mIHdpZGdldHMuIFBsZWFzZSB1c2UgYHJlbW92ZVdpZGdldGAuJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAod2lkZ2V0cy5zb21lKGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aWRnZXQuZGlzcG9zZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSB3aWRnZXQgZGVmaW5pdGlvbiBleHBlY3RzIGEgYGRpc3Bvc2VgIG1ldGhvZC4nKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFpbkluZGV4LnJlbW92ZVdpZGdldHMod2lkZ2V0cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5kcyB0aGUgaW5pdGlhbGl6YXRpb24gb2YgSW5zdGFudFNlYXJjaC5qcyBhbmQgdHJpZ2dlcnMgdGhlXG4gICAgICogZmlyc3Qgc2VhcmNoLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFsbCB3aWRnZXRzIGhhdmUgYmVlbiBhZGRlZFxuICAgICAqIHRvIHRoZSBpbnN0YW5jZSBvZiBJbnN0YW50U2VhcmNoLmpzLiBJbnN0YW50U2VhcmNoLmpzIGFsc28gc3VwcG9ydHMgYWRkaW5nIGFuZCByZW1vdmluZ1xuICAgICAqIHdpZGdldHMgYWZ0ZXIgdGhlIHN0YXJ0IGFzIGFuICoqRVhQRVJJTUVOVEFMKiogZmVhdHVyZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdpdGhVc2FnZSgnVGhlIGBzdGFydGAgbWV0aG9kIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIG9uY2UuJykpO1xuICAgICAgfSAvLyBUaGlzIEhlbHBlciBpcyB1c2VkIGZvciB0aGUgcXVlcmllcywgd2UgZG9uJ3QgY2FyZSBhYm91dCBpdHMgc3RhdGUuIFRoZVxuICAgICAgLy8gc3RhdGVzIGFyZSBtYW5hZ2VkIGF0IHRoZSBgaW5kZXhgIGxldmVsLiBXZSB1c2UgdGhpcyBIZWxwZXIgdG8gY3JlYXRlXG4gICAgICAvLyBEZXJpdmVkSGVscGVyIHNjb3BlZCBpbnRvIHRoZSBgaW5kZXhgIHdpZGdldHMuXG4gICAgICAvLyBJbiBWdWUgSW5zdGFudFNlYXJjaCcgaHlkcmF0ZSwgYSBtYWluIGhlbHBlciBnZXRzIHNldCBiZWZvcmUgc3RhcnQsIHNvXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJlc3BlY3QgdGhpcyBoZWxwZXIgYXMgYSB3YXkgdG8ga2VlcCBhbGwgbGlzdGVuZXJzIGNvcnJlY3QuXG5cblxuICAgICAgdmFyIG1haW5IZWxwZXIgPSB0aGlzLm1haW5IZWxwZXIgfHwgYWxnb2xpYXNlYXJjaEhlbHBlcih0aGlzLmNsaWVudCwgdGhpcy5pbmRleE5hbWUpO1xuXG4gICAgICBtYWluSGVscGVyLnNlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhpcyBzb2x1dGlvbiBhbGxvd3MgdXMgdG8ga2VlcCB0aGUgZXhhY3Qgc2FtZSBBUEkgZm9yIHRoZSB1c2VycyBidXRcbiAgICAgICAgLy8gdW5kZXIgdGhlIGhvb2QsIHdlIGhhdmUgYSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb24uIEl0IHNob3VsZCBiZVxuICAgICAgICAvLyBjb21wbGV0ZWx5IHRyYW5zcGFyZW50IGZvciB0aGUgcmVzdCBvZiB0aGUgY29kZWJhc2UuIE9ubHkgdGhpcyBtb2R1bGVcbiAgICAgICAgLy8gaXMgaW1wYWN0ZWQuXG4gICAgICAgIHJldHVybiBtYWluSGVscGVyLnNlYXJjaE9ubHlXaXRoRGVyaXZlZEhlbHBlcnMoKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9zZWFyY2hGdW5jdGlvbikge1xuICAgICAgICAvLyB0aGlzIGNsaWVudCBpc24ndCB1c2VkIHRvIGFjdHVhbGx5IHNlYXJjaCwgYnV0IHJlcXVpcmVkIGZvciB0aGUgaGVscGVyXG4gICAgICAgIC8vIHRvIG5vdCB0aHJvdyBlcnJvcnNcbiAgICAgICAgdmFyIGZha2VDbGllbnQgPSB7XG4gICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2goKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2Uobm9vcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9tYWluSGVscGVyU2VhcmNoID0gbWFpbkhlbHBlci5zZWFyY2guYmluZChtYWluSGVscGVyKTtcblxuICAgICAgICBtYWluSGVscGVyLnNlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbWFpbkluZGV4SGVscGVyID0gX3RoaXMzLm1haW5JbmRleC5nZXRIZWxwZXIoKTtcblxuICAgICAgICAgIHZhciBzZWFyY2hGdW5jdGlvbkhlbHBlciA9IGFsZ29saWFzZWFyY2hIZWxwZXIoZmFrZUNsaWVudCwgbWFpbkluZGV4SGVscGVyLnN0YXRlLmluZGV4LCBtYWluSW5kZXhIZWxwZXIuc3RhdGUpO1xuICAgICAgICAgIHNlYXJjaEZ1bmN0aW9uSGVscGVyLm9uY2UoJ3NlYXJjaCcsIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gICAgICAgICAgICBtYWluSW5kZXhIZWxwZXIub3ZlcnJpZGVTdGF0ZVdpdGhvdXRUcmlnZ2VyaW5nQ2hhbmdlRXZlbnQoc3RhdGUpO1xuXG4gICAgICAgICAgICBfdGhpczMuX21haW5IZWxwZXJTZWFyY2goKTtcbiAgICAgICAgICB9KTsgLy8gRm9yd2FyZCBzdGF0ZSBjaGFuZ2VzIGZyb20gYHNlYXJjaEZ1bmN0aW9uSGVscGVyYCB0byBgbWFpbkluZGV4SGVscGVyYFxuXG4gICAgICAgICAgc2VhcmNoRnVuY3Rpb25IZWxwZXIub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gX3JlZjMuc3RhdGU7XG4gICAgICAgICAgICBtYWluSW5kZXhIZWxwZXIuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMzLl9zZWFyY2hGdW5jdGlvbihzZWFyY2hGdW5jdGlvbkhlbHBlcik7XG5cbiAgICAgICAgICByZXR1cm4gbWFpbkhlbHBlcjtcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gT25seSB0aGUgXCJtYWluXCIgSGVscGVyIGVtaXRzIHRoZSBgZXJyb3JgIGV2ZW50IHZzIHRoZSBvbmUgZm9yIGBzZWFyY2hgXG4gICAgICAvLyBhbmQgYHJlc3VsdHNgIHRoYXQgYXJlIGFsc28gZW1pdHRlZCBvbiB0aGUgZGVyaXZlZCBvbmUuXG5cblxuICAgICAgbWFpbkhlbHBlci5vbignZXJyb3InLCBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gX3JlZjQuZXJyb3I7XG5cbiAgICAgICAgX3RoaXMzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYWluSGVscGVyID0gbWFpbkhlbHBlcjtcbiAgICAgIHRoaXMubWFpbkluZGV4LmluaXQoe1xuICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IHRoaXMsXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgdWlTdGF0ZTogdGhpcy5faW5pdGlhbFVpU3RhdGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5taWRkbGV3YXJlLmZvckVhY2goZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IF9yZWY1Lmluc3RhbmNlO1xuICAgICAgICBpbnN0YW5jZS5zdWJzY3JpYmUoKTtcbiAgICAgIH0pO1xuICAgICAgbWFpbkhlbHBlci5zZWFyY2goKTsgLy8gS2VlcCB0aGUgcHJldmlvdXMgcmVmZXJlbmNlIGZvciBsZWdhY3kgcHVycG9zZSwgc29tZSBwYXR0ZXJuIHVzZVxuICAgICAgLy8gdGhlIGRpcmVjdCBIZWxwZXIgYWNjZXNzIGBzZWFyY2guaGVscGVyYCAoZS5nIG11bHRpLWluZGV4KS5cblxuICAgICAgdGhpcy5oZWxwZXIgPSB0aGlzLm1haW5JbmRleC5nZXRIZWxwZXIoKTsgLy8gdHJhY2sgd2Ugc3RhcnRlZCB0aGUgc2VhcmNoIGlmIHdlIGFkZCBtb3JlIHdpZGdldHMsXG4gICAgICAvLyB0byBpbml0IHRoZW0gZGlyZWN0bHkgYWZ0ZXIgYWRkXG5cbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHdpZGdldHMgd2l0aG91dCB0cmlnZ2VyaW5nIGEgc2VhcmNoIGFmdGVyd2FyZHMuIFRoaXMgaXMgYW4gKipFWFBFUklNRU5UQUwqKiBmZWF0dXJlLFxuICAgICAqIGlmIHlvdSBmaW5kIGFuIGlzc3VlIHdpdGggaXQsIHBsZWFzZVxuICAgICAqIFtvcGVuIGFuIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vYWxnb2xpYS9pbnN0YW50c2VhcmNoLmpzL2lzc3Vlcy9uZXc/dGl0bGU9UHJvYmxlbSUyMHdpdGglMjBkaXNwb3NlKS5cbiAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9IFRoaXMgbWV0aG9kIGRvZXMgbm90IHJldHVybiBhbnl0aGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5zY2hlZHVsZVNlYXJjaC5jYW5jZWwoKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIuY2FuY2VsKCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2VhcmNoU3RhbGxlZFRpbWVyKTtcbiAgICAgIHRoaXMucmVtb3ZlV2lkZ2V0cyh0aGlzLm1haW5JbmRleC5nZXRXaWRnZXRzKCkpO1xuICAgICAgdGhpcy5tYWluSW5kZXguZGlzcG9zZSgpOyAvLyBZb3UgY2FuIG5vdCBzdGFydCBhbiBpbnN0YW5jZSB0d28gdGltZXMsIHRoZXJlZm9yZSBhIGRpc3Bvc2VkIGluc3RhbmNlXG4gICAgICAvLyBuZWVkcyB0byBzZXQgc3RhcnRlZCBhcyBmYWxzZSBvdGhlcndpc2UgdGhpcyBjYW4gbm90IGJlIHJlc3RhcnRlZCBhdCBhXG4gICAgICAvLyBsYXRlciBwb2ludC5cblxuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7IC8vIFRoZSBoZWxwZXIgbmVlZHMgdG8gYmUgcmVzZXQgdG8gcGVyZm9ybSB0aGUgbmV4dCBzZWFyY2ggZnJvbSBhIGZyZXNoIHN0YXRlLlxuICAgICAgLy8gSWYgbm90IHJlc2V0LCBpdCB3b3VsZCB1c2UgdGhlIHN0YXRlIHN0b3JlZCBiZWZvcmUgY2FsbGluZyBgZGlzcG9zZSgpYC5cblxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMubWFpbkhlbHBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMubWFpbkhlbHBlciA9IG51bGw7XG4gICAgICB0aGlzLmhlbHBlciA9IG51bGw7XG4gICAgICB0aGlzLm1pZGRsZXdhcmUuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gX3JlZjYuaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2NoZWR1bGVTdGFsbGVkUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlU3RhbGxlZFJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX3NlYXJjaFN0YWxsZWRUaW1lcikge1xuICAgICAgICB0aGlzLl9zZWFyY2hTdGFsbGVkVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuX2lzU2VhcmNoU3RhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgICBfdGhpczQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfSwgdGhpcy5fc3RhbGxlZFNlYXJjaERlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VWlTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVaVN0YXRlKHVpU3RhdGUpIHtcbiAgICAgIGlmICghdGhpcy5tYWluSGVscGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgc3RhcnRgIG1ldGhvZCBuZWVkcyB0byBiZSBjYWxsZWQgYmVmb3JlIGBzZXRVaVN0YXRlYC4nKSk7XG4gICAgICB9IC8vIFdlIHJlZnJlc2ggdGhlIGluZGV4IFVJIHN0YXRlIHRvIHVwZGF0ZSB0aGUgbG9jYWwgVUkgc3RhdGUgdGhhdCB0aGVcbiAgICAgIC8vIG1haW4gaW5kZXggcGFzc2VzIHRvIHRoZSBmdW5jdGlvbiBmb3JtIG9mIGBzZXRVaVN0YXRlYC5cblxuXG4gICAgICB0aGlzLm1haW5JbmRleC5yZWZyZXNoVWlTdGF0ZSgpO1xuICAgICAgdmFyIG5leHRVaVN0YXRlID0gdHlwZW9mIHVpU3RhdGUgPT09ICdmdW5jdGlvbicgPyB1aVN0YXRlKHRoaXMubWFpbkluZGV4LmdldFdpZGdldFVpU3RhdGUoe30pKSA6IHVpU3RhdGU7XG5cbiAgICAgIHZhciBzZXRJbmRleEhlbHBlclN0YXRlID0gZnVuY3Rpb24gc2V0SW5kZXhIZWxwZXJTdGF0ZShpbmRleFdpZGdldCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjaGVja0luZGV4VWlTdGF0ZSh7XG4gICAgICAgICAgICBpbmRleDogaW5kZXhXaWRnZXQsXG4gICAgICAgICAgICBpbmRleFVpU3RhdGU6IG5leHRVaVN0YXRlW2luZGV4V2lkZ2V0LmdldEluZGV4SWQoKV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4V2lkZ2V0LmdldEhlbHBlcigpLnNldFN0YXRlKGluZGV4V2lkZ2V0LmdldFdpZGdldFNlYXJjaFBhcmFtZXRlcnMoaW5kZXhXaWRnZXQuZ2V0SGVscGVyKCkuc3RhdGUsIHtcbiAgICAgICAgICB1aVN0YXRlOiBuZXh0VWlTdGF0ZVtpbmRleFdpZGdldC5nZXRJbmRleElkKCldXG4gICAgICAgIH0pKTtcbiAgICAgICAgaW5kZXhXaWRnZXQuZ2V0V2lkZ2V0cygpLmZpbHRlcihpc0luZGV4V2lkZ2V0KS5mb3JFYWNoKHNldEluZGV4SGVscGVyU3RhdGUpO1xuICAgICAgfTtcblxuICAgICAgc2V0SW5kZXhIZWxwZXJTdGF0ZSh0aGlzLm1haW5JbmRleCk7XG4gICAgICB0aGlzLnNjaGVkdWxlU2VhcmNoKCk7XG4gICAgICB0aGlzLm9uSW50ZXJuYWxTdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVaVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVpU3RhdGUoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgIC8vIFdlIHJlZnJlc2ggdGhlIGluZGV4IFVJIHN0YXRlIHRvIG1ha2Ugc3VyZSBjaGFuZ2VzIGZyb20gYHJlZmluZWAgYXJlIHRha2VuIGluIGFjY291bnRcbiAgICAgICAgdGhpcy5tYWluSW5kZXgucmVmcmVzaFVpU3RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWFpbkluZGV4LmdldFdpZGdldFVpU3RhdGUoe30pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVVUkxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVVJMKCkge1xuICAgICAgdmFyIG5leHRTdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgc3RhcnRgIG1ldGhvZCBuZWVkcyB0byBiZSBjYWxsZWQgYmVmb3JlIGBjcmVhdGVVUkxgLicpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVVSTChuZXh0U3RhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICBpZiAoIXRoaXMubWFpbkhlbHBlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod2l0aFVzYWdlKCdUaGUgYHN0YXJ0YCBtZXRob2QgbmVlZHMgdG8gYmUgY2FsbGVkIGJlZm9yZSBgcmVmcmVzaGAuJykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1haW5IZWxwZXIuY2xlYXJDYWNoZSgpLnNlYXJjaCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnN0YW50U2VhcmNoO1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBJbnN0YW50U2VhcmNoOyIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBoaWdobGlnaHQgYXMgX2hpZ2hsaWdodCwgcmV2ZXJzZUhpZ2hsaWdodCBhcyBfcmV2ZXJzZUhpZ2hsaWdodCwgc25pcHBldCBhcyBfc25pcHBldCwgcmV2ZXJzZVNuaXBwZXQgYXMgX3JldmVyc2VTbmlwcGV0LCBpbnNpZ2h0cyBhcyBfaW5zaWdodHMgfSBmcm9tICcuLi9oZWxwZXJzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhvZ2FuSGVscGVycyhfcmVmKSB7XG4gIHZhciBudW1iZXJMb2NhbGUgPSBfcmVmLm51bWJlckxvY2FsZTtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXROdW1iZXI6IGZ1bmN0aW9uIGZvcm1hdE51bWJlcih2YWx1ZSwgcmVuZGVyKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHJlbmRlcih2YWx1ZSkpLnRvTG9jYWxlU3RyaW5nKG51bWJlckxvY2FsZSk7XG4gICAgfSxcbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodChvcHRpb25zLCByZW5kZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBoaWdobGlnaHRPcHRpb25zID0gSlNPTi5wYXJzZShvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcihfaGlnaGxpZ2h0KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaGlnaGxpZ2h0T3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgaGl0OiB0aGlzXG4gICAgICAgIH0pKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG5UaGUgaGlnaGxpZ2h0IGhlbHBlciBleHBlY3RzIGEgSlNPTiBvYmplY3Qgb2YgdGhlIGZvcm1hdDpcXG57IFxcXCJhdHRyaWJ1dGVcXFwiOiBcXFwibmFtZVxcXCIsIFxcXCJoaWdobGlnaHRlZFRhZ05hbWVcXFwiOiBcXFwibWFya1xcXCIgfVwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJldmVyc2VIaWdobGlnaHQ6IGZ1bmN0aW9uIHJldmVyc2VIaWdobGlnaHQob3B0aW9ucywgcmVuZGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmV2ZXJzZUhpZ2hsaWdodE9wdGlvbnMgPSBKU09OLnBhcnNlKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVuZGVyKF9yZXZlcnNlSGlnaGxpZ2h0KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmV2ZXJzZUhpZ2hsaWdodE9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGhpdDogdGhpc1xuICAgICAgICB9KSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICBUaGUgcmV2ZXJzZUhpZ2hsaWdodCBoZWxwZXIgZXhwZWN0cyBhIEpTT04gb2JqZWN0IG9mIHRoZSBmb3JtYXQ6XFxuICB7IFxcXCJhdHRyaWJ1dGVcXFwiOiBcXFwibmFtZVxcXCIsIFxcXCJoaWdobGlnaHRlZFRhZ05hbWVcXFwiOiBcXFwibWFya1xcXCIgfVwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNuaXBwZXQ6IGZ1bmN0aW9uIHNuaXBwZXQob3B0aW9ucywgcmVuZGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc25pcHBldE9wdGlvbnMgPSBKU09OLnBhcnNlKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVuZGVyKF9zbmlwcGV0KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc25pcHBldE9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGhpdDogdGhpc1xuICAgICAgICB9KSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuVGhlIHNuaXBwZXQgaGVscGVyIGV4cGVjdHMgYSBKU09OIG9iamVjdCBvZiB0aGUgZm9ybWF0OlxcbnsgXFxcImF0dHJpYnV0ZVxcXCI6IFxcXCJuYW1lXFxcIiwgXFxcImhpZ2hsaWdodGVkVGFnTmFtZVxcXCI6IFxcXCJtYXJrXFxcIiB9XCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmV2ZXJzZVNuaXBwZXQ6IGZ1bmN0aW9uIHJldmVyc2VTbmlwcGV0KG9wdGlvbnMsIHJlbmRlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJldmVyc2VTbmlwcGV0T3B0aW9ucyA9IEpTT04ucGFyc2Uob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZW5kZXIoX3JldmVyc2VTbmlwcGV0KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmV2ZXJzZVNuaXBwZXRPcHRpb25zKSwge30sIHtcbiAgICAgICAgICBoaXQ6IHRoaXNcbiAgICAgICAgfSkpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgVGhlIHJldmVyc2VTbmlwcGV0IGhlbHBlciBleHBlY3RzIGEgSlNPTiBvYmplY3Qgb2YgdGhlIGZvcm1hdDpcXG4gIHsgXFxcImF0dHJpYnV0ZVxcXCI6IFxcXCJuYW1lXFxcIiwgXFxcImhpZ2hsaWdodGVkVGFnTmFtZVxcXCI6IFxcXCJtYXJrXFxcIiB9XCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5zaWdodHM6IGZ1bmN0aW9uIGluc2lnaHRzKG9wdGlvbnMsIHJlbmRlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9KU09OJHBhcnNlID0gSlNPTi5wYXJzZShvcHRpb25zKSxcbiAgICAgICAgICAgIG1ldGhvZCA9IF9KU09OJHBhcnNlLm1ldGhvZCxcbiAgICAgICAgICAgIHBheWxvYWQgPSBfSlNPTiRwYXJzZS5wYXlsb2FkO1xuXG4gICAgICAgIHJldHVybiByZW5kZXIoX2luc2lnaHRzKG1ldGhvZCwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgb2JqZWN0SURzOiBbdGhpcy5vYmplY3RJRF1cbiAgICAgICAgfSwgcGF5bG9hZCkpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcblRoZSBpbnNpZ2h0cyBoZWxwZXIgZXhwZWN0cyBhIEpTT04gb2JqZWN0IG9mIHRoZSBmb3JtYXQ6XFxueyBcXFwibWV0aG9kXFxcIjogXFxcIm1ldGhvZC1uYW1lXFxcIiwgXFxcInBheWxvYWRcXFwiOiB7IFxcXCJldmVudE5hbWVcXFwiOiBcXFwibmFtZSBvZiB0aGUgZXZlbnRcXFwiIH0gfVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59IiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IHsgaXNFcXVhbCB9IGZyb20gJy4uL3V0aWxzJztcblxuZnVuY3Rpb24gZ2V0U3RhdGVXaXRob3V0UGFnZShzdGF0ZSkge1xuICB2YXIgX3JlZiA9IHN0YXRlIHx8IHt9LFxuICAgICAgcGFnZSA9IF9yZWYucGFnZSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wicGFnZVwiXSk7XG5cbiAgcmV0dXJuIHJlc3Q7XG59XG5cbnZhciBLRVkgPSAnYWlzLmluZmluaXRlSGl0cyc7XG5cbmZ1bmN0aW9uIGhhc1Nlc3Npb25TdG9yYWdlKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5zZXNzaW9uU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUluZmluaXRlSGl0c1Nlc3Npb25TdG9yYWdlQ2FjaGUoKSB7XG4gIHJldHVybiB7XG4gICAgcmVhZDogZnVuY3Rpb24gcmVhZChfcmVmMikge1xuICAgICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG5cbiAgICAgIGlmICghaGFzU2Vzc2lvblN0b3JhZ2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGNhY2hlID0gSlNPTi5wYXJzZSggLy8gQHRzLWV4cGVjdC1lcnJvciBKU09OLnBhcnNlKCkgcmVxdWlyZXMgYSBzdHJpbmcsIGJ1dCBpdCBhY3R1YWxseSBhY2NlcHRzIG51bGwsIHRvby5cbiAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oS0VZKSk7XG4gICAgICAgIHJldHVybiBjYWNoZSAmJiBpc0VxdWFsKGNhY2hlLnN0YXRlLCBnZXRTdGF0ZVdpdGhvdXRQYWdlKHN0YXRlKSkgPyBjYWNoZS5oaXRzIDogbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKEtFWSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7Ly8gZG8gbm90aGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKF9yZWYzKSB7XG4gICAgICB2YXIgc3RhdGUgPSBfcmVmMy5zdGF0ZSxcbiAgICAgICAgICBoaXRzID0gX3JlZjMuaGl0cztcblxuICAgICAgaWYgKCFoYXNTZXNzaW9uU3RvcmFnZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oS0VZLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgc3RhdGU6IGdldFN0YXRlV2l0aG91dFBhZ2Uoc3RhdGUpLFxuICAgICAgICAgIGhpdHM6IGhpdHNcbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBkbyBub3RoaW5nXG4gICAgICB9XG4gICAgfVxuICB9O1xufSIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyB1bmlxLCBmaW5kLCBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvciwgd2FybmluZyB9IGZyb20gJy4uL3V0aWxzJztcblxudmFyIGdldFNlbGVjdGVkSGl0cyA9IGZ1bmN0aW9uIGdldFNlbGVjdGVkSGl0cyhoaXRzLCBzZWxlY3RlZE9iamVjdElEcykge1xuICByZXR1cm4gc2VsZWN0ZWRPYmplY3RJRHMubWFwKGZ1bmN0aW9uIChvYmplY3RJRCkge1xuICAgIHZhciBoaXQgPSBmaW5kKGhpdHMsIGZ1bmN0aW9uIChoKSB7XG4gICAgICByZXR1cm4gaC5vYmplY3RJRCA9PT0gb2JqZWN0SUQ7XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGhpdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG9iamVjdElEIFxcXCJcIi5jb25jYXQob2JqZWN0SUQsIFwiXFxcIiBwYXNzZWQgdG8gYGNsaWNrZWRPYmplY3RJRHNBZnRlclNlYXJjaGAgaW4gdGhlIHJldHVybmVkIGhpdHMuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGluZmVyIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBhbmQgdGhlIHF1ZXJ5IElELlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpdDtcbiAgfSk7XG59O1xuXG52YXIgZ2V0UXVlcnlJRCA9IGZ1bmN0aW9uIGdldFF1ZXJ5SUQoc2VsZWN0ZWRIaXRzKSB7XG4gIHZhciBxdWVyeUlEcyA9IHVuaXEoc2VsZWN0ZWRIaXRzLm1hcChmdW5jdGlvbiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdC5fX3F1ZXJ5SUQ7XG4gIH0pKTtcblxuICBpZiAocXVlcnlJRHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5zaWdodHMgY3VycmVudGx5IGFsbG93cyBhIHNpbmdsZSBgcXVlcnlJRGAuIFRoZSBgb2JqZWN0SURzYCBwcm92aWRlZCBtYXAgdG8gbXVsdGlwbGUgYHF1ZXJ5SURgcy4nKTtcbiAgfVxuXG4gIHZhciBxdWVyeUlEID0gcXVlcnlJRHNbMF07XG5cbiAgaWYgKHR5cGVvZiBxdWVyeUlEICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBpbmZlciBgcXVlcnlJRGAuIEVuc3VyZSBJbnN0YW50U2VhcmNoIGBjbGlja0FuYWx5dGljczogdHJ1ZWAgd2FzIGFkZGVkIHdpdGggdGhlIENvbmZpZ3VyZSB3aWRnZXQuXFxuXFxuU2VlOiBodHRwczovL2FsZy5saS9sTmlaWjdcIik7XG4gIH1cblxuICByZXR1cm4gcXVlcnlJRDtcbn07XG5cbnZhciBnZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiBnZXRQb3NpdGlvbnMoc2VsZWN0ZWRIaXRzKSB7XG4gIHJldHVybiBzZWxlY3RlZEhpdHMubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICByZXR1cm4gaGl0Ll9fcG9zaXRpb247XG4gIH0pO1xufTtcblxuZXhwb3J0IHZhciBpbmZlclBheWxvYWQgPSBmdW5jdGlvbiBpbmZlclBheWxvYWQoX3JlZikge1xuICB2YXIgbWV0aG9kID0gX3JlZi5tZXRob2QsXG4gICAgICByZXN1bHRzID0gX3JlZi5yZXN1bHRzLFxuICAgICAgaGl0cyA9IF9yZWYuaGl0cyxcbiAgICAgIG9iamVjdElEcyA9IF9yZWYub2JqZWN0SURzO1xuICB2YXIgaW5kZXggPSByZXN1bHRzLmluZGV4O1xuICB2YXIgc2VsZWN0ZWRIaXRzID0gZ2V0U2VsZWN0ZWRIaXRzKGhpdHMsIG9iamVjdElEcyk7XG4gIHZhciBxdWVyeUlEID0gZ2V0UXVlcnlJRChzZWxlY3RlZEhpdHMpO1xuXG4gIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgY2FzZSAnY2xpY2tlZE9iamVjdElEc0FmdGVyU2VhcmNoJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGdldFBvc2l0aW9ucyhzZWxlY3RlZEhpdHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBxdWVyeUlEOiBxdWVyeUlELFxuICAgICAgICAgIG9iamVjdElEczogb2JqZWN0SURzLFxuICAgICAgICAgIHBvc2l0aW9uczogcG9zaXRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdjb252ZXJ0ZWRPYmplY3RJRHNBZnRlclNlYXJjaCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHF1ZXJ5SUQ6IHF1ZXJ5SUQsXG4gICAgICAgIG9iamVjdElEczogb2JqZWN0SURzXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG1ldGhvZCBwYXNzZWQgdG8gaW5zaWdodHM6IFxcXCJcIi5jb25jYXQobWV0aG9kLCBcIlxcXCIuXCIpKTtcbiAgfVxufTtcblxudmFyIHdyYXBJbnNpZ2h0c0NsaWVudCA9IGZ1bmN0aW9uIHdyYXBJbnNpZ2h0c0NsaWVudChhYSwgcmVzdWx0cywgaGl0cykge1xuICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgcGF5bG9hZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gd2FybmluZyhmYWxzZSwgXCJgaW5zaWdodHNgIGZ1bmN0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIEl0IGlzIHN0aWxsIHN1cHBvcnRlZCBpbiA0LnggcmVsZWFzZXMsIGJ1dCBub3QgZnVydGhlci4gSXQgaXMgcmVwbGFjZWQgYnkgdGhlIGBpbnNpZ2h0c2AgbWlkZGxld2FyZS5cXG5cXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9nZXR0aW5nLWluc2lnaHRzLWFuZC1hbmFseXRpY3Mvc2VhcmNoLWFuYWx5dGljcy9jbGljay10aHJvdWdoLWFuZC1jb252ZXJzaW9ucy9ob3ctdG8vc2VuZC1jbGljay1hbmQtY29udmVyc2lvbi1ldmVudHMtd2l0aC1pbnN0YW50c2VhcmNoL2pzL1wiKSA6IHZvaWQgMDtcblxuICAgIGlmICghYWEpIHtcbiAgICAgIHZhciB3aXRoSW5zdGFudFNlYXJjaFVzYWdlID0gY3JlYXRlRG9jdW1lbnRhdGlvbk1lc3NhZ2VHZW5lcmF0b3Ioe1xuICAgICAgICBuYW1lOiAnaW5zdGFudHNlYXJjaCdcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHdpdGhJbnN0YW50U2VhcmNoVXNhZ2UoJ1RoZSBgaW5zaWdodHNDbGllbnRgIG9wdGlvbiBoYXMgbm90IGJlZW4gcHJvdmlkZWQgdG8gYGluc3RhbnRzZWFyY2hgLicpKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF5bG9hZC5vYmplY3RJRHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgb2JqZWN0SURzYCB0byBiZSBhbiBhcnJheS4nKTtcbiAgICB9XG5cbiAgICB2YXIgaW5mZXJyZWRQYXlsb2FkID0gaW5mZXJQYXlsb2FkKHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgcmVzdWx0czogcmVzdWx0cyxcbiAgICAgIGhpdHM6IGhpdHMsXG4gICAgICBvYmplY3RJRHM6IHBheWxvYWQub2JqZWN0SURzXG4gICAgfSk7XG4gICAgYWEobWV0aG9kLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGluZmVycmVkUGF5bG9hZCksIHBheWxvYWQpKTtcbiAgfTtcbn07XG4vKipcbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdGlsbCBzdXBwb3J0ZWQgaW4gNC54IHJlbGVhc2VzLCBidXQgbm90IGZ1cnRoZXIuIEl0IGlzIHJlcGxhY2VkIGJ5IHRoZSBgaW5zaWdodHNgIG1pZGRsZXdhcmUuIEZvciBtb3JlIGluZm9ybWF0aW9uLCB2aXNpdCBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvZ3VpZGVzL2dldHRpbmctaW5zaWdodHMtYW5kLWFuYWx5dGljcy9zZWFyY2gtYW5hbHl0aWNzL2NsaWNrLXRocm91Z2gtYW5kLWNvbnZlcnNpb25zL2hvdy10by9zZW5kLWNsaWNrLWFuZC1jb252ZXJzaW9uLWV2ZW50cy13aXRoLWluc3RhbnRzZWFyY2gvanMvXG4gKiBJdCBwYXNzZXMgYGluc2lnaHRzYCB0byBgSGl0c1dpdGhJbnNpZ2h0c0xpc3RlbmVyYCBhbmQgYEluZmluaXRlSGl0c1dpdGhJbnNpZ2h0c0xpc3RlbmVyYC5cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhJbnNpZ2h0cyhjb25uZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZW5kZXJGbiwgdW5tb3VudEZuKSB7XG4gICAgcmV0dXJuIGNvbm5lY3RvcihmdW5jdGlvbiAocmVuZGVyT3B0aW9ucywgaXNGaXJzdFJlbmRlcikge1xuICAgICAgdmFyIHJlc3VsdHMgPSByZW5kZXJPcHRpb25zLnJlc3VsdHMsXG4gICAgICAgICAgaGl0cyA9IHJlbmRlck9wdGlvbnMuaGl0cyxcbiAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2UgPSByZW5kZXJPcHRpb25zLmluc3RhbnRTZWFyY2hJbnN0YW5jZTtcblxuICAgICAgaWYgKHJlc3VsdHMgJiYgaGl0cyAmJiBpbnN0YW50U2VhcmNoSW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIGluc2lnaHRzID0gd3JhcEluc2lnaHRzQ2xpZW50KGluc3RhbnRTZWFyY2hJbnN0YW5jZS5pbnNpZ2h0c0NsaWVudCwgcmVzdWx0cywgaGl0cyk7XG4gICAgICAgIHJldHVybiByZW5kZXJGbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlbmRlck9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGluc2lnaHRzOiBpbnNpZ2h0c1xuICAgICAgICB9KSwgaXNGaXJzdFJlbmRlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW5kZXJGbihyZW5kZXJPcHRpb25zLCBpc0ZpcnN0UmVuZGVyKTtcbiAgICB9LCB1bm1vdW50Rm4pO1xuICB9O1xufSIsIi8qKiBAanN4IGggKi9cbmltcG9ydCB7IGggfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVQYXlsb2FkIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcmVhZERhdGFBdHRyaWJ1dGVzLCBoYXNEYXRhQXR0cmlidXRlcyB9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5zaWdodHMnO1xuXG52YXIgZmluZEluc2lnaHRzVGFyZ2V0ID0gZnVuY3Rpb24gZmluZEluc2lnaHRzVGFyZ2V0KHN0YXJ0RWxlbWVudCwgZW5kRWxlbWVudCwgdmFsaWRhdG9yKSB7XG4gIHZhciBlbGVtZW50ID0gc3RhcnRFbGVtZW50O1xuXG4gIHdoaWxlIChlbGVtZW50ICYmICF2YWxpZGF0b3IoZWxlbWVudCkpIHtcbiAgICBpZiAoZWxlbWVudCA9PT0gZW5kRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxudmFyIHBhcnNlSW5zaWdodHNFdmVudCA9IGZ1bmN0aW9uIHBhcnNlSW5zaWdodHNFdmVudChlbGVtZW50KSB7XG4gIHZhciBzZXJpYWxpemVkUGF5bG9hZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluc2lnaHRzLWV2ZW50Jyk7XG5cbiAgaWYgKHR5cGVvZiBzZXJpYWxpemVkUGF5bG9hZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbnNpZ2h0cyBtaWRkbGV3YXJlIGV4cGVjdHMgYGRhdGEtaW5zaWdodHMtZXZlbnRgIHRvIGJlIGEgYmFzZTY0LWVuY29kZWQgSlNPTiBzdHJpbmcuJyk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZVBheWxvYWQoc2VyaWFsaXplZFBheWxvYWQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluc2lnaHRzIG1pZGRsZXdhcmUgd2FzIHVuYWJsZSB0byBwYXJzZSBgZGF0YS1pbnNpZ2h0cy1ldmVudGAuJyk7XG4gIH1cbn07XG5cbnZhciBpbnNpZ2h0c0xpc3RlbmVyID0gZnVuY3Rpb24gaW5zaWdodHNMaXN0ZW5lcihCYXNlQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIFdpdGhJbnNpZ2h0c0xpc3RlbmVyKHByb3BzKSB7XG4gICAgdmFyIGhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgIGlmIChwcm9wcy5zZW5kRXZlbnQpIHtcbiAgICAgICAgLy8gbmV3IHdheSB3aXRoIGluc2lnaHRzIG1pZGRsZXdhcmVcbiAgICAgICAgdmFyIHRhcmdldFdpdGhFdmVudCA9IGZpbmRJbnNpZ2h0c1RhcmdldChldmVudC50YXJnZXQsIGV2ZW50LmN1cnJlbnRUYXJnZXQsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLWluc2lnaHRzLWV2ZW50Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0YXJnZXRXaXRoRXZlbnQpIHtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IHBhcnNlSW5zaWdodHNFdmVudCh0YXJnZXRXaXRoRXZlbnQpO1xuICAgICAgICAgIHByb3BzLnNlbmRFdmVudChwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBvbGQgd2F5LCBlLmcuIGluc3RhbnRzZWFyY2guaW5zaWdodHMoXCJjbGlja2VkT2JqZWN0SURzQWZ0ZXJTZWFyY2hcIiwgeyAuLiB9KVxuXG5cbiAgICAgIHZhciBpbnNpZ2h0c1RhcmdldCA9IGZpbmRJbnNpZ2h0c1RhcmdldChldmVudC50YXJnZXQsIGV2ZW50LmN1cnJlbnRUYXJnZXQsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBoYXNEYXRhQXR0cmlidXRlcyhlbGVtZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5zaWdodHNUYXJnZXQpIHtcbiAgICAgICAgdmFyIF9yZWFkRGF0YUF0dHJpYnV0ZXMgPSByZWFkRGF0YUF0dHJpYnV0ZXMoaW5zaWdodHNUYXJnZXQpLFxuICAgICAgICAgICAgbWV0aG9kID0gX3JlYWREYXRhQXR0cmlidXRlcy5tZXRob2QsXG4gICAgICAgICAgICBfcGF5bG9hZCA9IF9yZWFkRGF0YUF0dHJpYnV0ZXMucGF5bG9hZDtcblxuICAgICAgICBwcm9wcy5pbnNpZ2h0cyhtZXRob2QsIF9wYXlsb2FkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGgoXCJkaXZcIiwge1xuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2tcbiAgICB9LCBoKEJhc2VDb21wb25lbnQsIHByb3BzKSk7XG4gIH1cblxuICByZXR1cm4gV2l0aEluc2lnaHRzTGlzdGVuZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbnNpZ2h0c0xpc3RlbmVyOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IHFzIGZyb20gJ3FzJztcblxudmFyIHNldFdpbmRvd1RpdGxlID0gZnVuY3Rpb24gc2V0V2luZG93VGl0bGUodGl0bGUpIHtcbiAgaWYgKHRpdGxlKSB7XG4gICAgd2luZG93LmRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG4gIH1cbn07XG5cbnZhciBCcm93c2VySGlzdG9yeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBzdG9yYWdlIHByb3ZpZGVyIHRoYXQgc3luY3MgdGhlIHNlYXJjaCBzdGF0ZSB0byB0aGUgVVJMXG4gICAqIHVzaW5nIHdlYiBBUElzIChgd2luZG93LmxvY2F0aW9uLnB1c2hTdGF0ZWAgYW5kIGBvbnBvcHN0YXRlYCBldmVudCkuXG4gICAqL1xuICBmdW5jdGlvbiBCcm93c2VySGlzdG9yeShfcmVmKSB7XG4gICAgdmFyIHdpbmRvd1RpdGxlID0gX3JlZi53aW5kb3dUaXRsZSxcbiAgICAgICAgX3JlZiR3cml0ZURlbGF5ID0gX3JlZi53cml0ZURlbGF5LFxuICAgICAgICB3cml0ZURlbGF5ID0gX3JlZiR3cml0ZURlbGF5ID09PSB2b2lkIDAgPyA0MDAgOiBfcmVmJHdyaXRlRGVsYXksXG4gICAgICAgIGNyZWF0ZVVSTCA9IF9yZWYuY3JlYXRlVVJMLFxuICAgICAgICBwYXJzZVVSTCA9IF9yZWYucGFyc2VVUkw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJvd3Nlckhpc3RvcnkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93VGl0bGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndyaXRlRGVsYXlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jcmVhdGVVUkxcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcnNlVVJMXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZVRpbWVyXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLndpbmRvd1RpdGxlID0gd2luZG93VGl0bGU7XG4gICAgdGhpcy53cml0ZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud3JpdGVEZWxheSA9IHdyaXRlRGVsYXk7XG4gICAgdGhpcy5fY3JlYXRlVVJMID0gY3JlYXRlVVJMO1xuICAgIHRoaXMucGFyc2VVUkwgPSBwYXJzZVVSTDtcbiAgICB2YXIgdGl0bGUgPSB0aGlzLndpbmRvd1RpdGxlICYmIHRoaXMud2luZG93VGl0bGUodGhpcy5yZWFkKCkpO1xuICAgIHNldFdpbmRvd1RpdGxlKHRpdGxlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZHMgdGhlIFVSTCBhbmQgcmV0dXJucyBhIHN5bmNhYmxlIFVJIHNlYXJjaCBzdGF0ZS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQnJvd3Nlckhpc3RvcnksIFt7XG4gICAga2V5OiBcInJlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVVJMKHtcbiAgICAgICAgcXNNb2R1bGU6IHFzLFxuICAgICAgICBsb2NhdGlvbjogd2luZG93LmxvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgc2VhcmNoIHN0YXRlIGludG8gdGhlIFVSTC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKHJvdXRlU3RhdGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB1cmwgPSB0aGlzLmNyZWF0ZVVSTChyb3V0ZVN0YXRlKTtcbiAgICAgIHZhciB0aXRsZSA9IHRoaXMud2luZG93VGl0bGUgJiYgdGhpcy53aW5kb3dUaXRsZShyb3V0ZVN0YXRlKTtcblxuICAgICAgaWYgKHRoaXMud3JpdGVUaW1lcikge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMud3JpdGVUaW1lcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud3JpdGVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0V2luZG93VGl0bGUodGl0bGUpO1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUocm91dGVTdGF0ZSwgdGl0bGUgfHwgJycsIHVybCk7XG4gICAgICAgIF90aGlzLndyaXRlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9LCB0aGlzLndyaXRlRGVsYXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY2FsbGJhY2sgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudCBvZiB0aGUgaGlzdG9yeSBBUEkgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgKiBJdCBlbmFibGVzIHRoZSBVUkwgc3luYyB0byBrZWVwIHRyYWNrIG9mIHRoZSBjaGFuZ2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25VcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25VcGRhdGUoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9vblBvcFN0YXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpczIud3JpdGVUaW1lcikge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoX3RoaXMyLndyaXRlVGltZXIpO1xuICAgICAgICAgIF90aGlzMi53cml0ZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdXRlU3RhdGUgPSBldmVudC5zdGF0ZTsgLy8gQXQgaW5pdGlhbCBsb2FkLCB0aGUgc3RhdGUgaXMgcmVhZCBmcm9tIHRoZSBVUkwgd2l0aG91dCB1cGRhdGUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB0aGUgc3RhdGUgb2JqZWN0IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgZmFsbGJhY2sgYW5kIHJlYWQgdGhlIFVSTC5cblxuICAgICAgICBpZiAoIXJvdXRlU3RhdGUpIHtcbiAgICAgICAgICBjYWxsYmFjayhfdGhpczIucmVhZCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhyb3V0ZVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5fb25Qb3BTdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wbGV0ZSBVUkwgZnJvbSBhIGdpdmVuIHN5bmNhYmxlIFVJIHN0YXRlLlxuICAgICAqXG4gICAgICogSXQgYWx3YXlzIGdlbmVyYXRlcyB0aGUgZnVsbCBVUkwsIG5vdCBhIHJlbGF0aXZlIG9uZS5cbiAgICAgKiBUaGlzIGFsbG93cyB0byBoYW5kbGUgY2FzZXMgbGlrZSB1c2luZyBhIDxiYXNlIGhyZWY+LlxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvaW5zdGFudHNlYXJjaC5qcy9pc3N1ZXMvNzkwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVVUkxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVVJMKHJvdXRlU3RhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVVUkwoe1xuICAgICAgICBxc01vZHVsZTogcXMsXG4gICAgICAgIHJvdXRlU3RhdGU6IHJvdXRlU3RhdGUsXG4gICAgICAgIGxvY2F0aW9uOiB3aW5kb3cubG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW5zIHVwIHRoZSBVUkwuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICBpZiAodGhpcy5fb25Qb3BTdGF0ZSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLl9vblBvcFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud3JpdGVUaW1lcikge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMud3JpdGVUaW1lcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud3JpdGUoe30pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcm93c2VySGlzdG9yeTtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGlzdG9yeVJvdXRlcigpIHtcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYyJGNyZWF0ZVVSTCA9IF9yZWYyLmNyZWF0ZVVSTCxcbiAgICAgIGNyZWF0ZVVSTCA9IF9yZWYyJGNyZWF0ZVVSTCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIHFzTW9kdWxlID0gX3JlZjMucXNNb2R1bGUsXG4gICAgICAgIHJvdXRlU3RhdGUgPSBfcmVmMy5yb3V0ZVN0YXRlLFxuICAgICAgICBsb2NhdGlvbiA9IF9yZWYzLmxvY2F0aW9uO1xuICAgIHZhciBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sLFxuICAgICAgICBob3N0bmFtZSA9IGxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgICBfbG9jYXRpb24kcG9ydCA9IGxvY2F0aW9uLnBvcnQsXG4gICAgICAgIHBvcnQgPSBfbG9jYXRpb24kcG9ydCA9PT0gdm9pZCAwID8gJycgOiBfbG9jYXRpb24kcG9ydCxcbiAgICAgICAgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHF1ZXJ5U3RyaW5nID0gcXNNb2R1bGUuc3RyaW5naWZ5KHJvdXRlU3RhdGUpO1xuICAgIHZhciBwb3J0V2l0aFByZWZpeCA9IHBvcnQgPT09ICcnID8gJycgOiBcIjpcIi5jb25jYXQocG9ydCk7IC8vIElFIDw9IDExIGhhcyBubyBwcm9wZXIgYGxvY2F0aW9uLm9yaWdpbmAgc28gd2UgY2Fubm90IHJlbHkgb24gaXQuXG5cbiAgICAvLyBJRSA8PSAxMSBoYXMgbm8gcHJvcGVyIGBsb2NhdGlvbi5vcmlnaW5gIHNvIHdlIGNhbm5vdCByZWx5IG9uIGl0LlxuICAgIGlmICghcXVlcnlTdHJpbmcpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcm90b2NvbCwgXCIvL1wiKS5jb25jYXQoaG9zdG5hbWUpLmNvbmNhdChwb3J0V2l0aFByZWZpeCkuY29uY2F0KHBhdGhuYW1lKS5jb25jYXQoaGFzaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHByb3RvY29sLCBcIi8vXCIpLmNvbmNhdChob3N0bmFtZSkuY29uY2F0KHBvcnRXaXRoUHJlZml4KS5jb25jYXQocGF0aG5hbWUsIFwiP1wiKS5jb25jYXQocXVlcnlTdHJpbmcpLmNvbmNhdChoYXNoKTtcbiAgfSA6IF9yZWYyJGNyZWF0ZVVSTCxcbiAgICAgIF9yZWYyJHBhcnNlVVJMID0gX3JlZjIucGFyc2VVUkwsXG4gICAgICBwYXJzZVVSTCA9IF9yZWYyJHBhcnNlVVJMID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICB2YXIgcXNNb2R1bGUgPSBfcmVmNC5xc01vZHVsZSxcbiAgICAgICAgbG9jYXRpb24gPSBfcmVmNC5sb2NhdGlvbjtcbiAgICAvLyBgcXNgIGJ5IGRlZmF1bHQgY29udmVydHMgYXJyYXlzIHdpdGggbW9yZSB0aGFuIDIwIGl0ZW1zIHRvIGFuIG9iamVjdC5cbiAgICAvLyBXZSB3YW50IHRvIGF2b2lkIHRoaXMgYmVjYXVzZSB0aGUgZGF0YSBzdHJ1Y3R1cmUgbWFuaXB1bGF0ZWQgY2FuIHRoZXJlZm9yZSB2YXJ5LlxuICAgIC8vIFNldHRpbmcgdGhlIGxpbWl0IHRvIGAxMDBgIHNlZW1zIGEgZ29vZCBudW1iZXIgYmVjYXVzZSB0aGUgZW5naW5lJ3MgZGVmYXVsdCBpcyAxMDBcbiAgICAvLyAoaXQgY2FuIGdvIHVwIHRvIDEwMDAgYnV0IGl0IGlzIHZlcnkgdW5saWtlbHkgdG8gc2VsZWN0IG1vcmUgdGhhbiAxMDAgaXRlbXMgaW4gdGhlIFVJKS5cbiAgICAvL1xuICAgIC8vIFVzaW5nIGFuIGBhcnJheUxpbWl0YCBvZiBgbmAgYWxsb3dzIGBuICsgMWAgaXRlbXMuXG4gICAgLy9cbiAgICAvLyBTZWU6XG4gICAgLy8gICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcXMjcGFyc2luZy1hcnJheXNcbiAgICAvLyAgIC0gaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2FwaS1yZWZlcmVuY2UvYXBpLXBhcmFtZXRlcnMvbWF4VmFsdWVzUGVyRmFjZXQvXG4gICAgcmV0dXJuIHFzTW9kdWxlLnBhcnNlKGxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKSwge1xuICAgICAgYXJyYXlMaW1pdDogOTlcbiAgICB9KTtcbiAgfSA6IF9yZWYyJHBhcnNlVVJMLFxuICAgICAgX3JlZjIkd3JpdGVEZWxheSA9IF9yZWYyLndyaXRlRGVsYXksXG4gICAgICB3cml0ZURlbGF5ID0gX3JlZjIkd3JpdGVEZWxheSA9PT0gdm9pZCAwID8gNDAwIDogX3JlZjIkd3JpdGVEZWxheSxcbiAgICAgIHdpbmRvd1RpdGxlID0gX3JlZjIud2luZG93VGl0bGU7XG5cbiAgcmV0dXJuIG5ldyBCcm93c2VySGlzdG9yeSh7XG4gICAgY3JlYXRlVVJMOiBjcmVhdGVVUkwsXG4gICAgcGFyc2VVUkw6IHBhcnNlVVJMLFxuICAgIHdyaXRlRGVsYXk6IHdyaXRlRGVsYXksXG4gICAgd2luZG93VGl0bGU6IHdpbmRvd1RpdGxlXG4gIH0pO1xufSIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBnZXRJbmRleFN0YXRlV2l0aG91dENvbmZpZ3VyZSh1aVN0YXRlKSB7XG4gIHZhciBjb25maWd1cmUgPSB1aVN0YXRlLmNvbmZpZ3VyZSxcbiAgICAgIHRyYWNrZWRVaVN0YXRlID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHVpU3RhdGUsIFtcImNvbmZpZ3VyZVwiXSk7XG5cbiAgcmV0dXJuIHRyYWNrZWRVaVN0YXRlO1xufSAvLyB0ZWNobmljYWxseSBhIFVSTCBjb3VsZCBjb250YWluIGFueSBrZXksIHNpbmNlIHVzZXJzIHByb3ZpZGUgaXQsXG4vLyB3aGljaCBpcyB3aHkgdGhlIGlucHV0IHRvIHRoaXMgZnVuY3Rpb24gaXMgVWlTdGF0ZSwgbm90IHNvbWV0aGluZ1xuLy8gd2hpY2ggZXhjbHVkZXMgXCJjb25maWd1cmVcIiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2ltcGxlU3RhdGVNYXBwaW5nKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRlVG9Sb3V0ZTogZnVuY3Rpb24gc3RhdGVUb1JvdXRlKHVpU3RhdGUpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh1aVN0YXRlKS5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBpbmRleElkKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0YXRlKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgaW5kZXhJZCwgZ2V0SW5kZXhTdGF0ZVdpdGhvdXRDb25maWd1cmUodWlTdGF0ZVtpbmRleElkXSkpKTtcbiAgICAgIH0sIHt9KTtcbiAgICB9LFxuICAgIHJvdXRlVG9TdGF0ZTogZnVuY3Rpb24gcm91dGVUb1N0YXRlKCkge1xuICAgICAgdmFyIHJvdXRlU3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvdXRlU3RhdGUpLnJlZHVjZShmdW5jdGlvbiAoc3RhdGUsIGluZGV4SWQpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RhdGUpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBpbmRleElkLCBnZXRJbmRleFN0YXRlV2l0aG91dENvbmZpZ3VyZShyb3V0ZVN0YXRlW2luZGV4SWRdKSkpO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgfTtcbn0iLCJ2YXIgTkFNRVNQQUNFID0gJ2Fpcyc7XG5leHBvcnQgdmFyIGNvbXBvbmVudCA9IGZ1bmN0aW9uIGNvbXBvbmVudChjb21wb25lbnROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBkZXNjZW5kYW50TmFtZSA9IF9yZWYuZGVzY2VuZGFudE5hbWUsXG4gICAgICAgIG1vZGlmaWVyTmFtZSA9IF9yZWYubW9kaWZpZXJOYW1lO1xuXG4gICAgdmFyIGRlc2NlbmRlbnQgPSBkZXNjZW5kYW50TmFtZSA/IFwiLVwiLmNvbmNhdChkZXNjZW5kYW50TmFtZSkgOiAnJztcbiAgICB2YXIgbW9kaWZpZXIgPSBtb2RpZmllck5hbWUgPyBcIi0tXCIuY29uY2F0KG1vZGlmaWVyTmFtZSkgOiAnJztcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1cIikuY29uY2F0KGNvbXBvbmVudE5hbWUpLmNvbmNhdChkZXNjZW5kZW50KS5jb25jYXQobW9kaWZpZXIpO1xuICB9O1xufTsiLCJmdW5jdGlvbiBjYXBpdGFsaXplKHRleHQpIHtcbiAgcmV0dXJuIHRleHQudG9TdHJpbmcoKS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleHQudG9TdHJpbmcoKS5zbGljZSgxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FwaXRhbGl6ZTsiLCJmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuL2NhcGl0YWxpemUnO1xuaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IGtleXMgfSBmcm9tICcuL3R5cGVkT2JqZWN0JzsgLy8gU29tZSBjb25uZWN0b3JzIGFyZSByZXNwb25zaWJsZSBmb3IgbXVsdGlwbGUgd2lkZ2V0cyBzbyB3ZSBuZWVkXG4vLyB0byBtYXAgdGhlbS5cblxuZnVuY3Rpb24gZ2V0V2lkZ2V0TmFtZXMoY29ubmVjdG9yTmFtZSkge1xuICBzd2l0Y2ggKGNvbm5lY3Rvck5hbWUpIHtcbiAgICBjYXNlICdyYW5nZSc6XG4gICAgICByZXR1cm4gW107XG5cbiAgICBjYXNlICdtZW51JzpcbiAgICAgIHJldHVybiBbJ21lbnUnLCAnbWVudVNlbGVjdCddO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbY29ubmVjdG9yTmFtZV07XG4gIH1cbn1cblxudmFyIHN0YXRlVG9XaWRnZXRzTWFwID0ge1xuICBxdWVyeToge1xuICAgIGNvbm5lY3RvcnM6IFsnY29ubmVjdFNlYXJjaEJveCddLFxuICAgIHdpZGdldHM6IFsnYWlzLnNlYXJjaEJveCcsICdhaXMuYXV0b2NvbXBsZXRlJywgJ2Fpcy52b2ljZVNlYXJjaCddXG4gIH0sXG4gIHJlZmluZW1lbnRMaXN0OiB7XG4gICAgY29ubmVjdG9yczogWydjb25uZWN0UmVmaW5lbWVudExpc3QnXSxcbiAgICB3aWRnZXRzOiBbJ2Fpcy5yZWZpbmVtZW50TGlzdCddXG4gIH0sXG4gIG1lbnU6IHtcbiAgICBjb25uZWN0b3JzOiBbJ2Nvbm5lY3RNZW51J10sXG4gICAgd2lkZ2V0czogWydhaXMubWVudSddXG4gIH0sXG4gIGhpZXJhcmNoaWNhbE1lbnU6IHtcbiAgICBjb25uZWN0b3JzOiBbJ2Nvbm5lY3RIaWVyYXJjaGljYWxNZW51J10sXG4gICAgd2lkZ2V0czogWydhaXMuaGllcmFyY2hpY2FsTWVudSddXG4gIH0sXG4gIG51bWVyaWNNZW51OiB7XG4gICAgY29ubmVjdG9yczogWydjb25uZWN0TnVtZXJpY01lbnUnXSxcbiAgICB3aWRnZXRzOiBbJ2Fpcy5udW1lcmljTWVudSddXG4gIH0sXG4gIHJhdGluZ01lbnU6IHtcbiAgICBjb25uZWN0b3JzOiBbJ2Nvbm5lY3RSYXRpbmdNZW51J10sXG4gICAgd2lkZ2V0czogWydhaXMucmF0aW5nTWVudSddXG4gIH0sXG4gIHJhbmdlOiB7XG4gICAgY29ubmVjdG9yczogWydjb25uZWN0UmFuZ2UnXSxcbiAgICB3aWRnZXRzOiBbJ2Fpcy5yYW5nZUlucHV0JywgJ2Fpcy5yYW5nZVNsaWRlcicsICdhaXMucmFuZ2UnXVxuICB9LFxuICB0b2dnbGU6IHtcbiAgICBjb25uZWN0b3JzOiBbJ2Nvbm5lY3RUb2dnbGVSZWZpbmVtZW50J10sXG4gICAgd2lkZ2V0czogWydhaXMudG9nZ2xlUmVmaW5lbWVudCddXG4gIH0sXG4gIGdlb1NlYXJjaDoge1xuICAgIGNvbm5lY3RvcnM6IFsnY29ubmVjdEdlb1NlYXJjaCddLFxuICAgIHdpZGdldHM6IFsnYWlzLmdlb1NlYXJjaCddXG4gIH0sXG4gIHNvcnRCeToge1xuICAgIGNvbm5lY3RvcnM6IFsnY29ubmVjdFNvcnRCeSddLFxuICAgIHdpZGdldHM6IFsnYWlzLnNvcnRCeSddXG4gIH0sXG4gIHBhZ2U6IHtcbiAgICBjb25uZWN0b3JzOiBbJ2Nvbm5lY3RQYWdpbmF0aW9uJ10sXG4gICAgd2lkZ2V0czogWydhaXMucGFnaW5hdGlvbicsICdhaXMuaW5maW5pdGVIaXRzJ11cbiAgfSxcbiAgaGl0c1BlclBhZ2U6IHtcbiAgICBjb25uZWN0b3JzOiBbJ2Nvbm5lY3RIaXRzUGVyUGFnZSddLFxuICAgIHdpZGdldHM6IFsnYWlzLmhpdHNQZXJQYWdlJ11cbiAgfSxcbiAgY29uZmlndXJlOiB7XG4gICAgY29ubmVjdG9yczogWydjb25uZWN0Q29uZmlndXJlJ10sXG4gICAgd2lkZ2V0czogWydhaXMuY29uZmlndXJlJ11cbiAgfSxcbiAgcGxhY2VzOiB7XG4gICAgY29ubmVjdG9yczogW10sXG4gICAgd2lkZ2V0czogWydhaXMucGxhY2VzJ11cbiAgfVxufTtcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0luZGV4VWlTdGF0ZShfcmVmKSB7XG4gIHZhciBpbmRleCA9IF9yZWYuaW5kZXgsXG4gICAgICBpbmRleFVpU3RhdGUgPSBfcmVmLmluZGV4VWlTdGF0ZTtcbiAgdmFyIG1vdW50ZWRXaWRnZXRzID0gaW5kZXguZ2V0V2lkZ2V0cygpLm1hcChmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgcmV0dXJuIHdpZGdldC4kJHR5cGU7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgdmFyIG1pc3NpbmdXaWRnZXRzID0ga2V5cyhpbmRleFVpU3RhdGUpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwYXJhbWV0ZXIpIHtcbiAgICB2YXIgd2lkZ2V0VWlTdGF0ZSA9IHN0YXRlVG9XaWRnZXRzTWFwW3BhcmFtZXRlcl07XG5cbiAgICBpZiAoIXdpZGdldFVpU3RhdGUpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVpcmVkV2lkZ2V0cyA9IHdpZGdldFVpU3RhdGUud2lkZ2V0cztcblxuICAgIGlmIChyZXF1aXJlZFdpZGdldHMgJiYgIXJlcXVpcmVkV2lkZ2V0cy5zb21lKGZ1bmN0aW9uIChyZXF1aXJlZFdpZGdldCkge1xuICAgICAgcmV0dXJuIG1vdW50ZWRXaWRnZXRzLmluY2x1ZGVzKHJlcXVpcmVkV2lkZ2V0KTtcbiAgICB9KSkge1xuICAgICAgYWNjLnB1c2goW3BhcmFtZXRlciwge1xuICAgICAgICBjb25uZWN0b3JzOiB3aWRnZXRVaVN0YXRlLmNvbm5lY3RvcnMsXG4gICAgICAgIHdpZGdldHM6IHdpZGdldFVpU3RhdGUud2lkZ2V0cy5tYXAoZnVuY3Rpb24gKHdpZGdldElkZW50aWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gd2lkZ2V0SWRlbnRpZmllci5zcGxpdCgnYWlzLicpWzFdO1xuICAgICAgICB9KVxuICAgICAgfV0pO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyB3YXJuaW5nKG1pc3NpbmdXaWRnZXRzLmxlbmd0aCA9PT0gMCwgXCJUaGUgVUkgc3RhdGUgZm9yIHRoZSBpbmRleCBcXFwiXCIuY29uY2F0KGluZGV4LmdldEluZGV4SWQoKSwgXCJcXFwiIGlzIG5vdCBjb25zaXN0ZW50IHdpdGggdGhlIHdpZGdldHMgbW91bnRlZC5cXG5cXG5UaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgVUkgc3RhdGUgaXMgc3BlY2lmaWVkIHZpYSBgaW5pdGlhbFVpU3RhdGVgLCBgcm91dGluZ2Agb3IgYHNldFVpU3RhdGVgIGJ1dCB0aGF0IHRoZSB3aWRnZXRzIHJlc3BvbnNpYmxlIGZvciB0aGlzIHN0YXRlIHdlcmUgbm90IGFkZGVkLiBUaGlzIHJlc3VsdHMgaW4gdGhvc2UgcXVlcnkgcGFyYW1ldGVycyBub3QgYmVpbmcgc2VudCB0byB0aGUgQVBJLlxcblxcblRvIGZ1bGx5IHJlZmxlY3QgdGhlIHN0YXRlLCBzb21lIHdpZGdldHMgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgaW5kZXggXFxcIlwiKS5jb25jYXQoaW5kZXguZ2V0SW5kZXhJZCgpLCBcIlxcXCI6XFxuXFxuXCIpLmNvbmNhdChtaXNzaW5nV2lkZ2V0cy5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIF9yZWY0O1xuXG4gICAgdmFyIF9yZWYzID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLFxuICAgICAgICBzdGF0ZVBhcmFtZXRlciA9IF9yZWYzWzBdLFxuICAgICAgICB3aWRnZXRzID0gX3JlZjNbMV0ud2lkZ2V0cztcblxuICAgIHJldHVybiBcIi0gYFwiLmNvbmNhdChzdGF0ZVBhcmFtZXRlciwgXCJgIG5lZWRzIG9uZSBvZiB0aGVzZSB3aWRnZXRzOiBcIikuY29uY2F0KChfcmVmNCA9IFtdKS5jb25jYXQuYXBwbHkoX3JlZjQsIF90b0NvbnN1bWFibGVBcnJheSh3aWRnZXRzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGdldFdpZGdldE5hbWVzKG5hbWUpO1xuICAgIH0pKSkubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIlwiKTtcbiAgICB9KS5qb2luKCcsICcpKTtcbiAgfSkuam9pbignXFxuJyksIFwiXFxuXFxuSWYgeW91IGRvIG5vdCB3aXNoIHRvIGRpc3BsYXkgd2lkZ2V0cyBidXQgc3RpbGwgd2FudCB0byBzdXBwb3J0IHRoZWlyIHNlYXJjaCBwYXJhbWV0ZXJzLCB5b3UgY2FuIG1vdW50IFxcXCJ2aXJ0dWFsIHdpZGdldHNcXFwiIHRoYXQgZG9uJ3QgcmVuZGVyIGFueXRoaW5nOlxcblxcbmBgYFxcblwiKS5jb25jYXQobWlzc2luZ1dpZGdldHMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKSxcbiAgICAgICAgX3N0YXRlUGFyYW1ldGVyID0gX3JlZjZbMF0sXG4gICAgICAgIGNvbm5lY3RvcnMgPSBfcmVmNlsxXS5jb25uZWN0b3JzO1xuXG4gICAgcmV0dXJuIGNvbm5lY3RvcnMubGVuZ3RoID4gMDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmNykge1xuICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAyKSxcbiAgICAgICAgX3N0YXRlUGFyYW1ldGVyID0gX3JlZjhbMF0sXG4gICAgICAgIF9yZWY4JCA9IF9yZWY4WzFdLFxuICAgICAgICBjb25uZWN0b3JzID0gX3JlZjgkLmNvbm5lY3RvcnMsXG4gICAgICAgIHdpZGdldHMgPSBfcmVmOCQud2lkZ2V0cztcblxuICAgIHZhciBjYXBpdGFsaXplZFdpZGdldCA9IGNhcGl0YWxpemUod2lkZ2V0c1swXSk7XG4gICAgdmFyIGNvbm5lY3Rvck5hbWUgPSBjb25uZWN0b3JzWzBdO1xuICAgIHJldHVybiBcImNvbnN0IHZpcnR1YWxcIi5jb25jYXQoY2FwaXRhbGl6ZWRXaWRnZXQsIFwiID0gXCIpLmNvbmNhdChjb25uZWN0b3JOYW1lLCBcIigoKSA9PiBudWxsKTtcIik7XG4gIH0pLmpvaW4oJ1xcbicpLCBcIlxcblxcbnNlYXJjaC5hZGRXaWRnZXRzKFtcXG4gIFwiKS5jb25jYXQobWlzc2luZ1dpZGdldHMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmOSkge1xuICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMiksXG4gICAgICAgIF9zdGF0ZVBhcmFtZXRlciA9IF9yZWYxMFswXSxcbiAgICAgICAgY29ubmVjdG9ycyA9IF9yZWYxMFsxXS5jb25uZWN0b3JzO1xuXG4gICAgcmV0dXJuIGNvbm5lY3RvcnMubGVuZ3RoID4gMDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmMTEpIHtcbiAgICB2YXIgX3JlZjEyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjExLCAyKSxcbiAgICAgICAgX3N0YXRlUGFyYW1ldGVyID0gX3JlZjEyWzBdLFxuICAgICAgICB3aWRnZXRzID0gX3JlZjEyWzFdLndpZGdldHM7XG5cbiAgICB2YXIgY2FwaXRhbGl6ZWRXaWRnZXQgPSBjYXBpdGFsaXplKHdpZGdldHNbMF0pO1xuICAgIHJldHVybiBcInZpcnR1YWxcIi5jb25jYXQoY2FwaXRhbGl6ZWRXaWRnZXQsIFwiKHsgLyogLi4uICovIH0pXCIpO1xuICB9KS5qb2luKCcsXFxuICAnKSwgXCJcXG5dKTtcXG5gYGBcXG5cXG5JZiB5b3UncmUgdXNpbmcgY3VzdG9tIHdpZGdldHMgdGhhdCBkbyBzZXQgdGhlc2UgcXVlcnkgcGFyYW1ldGVycywgd2UgcmVjb21tZW5kIHVzaW5nIGNvbm5lY3RvcnMgaW5zdGVhZC5cXG5cXG5TZWUgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9idWlsZGluZy1zZWFyY2gtdWkvd2lkZ2V0cy9jdXN0b21pemUtYW4tZXhpc3Rpbmctd2lkZ2V0L2pzLyNjdXN0b21pemUtdGhlLWNvbXBsZXRlLXVpLW9mLXRoZS13aWRnZXRzXCIpKSA6IHZvaWQgMDtcbn0iLCJpbXBvcnQgZ2V0T2JqZWN0VHlwZSBmcm9tICcuL2dldE9iamVjdFR5cGUnO1xuXG5mdW5jdGlvbiBjaGVja1JlbmRlcmluZyhyZW5kZXJpbmcsIHVzYWdlKSB7XG4gIGlmIChyZW5kZXJpbmcgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgcmVuZGVyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlbmRlciBmdW5jdGlvbiBpcyBub3QgdmFsaWQgKHJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KGdldE9iamVjdFR5cGUocmVuZGVyaW5nKSwgXCIpLlxcblxcblwiKS5jb25jYXQodXNhZ2UpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjaGVja1JlbmRlcmluZzsiLCJpbXBvcnQgeyBUQUdfUkVQTEFDRU1FTlQgfSBmcm9tICcuL2VzY2FwZS1oaWdobGlnaHQnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uY2F0SGlnaGxpZ2h0ZWRQYXJ0cyhwYXJ0cykge1xuICB2YXIgaGlnaGxpZ2h0UHJlVGFnID0gVEFHX1JFUExBQ0VNRU5ULmhpZ2hsaWdodFByZVRhZyxcbiAgICAgIGhpZ2hsaWdodFBvc3RUYWcgPSBUQUdfUkVQTEFDRU1FTlQuaGlnaGxpZ2h0UG9zdFRhZztcbiAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiBwYXJ0LmlzSGlnaGxpZ2h0ZWQgPyBoaWdobGlnaHRQcmVUYWcgKyBwYXJ0LnZhbHVlICsgaGlnaGxpZ2h0UG9zdFRhZyA6IHBhcnQudmFsdWU7XG4gIH0pLmpvaW4oJycpO1xufSIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuaW1wb3J0IHsgc2VyaWFsaXplUGF5bG9hZCB9IGZyb20gJy4uLy4uL2xpYi91dGlscy9zZXJpYWxpemVyJztcblxudmFyIGJ1aWxkUGF5bG9hZCA9IGZ1bmN0aW9uIGJ1aWxkUGF5bG9hZChfcmVmKSB7XG4gIHZhciBpbmRleCA9IF9yZWYuaW5kZXgsXG4gICAgICB3aWRnZXRUeXBlID0gX3JlZi53aWRnZXRUeXBlLFxuICAgICAgbWV0aG9kTmFtZSA9IF9yZWYubWV0aG9kTmFtZSxcbiAgICAgIGFyZ3MgPSBfcmVmLmFyZ3M7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIF90eXBlb2YoYXJnc1swXSkgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIH1cblxuICB2YXIgZXZlbnRUeXBlID0gYXJnc1swXTtcbiAgdmFyIGhpdHMgPSBhcmdzWzFdO1xuICB2YXIgZXZlbnROYW1lID0gYXJnc1syXTtcblxuICBpZiAoIWhpdHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHBhc3MgaGl0IG9yIGhpdHMgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBsaWtlOlxcbiAgXCIuY29uY2F0KG1ldGhvZE5hbWUsIFwiKGV2ZW50VHlwZSwgaGl0KTtcXG4gIFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICgoZXZlbnRUeXBlID09PSAnY2xpY2snIHx8IGV2ZW50VHlwZSA9PT0gJ2NvbnZlcnNpb24nKSAmJiAhZXZlbnROYW1lKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBwYXNzIGV2ZW50TmFtZSBhcyB0aGUgdGhpcmQgYXJndW1lbnQgZm9yICdjbGljaycgb3IgJ2NvbnZlcnNpb24nIGV2ZW50cyBsaWtlOlxcbiAgXCIuY29uY2F0KG1ldGhvZE5hbWUsIFwiKCdjbGljaycsIGhpdCwgJ1Byb2R1Y3QgUHVyY2hhc2VkJyk7XFxuXFxuICBUbyBsZWFybiBtb3JlIGFib3V0IGV2ZW50IG5hbWluZzogaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2d1aWRlcy9nZXR0aW5nLWluc2lnaHRzLWFuZC1hbmFseXRpY3Mvc2VhcmNoLWFuYWx5dGljcy9jbGljay10aHJvdWdoLWFuZC1jb252ZXJzaW9ucy9pbi1kZXB0aC9jbGlja3MtY29udmVyc2lvbnMtYmVzdC1wcmFjdGljZXMvXFxuICBcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgaGl0c0FycmF5ID0gQXJyYXkuaXNBcnJheShoaXRzKSA/IHJlbW92ZUVzY2FwZWRGcm9tSGl0cyhoaXRzKSA6IFtoaXRzXTtcblxuICBpZiAoaGl0c0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SUQgPSBoaXRzQXJyYXlbMF0uX19xdWVyeUlEO1xuICB2YXIgb2JqZWN0SURzID0gaGl0c0FycmF5Lm1hcChmdW5jdGlvbiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdC5vYmplY3RJRDtcbiAgfSk7XG4gIHZhciBwb3NpdGlvbnMgPSBoaXRzQXJyYXkubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICByZXR1cm4gaGl0Ll9fcG9zaXRpb247XG4gIH0pO1xuXG4gIGlmIChldmVudFR5cGUgPT09ICd2aWV3Jykge1xuICAgIHJldHVybiB7XG4gICAgICBpbnNpZ2h0c01ldGhvZDogJ3ZpZXdlZE9iamVjdElEcycsXG4gICAgICB3aWRnZXRUeXBlOiB3aWRnZXRUeXBlLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGV2ZW50TmFtZTogZXZlbnROYW1lIHx8ICdIaXRzIFZpZXdlZCcsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgb2JqZWN0SURzOiBvYmplY3RJRHNcbiAgICAgIH0sXG4gICAgICBoaXRzOiBoaXRzQXJyYXlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ2NsaWNrJykge1xuICAgIHJldHVybiB7XG4gICAgICBpbnNpZ2h0c01ldGhvZDogJ2NsaWNrZWRPYmplY3RJRHNBZnRlclNlYXJjaCcsXG4gICAgICB3aWRnZXRUeXBlOiB3aWRnZXRUeXBlLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGV2ZW50TmFtZTogZXZlbnROYW1lLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHF1ZXJ5SUQ6IHF1ZXJ5SUQsXG4gICAgICAgIG9iamVjdElEczogb2JqZWN0SURzLFxuICAgICAgICBwb3NpdGlvbnM6IHBvc2l0aW9uc1xuICAgICAgfSxcbiAgICAgIGhpdHM6IGhpdHNBcnJheVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnY29udmVyc2lvbicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5zaWdodHNNZXRob2Q6ICdjb252ZXJ0ZWRPYmplY3RJRHNBZnRlclNlYXJjaCcsXG4gICAgICB3aWRnZXRUeXBlOiB3aWRnZXRUeXBlLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGV2ZW50TmFtZTogZXZlbnROYW1lLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHF1ZXJ5SUQ6IHF1ZXJ5SUQsXG4gICAgICAgIG9iamVjdElEczogb2JqZWN0SURzXG4gICAgICB9LFxuICAgICAgaGl0czogaGl0c0FycmF5XG4gICAgfTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImV2ZW50VHlwZShcXFwiXCIuY29uY2F0KGV2ZW50VHlwZSwgXCJcXFwiKSBpcyBub3Qgc3VwcG9ydGVkLlxcbiAgICBJZiB5b3Ugd2FudCB0byBzZW5kIGEgY3VzdG9tIHBheWxvYWQsIHlvdSBjYW4gcGFzcyBvbmUgb2JqZWN0OiBcIikuY29uY2F0KG1ldGhvZE5hbWUsIFwiKGN1c3RvbVBheWxvYWQpO1xcbiAgICBcIikpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZW1vdmVFc2NhcGVkRnJvbUhpdHMoaGl0cykge1xuICAvLyB0aGlzIHJldHVybnMgd2l0aG91dCBgaGl0cy5fX2VzY2FwZWRgXG4gIC8vIGFuZCB0aGlzIHdheSBpdCBkb2Vzbid0IG11dGF0ZSB0aGUgb3JpZ2luYWwgYGhpdHNgXG4gIHJldHVybiBoaXRzLm1hcChmdW5jdGlvbiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZW5kRXZlbnRGb3JIaXRzKF9yZWYyKSB7XG4gIHZhciBpbnN0YW50U2VhcmNoSW5zdGFuY2UgPSBfcmVmMi5pbnN0YW50U2VhcmNoSW5zdGFuY2UsXG4gICAgICBpbmRleCA9IF9yZWYyLmluZGV4LFxuICAgICAgd2lkZ2V0VHlwZSA9IF9yZWYyLndpZGdldFR5cGU7XG5cbiAgdmFyIHNlbmRFdmVudEZvckhpdHMgPSBmdW5jdGlvbiBzZW5kRXZlbnRGb3JIaXRzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgcGF5bG9hZCA9IGJ1aWxkUGF5bG9hZCh7XG4gICAgICB3aWRnZXRUeXBlOiB3aWRnZXRUeXBlLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgbWV0aG9kTmFtZTogJ3NlbmRFdmVudCcsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG5cbiAgICBpZiAocGF5bG9hZCkge1xuICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlLnNlbmRFdmVudFRvSW5zaWdodHMocGF5bG9hZCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZW5kRXZlbnRGb3JIaXRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJpbmRFdmVudEZvckhpdHMoX3JlZjMpIHtcbiAgdmFyIGluZGV4ID0gX3JlZjMuaW5kZXgsXG4gICAgICB3aWRnZXRUeXBlID0gX3JlZjMud2lkZ2V0VHlwZTtcblxuICB2YXIgYmluZEV2ZW50Rm9ySGl0cyA9IGZ1bmN0aW9uIGJpbmRFdmVudEZvckhpdHMoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBidWlsZFBheWxvYWQoe1xuICAgICAgd2lkZ2V0VHlwZTogd2lkZ2V0VHlwZSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIG1ldGhvZE5hbWU6ICdiaW5kRXZlbnQnLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICAgIHJldHVybiBwYXlsb2FkID8gXCJkYXRhLWluc2lnaHRzLWV2ZW50PVwiLmNvbmNhdChzZXJpYWxpemVQYXlsb2FkKHBheWxvYWQpKSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBiaW5kRXZlbnRGb3JIaXRzO1xufSIsInZhciBuZXh0TWljcm9UYXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbnZhciBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGNhbGxiYWNrKSB7XG4gIHZhciBwcm9ncmVzcyA9IG51bGw7XG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTtcblxuICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJvZ3Jlc3MgPSBuZXh0TWljcm9UYXNrLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcHJvZ3Jlc3MgPSBudWxsO1xuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm4ud2FpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmVycmVkIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYHdhaXQoKWAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgZm4uY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmZXI7IiwiZXhwb3J0IHZhciBjcmVhdGVEb2N1bWVudGF0aW9uTGluayA9IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50YXRpb25MaW5rKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBfcmVmJGNvbm5lY3RvciA9IF9yZWYuY29ubmVjdG9yLFxuICAgICAgY29ubmVjdG9yID0gX3JlZiRjb25uZWN0b3IgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRjb25uZWN0b3I7XG4gIHJldHVybiBbJ2h0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9hcGktcmVmZXJlbmNlL3dpZGdldHMvJywgbmFtZSwgJy9qcy8nLCBjb25uZWN0b3IgPyAnI2Nvbm5lY3RvcicgOiAnJ10uam9pbignJyk7XG59O1xuZXhwb3J0IHZhciBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgd2lkZ2V0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB3aWRnZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGxpbmtzID0gd2lkZ2V0cy5tYXAoZnVuY3Rpb24gKHdpZGdldCkge1xuICAgIHJldHVybiBjcmVhdGVEb2N1bWVudGF0aW9uTGluayh3aWRnZXQpO1xuICB9KS5qb2luKCcsICcpO1xuICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gW21lc3NhZ2UsIFwiU2VlIGRvY3VtZW50YXRpb246IFwiLmNvbmNhdChsaW5rcyldLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG5cXG4nKTtcbiAgfTtcbn07IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCBlc2NhcGUgZnJvbSAnLi9lc2NhcGUnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0JztcbmV4cG9ydCB2YXIgVEFHX1BMQUNFSE9MREVSID0ge1xuICBoaWdobGlnaHRQcmVUYWc6ICdfX2Fpcy1oaWdobGlnaHRfXycsXG4gIGhpZ2hsaWdodFBvc3RUYWc6ICdfXy9haXMtaGlnaGxpZ2h0X18nXG59O1xuZXhwb3J0IHZhciBUQUdfUkVQTEFDRU1FTlQgPSB7XG4gIGhpZ2hsaWdodFByZVRhZzogJzxtYXJrPicsXG4gIGhpZ2hsaWdodFBvc3RUYWc6ICc8L21hcms+J1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVRhZ3NBbmRFc2NhcGUodmFsdWUpIHtcbiAgcmV0dXJuIGVzY2FwZSh2YWx1ZSkucmVwbGFjZShuZXcgUmVnRXhwKFRBR19QTEFDRUhPTERFUi5oaWdobGlnaHRQcmVUYWcsICdnJyksIFRBR19SRVBMQUNFTUVOVC5oaWdobGlnaHRQcmVUYWcpLnJlcGxhY2UobmV3IFJlZ0V4cChUQUdfUExBQ0VIT0xERVIuaGlnaGxpZ2h0UG9zdFRhZywgJ2cnKSwgVEFHX1JFUExBQ0VNRU5ULmhpZ2hsaWdodFBvc3RUYWcpO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVFc2NhcGUoaW5wdXQpIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaW5wdXQpICYmIHR5cGVvZiBpbnB1dC52YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaW5wdXQpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFjYyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgcmVjdXJzaXZlRXNjYXBlKGlucHV0W2tleV0pKSk7XG4gICAgfSwge30pO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0Lm1hcChyZWN1cnNpdmVFc2NhcGUpO1xuICB9XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaW5wdXQpLCB7fSwge1xuICAgIHZhbHVlOiByZXBsYWNlVGFnc0FuZEVzY2FwZShpbnB1dC52YWx1ZSlcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVIaXRzKGhpdHMpIHtcbiAgaWYgKGhpdHMuX19lc2NhcGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBkb24ndCBvdmVycmlkZSB0aGUgdmFsdWUgb24gaGl0IGJlY2F1c2UgaXQgd2lsbCBtdXRhdGUgdGhlIHJhdyByZXN1bHRzXG4gICAgLy8gaW5zdGVhZCB3ZSBtYWtlIGEgc2hhbGxvdyBjb3B5IGFuZCB3ZSBhc3NpZ24gdGhlIGVzY2FwZWQgdmFsdWVzIG9uIGl0LlxuICAgIGhpdHMgPSBoaXRzLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGhpdCA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICAgICAgaWYgKGhpdC5faGlnaGxpZ2h0UmVzdWx0KSB7XG4gICAgICAgIGhpdC5faGlnaGxpZ2h0UmVzdWx0ID0gcmVjdXJzaXZlRXNjYXBlKGhpdC5faGlnaGxpZ2h0UmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhpdC5fc25pcHBldFJlc3VsdCkge1xuICAgICAgICBoaXQuX3NuaXBwZXRSZXN1bHQgPSByZWN1cnNpdmVFc2NhcGUoaGl0Ll9zbmlwcGV0UmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhpdDtcbiAgICB9KTtcbiAgICBoaXRzLl9fZXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gaGl0cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGYWNldHMoZmFjZXRIaXRzKSB7XG4gIHJldHVybiBmYWNldEhpdHMubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaCksIHt9LCB7XG4gICAgICBoaWdobGlnaHRlZDogcmVwbGFjZVRhZ3NBbmRFc2NhcGUoaC5oaWdobGlnaHRlZClcbiAgICB9KTtcbiAgfSk7XG59IiwiLyoqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHRha2VuIGZyb20gTG9kYXNoIGltcGxlbWVudGF0aW9uLlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTEtbnBtL2VzY2FwZS5qc1xuICovXG4vLyBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07IC8vIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLlxuXG52YXIgcmVnZXhVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2c7XG52YXIgcmVnZXhIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlZ2V4VW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHJlZ2V4SGFzVW5lc2NhcGVkSHRtbC50ZXN0KHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UocmVnZXhVbmVzY2FwZWRIdG1sLCBmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGh0bWxFc2NhcGVzW2NoYXJhY3Rlcl07XG4gIH0pIDogdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZTsiLCIvLyBXZSBhcmVuJ3QgdXNpbmcgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLmZpbmRgIGJlY2F1c2UgdGhlIHJlZmFjdG9yIGF3YXkgZnJvbSBMb2Rhc2ggaXMgbm90XG4vLyBwdWJsaXNoZWQgYXMgYSBtYWpvciB2ZXJzaW9uLlxuLy8gUmVseWluZyBvbiB0aGUgYGZpbmRgIHBvbHlmaWxsIG9uIHVzZXItbGFuZCwgd2hpY2ggYmVmb3JlIHdhcyBvbmx5IHJlcXVpcmVkIGZvciBuaWNoZSB1c2UtY2FzZXMsXG4vLyB3YXMgZGVjaWRlZCBhcyB0b28gcmlza3kuXG4vLyBATUFKT1IgUmVwbGFjZSB3aXRoIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRcbmZ1bmN0aW9uIGZpbmQoaXRlbXMsIHByZWRpY2F0ZSkge1xuICB2YXIgdmFsdWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhbHVlID0gaXRlbXNbaV07IC8vIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlOiBpZiAoQ2FsbChwcmVkaWNhdGUsIHRoaXNBcmcsIFt2YWx1ZSwgaSwgbGlzdF0pKSB7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpLCBpdGVtcykpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmaW5kOyIsIi8vIFdlIGFyZW4ndCB1c2luZyB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBiZWNhdXNlIHRoZSByZWZhY3RvciBhd2F5IGZyb20gTG9kYXNoIGlzIG5vdFxuLy8gcHVibGlzaGVkIGFzIGEgbWFqb3IgdmVyc2lvbi5cbi8vIFJlbHlpbmcgb24gdGhlIGBmaW5kSW5kZXhgIHBvbHlmaWxsIG9uIHVzZXItbGFuZCwgd2hpY2ggYmVmb3JlIHdhcyBvbmx5IHJlcXVpcmVkIGZvciBuaWNoZSB1c2UtY2FzZXMsXG4vLyB3YXMgZGVjaWRlZCBhcyB0b28gcmlza3kuXG4vLyBATUFKT1IgUmVwbGFjZSB3aXRoIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZEluZGV4XG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmluZEluZGV4OyIsImltcG9ydCBpc0RvbUVsZW1lbnQgZnJvbSAnLi9pc0RvbUVsZW1lbnQnO1xuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbnRhaW5lci4gSWYgaXQncyBhIHN0cmluZywgaXQgaXMgY29uc2lkZXJlZCBhXG4gKiBjc3Mgc2VsZWN0b3IgYW5kIHJldHJpZXZlcyB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudC4gT3RoZXJ3aXNlXG4gKiB0ZXN0IGlmIGl0IHZhbGlkYXRlcyB0aGF0IGl0J3MgYSBjb3JyZWN0IERPTUVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR9IHNlbGVjdG9yT3JIVE1MRWxlbWVudCBDU1MgU2VsZWN0b3Igb3IgY29udGFpbmVyIG5vZGUuXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gQ29udGFpbmVyIG5vZGVcbiAqIEB0aHJvd3MgRXJyb3Igd2hlbiB0aGUgdHlwZSBpcyBub3QgY29ycmVjdFxuICovXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lck5vZGUoc2VsZWN0b3JPckhUTUxFbGVtZW50KSB7XG4gIHZhciBpc1NlbGVjdG9yU3RyaW5nID0gdHlwZW9mIHNlbGVjdG9yT3JIVE1MRWxlbWVudCA9PT0gJ3N0cmluZyc7XG4gIHZhciBkb21FbGVtZW50ID0gaXNTZWxlY3RvclN0cmluZyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JPckhUTUxFbGVtZW50KSA6IHNlbGVjdG9yT3JIVE1MRWxlbWVudDtcblxuICBpZiAoIWlzRG9tRWxlbWVudChkb21FbGVtZW50KSkge1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnQ29udGFpbmVyIG11c3QgYmUgYHN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC4nO1xuXG4gICAgaWYgKGlzU2VsZWN0b3JTdHJpbmcpIHtcbiAgICAgIGVycm9yTWVzc2FnZSArPSBcIiBVbmFibGUgdG8gZmluZCBcIi5jb25jYXQoc2VsZWN0b3JPckhUTUxFbGVtZW50KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRDb250YWluZXJOb2RlOyIsImltcG9ydCB1bmVzY2FwZSBmcm9tICcuL3VuZXNjYXBlJztcbnZhciBoYXNBbHBoYW51bWVyaWMgPSBuZXcgUmVnRXhwKC9cXHcvaSk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIaWdobGlnaHRGcm9tU2libGluZ3MocGFydHMsIGkpIHtcbiAgdmFyIF9wYXJ0cywgX3BhcnRzMjtcblxuICB2YXIgY3VycmVudCA9IHBhcnRzW2ldO1xuICB2YXIgaXNOZXh0SGlnaGxpZ2h0ZWQgPSAoKF9wYXJ0cyA9IHBhcnRzW2kgKyAxXSkgPT09IG51bGwgfHwgX3BhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGFydHMuaXNIaWdobGlnaHRlZCkgfHwgdHJ1ZTtcbiAgdmFyIGlzUHJldmlvdXNIaWdobGlnaHRlZCA9ICgoX3BhcnRzMiA9IHBhcnRzW2kgLSAxXSkgPT09IG51bGwgfHwgX3BhcnRzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BhcnRzMi5pc0hpZ2hsaWdodGVkKSB8fCB0cnVlO1xuXG4gIGlmICghaGFzQWxwaGFudW1lcmljLnRlc3QodW5lc2NhcGUoY3VycmVudC52YWx1ZSkpICYmIGlzUHJldmlvdXNIaWdobGlnaHRlZCA9PT0gaXNOZXh0SGlnaGxpZ2h0ZWQpIHtcbiAgICByZXR1cm4gaXNQcmV2aW91c0hpZ2hsaWdodGVkO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnQuaXNIaWdobGlnaHRlZDtcbn0iLCJpbXBvcnQgeyBUQUdfUkVQTEFDRU1FTlQgfSBmcm9tICcuL2VzY2FwZS1oaWdobGlnaHQnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZWRQYXJ0cyhoaWdobGlnaHRlZFZhbHVlKSB7XG4gIHZhciBoaWdobGlnaHRQb3N0VGFnID0gVEFHX1JFUExBQ0VNRU5ULmhpZ2hsaWdodFBvc3RUYWcsXG4gICAgICBoaWdobGlnaHRQcmVUYWcgPSBUQUdfUkVQTEFDRU1FTlQuaGlnaGxpZ2h0UHJlVGFnO1xuICB2YXIgc3BsaXRCeVByZVRhZyA9IGhpZ2hsaWdodGVkVmFsdWUuc3BsaXQoaGlnaGxpZ2h0UHJlVGFnKTtcbiAgdmFyIGZpcnN0VmFsdWUgPSBzcGxpdEJ5UHJlVGFnLnNoaWZ0KCk7XG4gIHZhciBlbGVtZW50cyA9ICFmaXJzdFZhbHVlID8gW10gOiBbe1xuICAgIHZhbHVlOiBmaXJzdFZhbHVlLFxuICAgIGlzSGlnaGxpZ2h0ZWQ6IGZhbHNlXG4gIH1dO1xuICBzcGxpdEJ5UHJlVGFnLmZvckVhY2goZnVuY3Rpb24gKHNwbGl0KSB7XG4gICAgdmFyIHNwbGl0QnlQb3N0VGFnID0gc3BsaXQuc3BsaXQoaGlnaGxpZ2h0UG9zdFRhZyk7XG4gICAgZWxlbWVudHMucHVzaCh7XG4gICAgICB2YWx1ZTogc3BsaXRCeVBvc3RUYWdbMF0sXG4gICAgICBpc0hpZ2hsaWdodGVkOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoc3BsaXRCeVBvc3RUYWdbMV0gIT09ICcnKSB7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHNwbGl0QnlQb3N0VGFnWzFdLFxuICAgICAgICBpc0hpZ2hsaWdodGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnRzO1xufSIsImZ1bmN0aW9uIGdldE9iamVjdFR5cGUob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5zbGljZSg4LCAtMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE9iamVjdFR5cGU7IiwiZnVuY3Rpb24gZ2V0UHJvcGVydHlCeVBhdGgob2JqZWN0LCBwYXRoKSB7XG4gIHZhciBwYXJ0cyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChjdXJyZW50LCBrZXkpIHtcbiAgICByZXR1cm4gY3VycmVudCAmJiBjdXJyZW50W2tleV07XG4gIH0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3BlcnR5QnlQYXRoOyIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQWJzb2x1dGVQb3NpdGlvbihoaXRzLCBwYWdlLCBoaXRzUGVyUGFnZSkge1xuICByZXR1cm4gaGl0cy5tYXAoZnVuY3Rpb24gKGhpdCwgaWR4KSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaGl0KSwge30sIHtcbiAgICAgIF9fcG9zaXRpb246IGhpdHNQZXJQYWdlICogcGFnZSArIGlkeCArIDFcbiAgICB9KTtcbiAgfSk7XG59IiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRRdWVyeUlEKGhpdHMsIHF1ZXJ5SUQpIHtcbiAgaWYgKCFxdWVyeUlEKSB7XG4gICAgcmV0dXJuIGhpdHM7XG4gIH1cblxuICByZXR1cm4gaGl0cy5tYXAoZnVuY3Rpb24gKGhpdCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGhpdCksIHt9LCB7XG4gICAgICBfX3F1ZXJ5SUQ6IHF1ZXJ5SURcbiAgICB9KTtcbiAgfSk7XG59IiwiZnVuY3Rpb24gaXNEb21FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgQm9vbGVhbihvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA+IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRG9tRWxlbWVudDsiLCJmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gT2JqZWN0KG9iaik7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzUHJpbWl0aXZlKGZpcnN0KSB8fCBpc1ByaW1pdGl2ZShzZWNvbmQpIHx8IHR5cGVvZiBmaXJzdCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygc2Vjb25kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZpcnN0ID09PSBzZWNvbmQ7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZmlyc3QpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc2Vjb25kKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKGZpcnN0KTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGtleSA9IF9PYmplY3Qka2V5c1tfaV07XG5cbiAgICBpZiAoIShrZXkgaW4gc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghaXNFcXVhbChmaXJzdFtrZXldLCBzZWNvbmRba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNFcXVhbDsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyB0YWtlbiBmcm9tIExvZGFzaCBpbXBsZW1lbnRhdGlvbi5cbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvaXNQbGFpbk9iamVjdC5qc1xuICovXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyAnW29iamVjdCBVbmRlZmluZWRdJyA6ICdbb2JqZWN0IE51bGxdJztcbiAgfVxuXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QuXG4gKlxuICogQSBwbGFpbiBvYmplY3QgaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgXG4gKiBjb25zdHJ1Y3RvciBvciB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGdldFRhZyh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwcm90byA9IHZhbHVlO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0OyIsImZ1bmN0aW9uIGlzU3BlY2lhbENsaWNrKGV2ZW50KSB7XG4gIHZhciBpc01pZGRsZUNsaWNrID0gZXZlbnQuYnV0dG9uID09PSAxO1xuICByZXR1cm4gaXNNaWRkbGVDbGljayB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1NwZWNpYWxDbGljazsiLCJpbXBvcnQgbm9vcCBmcm9tICcuL25vb3AnO1xuXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQsIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50IG9ubHkuXG4gKi9cbnZhciBkZXByZWNhdGUgPSBmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGZuO1xufTtcbi8qKlxuICogTG9ncyBhIHdhcm5pbmdcbiAqIFRoaXMgaXMgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50IG9ubHkuXG4gKi9cblxuXG52YXIgd2FybiA9IG5vb3A7XG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgaXMgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50IG9ubHkuXG4gKi9cblxudmFyIF93YXJuaW5nID0gbm9vcDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gIHdhcm4gPSBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcIltJbnN0YW50U2VhcmNoLmpzXTogXCIuY29uY2F0KG1lc3NhZ2UudHJpbSgpKSk7XG4gIH07XG5cbiAgZGVwcmVjYXRlID0gZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtZXNzYWdlKSB7XG4gICAgdmFyIGhhc0FscmVhZHlQcmludGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaGFzQWxyZWFkeVByaW50ZWQpIHtcbiAgICAgICAgaGFzQWxyZWFkeVByaW50ZWQgPSB0cnVlO1xuICAgICAgICB3YXJuKG1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4uYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgX3dhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFzQWxyZWFkeVByaW50ZWQgPSBfd2FybmluZy5jYWNoZVttZXNzYWdlXTtcblxuICAgIGlmICghaGFzQWxyZWFkeVByaW50ZWQpIHtcbiAgICAgIF93YXJuaW5nLmNhY2hlW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgIHdhcm4obWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIF93YXJuaW5nLmNhY2hlID0ge307XG59XG5cbmV4cG9ydCB7IHdhcm4sIGRlcHJlY2F0ZSwgX3dhcm5pbmcgYXMgd2FybmluZyB9OyIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgZmluZEluZGV4IGZyb20gJy4vZmluZEluZGV4JztcbmltcG9ydCB1bmlxIGZyb20gJy4vdW5pcSc7XG5cbnZhciBtZXJnZVdpdGhSZXN0ID0gZnVuY3Rpb24gbWVyZ2VXaXRoUmVzdChsZWZ0LCByaWdodCkge1xuICB2YXIgZmFjZXRzID0gcmlnaHQuZmFjZXRzLFxuICAgICAgZGlzanVuY3RpdmVGYWNldHMgPSByaWdodC5kaXNqdW5jdGl2ZUZhY2V0cyxcbiAgICAgIGZhY2V0c1JlZmluZW1lbnRzID0gcmlnaHQuZmFjZXRzUmVmaW5lbWVudHMsXG4gICAgICBmYWNldHNFeGNsdWRlcyA9IHJpZ2h0LmZhY2V0c0V4Y2x1ZGVzLFxuICAgICAgZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cyA9IHJpZ2h0LmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMsXG4gICAgICBudW1lcmljUmVmaW5lbWVudHMgPSByaWdodC5udW1lcmljUmVmaW5lbWVudHMsXG4gICAgICB0YWdSZWZpbmVtZW50cyA9IHJpZ2h0LnRhZ1JlZmluZW1lbnRzLFxuICAgICAgaGllcmFyY2hpY2FsRmFjZXRzID0gcmlnaHQuaGllcmFyY2hpY2FsRmFjZXRzLFxuICAgICAgaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHMgPSByaWdodC5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50cyxcbiAgICAgIHJ1bGVDb250ZXh0cyA9IHJpZ2h0LnJ1bGVDb250ZXh0cyxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmlnaHQsIFtcImZhY2V0c1wiLCBcImRpc2p1bmN0aXZlRmFjZXRzXCIsIFwiZmFjZXRzUmVmaW5lbWVudHNcIiwgXCJmYWNldHNFeGNsdWRlc1wiLCBcImRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHNcIiwgXCJudW1lcmljUmVmaW5lbWVudHNcIiwgXCJ0YWdSZWZpbmVtZW50c1wiLCBcImhpZXJhcmNoaWNhbEZhY2V0c1wiLCBcImhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzXCIsIFwicnVsZUNvbnRleHRzXCJdKTtcblxuICByZXR1cm4gbGVmdC5zZXRRdWVyeVBhcmFtZXRlcnMocmVzdCk7XG59OyAvLyBNZXJnZSBmYWNldHNcblxuXG52YXIgbWVyZ2VGYWNldHMgPSBmdW5jdGlvbiBtZXJnZUZhY2V0cyhsZWZ0LCByaWdodCkge1xuICByZXR1cm4gcmlnaHQuZmFjZXRzLnJlZHVjZShmdW5jdGlvbiAoXywgbmFtZSkge1xuICAgIHJldHVybiBfLmFkZEZhY2V0KG5hbWUpO1xuICB9LCBsZWZ0KTtcbn07XG5cbnZhciBtZXJnZURpc2p1bmN0aXZlRmFjZXRzID0gZnVuY3Rpb24gbWVyZ2VEaXNqdW5jdGl2ZUZhY2V0cyhsZWZ0LCByaWdodCkge1xuICByZXR1cm4gcmlnaHQuZGlzanVuY3RpdmVGYWNldHMucmVkdWNlKGZ1bmN0aW9uIChfLCBuYW1lKSB7XG4gICAgcmV0dXJuIF8uYWRkRGlzanVuY3RpdmVGYWNldChuYW1lKTtcbiAgfSwgbGVmdCk7XG59O1xuXG52YXIgbWVyZ2VIaWVyYXJjaGljYWxGYWNldHMgPSBmdW5jdGlvbiBtZXJnZUhpZXJhcmNoaWNhbEZhY2V0cyhsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbGVmdC5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgIGhpZXJhcmNoaWNhbEZhY2V0czogcmlnaHQuaGllcmFyY2hpY2FsRmFjZXRzLnJlZHVjZShmdW5jdGlvbiAoZmFjZXRzLCBmYWNldCkge1xuICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4KGZhY2V0cywgZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIF8ubmFtZSA9PT0gZmFjZXQubmFtZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWNldHMuY29uY2F0KGZhY2V0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHRGYWNldHMgPSBmYWNldHMuc2xpY2UoKTtcbiAgICAgIG5leHRGYWNldHMuc3BsaWNlKGluZGV4LCAxLCBmYWNldCk7XG4gICAgICByZXR1cm4gbmV4dEZhY2V0cztcbiAgICB9LCBsZWZ0LmhpZXJhcmNoaWNhbEZhY2V0cylcbiAgfSk7XG59OyAvLyBNZXJnZSBmYWNldCByZWZpbmVtZW50c1xuXG5cbnZhciBtZXJnZVRhZ1JlZmluZW1lbnRzID0gZnVuY3Rpb24gbWVyZ2VUYWdSZWZpbmVtZW50cyhsZWZ0LCByaWdodCkge1xuICByZXR1cm4gcmlnaHQudGFnUmVmaW5lbWVudHMucmVkdWNlKGZ1bmN0aW9uIChfLCB2YWx1ZSkge1xuICAgIHJldHVybiBfLmFkZFRhZ1JlZmluZW1lbnQodmFsdWUpO1xuICB9LCBsZWZ0KTtcbn07XG5cbnZhciBtZXJnZUZhY2V0UmVmaW5lbWVudHMgPSBmdW5jdGlvbiBtZXJnZUZhY2V0UmVmaW5lbWVudHMobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGxlZnQuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICBmYWNldHNSZWZpbmVtZW50czogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsZWZ0LmZhY2V0c1JlZmluZW1lbnRzKSwgcmlnaHQuZmFjZXRzUmVmaW5lbWVudHMpXG4gIH0pO1xufTtcblxudmFyIG1lcmdlRmFjZXRzRXhjbHVkZXMgPSBmdW5jdGlvbiBtZXJnZUZhY2V0c0V4Y2x1ZGVzKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0LnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgZmFjZXRzRXhjbHVkZXM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGVmdC5mYWNldHNFeGNsdWRlcyksIHJpZ2h0LmZhY2V0c0V4Y2x1ZGVzKVxuICB9KTtcbn07XG5cbnZhciBtZXJnZURpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMgPSBmdW5jdGlvbiBtZXJnZURpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGxlZnQuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICBkaXNqdW5jdGl2ZUZhY2V0c1JlZmluZW1lbnRzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxlZnQuZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cyksIHJpZ2h0LmRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHMpXG4gIH0pO1xufTtcblxudmFyIG1lcmdlTnVtZXJpY1JlZmluZW1lbnRzID0gZnVuY3Rpb24gbWVyZ2VOdW1lcmljUmVmaW5lbWVudHMobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGxlZnQuc2V0UXVlcnlQYXJhbWV0ZXJzKHtcbiAgICBudW1lcmljUmVmaW5lbWVudHM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGVmdC5udW1lcmljUmVmaW5lbWVudHMpLCByaWdodC5udW1lcmljUmVmaW5lbWVudHMpXG4gIH0pO1xufTtcblxudmFyIG1lcmdlSGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHMgPSBmdW5jdGlvbiBtZXJnZUhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0LnNldFF1ZXJ5UGFyYW1ldGVycyh7XG4gICAgaGllcmFyY2hpY2FsRmFjZXRzUmVmaW5lbWVudHM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGVmdC5oaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50cyksIHJpZ2h0LmhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzKVxuICB9KTtcbn07XG5cbnZhciBtZXJnZVJ1bGVDb250ZXh0cyA9IGZ1bmN0aW9uIG1lcmdlUnVsZUNvbnRleHRzKGxlZnQsIHJpZ2h0KSB7XG4gIHZhciBydWxlQ29udGV4dHMgPSB1bmlxKFtdLmNvbmNhdChsZWZ0LnJ1bGVDb250ZXh0cykuY29uY2F0KHJpZ2h0LnJ1bGVDb250ZXh0cykuZmlsdGVyKEJvb2xlYW4pKTtcblxuICBpZiAocnVsZUNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gbGVmdC5zZXRRdWVyeVBhcmFtZXRlcnMoe1xuICAgICAgcnVsZUNvbnRleHRzOiBydWxlQ29udGV4dHNcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsZWZ0O1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbWV0ZXJzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBhcmFtZXRlcnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gcGFyYW1ldGVycy5yZWR1Y2UoZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIGhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzTWVyZ2VkID0gbWVyZ2VIaWVyYXJjaGljYWxGYWNldHNSZWZpbmVtZW50cyhsZWZ0LCByaWdodCk7XG4gICAgdmFyIGhpZXJhcmNoaWNhbEZhY2V0c01lcmdlZCA9IG1lcmdlSGllcmFyY2hpY2FsRmFjZXRzKGhpZXJhcmNoaWNhbEZhY2V0c1JlZmluZW1lbnRzTWVyZ2VkLCByaWdodCk7XG4gICAgdmFyIHRhZ1JlZmluZW1lbnRzTWVyZ2VkID0gbWVyZ2VUYWdSZWZpbmVtZW50cyhoaWVyYXJjaGljYWxGYWNldHNNZXJnZWQsIHJpZ2h0KTtcbiAgICB2YXIgbnVtZXJpY1JlZmluZW1lbnRzTWVyZ2VkID0gbWVyZ2VOdW1lcmljUmVmaW5lbWVudHModGFnUmVmaW5lbWVudHNNZXJnZWQsIHJpZ2h0KTtcbiAgICB2YXIgZGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50c01lcmdlZCA9IG1lcmdlRGlzanVuY3RpdmVGYWNldHNSZWZpbmVtZW50cyhudW1lcmljUmVmaW5lbWVudHNNZXJnZWQsIHJpZ2h0KTtcbiAgICB2YXIgZmFjZXRzRXhjbHVkZXNNZXJnZWQgPSBtZXJnZUZhY2V0c0V4Y2x1ZGVzKGRpc2p1bmN0aXZlRmFjZXRzUmVmaW5lbWVudHNNZXJnZWQsIHJpZ2h0KTtcbiAgICB2YXIgZmFjZXRSZWZpbmVtZW50c01lcmdlZCA9IG1lcmdlRmFjZXRSZWZpbmVtZW50cyhmYWNldHNFeGNsdWRlc01lcmdlZCwgcmlnaHQpO1xuICAgIHZhciBkaXNqdW5jdGl2ZUZhY2V0c01lcmdlZCA9IG1lcmdlRGlzanVuY3RpdmVGYWNldHMoZmFjZXRSZWZpbmVtZW50c01lcmdlZCwgcmlnaHQpO1xuICAgIHZhciBydWxlQ29udGV4dHNNZXJnZWQgPSBtZXJnZVJ1bGVDb250ZXh0cyhkaXNqdW5jdGl2ZUZhY2V0c01lcmdlZCwgcmlnaHQpO1xuICAgIHZhciBmYWNldHNNZXJnZWQgPSBtZXJnZUZhY2V0cyhydWxlQ29udGV4dHNNZXJnZWQsIHJpZ2h0KTtcbiAgICByZXR1cm4gbWVyZ2VXaXRoUmVzdChmYWNldHNNZXJnZWQsIHJpZ2h0KTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZTsiLCJmdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGRlZmF1bHQgbm9vcDsiLCJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5pbXBvcnQgdW5pcSBmcm9tICcuL3VuaXEnO1xuXG5mdW5jdGlvbiBwcmVwYXJlVGVtcGxhdGVzKCAvLyBjYW4gbm90IHVzZSA9IHt9IGhlcmUsIHNpbmNlIHRoZSB0ZW1wbGF0ZSBjb3VsZCBoYXZlIGRpZmZlcmVudCBjb25zdHJhaW50c1xuZGVmYXVsdFRlbXBsYXRlcykge1xuICB2YXIgdGVtcGxhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGFsbEtleXMgPSB1bmlxKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmtleXMoZGVmYXVsdFRlbXBsYXRlcyB8fCB7fSkpLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmtleXModGVtcGxhdGVzKSkpKTtcbiAgcmV0dXJuIGFsbEtleXMucmVkdWNlKGZ1bmN0aW9uIChjb25maWcsIGtleSkge1xuICAgIHZhciBkZWZhdWx0VGVtcGxhdGUgPSBkZWZhdWx0VGVtcGxhdGVzID8gZGVmYXVsdFRlbXBsYXRlc1trZXldIDogdW5kZWZpbmVkO1xuICAgIHZhciBjdXN0b21UZW1wbGF0ZSA9IHRlbXBsYXRlc1trZXldO1xuICAgIHZhciBpc0N1c3RvbVRlbXBsYXRlID0gY3VzdG9tVGVtcGxhdGUgIT09IHVuZGVmaW5lZCAmJiBjdXN0b21UZW1wbGF0ZSAhPT0gZGVmYXVsdFRlbXBsYXRlO1xuICAgIGNvbmZpZy50ZW1wbGF0ZXNba2V5XSA9IGlzQ3VzdG9tVGVtcGxhdGUgPyBjdXN0b21UZW1wbGF0ZSAvLyB0eXBlc2NyaXB0IGRvZXNuJ3QgcmVjb2duaXplIHRoYXQgdGhpcyBjb25kaXRpb24gYXNzZXJ0cyBjdXN0b21UZW1wbGF0ZSBpcyBkZWZpbmVkXG4gICAgOiBkZWZhdWx0VGVtcGxhdGU7XG4gICAgY29uZmlnLnVzZUN1c3RvbUNvbXBpbGVPcHRpb25zW2tleV0gPSBpc0N1c3RvbVRlbXBsYXRlO1xuICAgIHJldHVybiBjb25maWc7XG4gIH0sIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgdGVtcGxhdGVzOiB7fSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgdXNlQ3VzdG9tQ29tcGlsZU9wdGlvbnM6IHt9XG4gIH0pO1xufVxuLyoqXG4gKiBQcmVwYXJlcyBhbiBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBUZW1wbGF0ZSB3aWRnZXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXBhcmVUZW1wbGF0ZVByb3BzKF9yZWYpIHtcbiAgdmFyIGRlZmF1bHRUZW1wbGF0ZXMgPSBfcmVmLmRlZmF1bHRUZW1wbGF0ZXMsXG4gICAgICB0ZW1wbGF0ZXMgPSBfcmVmLnRlbXBsYXRlcyxcbiAgICAgIHRlbXBsYXRlc0NvbmZpZyA9IF9yZWYudGVtcGxhdGVzQ29uZmlnO1xuICB2YXIgcHJlcGFyZWRUZW1wbGF0ZXMgPSBwcmVwYXJlVGVtcGxhdGVzKGRlZmF1bHRUZW1wbGF0ZXMsIHRlbXBsYXRlcyk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICB0ZW1wbGF0ZXNDb25maWc6IHRlbXBsYXRlc0NvbmZpZ1xuICB9LCBwcmVwYXJlZFRlbXBsYXRlcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZXBhcmVUZW1wbGF0ZVByb3BzOyIsImZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gcmFuZ2UoX3JlZikge1xuICB2YXIgX3JlZiRzdGFydCA9IF9yZWYuc3RhcnQsXG4gICAgICBzdGFydCA9IF9yZWYkc3RhcnQgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHN0YXJ0LFxuICAgICAgZW5kID0gX3JlZi5lbmQsXG4gICAgICBfcmVmJHN0ZXAgPSBfcmVmLnN0ZXAsXG4gICAgICBzdGVwID0gX3JlZiRzdGVwID09PSB2b2lkIDAgPyAxIDogX3JlZiRzdGVwO1xuICAvLyBXZSBjYW4ndCBkaXZpZGUgYnkgMCBzbyB3ZSByZS1hc3NpZ24gdGhlIHN0ZXAgdG8gMSBpZiBpdCBoYXBwZW5zLlxuICB2YXIgbGltaXRTdGVwID0gc3RlcCA9PT0gMCA/IDEgOiBzdGVwOyAvLyBJbiBzb21lIGNhc2VzIHRoZSBhcnJheSB0byBjcmVhdGUgaGFzIGEgZGVjaW1hbCBsZW5ndGguXG4gIC8vIFdlIHRoZXJlZm9yZSBuZWVkIHRvIHJvdW5kIHRoZSB2YWx1ZS5cbiAgLy8gRXhhbXBsZTpcbiAgLy8gICB7IHN0YXJ0OiAxLCBlbmQ6IDUwMDAsIHN0ZXA6IDUwMCB9XG4gIC8vICAgPT4gQXJyYXkgbGVuZ3RoID0gKDUwMDAgLSAxKSAvIDUwMCA9IDkuOTk4XG5cbiAgdmFyIGFycmF5TGVuZ3RoID0gTWF0aC5yb3VuZCgoZW5kIC0gc3RhcnQpIC8gbGltaXRTdGVwKTtcbiAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShBcnJheShhcnJheUxlbmd0aCkpLm1hcChmdW5jdGlvbiAoXywgY3VycmVudCkge1xuICAgIHJldHVybiBzdGFydCArIGN1cnJlbnQgKiBsaW1pdFN0ZXA7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCByYW5nZTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgaG9nYW4gZnJvbSAnaG9nYW4uanMnO1xuXG4vLyBXZSBhZGQgYWxsIG91ciB0ZW1wbGF0ZSBoZWxwZXIgbWV0aG9kcyB0byB0aGUgdGVtcGxhdGUgYXMgbGFtYmRhcy4gTm90ZVxuLy8gdGhhdCBsYW1iZGFzIGluIE11c3RhY2hlIGFyZSBzdXBwb3NlZCB0byBhY2NlcHQgYSBzZWNvbmQgYXJndW1lbnQgb2Zcbi8vIGByZW5kZXJgIHRvIGdldCB0aGUgcmVuZGVyZWQgdmFsdWUsIG5vdCB0aGUgbGl0ZXJhbCBge3t2YWx1ZX19YC4gQnV0XG4vLyB0aGlzIGlzIGN1cnJlbnRseSBicm9rZW4gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdpdHRlci9ob2dhbi5qcy9pc3N1ZXMvMjIyKS5cbmZ1bmN0aW9uIHRyYW5zZm9ybUhlbHBlcnNUb0hvZ2FuKCkge1xuICB2YXIgaGVscGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBjb21waWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVscGVycykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGhlbHBlcktleSkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFjYyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGhlbHBlcktleSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaG9nYW4uY29tcGlsZSh2YWx1ZSwgY29tcGlsZU9wdGlvbnMpLnJlbmRlcihfdGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGhlbHBlcnNbaGVscGVyS2V5XS5jYWxsKGRhdGEsIHRleHQsIHJlbmRlcik7XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUZW1wbGF0ZShfcmVmKSB7XG4gIHZhciB0ZW1wbGF0ZXMgPSBfcmVmLnRlbXBsYXRlcyxcbiAgICAgIHRlbXBsYXRlS2V5ID0gX3JlZi50ZW1wbGF0ZUtleSxcbiAgICAgIGNvbXBpbGVPcHRpb25zID0gX3JlZi5jb21waWxlT3B0aW9ucyxcbiAgICAgIGhlbHBlcnMgPSBfcmVmLmhlbHBlcnMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgYmluZEV2ZW50ID0gX3JlZi5iaW5kRXZlbnQ7XG4gIHZhciB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1t0ZW1wbGF0ZUtleV07XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHRlbXBsYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgbXVzdCBiZSAnc3RyaW5nJyBvciAnZnVuY3Rpb24nLCB3YXMgJ1wiLmNvbmNhdChfdHlwZW9mKHRlbXBsYXRlKSwgXCInIChrZXk6IFwiKS5jb25jYXQodGVtcGxhdGVLZXksIFwiKVwiKSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEsIGJpbmRFdmVudCk7XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtZWRIZWxwZXJzID0gdHJhbnNmb3JtSGVscGVyc1RvSG9nYW4oaGVscGVycywgY29tcGlsZU9wdGlvbnMsIGRhdGEpO1xuICByZXR1cm4gaG9nYW4uY29tcGlsZSh0ZW1wbGF0ZSwgY29tcGlsZU9wdGlvbnMpLnJlbmRlcihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRhdGEpLCB7fSwge1xuICAgIGhlbHBlcnM6IHRyYW5zZm9ybWVkSGVscGVyc1xuICB9KSkucmVwbGFjZSgvWyBcXG5cXHJcXHRcXGZcXHhBMF0rL2csIGZ1bmN0aW9uIChzcGFjZXMpIHtcbiAgICByZXR1cm4gc3BhY2VzLnJlcGxhY2UoLyhefFxceEEwKylbXlxceEEwXSsvZywgJyQxICcpO1xuICB9KS50cmltKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlclRlbXBsYXRlOyIsInZhciByZXNvbHZlU2VhcmNoUGFyYW1ldGVycyA9IGZ1bmN0aW9uIHJlc29sdmVTZWFyY2hQYXJhbWV0ZXJzKGN1cnJlbnQpIHtcbiAgdmFyIHBhcmVudCA9IGN1cnJlbnQuZ2V0UGFyZW50KCk7XG4gIHZhciBzdGF0ZXMgPSBbY3VycmVudC5nZXRIZWxwZXIoKS5zdGF0ZV07XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHN0YXRlcyA9IFtwYXJlbnQuZ2V0SGVscGVyKCkuc3RhdGVdLmNvbmNhdChzdGF0ZXMpO1xuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZXM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlU2VhcmNoUGFyYW1ldGVyczsiLCJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IGdldEhpZ2hsaWdodEZyb21TaWJsaW5ncyBmcm9tICcuL2dldEhpZ2hsaWdodEZyb21TaWJsaW5ncyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXZlcnNlSGlnaGxpZ2h0ZWRQYXJ0cyhwYXJ0cykge1xuICBpZiAoIXBhcnRzLnNvbWUoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcGFydC5pc0hpZ2hsaWdodGVkO1xuICB9KSkge1xuICAgIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcnQpLCB7fSwge1xuICAgICAgICBpc0hpZ2hsaWdodGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0LCBpKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFydCksIHt9LCB7XG4gICAgICBpc0hpZ2hsaWdodGVkOiAhZ2V0SGlnaGxpZ2h0RnJvbVNpYmxpbmdzKHBhcnRzLCBpKVxuICAgIH0pO1xuICB9KTtcbn0iLCJleHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplUGF5bG9hZChwYXlsb2FkKSB7XG4gIHJldHVybiBidG9hKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplUGF5bG9hZChwYXlsb2FkKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudChhdG9iKHBheWxvYWQpKSk7XG59IiwiLyoqXG4gKiBBIHR5cGVkIHZlcnNpb24gb2YgT2JqZWN0LmtleXMsIHRvIHVzZSB3aGVuIGxvb3Bpbmcgb3ZlciBhIHN0YXRpYyBvYmplY3RcbiAqIGluc3BpcmVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY1MTE3NDY1LzMxODUzMDdcbiAqL1xuZXhwb3J0IHZhciBrZXlzID0gT2JqZWN0LmtleXM7IiwiLyoqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHRha2VuIGZyb20gTG9kYXNoIGltcGxlbWVudGF0aW9uLlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTEtbnBtL3VuZXNjYXBlLmpzXG4gKi9cbi8vIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyZhbXA7JzogJyYnLFxuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJiMzOTsnOiBcIidcIlxufTsgLy8gVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuXG5cbnZhciByZWdleEVzY2FwZWRIdG1sID0gLyYoYW1wfHF1b3R8bHR8Z3R8IzM5KTsvZztcbnZhciByZWdleEhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlZ2V4RXNjYXBlZEh0bWwuc291cmNlKTtcbi8qKlxuICogQ29udmVydHMgdGhlIEhUTUwgZW50aXRpZXMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gKiBjaGFyYWN0ZXJzLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuZXNjYXBlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiByZWdleEhhc0VzY2FwZWRIdG1sLnRlc3QodmFsdWUpID8gdmFsdWUucmVwbGFjZShyZWdleEVzY2FwZWRIdG1sLCBmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGh0bWxFc2NhcGVzW2NoYXJhY3Rlcl07XG4gIH0pIDogdmFsdWU7XG59IiwiZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1bmlxOyIsImV4cG9ydCBkZWZhdWx0ICc0LjI3LjInOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gZXh0cmFjdFBheWxvYWQod2lkZ2V0cywgaW5zdGFudFNlYXJjaEluc3RhbmNlLCBwYXlsb2FkKSB7XG4gIHZhciBwYXJlbnQgPSBpbnN0YW50U2VhcmNoSW5zdGFuY2UubWFpbkluZGV4O1xuICB2YXIgaW5pdE9wdGlvbnMgPSB7XG4gICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgc2NvcGVkUmVzdWx0czogW10sXG4gICAgc3RhdGU6IHBhcmVudC5nZXRIZWxwZXIoKS5zdGF0ZSxcbiAgICBoZWxwZXI6IHBhcmVudC5nZXRIZWxwZXIoKSxcbiAgICBjcmVhdGVVUkw6IHBhcmVudC5jcmVhdGVVUkwsXG4gICAgdWlTdGF0ZTogaW5zdGFudFNlYXJjaEluc3RhbmNlLl9pbml0aWFsVWlTdGF0ZSxcbiAgICByZW5kZXJTdGF0ZTogaW5zdGFudFNlYXJjaEluc3RhbmNlLnJlbmRlclN0YXRlLFxuICAgIHRlbXBsYXRlc0NvbmZpZzogaW5zdGFudFNlYXJjaEluc3RhbmNlLnRlbXBsYXRlc0NvbmZpZyxcbiAgICBzZWFyY2hNZXRhZGF0YToge1xuICAgICAgaXNTZWFyY2hTdGFsbGVkOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UuX2lzU2VhcmNoU3RhbGxlZFxuICAgIH1cbiAgfTtcbiAgd2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICB2YXIgd2lkZ2V0UGFyYW1zID0ge307XG5cbiAgICBpZiAod2lkZ2V0LmdldFdpZGdldFJlbmRlclN0YXRlKSB7XG4gICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3aWRnZXQuZ2V0V2lkZ2V0UmVuZGVyU3RhdGUoaW5pdE9wdGlvbnMpO1xuXG4gICAgICBpZiAocmVuZGVyU3RhdGUgJiYgX3R5cGVvZihyZW5kZXJTdGF0ZS53aWRnZXRQYXJhbXMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICB3aWRnZXRQYXJhbXMgPSByZW5kZXJTdGF0ZS53aWRnZXRQYXJhbXM7XG4gICAgICB9XG4gICAgfSAvLyBzaW5jZSB3ZSBkZXN0cnVjdHVyZSBpbiBhbGwgd2lkZ2V0cywgdGhlIHBhcmFtZXRlcnMgd2l0aCBkZWZhdWx0cyBhcmUgc2V0IHRvIFwidW5kZWZpbmVkXCJcblxuXG4gICAgdmFyIHBhcmFtcyA9IE9iamVjdC5rZXlzKHdpZGdldFBhcmFtcykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiB3aWRnZXRQYXJhbXNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHBheWxvYWQud2lkZ2V0cy5wdXNoKHtcbiAgICAgIHR5cGU6IHdpZGdldC4kJHR5cGUsXG4gICAgICB3aWRnZXRUeXBlOiB3aWRnZXQuJCR3aWRnZXRUeXBlLFxuICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICB9KTtcblxuICAgIGlmICh3aWRnZXQuJCR0eXBlID09PSAnYWlzLmluZGV4Jykge1xuICAgICAgZXh0cmFjdFBheWxvYWQod2lkZ2V0LmdldFdpZGdldHMoKSwgaW5zdGFudFNlYXJjaEluc3RhbmNlLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNZXRhZGF0YUVuYWJsZWQoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbGdvbGlhIENyYXdsZXInKSA+IC0xO1xufVxuLyoqXG4gKiBFeHBvc2VzIHRoZSBtZXRhZGF0YSBvZiBtb3VudGVkIHdpZGdldHMgaW4gYSBjdXN0b21cbiAqIGA8bWV0YSBuYW1lPVwiaW5zdGFudHNlYXJjaDp3aWRnZXRzXCIgLz5gIHRhZy4gVGhlIG1ldGFkYXRhIHBlciB3aWRnZXQgaXM6XG4gKiAtIGFwcGxpZWQgcGFyYW1ldGVyc1xuICogLSB3aWRnZXQgbmFtZVxuICogLSBjb25uZWN0b3IgbmFtZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZXRhZGF0YU1pZGRsZXdhcmUoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBpbnN0YW50U2VhcmNoSW5zdGFuY2UgPSBfcmVmLmluc3RhbnRTZWFyY2hJbnN0YW5jZTtcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgIHdpZGdldHM6IFtdXG4gICAgfTtcbiAgICB2YXIgcGF5bG9hZENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICB2YXIgcmVmTm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgICBwYXlsb2FkQ29udGFpbmVyLm5hbWUgPSAnaW5zdGFudHNlYXJjaDp3aWRnZXRzJztcbiAgICByZXR1cm4ge1xuICAgICAgb25TdGF0ZUNoYW5nZTogZnVuY3Rpb24gb25TdGF0ZUNoYW5nZSgpIHt9LFxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUoKSB7XG4gICAgICAgIC8vIHVzaW5nIHNldFRpbWVvdXQgaGVyZSB0byBkZWxheSBleHRyYWN0aW9uIHVudGlsIHdpZGdldHMgaGF2ZSBiZWVuIGFkZGVkIGluIGEgdGljayAoZS5nLiBWdWUpXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBjbGllbnQgPSBpbnN0YW50U2VhcmNoSW5zdGFuY2UuY2xpZW50O1xuICAgICAgICAgIHBheWxvYWQudWEgPSBjbGllbnQudHJhbnNwb3J0ZXIgJiYgY2xpZW50LnRyYW5zcG9ydGVyLnVzZXJBZ2VudCA/IGNsaWVudC50cmFuc3BvcnRlci51c2VyQWdlbnQudmFsdWUgOiBjbGllbnQuX3VhO1xuICAgICAgICAgIGV4dHJhY3RQYXlsb2FkKGluc3RhbnRTZWFyY2hJbnN0YW5jZS5tYWluSW5kZXguZ2V0V2lkZ2V0cygpLCBpbnN0YW50U2VhcmNoSW5zdGFuY2UsIHBheWxvYWQpO1xuICAgICAgICAgIHBheWxvYWRDb250YWluZXIuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICAgIHJlZk5vZGUuYXBwZW5kQ2hpbGQocGF5bG9hZENvbnRhaW5lcik7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSxcbiAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgcGF5bG9hZENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufSIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgc2ltcGxlU3RhdGVNYXBwaW5nIGZyb20gJy4uL2xpYi9zdGF0ZU1hcHBpbmdzL3NpbXBsZSc7XG5pbXBvcnQgaGlzdG9yeVJvdXRlciBmcm9tICcuLi9saWIvcm91dGVycy9oaXN0b3J5JztcbmltcG9ydCB7IGlzRXF1YWwgfSBmcm9tICcuLi9saWIvdXRpbHMnO1xuZXhwb3J0IHZhciBjcmVhdGVSb3V0ZXJNaWRkbGV3YXJlID0gZnVuY3Rpb24gY3JlYXRlUm91dGVyTWlkZGxld2FyZSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIF9wcm9wcyRyb3V0ZXIgPSBwcm9wcy5yb3V0ZXIsXG4gICAgICByb3V0ZXIgPSBfcHJvcHMkcm91dGVyID09PSB2b2lkIDAgPyBoaXN0b3J5Um91dGVyKCkgOiBfcHJvcHMkcm91dGVyLFxuICAgICAgX3Byb3BzJHN0YXRlTWFwcGluZyA9IHByb3BzLnN0YXRlTWFwcGluZyxcbiAgICAgIHN0YXRlTWFwcGluZyA9IF9wcm9wcyRzdGF0ZU1hcHBpbmcgPT09IHZvaWQgMCA/IHNpbXBsZVN0YXRlTWFwcGluZygpIDogX3Byb3BzJHN0YXRlTWFwcGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGluc3RhbnRTZWFyY2hJbnN0YW5jZSA9IF9yZWYuaW5zdGFudFNlYXJjaEluc3RhbmNlO1xuXG4gICAgZnVuY3Rpb24gdG9wTGV2ZWxDcmVhdGVVUkwobmV4dFN0YXRlKSB7XG4gICAgICB2YXIgdWlTdGF0ZSA9IE9iamVjdC5rZXlzKG5leHRTdGF0ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGluZGV4SWQpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYWNjKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgaW5kZXhJZCwgbmV4dFN0YXRlW2luZGV4SWRdKSk7XG4gICAgICB9LCBpbnN0YW50U2VhcmNoSW5zdGFuY2UubWFpbkluZGV4LmdldFdpZGdldFVpU3RhdGUoe30pKTtcbiAgICAgIHZhciByb3V0ZSA9IHN0YXRlTWFwcGluZy5zdGF0ZVRvUm91dGUodWlTdGF0ZSk7XG4gICAgICByZXR1cm4gcm91dGVyLmNyZWF0ZVVSTChyb3V0ZSk7XG4gICAgfSAvLyBjYXN0aW5nIHRvIFVpU3RhdGUgaGVyZSB0byBrZWVwIGNyZWF0ZVVSTCB1bmF3YXJlIG9mIGN1c3RvbSBVaVN0YXRlXG4gICAgLy8gKGFzIGxvbmcgYXMgaXQncyBhbiBvYmplY3QsIGl0J3Mgb2spXG5cblxuICAgIGluc3RhbnRTZWFyY2hJbnN0YW5jZS5fY3JlYXRlVVJMID0gdG9wTGV2ZWxDcmVhdGVVUkw7XG4gICAgaW5zdGFudFNlYXJjaEluc3RhbmNlLl9pbml0aWFsVWlTdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaW5zdGFudFNlYXJjaEluc3RhbmNlLl9pbml0aWFsVWlTdGF0ZSksIHN0YXRlTWFwcGluZy5yb3V0ZVRvU3RhdGUocm91dGVyLnJlYWQoKSkpO1xuICAgIHZhciBsYXN0Um91dGVTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgb25TdGF0ZUNoYW5nZTogZnVuY3Rpb24gb25TdGF0ZUNoYW5nZShfcmVmMikge1xuICAgICAgICB2YXIgdWlTdGF0ZSA9IF9yZWYyLnVpU3RhdGU7XG4gICAgICAgIHZhciByb3V0ZVN0YXRlID0gc3RhdGVNYXBwaW5nLnN0YXRlVG9Sb3V0ZSh1aVN0YXRlKTtcblxuICAgICAgICBpZiAobGFzdFJvdXRlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCAhaXNFcXVhbChsYXN0Um91dGVTdGF0ZSwgcm91dGVTdGF0ZSkpIHtcbiAgICAgICAgICByb3V0ZXIud3JpdGUocm91dGVTdGF0ZSk7XG4gICAgICAgICAgbGFzdFJvdXRlU3RhdGUgPSByb3V0ZVN0YXRlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUoKSB7XG4gICAgICAgIHJvdXRlci5vblVwZGF0ZShmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2Uuc2V0VWlTdGF0ZShzdGF0ZU1hcHBpbmcucm91dGVUb1N0YXRlKHJvdXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgcm91dGVyLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTsiLCIiLCIiLCIiLCIvLyBpbnRlcm5hbFxuZXhwb3J0ICogZnJvbSAnLi91dGlscyc7IC8vIEFsZ29saWEtcmVsYXRlZFxuXG5leHBvcnQgKiBmcm9tICcuL2FsZ29saWFzZWFyY2gnO1xuZXhwb3J0ICogZnJvbSAnLi9yZXN1bHRzJzsgLy8gY29tcG9uZW50LXJlbGF0ZWRcblxuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnQnOyAvLyBpbnN0YW50c2VhcmNoLXJlbGF0ZWRcblxuZXhwb3J0ICogZnJvbSAnLi9pbnN0YW50c2VhcmNoJztcbmV4cG9ydCAqIGZyb20gJy4vbWlkZGxld2FyZSc7XG5leHBvcnQgKiBmcm9tICcuL3JvdXRlcic7XG5leHBvcnQgKiBmcm9tICcuL2luc2lnaHRzJzsgLy8gd2lkZ2V0LXJlbGF0ZWRcblxuZXhwb3J0ICogZnJvbSAnLi9jb25uZWN0b3InO1xuZXhwb3J0ICogZnJvbSAnLi93aWRnZXQtZmFjdG9yeSc7XG5leHBvcnQgKiBmcm9tICcuL3dpZGdldCc7XG5leHBvcnQgKiBmcm9tICcuL3VpLXN0YXRlJztcbmV4cG9ydCAqIGZyb20gJy4vcmVuZGVyLXN0YXRlJztcbmV4cG9ydCAqIGZyb20gJy4vdGVtcGxhdGVzJzsiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IGNvbm5lY3RDb25maWd1cmUgZnJvbSAnLi4vLi4vY29ubmVjdG9ycy9jb25maWd1cmUvY29ubmVjdENvbmZpZ3VyZSc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbi8qKlxuICogQSBsaXN0IG9mIFtzZWFyY2ggcGFyYW1ldGVyc10oaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL2FwaS1yZWZlcmVuY2Uvc2VhcmNoLWFwaS1wYXJhbWV0ZXJzLylcbiAqIHRvIGVuYWJsZSB3aGVuIHRoZSB3aWRnZXQgbW91bnRzLlxuICovXG5cbnZhciBjb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUod2lkZ2V0UGFyYW1zKSB7XG4gIC8vIFRoaXMgaXMgYSByZW5kZXJsZXNzIHdpZGdldCB0aGF0IGZhbGxzIGJhY2sgdG8gdGhlIGNvbm5lY3RvcidzXG4gIC8vIG5vb3AgcmVuZGVyIGFuZCB1bm1vdW50IGZ1bmN0aW9ucy5cbiAgdmFyIG1ha2VXaWRnZXQgPSBjb25uZWN0Q29uZmlndXJlKG5vb3ApO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtYWtlV2lkZ2V0KHtcbiAgICBzZWFyY2hQYXJhbWV0ZXJzOiB3aWRnZXRQYXJhbXNcbiAgfSkpLCB7fSwge1xuICAgICQkd2lkZ2V0VHlwZTogJ2Fpcy5jb25maWd1cmUnXG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29uZmlndXJlOyIsInZhciBkZWZhdWx0VGVtcGxhdGVzID0ge1xuICBlbXB0eTogJ05vIHJlc3VsdHMnLFxuICBpdGVtOiBmdW5jdGlvbiBpdGVtKGRhdGEpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0VGVtcGxhdGVzOyIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKiogQGpzeCBoICovXG5pbXBvcnQgeyBoLCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IGNvbm5lY3RIaXRzIGZyb20gJy4uLy4uL2Nvbm5lY3RvcnMvaGl0cy9jb25uZWN0SGl0cyc7XG5pbXBvcnQgSGl0cyBmcm9tICcuLi8uLi9jb21wb25lbnRzL0hpdHMvSGl0cyc7XG5pbXBvcnQgZGVmYXVsdFRlbXBsYXRlcyBmcm9tICcuL2RlZmF1bHRUZW1wbGF0ZXMnO1xuaW1wb3J0IHsgcHJlcGFyZVRlbXBsYXRlUHJvcHMsIGdldENvbnRhaW5lck5vZGUsIGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCB7IGNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2xpYi9zdWl0JztcbmltcG9ydCB7IHdpdGhJbnNpZ2h0cywgd2l0aEluc2lnaHRzTGlzdGVuZXIgfSBmcm9tICcuLi8uLi9saWIvaW5zaWdodHMnO1xudmFyIHdpdGhVc2FnZSA9IGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yKHtcbiAgbmFtZTogJ2hpdHMnXG59KTtcbnZhciBzdWl0ID0gY29tcG9uZW50KCdIaXRzJyk7XG52YXIgSGl0c1dpdGhJbnNpZ2h0c0xpc3RlbmVyID0gd2l0aEluc2lnaHRzTGlzdGVuZXIoSGl0cyk7XG5cbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uIHJlbmRlcmVyKF9yZWYpIHtcbiAgdmFyIHJlbmRlclN0YXRlID0gX3JlZi5yZW5kZXJTdGF0ZSxcbiAgICAgIGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICBjb250YWluZXJOb2RlID0gX3JlZi5jb250YWluZXJOb2RlLFxuICAgICAgdGVtcGxhdGVzID0gX3JlZi50ZW1wbGF0ZXM7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZjIsIGlzRmlyc3RSZW5kZXJpbmcpIHtcbiAgICB2YXIgcmVjZWl2ZWRIaXRzID0gX3JlZjIuaGl0cyxcbiAgICAgICAgcmVzdWx0cyA9IF9yZWYyLnJlc3VsdHMsXG4gICAgICAgIGluc3RhbnRTZWFyY2hJbnN0YW5jZSA9IF9yZWYyLmluc3RhbnRTZWFyY2hJbnN0YW5jZSxcbiAgICAgICAgaW5zaWdodHMgPSBfcmVmMi5pbnNpZ2h0cyxcbiAgICAgICAgYmluZEV2ZW50ID0gX3JlZjIuYmluZEV2ZW50O1xuXG4gICAgaWYgKGlzRmlyc3RSZW5kZXJpbmcpIHtcbiAgICAgIHJlbmRlclN0YXRlLnRlbXBsYXRlUHJvcHMgPSBwcmVwYXJlVGVtcGxhdGVQcm9wcyh7XG4gICAgICAgIGRlZmF1bHRUZW1wbGF0ZXM6IGRlZmF1bHRUZW1wbGF0ZXMsXG4gICAgICAgIHRlbXBsYXRlc0NvbmZpZzogaW5zdGFudFNlYXJjaEluc3RhbmNlLnRlbXBsYXRlc0NvbmZpZyxcbiAgICAgICAgdGVtcGxhdGVzOiB0ZW1wbGF0ZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbmRlcihoKEhpdHNXaXRoSW5zaWdodHNMaXN0ZW5lciwge1xuICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3NlcyxcbiAgICAgIGhpdHM6IHJlY2VpdmVkSGl0cyxcbiAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICB0ZW1wbGF0ZVByb3BzOiByZW5kZXJTdGF0ZS50ZW1wbGF0ZVByb3BzLFxuICAgICAgaW5zaWdodHM6IGluc2lnaHRzLFxuICAgICAgc2VuZEV2ZW50OiBmdW5jdGlvbiBzZW5kRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlLnNlbmRFdmVudFRvSW5zaWdodHMoZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJpbmRFdmVudDogYmluZEV2ZW50XG4gICAgfSksIGNvbnRhaW5lck5vZGUpO1xuICB9O1xufTtcblxudmFyIGhpdHMgPSBmdW5jdGlvbiBoaXRzKHdpZGdldFBhcmFtcykge1xuICB2YXIgX3JlZjMgPSB3aWRnZXRQYXJhbXMgfHwge30sXG4gICAgICBjb250YWluZXIgPSBfcmVmMy5jb250YWluZXIsXG4gICAgICBlc2NhcGVIVE1MID0gX3JlZjMuZXNjYXBlSFRNTCxcbiAgICAgIHRyYW5zZm9ybUl0ZW1zID0gX3JlZjMudHJhbnNmb3JtSXRlbXMsXG4gICAgICBfcmVmMyR0ZW1wbGF0ZXMgPSBfcmVmMy50ZW1wbGF0ZXMsXG4gICAgICB0ZW1wbGF0ZXMgPSBfcmVmMyR0ZW1wbGF0ZXMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkdGVtcGxhdGVzLFxuICAgICAgX3JlZjMkY3NzQ2xhc3NlcyA9IF9yZWYzLmNzc0NsYXNzZXMsXG4gICAgICB1c2VyQ3NzQ2xhc3NlcyA9IF9yZWYzJGNzc0NsYXNzZXMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkY3NzQ2xhc3NlcztcblxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgY29udGFpbmVyYCBvcHRpb24gaXMgcmVxdWlyZWQuJykpO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lck5vZGUgPSBnZXRDb250YWluZXJOb2RlKGNvbnRhaW5lcik7XG4gIHZhciBjc3NDbGFzc2VzID0ge1xuICAgIHJvb3Q6IGN4KHN1aXQoKSwgdXNlckNzc0NsYXNzZXMucm9vdCksXG4gICAgZW1wdHlSb290OiBjeChzdWl0KHtcbiAgICAgIG1vZGlmaWVyTmFtZTogJ2VtcHR5J1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5lbXB0eVJvb3QpLFxuICAgIGxpc3Q6IGN4KHN1aXQoe1xuICAgICAgZGVzY2VuZGFudE5hbWU6ICdsaXN0J1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5saXN0KSxcbiAgICBpdGVtOiBjeChzdWl0KHtcbiAgICAgIGRlc2NlbmRhbnROYW1lOiAnaXRlbSdcbiAgICB9KSwgdXNlckNzc0NsYXNzZXMuaXRlbSlcbiAgfTtcbiAgdmFyIHNwZWNpYWxpemVkUmVuZGVyZXIgPSByZW5kZXJlcih7XG4gICAgY29udGFpbmVyTm9kZTogY29udGFpbmVyTm9kZSxcbiAgICBjc3NDbGFzc2VzOiBjc3NDbGFzc2VzLFxuICAgIHJlbmRlclN0YXRlOiB7fSxcbiAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlc1xuICB9KTtcbiAgdmFyIG1ha2VXaWRnZXQgPSB3aXRoSW5zaWdodHMoY29ubmVjdEhpdHMpKHNwZWNpYWxpemVkUmVuZGVyZXIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVuZGVyKG51bGwsIGNvbnRhaW5lck5vZGUpO1xuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbWFrZVdpZGdldCh7XG4gICAgZXNjYXBlSFRNTDogZXNjYXBlSFRNTCxcbiAgICB0cmFuc2Zvcm1JdGVtczogdHJhbnNmb3JtSXRlbXNcbiAgfSkpLCB7fSwge1xuICAgICQkd2lkZ2V0VHlwZTogJ2Fpcy5oaXRzJ1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhpdHM7IiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IGFsZ29saWFzZWFyY2hIZWxwZXIgZnJvbSAnYWxnb2xpYXNlYXJjaC1oZWxwZXInO1xuaW1wb3J0IHsgY2hlY2tJbmRleFVpU3RhdGUsIGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yLCByZXNvbHZlU2VhcmNoUGFyYW1ldGVycywgbWVyZ2VTZWFyY2hQYXJhbWV0ZXJzLCB3YXJuaW5nIH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbnZhciB3aXRoVXNhZ2UgPSBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvcih7XG4gIG5hbWU6ICdpbmRleC13aWRnZXQnXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpc0luZGV4V2lkZ2V0KHdpZGdldCkge1xuICByZXR1cm4gd2lkZ2V0LiQkdHlwZSA9PT0gJ2Fpcy5pbmRleCc7XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIHNhbWUgY29udGVudCBhcyBoZWxwZXIuX2NoYW5nZSAvIHNldFN0YXRlLCBidXQgYWxsb3dpbmcgZm9yIGV4dHJhXG4gKiBVaVN0YXRlIHRvIGJlIHN5bmNocm9uaXplZC5cbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvYWxnb2xpYXNlYXJjaC1oZWxwZXItanMvYmxvYi82YjgzNWZmZDA3NzQyZjJkNmIzMTQwMjJjY2U2ODQ4ZjVjZmVjZDRhL3NyYy9hbGdvbGlhc2VhcmNoLmhlbHBlci5qcyNMMTMxMS1MMTMyNFxuICovXG5cbmZ1bmN0aW9uIHByaXZhdGVIZWxwZXJTZXRTdGF0ZShoZWxwZXIsIF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGlzUGFnZVJlc2V0ID0gX3JlZi5pc1BhZ2VSZXNldCxcbiAgICAgIF91aVN0YXRlID0gX3JlZi5fdWlTdGF0ZTtcblxuICBpZiAoc3RhdGUgIT09IGhlbHBlci5zdGF0ZSkge1xuICAgIGhlbHBlci5zdGF0ZSA9IHN0YXRlO1xuICAgIGhlbHBlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICBzdGF0ZTogaGVscGVyLnN0YXRlLFxuICAgICAgcmVzdWx0czogaGVscGVyLmxhc3RSZXN1bHRzLFxuICAgICAgaXNQYWdlUmVzZXQ6IGlzUGFnZVJlc2V0LFxuICAgICAgX3VpU3RhdGU6IF91aVN0YXRlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TG9jYWxXaWRnZXRzVWlTdGF0ZSh3aWRnZXRzLCB3aWRnZXRTdGF0ZU9wdGlvbnMpIHtcbiAgdmFyIGluaXRpYWxVaVN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgcmV0dXJuIHdpZGdldHMucmVkdWNlKGZ1bmN0aW9uICh1aVN0YXRlLCB3aWRnZXQpIHtcbiAgICBpZiAoaXNJbmRleFdpZGdldCh3aWRnZXQpKSB7XG4gICAgICByZXR1cm4gdWlTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoIXdpZGdldC5nZXRXaWRnZXRVaVN0YXRlICYmICF3aWRnZXQuZ2V0V2lkZ2V0U3RhdGUpIHtcbiAgICAgIHJldHVybiB1aVN0YXRlO1xuICAgIH1cblxuICAgIGlmICh3aWRnZXQuZ2V0V2lkZ2V0VWlTdGF0ZSkge1xuICAgICAgcmV0dXJuIHdpZGdldC5nZXRXaWRnZXRVaVN0YXRlKHVpU3RhdGUsIHdpZGdldFN0YXRlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZGdldC5nZXRXaWRnZXRTdGF0ZSh1aVN0YXRlLCB3aWRnZXRTdGF0ZU9wdGlvbnMpO1xuICB9LCBpbml0aWFsVWlTdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldExvY2FsV2lkZ2V0c1NlYXJjaFBhcmFtZXRlcnMod2lkZ2V0cywgd2lkZ2V0U2VhcmNoUGFyYW1ldGVyc09wdGlvbnMpIHtcbiAgdmFyIGluaXRpYWxTZWFyY2hQYXJhbWV0ZXJzID0gd2lkZ2V0U2VhcmNoUGFyYW1ldGVyc09wdGlvbnMuaW5pdGlhbFNlYXJjaFBhcmFtZXRlcnMsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHdpZGdldFNlYXJjaFBhcmFtZXRlcnNPcHRpb25zLCBbXCJpbml0aWFsU2VhcmNoUGFyYW1ldGVyc1wiXSk7XG5cbiAgcmV0dXJuIHdpZGdldHMuZmlsdGVyKGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICByZXR1cm4gIWlzSW5kZXhXaWRnZXQod2lkZ2V0KTtcbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChzdGF0ZSwgd2lkZ2V0KSB7XG4gICAgaWYgKCF3aWRnZXQuZ2V0V2lkZ2V0U2VhcmNoUGFyYW1ldGVycykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiB3aWRnZXQuZ2V0V2lkZ2V0U2VhcmNoUGFyYW1ldGVycyhzdGF0ZSwgcmVzdCk7XG4gIH0sIGluaXRpYWxTZWFyY2hQYXJhbWV0ZXJzKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRQYWdlRnJvbVdpZGdldHMod2lkZ2V0cykge1xuICB2YXIgaW5kZXhXaWRnZXRzID0gd2lkZ2V0cy5maWx0ZXIoaXNJbmRleFdpZGdldCk7XG5cbiAgaWYgKGluZGV4V2lkZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpbmRleFdpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgdmFyIHdpZGdldEhlbHBlciA9IHdpZGdldC5nZXRIZWxwZXIoKTtcbiAgICBwcml2YXRlSGVscGVyU2V0U3RhdGUod2lkZ2V0SGVscGVyLCB7XG4gICAgICBzdGF0ZTogd2lkZ2V0SGVscGVyLnN0YXRlLnJlc2V0UGFnZSgpLFxuICAgICAgaXNQYWdlUmVzZXQ6IHRydWVcbiAgICB9KTtcbiAgICByZXNldFBhZ2VGcm9tV2lkZ2V0cyh3aWRnZXQuZ2V0V2lkZ2V0cygpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRSZXN1bHRzRnJvbVdpZGdldHMod2lkZ2V0cykge1xuICB2YXIgaW5kZXhXaWRnZXRzID0gd2lkZ2V0cy5maWx0ZXIoaXNJbmRleFdpZGdldCk7XG4gIHJldHVybiBpbmRleFdpZGdldHMucmVkdWNlKGZ1bmN0aW9uIChzY29wZWRSZXN1bHRzLCBjdXJyZW50KSB7XG4gICAgcmV0dXJuIHNjb3BlZFJlc3VsdHMuY29uY2F0LmFwcGx5KHNjb3BlZFJlc3VsdHMsIFt7XG4gICAgICBpbmRleElkOiBjdXJyZW50LmdldEluZGV4SWQoKSxcbiAgICAgIHJlc3VsdHM6IGN1cnJlbnQuZ2V0UmVzdWx0cygpLFxuICAgICAgaGVscGVyOiBjdXJyZW50LmdldEhlbHBlcigpXG4gICAgfV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXNvbHZlU2NvcGVkUmVzdWx0c0Zyb21XaWRnZXRzKGN1cnJlbnQuZ2V0V2lkZ2V0cygpKSkpKTtcbiAgfSwgW10pO1xufVxuXG52YXIgaW5kZXggPSBmdW5jdGlvbiBpbmRleCh3aWRnZXRQYXJhbXMpIHtcbiAgaWYgKHdpZGdldFBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8IHdpZGdldFBhcmFtcy5pbmRleE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgaW5kZXhOYW1lYCBvcHRpb24gaXMgcmVxdWlyZWQuJykpO1xuICB9XG5cbiAgdmFyIGluZGV4TmFtZSA9IHdpZGdldFBhcmFtcy5pbmRleE5hbWUsXG4gICAgICBfd2lkZ2V0UGFyYW1zJGluZGV4SWQgPSB3aWRnZXRQYXJhbXMuaW5kZXhJZCxcbiAgICAgIGluZGV4SWQgPSBfd2lkZ2V0UGFyYW1zJGluZGV4SWQgPT09IHZvaWQgMCA/IGluZGV4TmFtZSA6IF93aWRnZXRQYXJhbXMkaW5kZXhJZDtcbiAgdmFyIGxvY2FsV2lkZ2V0cyA9IFtdO1xuICB2YXIgbG9jYWxVaVN0YXRlID0ge307XG4gIHZhciBsb2NhbEluc3RhbnRTZWFyY2hJbnN0YW5jZSA9IG51bGw7XG4gIHZhciBsb2NhbFBhcmVudCA9IG51bGw7XG4gIHZhciBoZWxwZXIgPSBudWxsO1xuICB2YXIgZGVyaXZlZEhlbHBlciA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlOiAnYWlzLmluZGV4JyxcbiAgICAkJHdpZGdldFR5cGU6ICdhaXMuaW5kZXgnLFxuICAgIGdldEluZGV4TmFtZTogZnVuY3Rpb24gZ2V0SW5kZXhOYW1lKCkge1xuICAgICAgcmV0dXJuIGluZGV4TmFtZTtcbiAgICB9LFxuICAgIGdldEluZGV4SWQ6IGZ1bmN0aW9uIGdldEluZGV4SWQoKSB7XG4gICAgICByZXR1cm4gaW5kZXhJZDtcbiAgICB9LFxuICAgIGdldEhlbHBlcjogZnVuY3Rpb24gZ2V0SGVscGVyKCkge1xuICAgICAgcmV0dXJuIGhlbHBlcjtcbiAgICB9LFxuICAgIGdldFJlc3VsdHM6IGZ1bmN0aW9uIGdldFJlc3VsdHMoKSB7XG4gICAgICByZXR1cm4gZGVyaXZlZEhlbHBlciAmJiBkZXJpdmVkSGVscGVyLmxhc3RSZXN1bHRzO1xuICAgIH0sXG4gICAgZ2V0U2NvcGVkUmVzdWx0czogZnVuY3Rpb24gZ2V0U2NvcGVkUmVzdWx0cygpIHtcbiAgICAgIHZhciB3aWRnZXRQYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpOyAvLyBJZiB0aGUgd2lkZ2V0IGlzIHRoZSByb290LCB3ZSBjb25zaWRlciBpdHNlbGYgYXMgdGhlIG9ubHkgc2libGluZy5cblxuICAgICAgdmFyIHdpZGdldFNpYmxpbmdzID0gd2lkZ2V0UGFyZW50ID8gd2lkZ2V0UGFyZW50LmdldFdpZGdldHMoKSA6IFt0aGlzXTtcbiAgICAgIHJldHVybiByZXNvbHZlU2NvcGVkUmVzdWx0c0Zyb21XaWRnZXRzKHdpZGdldFNpYmxpbmdzKTtcbiAgICB9LFxuICAgIGdldFBhcmVudDogZnVuY3Rpb24gZ2V0UGFyZW50KCkge1xuICAgICAgcmV0dXJuIGxvY2FsUGFyZW50O1xuICAgIH0sXG4gICAgY3JlYXRlVVJMOiBmdW5jdGlvbiBjcmVhdGVVUkwobmV4dFN0YXRlKSB7XG4gICAgICByZXR1cm4gbG9jYWxJbnN0YW50U2VhcmNoSW5zdGFuY2UuX2NyZWF0ZVVSTChfZGVmaW5lUHJvcGVydHkoe30sIGluZGV4SWQsIGdldExvY2FsV2lkZ2V0c1VpU3RhdGUobG9jYWxXaWRnZXRzLCB7XG4gICAgICAgIHNlYXJjaFBhcmFtZXRlcnM6IG5leHRTdGF0ZSxcbiAgICAgICAgaGVscGVyOiBoZWxwZXJcbiAgICAgIH0pKSk7XG4gICAgfSxcbiAgICBnZXRXaWRnZXRzOiBmdW5jdGlvbiBnZXRXaWRnZXRzKCkge1xuICAgICAgcmV0dXJuIGxvY2FsV2lkZ2V0cztcbiAgICB9LFxuICAgIGFkZFdpZGdldHM6IGZ1bmN0aW9uIGFkZFdpZGdldHMod2lkZ2V0cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdpZGdldHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgYWRkV2lkZ2V0c2AgbWV0aG9kIGV4cGVjdHMgYW4gYXJyYXkgb2Ygd2lkZ2V0cy4nKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aWRnZXRzLnNvbWUoZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHdpZGdldC5pbml0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB3aWRnZXQucmVuZGVyICE9PSAnZnVuY3Rpb24nO1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdpdGhVc2FnZSgnVGhlIHdpZGdldCBkZWZpbml0aW9uIGV4cGVjdHMgYSBgcmVuZGVyYCBhbmQvb3IgYW4gYGluaXRgIG1ldGhvZC4nKSk7XG4gICAgICB9XG5cbiAgICAgIGxvY2FsV2lkZ2V0cyA9IGxvY2FsV2lkZ2V0cy5jb25jYXQod2lkZ2V0cyk7XG5cbiAgICAgIGlmIChsb2NhbEluc3RhbnRTZWFyY2hJbnN0YW5jZSAmJiBCb29sZWFuKHdpZGdldHMubGVuZ3RoKSkge1xuICAgICAgICBwcml2YXRlSGVscGVyU2V0U3RhdGUoaGVscGVyLCB7XG4gICAgICAgICAgc3RhdGU6IGdldExvY2FsV2lkZ2V0c1NlYXJjaFBhcmFtZXRlcnMobG9jYWxXaWRnZXRzLCB7XG4gICAgICAgICAgICB1aVN0YXRlOiBsb2NhbFVpU3RhdGUsXG4gICAgICAgICAgICBpbml0aWFsU2VhcmNoUGFyYW1ldGVyczogaGVscGVyLnN0YXRlXG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3VpU3RhdGU6IGxvY2FsVWlTdGF0ZVxuICAgICAgICB9KTsgLy8gV2UgY29tcHV0ZSB0aGUgcmVuZGVyIHN0YXRlIGJlZm9yZSBjYWxsaW5nIGBpbml0YCBpbiBhIHNlcGFyYXRlIGxvb3BcbiAgICAgICAgLy8gdG8gY29uc3RydWN0IHRoZSB3aG9sZSByZW5kZXIgc3RhdGUgb2JqZWN0IHRoYXQgaXMgdGhlbiBwYXNzZWQgdG9cbiAgICAgICAgLy8gYGluaXRgLlxuXG4gICAgICAgIHdpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgaWYgKHdpZGdldC5nZXRSZW5kZXJTdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd2lkZ2V0LmdldFJlbmRlclN0YXRlKGxvY2FsSW5zdGFudFNlYXJjaEluc3RhbmNlLnJlbmRlclN0YXRlW190aGlzLmdldEluZGV4SWQoKV0gfHwge30sIHtcbiAgICAgICAgICAgICAgdWlTdGF0ZTogbG9jYWxJbnN0YW50U2VhcmNoSW5zdGFuY2UuX2luaXRpYWxVaVN0YXRlLFxuICAgICAgICAgICAgICBoZWxwZXI6IF90aGlzLmdldEhlbHBlcigpLFxuICAgICAgICAgICAgICBwYXJlbnQ6IF90aGlzLFxuICAgICAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGxvY2FsSW5zdGFudFNlYXJjaEluc3RhbmNlLFxuICAgICAgICAgICAgICBzdGF0ZTogaGVscGVyLnN0YXRlLFxuICAgICAgICAgICAgICByZW5kZXJTdGF0ZTogbG9jYWxJbnN0YW50U2VhcmNoSW5zdGFuY2UucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlc0NvbmZpZzogbG9jYWxJbnN0YW50U2VhcmNoSW5zdGFuY2UudGVtcGxhdGVzQ29uZmlnLFxuICAgICAgICAgICAgICBjcmVhdGVVUkw6IF90aGlzLmNyZWF0ZVVSTCxcbiAgICAgICAgICAgICAgc2NvcGVkUmVzdWx0czogW10sXG4gICAgICAgICAgICAgIHNlYXJjaE1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgaXNTZWFyY2hTdGFsbGVkOiBsb2NhbEluc3RhbnRTZWFyY2hJbnN0YW5jZS5faXNTZWFyY2hTdGFsbGVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RvcmVSZW5kZXJTdGF0ZSh7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlOiByZW5kZXJTdGF0ZSxcbiAgICAgICAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBsb2NhbEluc3RhbnRTZWFyY2hJbnN0YW5jZSxcbiAgICAgICAgICAgICAgcGFyZW50OiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgICBpZiAod2lkZ2V0LmluaXQpIHtcbiAgICAgICAgICAgIHdpZGdldC5pbml0KHtcbiAgICAgICAgICAgICAgaGVscGVyOiBoZWxwZXIsXG4gICAgICAgICAgICAgIHBhcmVudDogX3RoaXMsXG4gICAgICAgICAgICAgIHVpU3RhdGU6IGxvY2FsSW5zdGFudFNlYXJjaEluc3RhbmNlLl9pbml0aWFsVWlTdGF0ZSxcbiAgICAgICAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBsb2NhbEluc3RhbnRTZWFyY2hJbnN0YW5jZSxcbiAgICAgICAgICAgICAgc3RhdGU6IGhlbHBlci5zdGF0ZSxcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGU6IGxvY2FsSW5zdGFudFNlYXJjaEluc3RhbmNlLnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZXNDb25maWc6IGxvY2FsSW5zdGFudFNlYXJjaEluc3RhbmNlLnRlbXBsYXRlc0NvbmZpZyxcbiAgICAgICAgICAgICAgY3JlYXRlVVJMOiBfdGhpcy5jcmVhdGVVUkwsXG4gICAgICAgICAgICAgIHNjb3BlZFJlc3VsdHM6IFtdLFxuICAgICAgICAgICAgICBzZWFyY2hNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIGlzU2VhcmNoU3RhbGxlZDogbG9jYWxJbnN0YW50U2VhcmNoSW5zdGFuY2UuX2lzU2VhcmNoU3RhbGxlZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsb2NhbEluc3RhbnRTZWFyY2hJbnN0YW5jZS5zY2hlZHVsZVNlYXJjaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZVdpZGdldHM6IGZ1bmN0aW9uIHJlbW92ZVdpZGdldHMod2lkZ2V0cykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3aWRnZXRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iod2l0aFVzYWdlKCdUaGUgYHJlbW92ZVdpZGdldHNgIG1ldGhvZCBleHBlY3RzIGFuIGFycmF5IG9mIHdpZGdldHMuJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAod2lkZ2V0cy5zb21lKGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aWRnZXQuZGlzcG9zZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSB3aWRnZXQgZGVmaW5pdGlvbiBleHBlY3RzIGEgYGRpc3Bvc2VgIG1ldGhvZC4nKSk7XG4gICAgICB9XG5cbiAgICAgIGxvY2FsV2lkZ2V0cyA9IGxvY2FsV2lkZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICByZXR1cm4gd2lkZ2V0cy5pbmRleE9mKHdpZGdldCkgPT09IC0xO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChsb2NhbEluc3RhbnRTZWFyY2hJbnN0YW5jZSAmJiBCb29sZWFuKHdpZGdldHMubGVuZ3RoKSkge1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd2lkZ2V0cy5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCB3aWRnZXQpIHtcbiAgICAgICAgICAvLyB0aGUgYGRpc3Bvc2VgIG1ldGhvZCBleGlzdHMgYXQgdGhpcyBwb2ludCB3ZSBhbHJlYWR5IGFzc2VydCBpdFxuICAgICAgICAgIHZhciBuZXh0ID0gd2lkZ2V0LmRpc3Bvc2Uoe1xuICAgICAgICAgICAgaGVscGVyOiBoZWxwZXIsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBwYXJlbnQ6IF90aGlzMlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBuZXh0IHx8IHN0YXRlO1xuICAgICAgICB9LCBoZWxwZXIuc3RhdGUpO1xuICAgICAgICBsb2NhbFVpU3RhdGUgPSBnZXRMb2NhbFdpZGdldHNVaVN0YXRlKGxvY2FsV2lkZ2V0cywge1xuICAgICAgICAgIHNlYXJjaFBhcmFtZXRlcnM6IG5leHRTdGF0ZSxcbiAgICAgICAgICBoZWxwZXI6IGhlbHBlclxuICAgICAgICB9KTtcbiAgICAgICAgaGVscGVyLnNldFN0YXRlKGdldExvY2FsV2lkZ2V0c1NlYXJjaFBhcmFtZXRlcnMobG9jYWxXaWRnZXRzLCB7XG4gICAgICAgICAgdWlTdGF0ZTogbG9jYWxVaVN0YXRlLFxuICAgICAgICAgIGluaXRpYWxTZWFyY2hQYXJhbWV0ZXJzOiBuZXh0U3RhdGVcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChsb2NhbFdpZGdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgbG9jYWxJbnN0YW50U2VhcmNoSW5zdGFuY2Uuc2NoZWR1bGVTZWFyY2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoX3JlZjIpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgaW5zdGFudFNlYXJjaEluc3RhbmNlID0gX3JlZjIuaW5zdGFudFNlYXJjaEluc3RhbmNlLFxuICAgICAgICAgIHBhcmVudCA9IF9yZWYyLnBhcmVudCxcbiAgICAgICAgICB1aVN0YXRlID0gX3JlZjIudWlTdGF0ZTtcblxuICAgICAgaWYgKGhlbHBlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBoZWxwZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZCwgdGhlcmVmb3JlIHdlIGRvIG5vdCBuZWVkIHRvIHNldCB1cFxuICAgICAgICAvLyBhbnkgbGlzdGVuZXJzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWxJbnN0YW50U2VhcmNoSW5zdGFuY2UgPSBpbnN0YW50U2VhcmNoSW5zdGFuY2U7XG4gICAgICBsb2NhbFBhcmVudCA9IHBhcmVudDtcbiAgICAgIGxvY2FsVWlTdGF0ZSA9IHVpU3RhdGVbaW5kZXhJZF0gfHwge307IC8vIFRoZSBgbWFpbkhlbHBlcmAgaXMgYWxyZWFkeSBkZWZpbmVkIGF0IHRoaXMgcG9pbnQuIFRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAgICAvLyBpbnNpZGUgSW5zdGFudFNlYXJjaCBhdCB0aGUgYHN0YXJ0YCBtZXRob2QsIHdoaWNoIG9jY3VycyBiZWZvcmUgdGhlIGBpbml0YFxuICAgICAgLy8gc3RlcC5cblxuICAgICAgdmFyIG1haW5IZWxwZXIgPSBpbnN0YW50U2VhcmNoSW5zdGFuY2UubWFpbkhlbHBlcjtcbiAgICAgIHZhciBwYXJhbWV0ZXJzID0gZ2V0TG9jYWxXaWRnZXRzU2VhcmNoUGFyYW1ldGVycyhsb2NhbFdpZGdldHMsIHtcbiAgICAgICAgdWlTdGF0ZTogbG9jYWxVaVN0YXRlLFxuICAgICAgICBpbml0aWFsU2VhcmNoUGFyYW1ldGVyczogbmV3IGFsZ29saWFzZWFyY2hIZWxwZXIuU2VhcmNoUGFyYW1ldGVycyh7XG4gICAgICAgICAgaW5kZXg6IGluZGV4TmFtZVxuICAgICAgICB9KVxuICAgICAgfSk7IC8vIFRoaXMgSGVscGVyIGlzIG9ubHkgdXNlZCBmb3Igc3RhdGUgbWFuYWdlbWVudCB3ZSBkbyBub3QgY2FyZSBhYm91dCB0aGVcbiAgICAgIC8vIGBzZWFyY2hDbGllbnRgLiBPbmx5IHRoZSBcIm1haW5cIiBIZWxwZXIgY3JlYXRlZCBhdCB0aGUgYEluc3RhbnRTZWFyY2hgXG4gICAgICAvLyBsZXZlbCBpcyBhd2FyZSBvZiB0aGUgY2xpZW50LlxuXG4gICAgICBoZWxwZXIgPSBhbGdvbGlhc2VhcmNoSGVscGVyKHt9LCBwYXJhbWV0ZXJzLmluZGV4LCBwYXJhbWV0ZXJzKTsgLy8gV2UgZm9yd2FyZCB0aGUgY2FsbCB0byBgc2VhcmNoYCB0byB0aGUgXCJtYWluXCIgaW5zdGFuY2Ugb2YgdGhlIEhlbHBlclxuICAgICAgLy8gd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHRoZSBxdWVyaWVzIChpdCdzIHRoZSBvbmx5IG9uZSB0aGF0IGlzXG4gICAgICAvLyBhd2FyZSBvZiB0aGUgYHNlYXJjaENsaWVudGApLlxuXG4gICAgICBoZWxwZXIuc2VhcmNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFudFNlYXJjaEluc3RhbmNlLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2Uub25TdGF0ZUNoYW5nZSh7XG4gICAgICAgICAgICB1aVN0YXRlOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UubWFpbkluZGV4LmdldFdpZGdldFVpU3RhdGUoe30pLFxuICAgICAgICAgICAgc2V0VWlTdGF0ZTogaW5zdGFudFNlYXJjaEluc3RhbmNlLnNldFVpU3RhdGUuYmluZChpbnN0YW50U2VhcmNoSW5zdGFuY2UpXG4gICAgICAgICAgfSk7IC8vIFdlIGRvbid0IHRyaWdnZXIgYSBzZWFyY2ggd2hlbiBjb250cm9sbGVkIGJlY2F1c2UgaXQgYmVjb21lcyB0aGVcbiAgICAgICAgICAvLyByZXNwb25zaWJpbGl0eSBvZiBgc2V0VWlTdGF0ZWAuXG5cbiAgICAgICAgICByZXR1cm4gbWFpbkhlbHBlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYWluSGVscGVyLnNlYXJjaCgpO1xuICAgICAgfTtcblxuICAgICAgaGVscGVyLnNlYXJjaFdpdGhvdXRUcmlnZ2VyaW5nT25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1haW5IZWxwZXIuc2VhcmNoKCk7XG4gICAgICB9OyAvLyBXZSB1c2UgdGhlIHNhbWUgcGF0dGVybiBmb3IgdGhlIGBzZWFyY2hGb3JGYWNldFZhbHVlc2AuXG5cblxuICAgICAgaGVscGVyLnNlYXJjaEZvckZhY2V0VmFsdWVzID0gZnVuY3Rpb24gKGZhY2V0TmFtZSwgZmFjZXRWYWx1ZSwgbWF4RmFjZXRIaXRzLCB1c2VyU3RhdGUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gaGVscGVyLnN0YXRlLnNldFF1ZXJ5UGFyYW1ldGVycyh1c2VyU3RhdGUpO1xuICAgICAgICByZXR1cm4gbWFpbkhlbHBlci5zZWFyY2hGb3JGYWNldFZhbHVlcyhmYWNldE5hbWUsIGZhY2V0VmFsdWUsIG1heEZhY2V0SGl0cywgc3RhdGUpO1xuICAgICAgfTtcblxuICAgICAgZGVyaXZlZEhlbHBlciA9IG1haW5IZWxwZXIuZGVyaXZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlU2VhcmNoUGFyYW1ldGVycy5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShyZXNvbHZlU2VhcmNoUGFyYW1ldGVycyhfdGhpczMpKSk7XG4gICAgICB9KTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBIZWxwZXIgc3RhdGUgY2hhbmdlcyBmb3IgdGhlIHBhZ2UgYmVmb3JlIHdpZGdldHNcbiAgICAgIC8vIGFyZSBpbml0aWFsaXplZC4gVGhpcyBiZWhhdmlvciBtaW1pY3MgdGhlIG9yaWdpbmFsIG9uZSBvZiB0aGUgSGVscGVyLlxuICAgICAgLy8gSXQgbWFrZXMgc2Vuc2UgdG8gcmVwbGljYXRlIGl0IGF0IHRoZSBgaW5pdGAgc3RlcC4gV2UgaGF2ZSBhbm90aGVyXG4gICAgICAvLyBsaXN0ZW5lciBvbiBgY2hhbmdlYCBiZWxvdywgb25jZSBgaW5pdGAgaXMgZG9uZS5cblxuICAgICAgaGVscGVyLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIGlzUGFnZVJlc2V0ID0gX3JlZjMuaXNQYWdlUmVzZXQ7XG5cbiAgICAgICAgaWYgKGlzUGFnZVJlc2V0KSB7XG4gICAgICAgICAgcmVzZXRQYWdlRnJvbVdpZGdldHMobG9jYWxXaWRnZXRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZXJpdmVkSGVscGVyLm9uKCdzZWFyY2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZSBpbmRleCBkb2VzIG5vdCBtYW5hZ2UgdGhlIFwic3RhbGVuZXNzXCIgb2YgdGhlIHNlYXJjaC4gVGhpcyBpcyB0aGVcbiAgICAgICAgLy8gcmVzcG9uc2liaWxpdHkgb2YgdGhlIG1haW4gaW5zdGFuY2UuIEl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdG8gbWFuYWdlXG4gICAgICAgIC8vIGl0IGF0IHRoZSBpbmRleCBsZXZlbCBiZWNhdXNlIGl0J3MgZWl0aGVyOiBhbGwgb2YgdGhlbSBvciBub25lIG9mIHRoZW1cbiAgICAgICAgLy8gdGhhdCBhcmUgc3RhbGxlZC4gVGhlIHF1ZXJpZXMgYXJlIHBlcmZvcm1lZCBpbnRvIGEgc2luZ2xlIG5ldHdvcmsgcmVxdWVzdC5cbiAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlLnNjaGVkdWxlU3RhbGxlZFJlbmRlcigpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNoZWNrSW5kZXhVaVN0YXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBfdGhpczMsXG4gICAgICAgICAgICBpbmRleFVpU3RhdGU6IGxvY2FsVWlTdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlcml2ZWRIZWxwZXIub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IF9yZWY0LnJlc3VsdHM7XG4gICAgICAgIC8vIFRoZSBpbmRleCBkb2VzIG5vdCByZW5kZXIgdGhlIHJlc3VsdHMgaXQgc2NoZWR1bGVzIGEgbmV3IHJlbmRlclxuICAgICAgICAvLyB0byBsZXQgYWxsIHRoZSBvdGhlciBpbmRpY2VzIGVtaXQgdGhlaXIgb3duIHJlc3VsdHMuIEl0IGFsbG93cyB1cyB0b1xuICAgICAgICAvLyBydW4gdGhlIHJlbmRlciBwcm9jZXNzIGluIG9uZSBwYXNzLlxuICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2Uuc2NoZWR1bGVSZW5kZXIoKTsgLy8gdGhlIGRlcml2ZWQgaGVscGVyIGlzIHRoZSBvbmUgd2hpY2ggYWN0dWFsbHkgc2VhcmNoZXMsIGJ1dCB0aGUgaGVscGVyXG4gICAgICAgIC8vIHdoaWNoIGlzIGV4cG9zZWQgZS5nLiB2aWEgaW5zdGFuY2UuaGVscGVyLCBkb2Vzbid0IHNlYXJjaCwgYW5kIHRodXNcbiAgICAgICAgLy8gZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gbGFzdFJlc3VsdHMsIHdoaWNoIGl0IHVzZWQgdG8gaW4gcHJlLWZlZGVyYXRlZFxuICAgICAgICAvLyBzZWFyY2ggYmVoYXZpb3IuXG5cbiAgICAgICAgaGVscGVyLmxhc3RSZXN1bHRzID0gcmVzdWx0cztcbiAgICAgIH0pOyAvLyBXZSBjb21wdXRlIHRoZSByZW5kZXIgc3RhdGUgYmVmb3JlIGNhbGxpbmcgYGluaXRgIGluIGEgc2VwYXJhdGUgbG9vcFxuICAgICAgLy8gdG8gY29uc3RydWN0IHRoZSB3aG9sZSByZW5kZXIgc3RhdGUgb2JqZWN0IHRoYXQgaXMgdGhlbiBwYXNzZWQgdG9cbiAgICAgIC8vIGBpbml0YC5cblxuICAgICAgbG9jYWxXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICBpZiAod2lkZ2V0LmdldFJlbmRlclN0YXRlKSB7XG4gICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd2lkZ2V0LmdldFJlbmRlclN0YXRlKGluc3RhbnRTZWFyY2hJbnN0YW5jZS5yZW5kZXJTdGF0ZVtfdGhpczMuZ2V0SW5kZXhJZCgpXSB8fCB7fSwge1xuICAgICAgICAgICAgdWlTdGF0ZTogdWlTdGF0ZSxcbiAgICAgICAgICAgIGhlbHBlcjogaGVscGVyLFxuICAgICAgICAgICAgcGFyZW50OiBfdGhpczMsXG4gICAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGluc3RhbnRTZWFyY2hJbnN0YW5jZSxcbiAgICAgICAgICAgIHN0YXRlOiBoZWxwZXIuc3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZTogaW5zdGFudFNlYXJjaEluc3RhbmNlLnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVzQ29uZmlnOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UudGVtcGxhdGVzQ29uZmlnLFxuICAgICAgICAgICAgY3JlYXRlVVJMOiBfdGhpczMuY3JlYXRlVVJMLFxuICAgICAgICAgICAgc2NvcGVkUmVzdWx0czogW10sXG4gICAgICAgICAgICBzZWFyY2hNZXRhZGF0YToge1xuICAgICAgICAgICAgICBpc1NlYXJjaFN0YWxsZWQ6IGluc3RhbnRTZWFyY2hJbnN0YW5jZS5faXNTZWFyY2hTdGFsbGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RvcmVSZW5kZXJTdGF0ZSh7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZTogcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGluc3RhbnRTZWFyY2hJbnN0YW5jZSxcbiAgICAgICAgICAgIHBhcmVudDogX3RoaXMzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9jYWxXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHdhcm5pbmcoIC8vIGlmIGl0IGhhcyBOTyBnZXRXaWRnZXRTdGF0ZSBvciBpZiBpdCBoYXMgZ2V0V2lkZ2V0VWlTdGF0ZSwgd2UgZG9uJ3Qgd2FyblxuICAgICAgICAvLyBha2Egd2Ugd2FybiBpZiB0aGVyZSdzIF9vbmx5XyBnZXRXaWRnZXRTdGF0ZVxuICAgICAgICAhd2lkZ2V0LmdldFdpZGdldFN0YXRlIHx8IEJvb2xlYW4od2lkZ2V0LmdldFdpZGdldFVpU3RhdGUpLCAnVGhlIGBnZXRXaWRnZXRTdGF0ZWAgbWV0aG9kIGlzIHJlbmFtZWQgYGdldFdpZGdldFVpU3RhdGVgIGFuZCB3aWxsIG5vIGxvbmdlciBleGlzdCB1bmRlciB0aGF0IG5hbWUgaW4gSW5zdGFudFNlYXJjaC5qcyA1LnguIFBsZWFzZSB1c2UgYGdldFdpZGdldFVpU3RhdGVgIGluc3RlYWQuJykgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHdpZGdldC5pbml0KSB7XG4gICAgICAgICAgd2lkZ2V0LmluaXQoe1xuICAgICAgICAgICAgdWlTdGF0ZTogdWlTdGF0ZSxcbiAgICAgICAgICAgIGhlbHBlcjogaGVscGVyLFxuICAgICAgICAgICAgcGFyZW50OiBfdGhpczMsXG4gICAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGluc3RhbnRTZWFyY2hJbnN0YW5jZSxcbiAgICAgICAgICAgIHN0YXRlOiBoZWxwZXIuc3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZTogaW5zdGFudFNlYXJjaEluc3RhbmNlLnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVzQ29uZmlnOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UudGVtcGxhdGVzQ29uZmlnLFxuICAgICAgICAgICAgY3JlYXRlVVJMOiBfdGhpczMuY3JlYXRlVVJMLFxuICAgICAgICAgICAgc2NvcGVkUmVzdWx0czogW10sXG4gICAgICAgICAgICBzZWFyY2hNZXRhZGF0YToge1xuICAgICAgICAgICAgICBpc1NlYXJjaFN0YWxsZWQ6IGluc3RhbnRTZWFyY2hJbnN0YW5jZS5faXNTZWFyY2hTdGFsbGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBTdWJzY3JpYmUgdG8gdGhlIEhlbHBlciBzdGF0ZSBjaGFuZ2VzIGZvciB0aGUgYHVpU3RhdGVgIG9uY2Ugd2lkZ2V0c1xuICAgICAgLy8gYXJlIGluaXRpYWxpemVkLiBVbnRpbCB0aGUgZmlyc3QgcmVuZGVyLCBzdGF0ZSBjaGFuZ2VzIGFyZSBwYXJ0IG9mIHRoZVxuICAgICAgLy8gY29uZmlndXJhdGlvbiBzdGVwLiBUaGlzIGlzIG1haW5seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGN1c3RvbVxuICAgICAgLy8gd2lkZ2V0cy4gV2hlbiB0aGUgc3Vic2NyaXB0aW9uIGhhcHBlbnMgYmVmb3JlIHRoZSBgaW5pdGAgc3RlcCwgdGhlIChzdGF0aWMpXG4gICAgICAvLyBjb25maWd1cmF0aW9uIG9mIHRoZSB3aWRnZXQgaXMgcHVzaGVkIGluIHRoZSBVUkwuIFRoYXQncyB3aGF0IHdlIHdhbnQgdG8gYXZvaWQuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb2xpYS9pbnN0YW50c2VhcmNoLmpzL3B1bGwvOTk0L2NvbW1pdHMvNGE2NzJhZTNmZDc4ODA5ZTIxM2RlMDM2ODU0OWVmMTJlOWRjOTQ1NFxuXG4gICAgICBoZWxwZXIub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBldmVudC5zdGF0ZTtcbiAgICAgICAgdmFyIF91aVN0YXRlID0gZXZlbnQuX3VpU3RhdGU7XG4gICAgICAgIGxvY2FsVWlTdGF0ZSA9IGdldExvY2FsV2lkZ2V0c1VpU3RhdGUobG9jYWxXaWRnZXRzLCB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1ldGVyczogc3RhdGUsXG4gICAgICAgICAgaGVscGVyOiBoZWxwZXJcbiAgICAgICAgfSwgX3VpU3RhdGUgfHwge30pOyAvLyBXZSBkb24ndCB0cmlnZ2VyIGFuIGludGVybmFsIGNoYW5nZSB3aGVuIGNvbnRyb2xsZWQgYmVjYXVzZSBpdFxuICAgICAgICAvLyBiZWNvbWVzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBgc2V0VWlTdGF0ZWAuXG5cbiAgICAgICAgaWYgKCFpbnN0YW50U2VhcmNoSW5zdGFuY2Uub25TdGF0ZUNoYW5nZSkge1xuICAgICAgICAgIGluc3RhbnRTZWFyY2hJbnN0YW5jZS5vbkludGVybmFsU3RhdGVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihfcmVmNSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBpbnN0YW50U2VhcmNoSW5zdGFuY2UgPSBfcmVmNS5pbnN0YW50U2VhcmNoSW5zdGFuY2U7XG5cbiAgICAgIGlmICghdGhpcy5nZXRSZXN1bHRzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2NhbFdpZGdldHMuZm9yRWFjaChmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIGlmICh3aWRnZXQuZ2V0UmVuZGVyU3RhdGUpIHtcbiAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3aWRnZXQuZ2V0UmVuZGVyU3RhdGUoaW5zdGFudFNlYXJjaEluc3RhbmNlLnJlbmRlclN0YXRlW190aGlzNC5nZXRJbmRleElkKCldIHx8IHt9LCB7XG4gICAgICAgICAgICBoZWxwZXI6IF90aGlzNC5nZXRIZWxwZXIoKSxcbiAgICAgICAgICAgIHBhcmVudDogX3RoaXM0LFxuICAgICAgICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UsXG4gICAgICAgICAgICByZXN1bHRzOiBfdGhpczQuZ2V0UmVzdWx0cygpLFxuICAgICAgICAgICAgc2NvcGVkUmVzdWx0czogX3RoaXM0LmdldFNjb3BlZFJlc3VsdHMoKSxcbiAgICAgICAgICAgIHN0YXRlOiBfdGhpczQuZ2V0UmVzdWx0cygpLl9zdGF0ZSxcbiAgICAgICAgICAgIHJlbmRlclN0YXRlOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UucmVuZGVyU3RhdGUsXG4gICAgICAgICAgICB0ZW1wbGF0ZXNDb25maWc6IGluc3RhbnRTZWFyY2hJbnN0YW5jZS50ZW1wbGF0ZXNDb25maWcsXG4gICAgICAgICAgICBjcmVhdGVVUkw6IF90aGlzNC5jcmVhdGVVUkwsXG4gICAgICAgICAgICBzZWFyY2hNZXRhZGF0YToge1xuICAgICAgICAgICAgICBpc1NlYXJjaFN0YWxsZWQ6IGluc3RhbnRTZWFyY2hJbnN0YW5jZS5faXNTZWFyY2hTdGFsbGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RvcmVSZW5kZXJTdGF0ZSh7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZTogcmVuZGVyU3RhdGUsXG4gICAgICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2U6IGluc3RhbnRTZWFyY2hJbnN0YW5jZSxcbiAgICAgICAgICAgIHBhcmVudDogX3RoaXM0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9jYWxXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBhbGwgdGhlIHZhcmlhYmxlcyB1c2VkIGJlbG93IGFyZSBzZXQuIEJvdGggYGhlbHBlcmBcbiAgICAgICAgLy8gYW5kIGBkZXJpdmVkSGVscGVyYCBoYXZlIGJlZW4gY3JlYXRlZCBhdCB0aGUgYGluaXRgIHN0ZXAuIFRoZSBhdHRyaWJ1dGVcbiAgICAgICAgLy8gYGxhc3RSZXN1bHRzYCBtaWdodCBiZSBgbnVsbGAgdGhvdWdoLiBJdCdzIHBvc3NpYmxlIHRoYXQgYSBzdGFsbGVkIHJlbmRlclxuICAgICAgICAvLyBoYXBwZW5zIGJlZm9yZSB0aGUgcmVzdWx0IGUuZyB3aXRoIGEgZHluYW1pY2FsbHkgYWRkZWQgaW5kZXggdGhlIHJlcXVlc3QgbWlnaHRcbiAgICAgICAgLy8gYmUgZGVsYXllZC4gVGhlIHJlbmRlciBpcyB0cmlnZ2VyZWQgZm9yIHRoZSBjb21wbGV0ZSB0cmVlIGJ1dCBzb21lIHBhcnRzIGRvXG4gICAgICAgIC8vIG5vdCBoYXZlIHJlc3VsdHMgeWV0LlxuICAgICAgICBpZiAod2lkZ2V0LnJlbmRlcikge1xuICAgICAgICAgIHdpZGdldC5yZW5kZXIoe1xuICAgICAgICAgICAgaGVscGVyOiBoZWxwZXIsXG4gICAgICAgICAgICBwYXJlbnQ6IF90aGlzNCxcbiAgICAgICAgICAgIGluc3RhbnRTZWFyY2hJbnN0YW5jZTogaW5zdGFudFNlYXJjaEluc3RhbmNlLFxuICAgICAgICAgICAgcmVzdWx0czogX3RoaXM0LmdldFJlc3VsdHMoKSxcbiAgICAgICAgICAgIHNjb3BlZFJlc3VsdHM6IF90aGlzNC5nZXRTY29wZWRSZXN1bHRzKCksXG4gICAgICAgICAgICBzdGF0ZTogX3RoaXM0LmdldFJlc3VsdHMoKS5fc3RhdGUsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZTogaW5zdGFudFNlYXJjaEluc3RhbmNlLnJlbmRlclN0YXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVzQ29uZmlnOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UudGVtcGxhdGVzQ29uZmlnLFxuICAgICAgICAgICAgY3JlYXRlVVJMOiBfdGhpczQuY3JlYXRlVVJMLFxuICAgICAgICAgICAgc2VhcmNoTWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgaXNTZWFyY2hTdGFsbGVkOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UuX2lzU2VhcmNoU3RhbGxlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgbG9jYWxXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICBpZiAod2lkZ2V0LmRpc3Bvc2UpIHtcbiAgICAgICAgICAvLyBUaGUgZGlzcG9zZSBmdW5jdGlvbiBpcyBhbHdheXMgY2FsbGVkIG9uY2UgdGhlIGluc3RhbmNlIGlzIHN0YXJ0ZWRcbiAgICAgICAgICAvLyAoaXQncyBhbiBlZmZlY3Qgb2YgYHJlbW92ZVdpZGdldHNgKS4gVGhlIGluZGV4IGlzIGluaXRpYWxpemVkIGFuZFxuICAgICAgICAgIC8vIHRoZSBIZWxwZXIgaXMgYXZhaWxhYmxlLiBXZSBkb24ndCBjYXJlIGFib3V0IHRoZSByZXR1cm4gdmFsdWUgb2ZcbiAgICAgICAgICAvLyBgZGlzcG9zZWAgYmVjYXVzZSB0aGUgaW5kZXggaXMgcmVtb3ZlZC4gV2UgY2FuJ3QgY2FsbCBgcmVtb3ZlV2lkZ2V0c2BcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8ga2VlcCB0aGUgd2lkZ2V0cyBvbiB0aGUgaW5zdGFuY2UsIHRvIGFsbG93IGlkZW1wb3RlbnRcbiAgICAgICAgICAvLyBvcGVyYXRpb25zIG9uIGBhZGRgICYgYHJlbW92ZWAuXG4gICAgICAgICAgd2lkZ2V0LmRpc3Bvc2Uoe1xuICAgICAgICAgICAgaGVscGVyOiBoZWxwZXIsXG4gICAgICAgICAgICBzdGF0ZTogaGVscGVyLnN0YXRlLFxuICAgICAgICAgICAgcGFyZW50OiBfdGhpczVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsb2NhbEluc3RhbnRTZWFyY2hJbnN0YW5jZSA9IG51bGw7XG4gICAgICBsb2NhbFBhcmVudCA9IG51bGw7XG4gICAgICBoZWxwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICBoZWxwZXIgPSBudWxsO1xuICAgICAgZGVyaXZlZEhlbHBlci5kZXRhY2goKTtcbiAgICAgIGRlcml2ZWRIZWxwZXIgPSBudWxsO1xuICAgIH0sXG4gICAgZ2V0V2lkZ2V0VWlTdGF0ZTogZnVuY3Rpb24gZ2V0V2lkZ2V0VWlTdGF0ZSh1aVN0YXRlKSB7XG4gICAgICByZXR1cm4gbG9jYWxXaWRnZXRzLmZpbHRlcihpc0luZGV4V2lkZ2V0KS5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzVWlTdGF0ZSwgaW5uZXJJbmRleCkge1xuICAgICAgICByZXR1cm4gaW5uZXJJbmRleC5nZXRXaWRnZXRVaVN0YXRlKHByZXZpb3VzVWlTdGF0ZSk7XG4gICAgICB9LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHVpU3RhdGUpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLmdldEluZGV4SWQoKSwgbG9jYWxVaVN0YXRlKSkpO1xuICAgIH0sXG4gICAgZ2V0V2lkZ2V0U3RhdGU6IGZ1bmN0aW9uIGdldFdpZGdldFN0YXRlKHVpU3RhdGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgZ2V0V2lkZ2V0U3RhdGVgIG1ldGhvZCBpcyByZW5hbWVkIGBnZXRXaWRnZXRVaVN0YXRlYCBhbmQgd2lsbCBubyBsb25nZXIgZXhpc3QgdW5kZXIgdGhhdCBuYW1lIGluIEluc3RhbnRTZWFyY2guanMgNS54LiBQbGVhc2UgdXNlIGBnZXRXaWRnZXRVaVN0YXRlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0V2lkZ2V0VWlTdGF0ZSh1aVN0YXRlKTtcbiAgICB9LFxuICAgIGdldFdpZGdldFNlYXJjaFBhcmFtZXRlcnM6IGZ1bmN0aW9uIGdldFdpZGdldFNlYXJjaFBhcmFtZXRlcnMoc2VhcmNoUGFyYW1ldGVycywgX3JlZjYpIHtcbiAgICAgIHZhciB1aVN0YXRlID0gX3JlZjYudWlTdGF0ZTtcbiAgICAgIHJldHVybiBnZXRMb2NhbFdpZGdldHNTZWFyY2hQYXJhbWV0ZXJzKGxvY2FsV2lkZ2V0cywge1xuICAgICAgICB1aVN0YXRlOiB1aVN0YXRlLFxuICAgICAgICBpbml0aWFsU2VhcmNoUGFyYW1ldGVyczogc2VhcmNoUGFyYW1ldGVyc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICByZWZyZXNoVWlTdGF0ZTogZnVuY3Rpb24gcmVmcmVzaFVpU3RhdGUoKSB7XG4gICAgICBsb2NhbFVpU3RhdGUgPSBnZXRMb2NhbFdpZGdldHNVaVN0YXRlKGxvY2FsV2lkZ2V0cywge1xuICAgICAgICBzZWFyY2hQYXJhbWV0ZXJzOiB0aGlzLmdldEhlbHBlcigpLnN0YXRlLFxuICAgICAgICBoZWxwZXI6IHRoaXMuZ2V0SGVscGVyKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuXG5mdW5jdGlvbiBzdG9yZVJlbmRlclN0YXRlKF9yZWY3KSB7XG4gIHZhciByZW5kZXJTdGF0ZSA9IF9yZWY3LnJlbmRlclN0YXRlLFxuICAgICAgaW5zdGFudFNlYXJjaEluc3RhbmNlID0gX3JlZjcuaW5zdGFudFNlYXJjaEluc3RhbmNlLFxuICAgICAgcGFyZW50ID0gX3JlZjcucGFyZW50O1xuICB2YXIgcGFyZW50SW5kZXhOYW1lID0gcGFyZW50ID8gcGFyZW50LmdldEluZGV4SWQoKSA6IGluc3RhbnRTZWFyY2hJbnN0YW5jZS5tYWluSW5kZXguZ2V0SW5kZXhJZCgpO1xuICBpbnN0YW50U2VhcmNoSW5zdGFuY2UucmVuZGVyU3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGluc3RhbnRTZWFyY2hJbnN0YW5jZS5yZW5kZXJTdGF0ZSksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIHBhcmVudEluZGV4TmFtZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpbnN0YW50U2VhcmNoSW5zdGFuY2UucmVuZGVyU3RhdGVbcGFyZW50SW5kZXhOYW1lXSksIHJlbmRlclN0YXRlKSkpO1xufSIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKiogQGpzeCBoICovXG5pbXBvcnQgeyBoLCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFBhZ2luYXRpb24gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9QYWdpbmF0aW9uL1BhZ2luYXRpb24nO1xuaW1wb3J0IGNvbm5lY3RQYWdpbmF0aW9uIGZyb20gJy4uLy4uL2Nvbm5lY3RvcnMvcGFnaW5hdGlvbi9jb25uZWN0UGFnaW5hdGlvbic7XG5pbXBvcnQgeyBnZXRDb250YWluZXJOb2RlLCBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvciB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgeyBjb21wb25lbnQgfSBmcm9tICcuLi8uLi9saWIvc3VpdCc7XG52YXIgc3VpdCA9IGNvbXBvbmVudCgnUGFnaW5hdGlvbicpO1xudmFyIHdpdGhVc2FnZSA9IGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yKHtcbiAgbmFtZTogJ3BhZ2luYXRpb24nXG59KTtcbnZhciBkZWZhdWx0VGVtcGxhdGVzID0ge1xuICBwcmV2aW91czogJ+KAuScsXG4gIG5leHQ6ICfigLonLFxuICBmaXJzdDogJ8KrJyxcbiAgbGFzdDogJ8K7J1xufTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24gcmVuZGVyZXIoX3JlZikge1xuICB2YXIgY29udGFpbmVyTm9kZSA9IF9yZWYuY29udGFpbmVyTm9kZSxcbiAgICAgIGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICB0ZW1wbGF0ZXMgPSBfcmVmLnRlbXBsYXRlcyxcbiAgICAgIHNob3dGaXJzdCA9IF9yZWYuc2hvd0ZpcnN0LFxuICAgICAgc2hvd0xhc3QgPSBfcmVmLnNob3dMYXN0LFxuICAgICAgc2hvd1ByZXZpb3VzID0gX3JlZi5zaG93UHJldmlvdXMsXG4gICAgICBzaG93TmV4dCA9IF9yZWYuc2hvd05leHQsXG4gICAgICBzY3JvbGxUb05vZGUgPSBfcmVmLnNjcm9sbFRvTm9kZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmMiwgaXNGaXJzdFJlbmRlcmluZykge1xuICAgIHZhciBjcmVhdGVVUkwgPSBfcmVmMi5jcmVhdGVVUkwsXG4gICAgICAgIGN1cnJlbnRSZWZpbmVtZW50ID0gX3JlZjIuY3VycmVudFJlZmluZW1lbnQsXG4gICAgICAgIG5iUGFnZXMgPSBfcmVmMi5uYlBhZ2VzLFxuICAgICAgICBwYWdlcyA9IF9yZWYyLnBhZ2VzLFxuICAgICAgICBpc0ZpcnN0UGFnZSA9IF9yZWYyLmlzRmlyc3RQYWdlLFxuICAgICAgICBpc0xhc3RQYWdlID0gX3JlZjIuaXNMYXN0UGFnZSxcbiAgICAgICAgcmVmaW5lID0gX3JlZjIucmVmaW5lO1xuICAgIGlmIChpc0ZpcnN0UmVuZGVyaW5nKSByZXR1cm47XG5cbiAgICB2YXIgc2V0Q3VycmVudFBhZ2UgPSBmdW5jdGlvbiBzZXRDdXJyZW50UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgICByZWZpbmUocGFnZU51bWJlcik7XG5cbiAgICAgIGlmIChzY3JvbGxUb05vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgIHNjcm9sbFRvTm9kZS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZW5kZXIoaChQYWdpbmF0aW9uLCB7XG4gICAgICBjcmVhdGVVUkw6IGNyZWF0ZVVSTCxcbiAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICBjdXJyZW50UGFnZTogY3VycmVudFJlZmluZW1lbnQsXG4gICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcbiAgICAgIG5iUGFnZXM6IG5iUGFnZXMsXG4gICAgICBwYWdlczogcGFnZXMsXG4gICAgICBpc0ZpcnN0UGFnZTogaXNGaXJzdFBhZ2UsXG4gICAgICBpc0xhc3RQYWdlOiBpc0xhc3RQYWdlLFxuICAgICAgc2V0Q3VycmVudFBhZ2U6IHNldEN1cnJlbnRQYWdlLFxuICAgICAgc2hvd0ZpcnN0OiBzaG93Rmlyc3QsXG4gICAgICBzaG93TGFzdDogc2hvd0xhc3QsXG4gICAgICBzaG93UHJldmlvdXM6IHNob3dQcmV2aW91cyxcbiAgICAgIHNob3dOZXh0OiBzaG93TmV4dFxuICAgIH0pLCBjb250YWluZXJOb2RlKTtcbiAgfTtcbn07XG5cbnZhciBwYWdpbmF0aW9uID0gZnVuY3Rpb24gcGFnaW5hdGlvbih3aWRnZXRQYXJhbXMpIHtcbiAgdmFyIF9yZWYzID0gd2lkZ2V0UGFyYW1zIHx8IHt9LFxuICAgICAgY29udGFpbmVyID0gX3JlZjMuY29udGFpbmVyLFxuICAgICAgX3JlZjMkdGVtcGxhdGVzID0gX3JlZjMudGVtcGxhdGVzLFxuICAgICAgdXNlclRlbXBsYXRlcyA9IF9yZWYzJHRlbXBsYXRlcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyR0ZW1wbGF0ZXMsXG4gICAgICBfcmVmMyRjc3NDbGFzc2VzID0gX3JlZjMuY3NzQ2xhc3NlcyxcbiAgICAgIHVzZXJDc3NDbGFzc2VzID0gX3JlZjMkY3NzQ2xhc3NlcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRjc3NDbGFzc2VzLFxuICAgICAgdG90YWxQYWdlcyA9IF9yZWYzLnRvdGFsUGFnZXMsXG4gICAgICBwYWRkaW5nID0gX3JlZjMucGFkZGluZyxcbiAgICAgIF9yZWYzJHNob3dGaXJzdCA9IF9yZWYzLnNob3dGaXJzdCxcbiAgICAgIHNob3dGaXJzdCA9IF9yZWYzJHNob3dGaXJzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYzJHNob3dGaXJzdCxcbiAgICAgIF9yZWYzJHNob3dMYXN0ID0gX3JlZjMuc2hvd0xhc3QsXG4gICAgICBzaG93TGFzdCA9IF9yZWYzJHNob3dMYXN0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkc2hvd0xhc3QsXG4gICAgICBfcmVmMyRzaG93UHJldmlvdXMgPSBfcmVmMy5zaG93UHJldmlvdXMsXG4gICAgICBzaG93UHJldmlvdXMgPSBfcmVmMyRzaG93UHJldmlvdXMgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMyRzaG93UHJldmlvdXMsXG4gICAgICBfcmVmMyRzaG93TmV4dCA9IF9yZWYzLnNob3dOZXh0LFxuICAgICAgc2hvd05leHQgPSBfcmVmMyRzaG93TmV4dCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYzJHNob3dOZXh0LFxuICAgICAgX3JlZjMkc2Nyb2xsVG8gPSBfcmVmMy5zY3JvbGxUbyxcbiAgICAgIHVzZXJTY3JvbGxUbyA9IF9yZWYzJHNjcm9sbFRvID09PSB2b2lkIDAgPyAnYm9keScgOiBfcmVmMyRzY3JvbGxUbztcblxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgY29udGFpbmVyYCBvcHRpb24gaXMgcmVxdWlyZWQuJykpO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lck5vZGUgPSBnZXRDb250YWluZXJOb2RlKGNvbnRhaW5lcik7XG4gIHZhciBzY3JvbGxUbyA9IHVzZXJTY3JvbGxUbyA9PT0gdHJ1ZSA/ICdib2R5JyA6IHVzZXJTY3JvbGxUbztcbiAgdmFyIHNjcm9sbFRvTm9kZSA9IHNjcm9sbFRvICE9PSBmYWxzZSA/IGdldENvbnRhaW5lck5vZGUoc2Nyb2xsVG8pIDogZmFsc2U7XG4gIHZhciBjc3NDbGFzc2VzID0ge1xuICAgIHJvb3Q6IGN4KHN1aXQoKSwgdXNlckNzc0NsYXNzZXMucm9vdCksXG4gICAgbm9SZWZpbmVtZW50Um9vdDogY3goc3VpdCh7XG4gICAgICBtb2RpZmllck5hbWU6ICdub1JlZmluZW1lbnQnXG4gICAgfSksIHVzZXJDc3NDbGFzc2VzLm5vUmVmaW5lbWVudFJvb3QpLFxuICAgIGxpc3Q6IGN4KHN1aXQoe1xuICAgICAgZGVzY2VuZGFudE5hbWU6ICdsaXN0J1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5saXN0KSxcbiAgICBpdGVtOiBjeChzdWl0KHtcbiAgICAgIGRlc2NlbmRhbnROYW1lOiAnaXRlbSdcbiAgICB9KSwgdXNlckNzc0NsYXNzZXMuaXRlbSksXG4gICAgZmlyc3RQYWdlSXRlbTogY3goc3VpdCh7XG4gICAgICBkZXNjZW5kYW50TmFtZTogJ2l0ZW0nLFxuICAgICAgbW9kaWZpZXJOYW1lOiAnZmlyc3RQYWdlJ1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5maXJzdFBhZ2VJdGVtKSxcbiAgICBsYXN0UGFnZUl0ZW06IGN4KHN1aXQoe1xuICAgICAgZGVzY2VuZGFudE5hbWU6ICdpdGVtJyxcbiAgICAgIG1vZGlmaWVyTmFtZTogJ2xhc3RQYWdlJ1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5sYXN0UGFnZUl0ZW0pLFxuICAgIHByZXZpb3VzUGFnZUl0ZW06IGN4KHN1aXQoe1xuICAgICAgZGVzY2VuZGFudE5hbWU6ICdpdGVtJyxcbiAgICAgIG1vZGlmaWVyTmFtZTogJ3ByZXZpb3VzUGFnZSdcbiAgICB9KSwgdXNlckNzc0NsYXNzZXMucHJldmlvdXNQYWdlSXRlbSksXG4gICAgbmV4dFBhZ2VJdGVtOiBjeChzdWl0KHtcbiAgICAgIGRlc2NlbmRhbnROYW1lOiAnaXRlbScsXG4gICAgICBtb2RpZmllck5hbWU6ICduZXh0UGFnZSdcbiAgICB9KSwgdXNlckNzc0NsYXNzZXMubmV4dFBhZ2VJdGVtKSxcbiAgICBwYWdlSXRlbTogY3goc3VpdCh7XG4gICAgICBkZXNjZW5kYW50TmFtZTogJ2l0ZW0nLFxuICAgICAgbW9kaWZpZXJOYW1lOiAncGFnZSdcbiAgICB9KSwgdXNlckNzc0NsYXNzZXMucGFnZUl0ZW0pLFxuICAgIHNlbGVjdGVkSXRlbTogY3goc3VpdCh7XG4gICAgICBkZXNjZW5kYW50TmFtZTogJ2l0ZW0nLFxuICAgICAgbW9kaWZpZXJOYW1lOiAnc2VsZWN0ZWQnXG4gICAgfSksIHVzZXJDc3NDbGFzc2VzLnNlbGVjdGVkSXRlbSksXG4gICAgZGlzYWJsZWRJdGVtOiBjeChzdWl0KHtcbiAgICAgIGRlc2NlbmRhbnROYW1lOiAnaXRlbScsXG4gICAgICBtb2RpZmllck5hbWU6ICdkaXNhYmxlZCdcbiAgICB9KSwgdXNlckNzc0NsYXNzZXMuZGlzYWJsZWRJdGVtKSxcbiAgICBsaW5rOiBjeChzdWl0KHtcbiAgICAgIGRlc2NlbmRhbnROYW1lOiAnbGluaydcbiAgICB9KSwgdXNlckNzc0NsYXNzZXMubGluaylcbiAgfTtcblxuICB2YXIgdGVtcGxhdGVzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0VGVtcGxhdGVzKSwgdXNlclRlbXBsYXRlcyk7XG5cbiAgdmFyIHNwZWNpYWxpemVkUmVuZGVyZXIgPSByZW5kZXJlcih7XG4gICAgY29udGFpbmVyTm9kZTogY29udGFpbmVyTm9kZSxcbiAgICBjc3NDbGFzc2VzOiBjc3NDbGFzc2VzLFxuICAgIHRlbXBsYXRlczogdGVtcGxhdGVzLFxuICAgIHNob3dGaXJzdDogc2hvd0ZpcnN0LFxuICAgIHNob3dMYXN0OiBzaG93TGFzdCxcbiAgICBzaG93UHJldmlvdXM6IHNob3dQcmV2aW91cyxcbiAgICBzaG93TmV4dDogc2hvd05leHQsXG4gICAgc2Nyb2xsVG9Ob2RlOiBzY3JvbGxUb05vZGVcbiAgfSk7XG4gIHZhciBtYWtlV2lkZ2V0ID0gY29ubmVjdFBhZ2luYXRpb24oc3BlY2lhbGl6ZWRSZW5kZXJlciwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZW5kZXIobnVsbCwgY29udGFpbmVyTm9kZSk7XG4gIH0pO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtYWtlV2lkZ2V0KHtcbiAgICB0b3RhbFBhZ2VzOiB0b3RhbFBhZ2VzLFxuICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgfSkpLCB7fSwge1xuICAgICQkd2lkZ2V0VHlwZTogJ2Fpcy5wYWdpbmF0aW9uJ1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBhZ2luYXRpb247IiwidmFyIGRlZmF1bHRUZW1wbGF0ZSA9IHtcbiAgcmVzZXQ6IFwiXFxuPHN2ZyBjbGFzcz1cXFwie3tjc3NDbGFzc2VzLnJlc2V0SWNvbn19XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgd2lkdGg9XFxcIjEwXFxcIiBoZWlnaHQ9XFxcIjEwXFxcIj5cXG4gIDxwYXRoIGQ9XFxcIk04LjExNCAxMEwuOTQ0IDIuODMgMCAxLjg4NSAxLjg4NiAwbC45NDMuOTQzTDEwIDguMTEzbDcuMTctNy4xNy45NDQtLjk0M0wyMCAxLjg4NmwtLjk0My45NDMtNy4xNyA3LjE3IDcuMTcgNy4xNy45NDMuOTQ0TDE4LjExNCAyMGwtLjk0My0uOTQzLTcuMTctNy4xNy03LjE3IDcuMTctLjk0NC45NDNMMCAxOC4xMTRsLjk0My0uOTQzTDguMTEzIDEwelxcXCI+PC9wYXRoPlxcbjwvc3ZnPlxcbiAgXCIsXG4gIHN1Ym1pdDogXCJcXG48c3ZnIGNsYXNzPVxcXCJ7e2Nzc0NsYXNzZXMuc3VibWl0SWNvbn19XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIxMFxcXCIgaGVpZ2h0PVxcXCIxMFxcXCIgdmlld0JveD1cXFwiMCAwIDQwIDQwXFxcIj5cXG4gIDxwYXRoIGQ9XFxcIk0yNi44MDQgMjkuMDFjLTIuODMyIDIuMzQtNi40NjUgMy43NDYtMTAuNDI2IDMuNzQ2QzcuMzMzIDMyLjc1NiAwIDI1LjQyNCAwIDE2LjM3OCAwIDcuMzMzIDcuMzMzIDAgMTYuMzc4IDBjOS4wNDYgMCAxNi4zNzggNy4zMzMgMTYuMzc4IDE2LjM3OCAwIDMuOTYtMS40MDYgNy41OTQtMy43NDYgMTAuNDI2bDEwLjUzNCAxMC41MzRjLjYwNy42MDcuNjEgMS41OS0uMDA0IDIuMjAyLS42MS42MS0xLjU5Ny42MS0yLjIwMi4wMDRMMjYuODA0IDI5LjAxem0tMTAuNDI2LjYyN2M3LjMyMyAwIDEzLjI2LTUuOTM2IDEzLjI2LTEzLjI2IDAtNy4zMi01LjkzNy0xMy4yNTctMTMuMjYtMTMuMjU3QzkuMDU2IDMuMTIgMy4xMiA5LjA1NiAzLjEyIDE2LjM3OGMwIDcuMzIzIDUuOTM2IDEzLjI2IDEzLjI1OCAxMy4yNnpcXFwiPjwvcGF0aD5cXG48L3N2Zz5cXG4gIFwiLFxuICBsb2FkaW5nSW5kaWNhdG9yOiBcIlxcbjxzdmcgY2xhc3M9XFxcInt7Y3NzQ2xhc3Nlcy5sb2FkaW5nSWNvbn19XFxcIiB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHZpZXdCb3g9XFxcIjAgMCAzOCAzOFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiBzdHJva2U9XFxcIiM0NDRcXFwiPlxcbiAgPGcgZmlsbD1cXFwibm9uZVxcXCIgZmlsbFJ1bGU9XFxcImV2ZW5vZGRcXFwiPlxcbiAgICA8ZyB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgxIDEpXFxcIiBzdHJva2VXaWR0aD1cXFwiMlxcXCI+XFxuICAgICAgPGNpcmNsZSBzdHJva2VPcGFjaXR5PVxcXCIuNVxcXCIgY3g9XFxcIjE4XFxcIiBjeT1cXFwiMThcXFwiIHI9XFxcIjE4XFxcIiAvPlxcbiAgICAgIDxwYXRoIGQ9XFxcIk0zNiAxOGMwLTkuOTQtOC4wNi0xOC0xOC0xOFxcXCI+XFxuICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybVxcbiAgICAgICAgICBhdHRyaWJ1dGVOYW1lPVxcXCJ0cmFuc2Zvcm1cXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInJvdGF0ZVxcXCJcXG4gICAgICAgICAgZnJvbT1cXFwiMCAxOCAxOFxcXCJcXG4gICAgICAgICAgdG89XFxcIjM2MCAxOCAxOFxcXCJcXG4gICAgICAgICAgZHVyPVxcXCIxc1xcXCJcXG4gICAgICAgICAgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvcGF0aD5cXG4gICAgPC9nPlxcbiAgPC9nPlxcbjwvc3ZnPlxcbiAgXCJcbn07XG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0VGVtcGxhdGU7IiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKiBAanN4IGggKi9cbmltcG9ydCB7IGgsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBnZXRDb250YWluZXJOb2RlLCBjcmVhdGVEb2N1bWVudGF0aW9uTWVzc2FnZUdlbmVyYXRvciB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgeyBjb21wb25lbnQgfSBmcm9tICcuLi8uLi9saWIvc3VpdCc7XG5pbXBvcnQgY29ubmVjdFNlYXJjaEJveCBmcm9tICcuLi8uLi9jb25uZWN0b3JzL3NlYXJjaC1ib3gvY29ubmVjdFNlYXJjaEJveCc7XG5pbXBvcnQgU2VhcmNoQm94IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvU2VhcmNoQm94L1NlYXJjaEJveCc7XG5pbXBvcnQgZGVmYXVsdFRlbXBsYXRlcyBmcm9tICcuL2RlZmF1bHRUZW1wbGF0ZXMnO1xudmFyIHdpdGhVc2FnZSA9IGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yKHtcbiAgbmFtZTogJ3NlYXJjaC1ib3gnXG59KTtcbnZhciBzdWl0ID0gY29tcG9uZW50KCdTZWFyY2hCb3gnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24gcmVuZGVyZXIoX3JlZikge1xuICB2YXIgY29udGFpbmVyTm9kZSA9IF9yZWYuY29udGFpbmVyTm9kZSxcbiAgICAgIGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICBwbGFjZWhvbGRlciA9IF9yZWYucGxhY2Vob2xkZXIsXG4gICAgICB0ZW1wbGF0ZXMgPSBfcmVmLnRlbXBsYXRlcyxcbiAgICAgIGF1dG9mb2N1cyA9IF9yZWYuYXV0b2ZvY3VzLFxuICAgICAgc2VhcmNoQXNZb3VUeXBlID0gX3JlZi5zZWFyY2hBc1lvdVR5cGUsXG4gICAgICBzaG93UmVzZXQgPSBfcmVmLnNob3dSZXNldCxcbiAgICAgIHNob3dTdWJtaXQgPSBfcmVmLnNob3dTdWJtaXQsXG4gICAgICBzaG93TG9hZGluZ0luZGljYXRvciA9IF9yZWYuc2hvd0xvYWRpbmdJbmRpY2F0b3I7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgcmVmaW5lID0gX3JlZjIucmVmaW5lLFxuICAgICAgICBxdWVyeSA9IF9yZWYyLnF1ZXJ5LFxuICAgICAgICBpc1NlYXJjaFN0YWxsZWQgPSBfcmVmMi5pc1NlYXJjaFN0YWxsZWQ7XG4gICAgcmVuZGVyKGgoU2VhcmNoQm94LCB7XG4gICAgICBxdWVyeTogcXVlcnksXG4gICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICBhdXRvZm9jdXM6IGF1dG9mb2N1cyxcbiAgICAgIHJlZmluZTogcmVmaW5lLFxuICAgICAgc2VhcmNoQXNZb3VUeXBlOiBzZWFyY2hBc1lvdVR5cGUsXG4gICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcbiAgICAgIHNob3dTdWJtaXQ6IHNob3dTdWJtaXQsXG4gICAgICBzaG93UmVzZXQ6IHNob3dSZXNldCxcbiAgICAgIHNob3dMb2FkaW5nSW5kaWNhdG9yOiBzaG93TG9hZGluZ0luZGljYXRvcixcbiAgICAgIGlzU2VhcmNoU3RhbGxlZDogaXNTZWFyY2hTdGFsbGVkLFxuICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3Nlc1xuICAgIH0pLCBjb250YWluZXJOb2RlKTtcbiAgfTtcbn07XG4vKipcbiAqIFRoZSBzZWFyY2hib3ggd2lkZ2V0IGlzIHVzZWQgdG8gbGV0IHRoZSB1c2VyIHNldCBhIHRleHQgYmFzZWQgcXVlcnkuXG4gKlxuICogVGhpcyBpcyB1c3VhbGx5IHRoZSAgbWFpbiBlbnRyeSBwb2ludCB0byBzdGFydCB0aGUgc2VhcmNoIGluIGFuIGluc3RhbnRzZWFyY2ggY29udGV4dC4gRm9yIHRoYXRcbiAqIHJlYXNvbiBpcyB1c3VhbGx5IHBsYWNlZCBvbiB0b3AsIGFuZCBub3QgaGlkZGVuIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHN0YXJ0IHNlYXJjaGluZyByaWdodFxuICogYXdheS5cbiAqXG4gKi9cblxuXG52YXIgc2VhcmNoQm94ID0gZnVuY3Rpb24gc2VhcmNoQm94KHdpZGdldFBhcmFtcykge1xuICB2YXIgX3JlZjMgPSB3aWRnZXRQYXJhbXMgfHwge30sXG4gICAgICBjb250YWluZXIgPSBfcmVmMy5jb250YWluZXIsXG4gICAgICBfcmVmMyRwbGFjZWhvbGRlciA9IF9yZWYzLnBsYWNlaG9sZGVyLFxuICAgICAgcGxhY2Vob2xkZXIgPSBfcmVmMyRwbGFjZWhvbGRlciA9PT0gdm9pZCAwID8gJycgOiBfcmVmMyRwbGFjZWhvbGRlcixcbiAgICAgIF9yZWYzJGNzc0NsYXNzZXMgPSBfcmVmMy5jc3NDbGFzc2VzLFxuICAgICAgdXNlckNzc0NsYXNzZXMgPSBfcmVmMyRjc3NDbGFzc2VzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJGNzc0NsYXNzZXMsXG4gICAgICBfcmVmMyRhdXRvZm9jdXMgPSBfcmVmMy5hdXRvZm9jdXMsXG4gICAgICBhdXRvZm9jdXMgPSBfcmVmMyRhdXRvZm9jdXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjMkYXV0b2ZvY3VzLFxuICAgICAgX3JlZjMkc2VhcmNoQXNZb3VUeXBlID0gX3JlZjMuc2VhcmNoQXNZb3VUeXBlLFxuICAgICAgc2VhcmNoQXNZb3VUeXBlID0gX3JlZjMkc2VhcmNoQXNZb3VUeXBlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkc2VhcmNoQXNZb3VUeXBlLFxuICAgICAgX3JlZjMkc2hvd1Jlc2V0ID0gX3JlZjMuc2hvd1Jlc2V0LFxuICAgICAgc2hvd1Jlc2V0ID0gX3JlZjMkc2hvd1Jlc2V0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkc2hvd1Jlc2V0LFxuICAgICAgX3JlZjMkc2hvd1N1Ym1pdCA9IF9yZWYzLnNob3dTdWJtaXQsXG4gICAgICBzaG93U3VibWl0ID0gX3JlZjMkc2hvd1N1Ym1pdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYzJHNob3dTdWJtaXQsXG4gICAgICBfcmVmMyRzaG93TG9hZGluZ0luZGkgPSBfcmVmMy5zaG93TG9hZGluZ0luZGljYXRvcixcbiAgICAgIHNob3dMb2FkaW5nSW5kaWNhdG9yID0gX3JlZjMkc2hvd0xvYWRpbmdJbmRpID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkc2hvd0xvYWRpbmdJbmRpLFxuICAgICAgcXVlcnlIb29rID0gX3JlZjMucXVlcnlIb29rLFxuICAgICAgX3JlZjMkdGVtcGxhdGVzID0gX3JlZjMudGVtcGxhdGVzLFxuICAgICAgdXNlclRlbXBsYXRlcyA9IF9yZWYzJHRlbXBsYXRlcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyR0ZW1wbGF0ZXM7XG5cbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3Iod2l0aFVzYWdlKCdUaGUgYGNvbnRhaW5lcmAgb3B0aW9uIGlzIHJlcXVpcmVkLicpKTtcbiAgfVxuXG4gIHZhciBjb250YWluZXJOb2RlID0gZ2V0Q29udGFpbmVyTm9kZShjb250YWluZXIpO1xuICB2YXIgY3NzQ2xhc3NlcyA9IHtcbiAgICByb290OiBjeChzdWl0KCksIHVzZXJDc3NDbGFzc2VzLnJvb3QpLFxuICAgIGZvcm06IGN4KHN1aXQoe1xuICAgICAgZGVzY2VuZGFudE5hbWU6ICdmb3JtJ1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5mb3JtKSxcbiAgICBpbnB1dDogY3goc3VpdCh7XG4gICAgICBkZXNjZW5kYW50TmFtZTogJ2lucHV0J1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5pbnB1dCksXG4gICAgc3VibWl0OiBjeChzdWl0KHtcbiAgICAgIGRlc2NlbmRhbnROYW1lOiAnc3VibWl0J1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5zdWJtaXQpLFxuICAgIHN1Ym1pdEljb246IGN4KHN1aXQoe1xuICAgICAgZGVzY2VuZGFudE5hbWU6ICdzdWJtaXRJY29uJ1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5zdWJtaXRJY29uKSxcbiAgICByZXNldDogY3goc3VpdCh7XG4gICAgICBkZXNjZW5kYW50TmFtZTogJ3Jlc2V0J1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5yZXNldCksXG4gICAgcmVzZXRJY29uOiBjeChzdWl0KHtcbiAgICAgIGRlc2NlbmRhbnROYW1lOiAncmVzZXRJY29uJ1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5yZXNldEljb24pLFxuICAgIGxvYWRpbmdJbmRpY2F0b3I6IGN4KHN1aXQoe1xuICAgICAgZGVzY2VuZGFudE5hbWU6ICdsb2FkaW5nSW5kaWNhdG9yJ1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5sb2FkaW5nSW5kaWNhdG9yKSxcbiAgICBsb2FkaW5nSWNvbjogY3goc3VpdCh7XG4gICAgICBkZXNjZW5kYW50TmFtZTogJ2xvYWRpbmdJY29uJ1xuICAgIH0pLCB1c2VyQ3NzQ2xhc3Nlcy5sb2FkaW5nSWNvbilcbiAgfTtcblxuICB2YXIgdGVtcGxhdGVzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0VGVtcGxhdGVzKSwgdXNlclRlbXBsYXRlcyk7XG5cbiAgdmFyIHNwZWNpYWxpemVkUmVuZGVyZXIgPSByZW5kZXJlcih7XG4gICAgY29udGFpbmVyTm9kZTogY29udGFpbmVyTm9kZSxcbiAgICBjc3NDbGFzc2VzOiBjc3NDbGFzc2VzLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcbiAgICBhdXRvZm9jdXM6IGF1dG9mb2N1cyxcbiAgICBzZWFyY2hBc1lvdVR5cGU6IHNlYXJjaEFzWW91VHlwZSxcbiAgICBzaG93UmVzZXQ6IHNob3dSZXNldCxcbiAgICBzaG93U3VibWl0OiBzaG93U3VibWl0LFxuICAgIHNob3dMb2FkaW5nSW5kaWNhdG9yOiBzaG93TG9hZGluZ0luZGljYXRvclxuICB9KTtcbiAgdmFyIG1ha2VXaWRnZXQgPSBjb25uZWN0U2VhcmNoQm94KHNwZWNpYWxpemVkUmVuZGVyZXIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVuZGVyKG51bGwsIGNvbnRhaW5lck5vZGUpO1xuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbWFrZVdpZGdldCh7XG4gICAgcXVlcnlIb29rOiBxdWVyeUhvb2tcbiAgfSkpLCB7fSwge1xuICAgICQkd2lkZ2V0VHlwZTogJ2Fpcy5zZWFyY2hCb3gnXG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VhcmNoQm94OyIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKiogQGpzeCBoICovXG5pbXBvcnQgeyBoLCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvU3RhdHMvU3RhdHMnO1xuaW1wb3J0IGNvbm5lY3RTdGF0cyBmcm9tICcuLi8uLi9jb25uZWN0b3JzL3N0YXRzL2Nvbm5lY3RTdGF0cyc7XG5pbXBvcnQgeyBwcmVwYXJlVGVtcGxhdGVQcm9wcywgZ2V0Q29udGFpbmVyTm9kZSwgY3JlYXRlRG9jdW1lbnRhdGlvbk1lc3NhZ2VHZW5lcmF0b3IgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHsgY29tcG9uZW50IH0gZnJvbSAnLi4vLi4vbGliL3N1aXQnO1xudmFyIHdpdGhVc2FnZSA9IGNyZWF0ZURvY3VtZW50YXRpb25NZXNzYWdlR2VuZXJhdG9yKHtcbiAgbmFtZTogJ3N0YXRzJ1xufSk7XG52YXIgc3VpdCA9IGNvbXBvbmVudCgnU3RhdHMnKTtcbmV4cG9ydCB2YXIgZGVmYXVsdFRlbXBsYXRlcyA9IHtcbiAgdGV4dDogXCJcXG4gICAge3sjYXJlSGl0c1NvcnRlZH19XFxuICAgICAge3sjaGFzTm9Tb3J0ZWRSZXN1bHRzfX1ObyByZWxldmFudCByZXN1bHRze3svaGFzTm9Tb3J0ZWRSZXN1bHRzfX1cXG4gICAgICB7eyNoYXNPbmVTb3J0ZWRSZXN1bHRzfX0xIHJlbGV2YW50IHJlc3VsdHt7L2hhc09uZVNvcnRlZFJlc3VsdHN9fVxcbiAgICAgIHt7I2hhc01hbnlTb3J0ZWRSZXN1bHRzfX17eyNoZWxwZXJzLmZvcm1hdE51bWJlcn19e3tuYlNvcnRlZEhpdHN9fXt7L2hlbHBlcnMuZm9ybWF0TnVtYmVyfX0gcmVsZXZhbnQgcmVzdWx0c3t7L2hhc01hbnlTb3J0ZWRSZXN1bHRzfX1cXG4gICAgICBzb3J0ZWQgb3V0IG9mIHt7I2hlbHBlcnMuZm9ybWF0TnVtYmVyfX17e25iSGl0c319e3svaGVscGVycy5mb3JtYXROdW1iZXJ9fVxcbiAgICB7ey9hcmVIaXRzU29ydGVkfX1cXG4gICAge3teYXJlSGl0c1NvcnRlZH19XFxuICAgICAge3sjaGFzTm9SZXN1bHRzfX1ObyByZXN1bHRze3svaGFzTm9SZXN1bHRzfX1cXG4gICAgICB7eyNoYXNPbmVSZXN1bHR9fTEgcmVzdWx0e3svaGFzT25lUmVzdWx0fX1cXG4gICAgICB7eyNoYXNNYW55UmVzdWx0c319e3sjaGVscGVycy5mb3JtYXROdW1iZXJ9fXt7bmJIaXRzfX17ey9oZWxwZXJzLmZvcm1hdE51bWJlcn19IHJlc3VsdHN7ey9oYXNNYW55UmVzdWx0c319XFxuICAgIHt7L2FyZUhpdHNTb3J0ZWR9fVxcbiAgICBmb3VuZCBpbiB7e3Byb2Nlc3NpbmdUaW1lTVN9fW1zXCJcbn07XG5cbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uIHJlbmRlcmVyKF9yZWYpIHtcbiAgdmFyIHJlbmRlclN0YXRlID0gX3JlZi5yZW5kZXJTdGF0ZSxcbiAgICAgIGNzc0NsYXNzZXMgPSBfcmVmLmNzc0NsYXNzZXMsXG4gICAgICBjb250YWluZXJOb2RlID0gX3JlZi5jb250YWluZXJOb2RlLFxuICAgICAgdGVtcGxhdGVzID0gX3JlZi50ZW1wbGF0ZXM7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZjIsIGlzRmlyc3RSZW5kZXJpbmcpIHtcbiAgICB2YXIgaGl0c1BlclBhZ2UgPSBfcmVmMi5oaXRzUGVyUGFnZSxcbiAgICAgICAgbmJIaXRzID0gX3JlZjIubmJIaXRzLFxuICAgICAgICBuYlNvcnRlZEhpdHMgPSBfcmVmMi5uYlNvcnRlZEhpdHMsXG4gICAgICAgIGFyZUhpdHNTb3J0ZWQgPSBfcmVmMi5hcmVIaXRzU29ydGVkLFxuICAgICAgICBuYlBhZ2VzID0gX3JlZjIubmJQYWdlcyxcbiAgICAgICAgcGFnZSA9IF9yZWYyLnBhZ2UsXG4gICAgICAgIHByb2Nlc3NpbmdUaW1lTVMgPSBfcmVmMi5wcm9jZXNzaW5nVGltZU1TLFxuICAgICAgICBxdWVyeSA9IF9yZWYyLnF1ZXJ5LFxuICAgICAgICBpbnN0YW50U2VhcmNoSW5zdGFuY2UgPSBfcmVmMi5pbnN0YW50U2VhcmNoSW5zdGFuY2U7XG5cbiAgICBpZiAoaXNGaXJzdFJlbmRlcmluZykge1xuICAgICAgcmVuZGVyU3RhdGUudGVtcGxhdGVQcm9wcyA9IHByZXBhcmVUZW1wbGF0ZVByb3BzKHtcbiAgICAgICAgZGVmYXVsdFRlbXBsYXRlczogZGVmYXVsdFRlbXBsYXRlcyxcbiAgICAgICAgdGVtcGxhdGVzQ29uZmlnOiBpbnN0YW50U2VhcmNoSW5zdGFuY2UudGVtcGxhdGVzQ29uZmlnLFxuICAgICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVuZGVyKGgoU3RhdHMsIHtcbiAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UsXG4gICAgICBuYkhpdHM6IG5iSGl0cyxcbiAgICAgIG5iU29ydGVkSGl0czogbmJTb3J0ZWRIaXRzLFxuICAgICAgYXJlSGl0c1NvcnRlZDogYXJlSGl0c1NvcnRlZCxcbiAgICAgIG5iUGFnZXM6IG5iUGFnZXMsXG4gICAgICBwYWdlOiBwYWdlLFxuICAgICAgcHJvY2Vzc2luZ1RpbWVNUzogcHJvY2Vzc2luZ1RpbWVNUyxcbiAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgIHRlbXBsYXRlUHJvcHM6IHJlbmRlclN0YXRlLnRlbXBsYXRlUHJvcHNcbiAgICB9KSwgY29udGFpbmVyTm9kZSk7XG4gIH07XG59O1xuLyoqXG4gKiBUaGUgYHN0YXRzYCB3aWRnZXQgaXMgdXNlZCB0byBkaXNwbGF5IHVzZWZ1bCBpbnNpZ2h0cyBhYm91dCB0aGUgY3VycmVudCByZXN1bHRzLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgZGlzcGxheSB0aGUgKipudW1iZXIgb2YgaGl0cyoqIGFuZCB0aGUgdGltZSB0YWtlbiB0byBjb21wdXRlIHRoZVxuICogcmVzdWx0cyBpbnNpZGUgdGhlIGVuZ2luZS5cbiAqL1xuXG5cbnZhciBzdGF0cyA9IGZ1bmN0aW9uIHN0YXRzKHdpZGdldFBhcmFtcykge1xuICB2YXIgX3JlZjMgPSB3aWRnZXRQYXJhbXMgfHwge30sXG4gICAgICBjb250YWluZXIgPSBfcmVmMy5jb250YWluZXIsXG4gICAgICBfcmVmMyRjc3NDbGFzc2VzID0gX3JlZjMuY3NzQ2xhc3NlcyxcbiAgICAgIHVzZXJDc3NDbGFzc2VzID0gX3JlZjMkY3NzQ2xhc3NlcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRjc3NDbGFzc2VzLFxuICAgICAgX3JlZjMkdGVtcGxhdGVzID0gX3JlZjMudGVtcGxhdGVzLFxuICAgICAgdGVtcGxhdGVzID0gX3JlZjMkdGVtcGxhdGVzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJHRlbXBsYXRlcztcblxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcih3aXRoVXNhZ2UoJ1RoZSBgY29udGFpbmVyYCBvcHRpb24gaXMgcmVxdWlyZWQuJykpO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lck5vZGUgPSBnZXRDb250YWluZXJOb2RlKGNvbnRhaW5lcik7XG4gIHZhciBjc3NDbGFzc2VzID0ge1xuICAgIHJvb3Q6IGN4KHN1aXQoKSwgdXNlckNzc0NsYXNzZXMucm9vdCksXG4gICAgdGV4dDogY3goc3VpdCh7XG4gICAgICBkZXNjZW5kYW50TmFtZTogJ3RleHQnXG4gICAgfSksIHVzZXJDc3NDbGFzc2VzLnRleHQpXG4gIH07XG4gIHZhciBzcGVjaWFsaXplZFJlbmRlcmVyID0gcmVuZGVyZXIoe1xuICAgIGNvbnRhaW5lck5vZGU6IGNvbnRhaW5lck5vZGUsXG4gICAgY3NzQ2xhc3NlczogY3NzQ2xhc3NlcyxcbiAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcbiAgICByZW5kZXJTdGF0ZToge31cbiAgfSk7XG4gIHZhciBtYWtlV2lkZ2V0ID0gY29ubmVjdFN0YXRzKHNwZWNpYWxpemVkUmVuZGVyZXIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVuZGVyKG51bGwsIGNvbnRhaW5lck5vZGUpO1xuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbWFrZVdpZGdldCh7fSkpLCB7fSwge1xuICAgICQkd2lkZ2V0VHlwZTogJ2Fpcy5zdGF0cydcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdGF0czsiLCJ2YXIgbixsLHUsaSx0LG8scixmLGU9e30sYz1bXSxzPS9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2k7ZnVuY3Rpb24gYShuLGwpe2Zvcih2YXIgdSBpbiBsKW5bdV09bFt1XTtyZXR1cm4gbn1mdW5jdGlvbiBoKG4pe3ZhciBsPW4ucGFyZW50Tm9kZTtsJiZsLnJlbW92ZUNoaWxkKG4pfWZ1bmN0aW9uIHYobCx1LGkpe3ZhciB0LG8scixmPXt9O2ZvcihyIGluIHUpXCJrZXlcIj09cj90PXVbcl06XCJyZWZcIj09cj9vPXVbcl06ZltyXT11W3JdO2lmKGFyZ3VtZW50cy5sZW5ndGg+MiYmKGYuY2hpbGRyZW49YXJndW1lbnRzLmxlbmd0aD4zP24uY2FsbChhcmd1bWVudHMsMik6aSksXCJmdW5jdGlvblwiPT10eXBlb2YgbCYmbnVsbCE9bC5kZWZhdWx0UHJvcHMpZm9yKHIgaW4gbC5kZWZhdWx0UHJvcHMpdm9pZCAwPT09ZltyXSYmKGZbcl09bC5kZWZhdWx0UHJvcHNbcl0pO3JldHVybiB5KGwsZix0LG8sbnVsbCl9ZnVuY3Rpb24geShuLGksdCxvLHIpe3ZhciBmPXt0eXBlOm4scHJvcHM6aSxrZXk6dCxyZWY6byxfX2s6bnVsbCxfXzpudWxsLF9fYjowLF9fZTpudWxsLF9fZDp2b2lkIDAsX19jOm51bGwsX19oOm51bGwsY29uc3RydWN0b3I6dm9pZCAwLF9fdjpudWxsPT1yPysrdTpyfTtyZXR1cm4gbnVsbCE9bC52bm9kZSYmbC52bm9kZShmKSxmfWZ1bmN0aW9uIHAoKXtyZXR1cm57Y3VycmVudDpudWxsfX1mdW5jdGlvbiBkKG4pe3JldHVybiBuLmNoaWxkcmVufWZ1bmN0aW9uIF8obixsKXt0aGlzLnByb3BzPW4sdGhpcy5jb250ZXh0PWx9ZnVuY3Rpb24gayhuLGwpe2lmKG51bGw9PWwpcmV0dXJuIG4uX18/ayhuLl9fLG4uX18uX19rLmluZGV4T2YobikrMSk6bnVsbDtmb3IodmFyIHU7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2UpcmV0dXJuIHUuX19lO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG4udHlwZT9rKG4pOm51bGx9ZnVuY3Rpb24gYihuKXt2YXIgbCx1O2lmKG51bGwhPShuPW4uX18pJiZudWxsIT1uLl9fYyl7Zm9yKG4uX19lPW4uX19jLmJhc2U9bnVsbCxsPTA7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2Upe24uX19lPW4uX19jLmJhc2U9dS5fX2U7YnJlYWt9cmV0dXJuIGIobil9fWZ1bmN0aW9uIG0obil7KCFuLl9fZCYmKG4uX19kPSEwKSYmdC5wdXNoKG4pJiYhZy5fX3IrK3x8ciE9PWwuZGVib3VuY2VSZW5kZXJpbmcpJiYoKHI9bC5kZWJvdW5jZVJlbmRlcmluZyl8fG8pKGcpfWZ1bmN0aW9uIGcoKXtmb3IodmFyIG47Zy5fX3I9dC5sZW5ndGg7KW49dC5zb3J0KGZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uX192Ll9fYi1sLl9fdi5fX2J9KSx0PVtdLG4uc29tZShmdW5jdGlvbihuKXt2YXIgbCx1LGksdCxvLHI7bi5fX2QmJihvPSh0PShsPW4pLl9fdikuX19lLChyPWwuX19QKSYmKHU9W10sKGk9YSh7fSx0KSkuX192PXQuX192KzEsaihyLHQsaSxsLl9fbix2b2lkIDAhPT1yLm93bmVyU1ZHRWxlbWVudCxudWxsIT10Ll9faD9bb106bnVsbCx1LG51bGw9PW8/ayh0KTpvLHQuX19oKSx6KHUsdCksdC5fX2UhPW8mJmIodCkpKX0pfWZ1bmN0aW9uIHcobixsLHUsaSx0LG8scixmLHMsYSl7dmFyIGgsdixwLF8sYixtLGcsdz1pJiZpLl9fa3x8YyxBPXcubGVuZ3RoO2Zvcih1Ll9faz1bXSxoPTA7aDxsLmxlbmd0aDtoKyspaWYobnVsbCE9KF89dS5fX2tbaF09bnVsbD09KF89bFtoXSl8fFwiYm9vbGVhblwiPT10eXBlb2YgXz9udWxsOlwic3RyaW5nXCI9PXR5cGVvZiBffHxcIm51bWJlclwiPT10eXBlb2YgX3x8XCJiaWdpbnRcIj09dHlwZW9mIF8/eShudWxsLF8sbnVsbCxudWxsLF8pOkFycmF5LmlzQXJyYXkoXyk/eShkLHtjaGlsZHJlbjpffSxudWxsLG51bGwsbnVsbCk6Xy5fX2I+MD95KF8udHlwZSxfLnByb3BzLF8ua2V5LG51bGwsXy5fX3YpOl8pKXtpZihfLl9fPXUsXy5fX2I9dS5fX2IrMSxudWxsPT09KHA9d1toXSl8fHAmJl8ua2V5PT1wLmtleSYmXy50eXBlPT09cC50eXBlKXdbaF09dm9pZCAwO2Vsc2UgZm9yKHY9MDt2PEE7disrKXtpZigocD13W3ZdKSYmXy5rZXk9PXAua2V5JiZfLnR5cGU9PT1wLnR5cGUpe3dbdl09dm9pZCAwO2JyZWFrfXA9bnVsbH1qKG4sXyxwPXB8fGUsdCxvLHIsZixzLGEpLGI9Xy5fX2UsKHY9Xy5yZWYpJiZwLnJlZiE9diYmKGd8fChnPVtdKSxwLnJlZiYmZy5wdXNoKHAucmVmLG51bGwsXyksZy5wdXNoKHYsXy5fX2N8fGIsXykpLG51bGwhPWI/KG51bGw9PW0mJihtPWIpLFwiZnVuY3Rpb25cIj09dHlwZW9mIF8udHlwZSYmbnVsbCE9Xy5fX2smJl8uX19rPT09cC5fX2s/Xy5fX2Q9cz14KF8scyxuKTpzPVAobixfLHAsdyxiLHMpLGF8fFwib3B0aW9uXCIhPT11LnR5cGU/XCJmdW5jdGlvblwiPT10eXBlb2YgdS50eXBlJiYodS5fX2Q9cyk6bi52YWx1ZT1cIlwiKTpzJiZwLl9fZT09cyYmcy5wYXJlbnROb2RlIT1uJiYocz1rKHApKX1mb3IodS5fX2U9bSxoPUE7aC0tOyludWxsIT13W2hdJiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdS50eXBlJiZudWxsIT13W2hdLl9fZSYmd1toXS5fX2U9PXUuX19kJiYodS5fX2Q9ayhpLGgrMSkpLE4od1toXSx3W2hdKSk7aWYoZylmb3IoaD0wO2g8Zy5sZW5ndGg7aCsrKU0oZ1toXSxnWysraF0sZ1srK2hdKX1mdW5jdGlvbiB4KG4sbCx1KXt2YXIgaSx0O2ZvcihpPTA7aTxuLl9fay5sZW5ndGg7aSsrKSh0PW4uX19rW2ldKSYmKHQuX189bixsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQudHlwZT94KHQsbCx1KTpQKHUsdCx0LG4uX19rLHQuX19lLGwpKTtyZXR1cm4gbH1mdW5jdGlvbiBBKG4sbCl7cmV0dXJuIGw9bHx8W10sbnVsbD09bnx8XCJib29sZWFuXCI9PXR5cGVvZiBufHwoQXJyYXkuaXNBcnJheShuKT9uLnNvbWUoZnVuY3Rpb24obil7QShuLGwpfSk6bC5wdXNoKG4pKSxsfWZ1bmN0aW9uIFAobixsLHUsaSx0LG8pe3ZhciByLGYsZTtpZih2b2lkIDAhPT1sLl9fZClyPWwuX19kLGwuX19kPXZvaWQgMDtlbHNlIGlmKG51bGw9PXV8fHQhPW98fG51bGw9PXQucGFyZW50Tm9kZSluOmlmKG51bGw9PW98fG8ucGFyZW50Tm9kZSE9PW4pbi5hcHBlbmRDaGlsZCh0KSxyPW51bGw7ZWxzZXtmb3IoZj1vLGU9MDsoZj1mLm5leHRTaWJsaW5nKSYmZTxpLmxlbmd0aDtlKz0yKWlmKGY9PXQpYnJlYWsgbjtuLmluc2VydEJlZm9yZSh0LG8pLHI9b31yZXR1cm4gdm9pZCAwIT09cj9yOnQubmV4dFNpYmxpbmd9ZnVuY3Rpb24gQyhuLGwsdSxpLHQpe3ZhciBvO2ZvcihvIGluIHUpXCJjaGlsZHJlblwiPT09b3x8XCJrZXlcIj09PW98fG8gaW4gbHx8SChuLG8sbnVsbCx1W29dLGkpO2ZvcihvIGluIGwpdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgbFtvXXx8XCJjaGlsZHJlblwiPT09b3x8XCJrZXlcIj09PW98fFwidmFsdWVcIj09PW98fFwiY2hlY2tlZFwiPT09b3x8dVtvXT09PWxbb118fEgobixvLGxbb10sdVtvXSxpKX1mdW5jdGlvbiAkKG4sbCx1KXtcIi1cIj09PWxbMF0/bi5zZXRQcm9wZXJ0eShsLHUpOm5bbF09bnVsbD09dT9cIlwiOlwibnVtYmVyXCIhPXR5cGVvZiB1fHxzLnRlc3QobCk/dTp1K1wicHhcIn1mdW5jdGlvbiBIKG4sbCx1LGksdCl7dmFyIG87bjppZihcInN0eWxlXCI9PT1sKWlmKFwic3RyaW5nXCI9PXR5cGVvZiB1KW4uc3R5bGUuY3NzVGV4dD11O2Vsc2V7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkmJihuLnN0eWxlLmNzc1RleHQ9aT1cIlwiKSxpKWZvcihsIGluIGkpdSYmbCBpbiB1fHwkKG4uc3R5bGUsbCxcIlwiKTtpZih1KWZvcihsIGluIHUpaSYmdVtsXT09PWlbbF18fCQobi5zdHlsZSxsLHVbbF0pfWVsc2UgaWYoXCJvXCI9PT1sWzBdJiZcIm5cIj09PWxbMV0pbz1sIT09KGw9bC5yZXBsYWNlKC9DYXB0dXJlJC8sXCJcIikpLGw9bC50b0xvd2VyQ2FzZSgpaW4gbj9sLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik6bC5zbGljZSgyKSxuLmx8fChuLmw9e30pLG4ubFtsK29dPXUsdT9pfHxuLmFkZEV2ZW50TGlzdGVuZXIobCxvP1Q6SSxvKTpuLnJlbW92ZUV2ZW50TGlzdGVuZXIobCxvP1Q6SSxvKTtlbHNlIGlmKFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWwpe2lmKHQpbD1sLnJlcGxhY2UoL3hsaW5rW0g6aF0vLFwiaFwiKS5yZXBsYWNlKC9zTmFtZSQvLFwic1wiKTtlbHNlIGlmKFwiaHJlZlwiIT09bCYmXCJsaXN0XCIhPT1sJiZcImZvcm1cIiE9PWwmJlwidGFiSW5kZXhcIiE9PWwmJlwiZG93bmxvYWRcIiE9PWwmJmwgaW4gbil0cnl7bltsXT1udWxsPT11P1wiXCI6dTticmVhayBufWNhdGNoKG4pe31cImZ1bmN0aW9uXCI9PXR5cGVvZiB1fHwobnVsbCE9dSYmKCExIT09dXx8XCJhXCI9PT1sWzBdJiZcInJcIj09PWxbMV0pP24uc2V0QXR0cmlidXRlKGwsdSk6bi5yZW1vdmVBdHRyaWJ1dGUobCkpfX1mdW5jdGlvbiBJKG4pe3RoaXMubFtuLnR5cGUrITFdKGwuZXZlbnQ/bC5ldmVudChuKTpuKX1mdW5jdGlvbiBUKG4pe3RoaXMubFtuLnR5cGUrITBdKGwuZXZlbnQ/bC5ldmVudChuKTpuKX1mdW5jdGlvbiBqKG4sdSxpLHQsbyxyLGYsZSxjKXt2YXIgcyxoLHYseSxwLGssYixtLGcseCxBLFA9dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpcmV0dXJuIG51bGw7bnVsbCE9aS5fX2gmJihjPWkuX19oLGU9dS5fX2U9aS5fX2UsdS5fX2g9bnVsbCxyPVtlXSksKHM9bC5fX2IpJiZzKHUpO3RyeXtuOmlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFApe2lmKG09dS5wcm9wcyxnPShzPVAuY29udGV4dFR5cGUpJiZ0W3MuX19jXSx4PXM/Zz9nLnByb3BzLnZhbHVlOnMuX186dCxpLl9fYz9iPShoPXUuX19jPWkuX19jKS5fXz1oLl9fRTooXCJwcm90b3R5cGVcImluIFAmJlAucHJvdG90eXBlLnJlbmRlcj91Ll9fYz1oPW5ldyBQKG0seCk6KHUuX19jPWg9bmV3IF8obSx4KSxoLmNvbnN0cnVjdG9yPVAsaC5yZW5kZXI9TyksZyYmZy5zdWIoaCksaC5wcm9wcz1tLGguc3RhdGV8fChoLnN0YXRlPXt9KSxoLmNvbnRleHQ9eCxoLl9fbj10LHY9aC5fX2Q9ITAsaC5fX2g9W10pLG51bGw9PWguX19zJiYoaC5fX3M9aC5zdGF0ZSksbnVsbCE9UC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJihoLl9fcz09aC5zdGF0ZSYmKGguX19zPWEoe30saC5fX3MpKSxhKGguX19zLFAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG0saC5fX3MpKSkseT1oLnByb3BzLHA9aC5zdGF0ZSx2KW51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZudWxsIT1oLmNvbXBvbmVudFdpbGxNb3VudCYmaC5jb21wb25lbnRXaWxsTW91bnQoKSxudWxsIT1oLmNvbXBvbmVudERpZE1vdW50JiZoLl9faC5wdXNoKGguY29tcG9uZW50RGlkTW91bnQpO2Vsc2V7aWYobnVsbD09UC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm0hPT15JiZudWxsIT1oLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmguY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhtLHgpLCFoLl9fZSYmbnVsbCE9aC5zaG91bGRDb21wb25lbnRVcGRhdGUmJiExPT09aC5zaG91bGRDb21wb25lbnRVcGRhdGUobSxoLl9fcyx4KXx8dS5fX3Y9PT1pLl9fdil7aC5wcm9wcz1tLGguc3RhdGU9aC5fX3MsdS5fX3YhPT1pLl9fdiYmKGguX19kPSExKSxoLl9fdj11LHUuX19lPWkuX19lLHUuX19rPWkuX19rLHUuX19rLmZvckVhY2goZnVuY3Rpb24obil7biYmKG4uX189dSl9KSxoLl9faC5sZW5ndGgmJmYucHVzaChoKTticmVhayBufW51bGwhPWguY29tcG9uZW50V2lsbFVwZGF0ZSYmaC5jb21wb25lbnRXaWxsVXBkYXRlKG0saC5fX3MseCksbnVsbCE9aC5jb21wb25lbnREaWRVcGRhdGUmJmguX19oLnB1c2goZnVuY3Rpb24oKXtoLmNvbXBvbmVudERpZFVwZGF0ZSh5LHAsayl9KX1oLmNvbnRleHQ9eCxoLnByb3BzPW0saC5zdGF0ZT1oLl9fcywocz1sLl9fcikmJnModSksaC5fX2Q9ITEsaC5fX3Y9dSxoLl9fUD1uLHM9aC5yZW5kZXIoaC5wcm9wcyxoLnN0YXRlLGguY29udGV4dCksaC5zdGF0ZT1oLl9fcyxudWxsIT1oLmdldENoaWxkQ29udGV4dCYmKHQ9YShhKHt9LHQpLGguZ2V0Q2hpbGRDb250ZXh0KCkpKSx2fHxudWxsPT1oLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHwoaz1oLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHkscCkpLEE9bnVsbCE9cyYmcy50eXBlPT09ZCYmbnVsbD09cy5rZXk/cy5wcm9wcy5jaGlsZHJlbjpzLHcobixBcnJheS5pc0FycmF5KEEpP0E6W0FdLHUsaSx0LG8scixmLGUsYyksaC5iYXNlPXUuX19lLHUuX19oPW51bGwsaC5fX2gubGVuZ3RoJiZmLnB1c2goaCksYiYmKGguX19FPWguX189bnVsbCksaC5fX2U9ITF9ZWxzZSBudWxsPT1yJiZ1Ll9fdj09PWkuX192Pyh1Ll9faz1pLl9fayx1Ll9fZT1pLl9fZSk6dS5fX2U9TChpLl9fZSx1LGksdCxvLHIsZixjKTsocz1sLmRpZmZlZCkmJnModSl9Y2F0Y2gobil7dS5fX3Y9bnVsbCwoY3x8bnVsbCE9cikmJih1Ll9fZT1lLHUuX19oPSEhYyxyW3IuaW5kZXhPZihlKV09bnVsbCksbC5fX2Uobix1LGkpfX1mdW5jdGlvbiB6KG4sdSl7bC5fX2MmJmwuX19jKHUsbiksbi5zb21lKGZ1bmN0aW9uKHUpe3RyeXtuPXUuX19oLHUuX19oPVtdLG4uc29tZShmdW5jdGlvbihuKXtuLmNhbGwodSl9KX1jYXRjaChuKXtsLl9fZShuLHUuX192KX19KX1mdW5jdGlvbiBMKGwsdSxpLHQsbyxyLGYsYyl7dmFyIHMsYSx2LHk9aS5wcm9wcyxwPXUucHJvcHMsZD11LnR5cGUsXz0wO2lmKFwic3ZnXCI9PT1kJiYobz0hMCksbnVsbCE9cilmb3IoO188ci5sZW5ndGg7XysrKWlmKChzPXJbX10pJiYocz09PWx8fChkP3MubG9jYWxOYW1lPT1kOjM9PXMubm9kZVR5cGUpKSl7bD1zLHJbX109bnVsbDticmVha31pZihudWxsPT1sKXtpZihudWxsPT09ZClyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocCk7bD1vP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsZCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkLHAuaXMmJnApLHI9bnVsbCxjPSExfWlmKG51bGw9PT1kKXk9PT1wfHxjJiZsLmRhdGE9PT1wfHwobC5kYXRhPXApO2Vsc2V7aWYocj1yJiZuLmNhbGwobC5jaGlsZE5vZGVzKSxhPSh5PWkucHJvcHN8fGUpLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLHY9cC5kYW5nZXJvdXNseVNldElubmVySFRNTCwhYyl7aWYobnVsbCE9cilmb3IoeT17fSxfPTA7XzxsLmF0dHJpYnV0ZXMubGVuZ3RoO18rKyl5W2wuYXR0cmlidXRlc1tfXS5uYW1lXT1sLmF0dHJpYnV0ZXNbX10udmFsdWU7KHZ8fGEpJiYodiYmKGEmJnYuX19odG1sPT1hLl9faHRtbHx8di5fX2h0bWw9PT1sLmlubmVySFRNTCl8fChsLmlubmVySFRNTD12JiZ2Ll9faHRtbHx8XCJcIikpfWlmKEMobCxwLHksbyxjKSx2KXUuX19rPVtdO2Vsc2UgaWYoXz11LnByb3BzLmNoaWxkcmVuLHcobCxBcnJheS5pc0FycmF5KF8pP186W19dLHUsaSx0LG8mJlwiZm9yZWlnbk9iamVjdFwiIT09ZCxyLGYscj9yWzBdOmkuX19rJiZrKGksMCksYyksbnVsbCE9cilmb3IoXz1yLmxlbmd0aDtfLS07KW51bGwhPXJbX10mJmgocltfXSk7Y3x8KFwidmFsdWVcImluIHAmJnZvaWQgMCE9PShfPXAudmFsdWUpJiYoXyE9PWwudmFsdWV8fFwicHJvZ3Jlc3NcIj09PWQmJiFfKSYmSChsLFwidmFsdWVcIixfLHkudmFsdWUsITEpLFwiY2hlY2tlZFwiaW4gcCYmdm9pZCAwIT09KF89cC5jaGVja2VkKSYmXyE9PWwuY2hlY2tlZCYmSChsLFwiY2hlY2tlZFwiLF8seS5jaGVja2VkLCExKSl9cmV0dXJuIGx9ZnVuY3Rpb24gTShuLHUsaSl7dHJ5e1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/bih1KTpuLmN1cnJlbnQ9dX1jYXRjaChuKXtsLl9fZShuLGkpfX1mdW5jdGlvbiBOKG4sdSxpKXt2YXIgdCxvO2lmKGwudW5tb3VudCYmbC51bm1vdW50KG4pLCh0PW4ucmVmKSYmKHQuY3VycmVudCYmdC5jdXJyZW50IT09bi5fX2V8fE0odCxudWxsLHUpKSxudWxsIT0odD1uLl9fYykpe2lmKHQuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e3QuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChuKXtsLl9fZShuLHUpfXQuYmFzZT10Ll9fUD1udWxsfWlmKHQ9bi5fX2spZm9yKG89MDtvPHQubGVuZ3RoO28rKyl0W29dJiZOKHRbb10sdSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBuLnR5cGUpO2l8fG51bGw9PW4uX19lfHxoKG4uX19lKSxuLl9fZT1uLl9fZD12b2lkIDB9ZnVuY3Rpb24gTyhuLGwsdSl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iobix1KX1mdW5jdGlvbiBTKHUsaSx0KXt2YXIgbyxyLGY7bC5fXyYmbC5fXyh1LGkpLHI9KG89XCJmdW5jdGlvblwiPT10eXBlb2YgdCk/bnVsbDp0JiZ0Ll9fa3x8aS5fX2ssZj1bXSxqKGksdT0oIW8mJnR8fGkpLl9faz12KGQsbnVsbCxbdV0pLHJ8fGUsZSx2b2lkIDAhPT1pLm93bmVyU1ZHRWxlbWVudCwhbyYmdD9bdF06cj9udWxsOmkuZmlyc3RDaGlsZD9uLmNhbGwoaS5jaGlsZE5vZGVzKTpudWxsLGYsIW8mJnQ/dDpyP3IuX19lOmkuZmlyc3RDaGlsZCxvKSx6KGYsdSl9ZnVuY3Rpb24gcShuLGwpe1MobixsLHEpfWZ1bmN0aW9uIEIobCx1LGkpe3ZhciB0LG8scixmPWEoe30sbC5wcm9wcyk7Zm9yKHIgaW4gdSlcImtleVwiPT1yP3Q9dVtyXTpcInJlZlwiPT1yP289dVtyXTpmW3JdPXVbcl07cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MiYmKGYuY2hpbGRyZW49YXJndW1lbnRzLmxlbmd0aD4zP24uY2FsbChhcmd1bWVudHMsMik6aSkseShsLnR5cGUsZix0fHxsLmtleSxvfHxsLnJlZixudWxsKX1mdW5jdGlvbiBEKG4sbCl7dmFyIHU9e19fYzpsPVwiX19jQ1wiK2YrKyxfXzpuLENvbnN1bWVyOmZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uY2hpbGRyZW4obCl9LFByb3ZpZGVyOmZ1bmN0aW9uKG4pe3ZhciB1LGk7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0fHwodT1bXSwoaT17fSlbbF09dGhpcyx0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBpfSx0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLnByb3BzLnZhbHVlIT09bi52YWx1ZSYmdS5zb21lKG0pfSx0aGlzLnN1Yj1mdW5jdGlvbihuKXt1LnB1c2gobik7dmFyIGw9bi5jb21wb25lbnRXaWxsVW5tb3VudDtuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dS5zcGxpY2UodS5pbmRleE9mKG4pLDEpLGwmJmwuY2FsbChuKX19KSxuLmNoaWxkcmVufX07cmV0dXJuIHUuUHJvdmlkZXIuX189dS5Db25zdW1lci5jb250ZXh0VHlwZT11fW49Yy5zbGljZSxsPXtfX2U6ZnVuY3Rpb24obixsKXtmb3IodmFyIHUsaSx0O2w9bC5fXzspaWYoKHU9bC5fX2MpJiYhdS5fXyl0cnl7aWYoKGk9dS5jb25zdHJ1Y3RvcikmJm51bGwhPWkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYodS5zZXRTdGF0ZShpLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSksdD11Ll9fZCksbnVsbCE9dS5jb21wb25lbnREaWRDYXRjaCYmKHUuY29tcG9uZW50RGlkQ2F0Y2gobiksdD11Ll9fZCksdClyZXR1cm4gdS5fX0U9dX1jYXRjaChsKXtuPWx9dGhyb3cgbn19LHU9MCxpPWZ1bmN0aW9uKG4pe3JldHVybiBudWxsIT1uJiZ2b2lkIDA9PT1uLmNvbnN0cnVjdG9yfSxfLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1O3U9bnVsbCE9dGhpcy5fX3MmJnRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1hKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4oYSh7fSx1KSx0aGlzLnByb3BzKSksbiYmYSh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYobCYmdGhpcy5fX2gucHVzaChsKSxtKHRoaXMpKX0sXy5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5fX3YmJih0aGlzLl9fZT0hMCxuJiZ0aGlzLl9faC5wdXNoKG4pLG0odGhpcykpfSxfLnByb3RvdHlwZS5yZW5kZXI9ZCx0PVtdLG89XCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpOnNldFRpbWVvdXQsZy5fX3I9MCxmPTA7ZXhwb3J0e1MgYXMgcmVuZGVyLHEgYXMgaHlkcmF0ZSx2IGFzIGNyZWF0ZUVsZW1lbnQsdiBhcyBoLGQgYXMgRnJhZ21lbnQscCBhcyBjcmVhdGVSZWYsaSBhcyBpc1ZhbGlkRWxlbWVudCxfIGFzIENvbXBvbmVudCxCIGFzIGNsb25lRWxlbWVudCxEIGFzIGNyZWF0ZUNvbnRleHQsQSBhcyB0b0NoaWxkQXJyYXksbCBhcyBvcHRpb25zfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5tb2R1bGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcblxudmFyIEZvcm1hdCA9IHtcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXG4gICAgUkZDMzk4NjogJ1JGQzM5ODYnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6IEZvcm1hdC5SRkMzOTg2LFxuICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZS5jYWxsKHZhbHVlLCBwZXJjZW50VHdlbnRpZXMsICcrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFJGQzE3Mzg6IEZvcm1hdC5SRkMxNzM4LFxuICAgIFJGQzM5ODY6IEZvcm1hdC5SRkMzOTg2XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBjb21tYTogZmFsc2UsXG4gICAgZGVjb2RlcjogdXRpbHMuZGVjb2RlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGRlcHRoOiA1LFxuICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IGZhbHNlLFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBhcnNlQXJyYXlzOiB0cnVlLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIGludGVycHJldE51bWVyaWNFbnRpdGllcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjKFxcZCspOy9nLCBmdW5jdGlvbiAoJDAsIG51bWJlclN0cikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChudW1iZXJTdHIsIDEwKSk7XG4gICAgfSk7XG59O1xuXG52YXIgcGFyc2VBcnJheVZhbHVlID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5jb21tYSAmJiB2YWwuaW5kZXhPZignLCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zcGxpdCgnLCcpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG59O1xuXG4vLyBUaGlzIGlzIHdoYXQgYnJvd3NlcnMgd2lsbCBzdWJtaXQgd2hlbiB0aGUg4pyTIGNoYXJhY3RlciBvY2N1cnMgaW4gYW5cbi8vIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBib2R5IGFuZCB0aGUgZW5jb2Rpbmcgb2YgdGhlIHBhZ2UgY29udGFpbmluZ1xuLy8gdGhlIGZvcm0gaXMgaXNvLTg4NTktMSwgb3Igd2hlbiB0aGUgc3VibWl0dGVkIGZvcm0gaGFzIGFuIGFjY2VwdC1jaGFyc2V0XG4vLyBhdHRyaWJ1dGUgb2YgaXNvLTg4NTktMS4gUHJlc3VtYWJseSBhbHNvIHdpdGggb3RoZXIgY2hhcnNldHMgdGhhdCBkbyBub3QgY29udGFpblxuLy8gdGhlIOKckyBjaGFyYWN0ZXIsIHN1Y2ggYXMgdXMtYXNjaWkuXG52YXIgaXNvU2VudGluZWwgPSAndXRmOD0lMjYlMjMxMDAwMyUzQic7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKVxuXG4vLyBUaGVzZSBhcmUgdGhlIHBlcmNlbnQtZW5jb2RlZCB1dGYtOCBvY3RldHMgcmVwcmVzZW50aW5nIGEgY2hlY2ttYXJrLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHJlcXVlc3QgYWN0dWFsbHkgaXMgdXRmLTggZW5jb2RlZC5cbnZhciBjaGFyc2V0U2VudGluZWwgPSAndXRmOD0lRTIlOUMlOTMnOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG5cbnZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBjbGVhblN0ciA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPyBzdHIucmVwbGFjZSgvXlxcPy8sICcnKSA6IHN0cjtcbiAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIGxpbWl0KTtcbiAgICB2YXIgc2tpcEluZGV4ID0gLTE7IC8vIEtlZXAgdHJhY2sgb2Ygd2hlcmUgdGhlIHV0Zjggc2VudGluZWwgd2FzIGZvdW5kXG4gICAgdmFyIGk7XG5cbiAgICB2YXIgY2hhcnNldCA9IG9wdGlvbnMuY2hhcnNldDtcbiAgICBpZiAob3B0aW9ucy5jaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbaV0uaW5kZXhPZigndXRmOD0nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1tpXSA9PT0gY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAndXRmLTgnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbaV0gPT09IGlzb1NlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAnaXNvLTg4NTktMSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXBJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaSA9IHBhcnRzLmxlbmd0aDsgLy8gVGhlIGVzbGludCBzZXR0aW5ncyBkbyBub3QgYWxsb3cgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT09IHNraXBJbmRleCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICB2YXIgYnJhY2tldEVxdWFsc1BvcyA9IHBhcnQuaW5kZXhPZignXT0nKTtcbiAgICAgICAgdmFyIHBvcyA9IGJyYWNrZXRFcXVhbHNQb3MgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBicmFja2V0RXF1YWxzUG9zICsgMTtcblxuICAgICAgICB2YXIga2V5LCB2YWw7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPyBudWxsIDogJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZSgwLCBwb3MpLCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG4gICAgICAgICAgICB2YWwgPSB1dGlscy5tYXliZU1hcChcbiAgICAgICAgICAgICAgICBwYXJzZUFycmF5VmFsdWUocGFydC5zbGljZShwb3MgKyAxKSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVuY29kZWRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVjb2RlcihlbmNvZGVkVmFsLCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAndmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCAmJiBvcHRpb25zLmludGVycHJldE51bWVyaWNFbnRpdGllcyAmJiBjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIHZhbCA9IGludGVycHJldE51bWVyaWNFbnRpdGllcyh2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnQuaW5kZXhPZignW109JykgPiAtMSkge1xuICAgICAgICAgICAgdmFsID0gaXNBcnJheSh2YWwpID8gW3ZhbF0gOiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHV0aWxzLmNvbWJpbmUob2JqW2tleV0sIHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgcGFyc2VPYmplY3QgPSBmdW5jdGlvbiAoY2hhaW4sIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKSB7XG4gICAgdmFyIGxlYWYgPSB2YWx1ZXNQYXJzZWQgPyB2YWwgOiBwYXJzZUFycmF5VmFsdWUodmFsLCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIGkgPSBjaGFpbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgb2JqO1xuICAgICAgICB2YXIgcm9vdCA9IGNoYWluW2ldO1xuXG4gICAgICAgIGlmIChyb290ID09PSAnW10nICYmIG9wdGlvbnMucGFyc2VBcnJheXMpIHtcbiAgICAgICAgICAgIG9iaiA9IFtdLmNvbmNhdChsZWFmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgICAgICAgdmFyIGNsZWFuUm9vdCA9IHJvb3QuY2hhckF0KDApID09PSAnWycgJiYgcm9vdC5jaGFyQXQocm9vdC5sZW5ndGggLSAxKSA9PT0gJ10nID8gcm9vdC5zbGljZSgxLCAtMSkgOiByb290O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoY2xlYW5Sb290LCAxMCk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucGFyc2VBcnJheXMgJiYgY2xlYW5Sb290ID09PSAnJykge1xuICAgICAgICAgICAgICAgIG9iaiA9IHsgMDogbGVhZiB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAhaXNOYU4oaW5kZXgpXG4gICAgICAgICAgICAgICAgJiYgcm9vdCAhPT0gY2xlYW5Sb290XG4gICAgICAgICAgICAgICAgJiYgU3RyaW5nKGluZGV4KSA9PT0gY2xlYW5Sb290XG4gICAgICAgICAgICAgICAgJiYgaW5kZXggPj0gMFxuICAgICAgICAgICAgICAgICYmIChvcHRpb25zLnBhcnNlQXJyYXlzICYmIGluZGV4IDw9IG9wdGlvbnMuYXJyYXlMaW1pdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgICAgIG9ialtpbmRleF0gPSBsZWFmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpbY2xlYW5Sb290XSA9IGxlYWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZWFmID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiBsZWFmO1xufTtcblxudmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIGlmICghZ2l2ZW5LZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBkb3Qgbm90YXRpb24gdG8gYnJhY2tldCBub3RhdGlvblxuICAgIHZhciBrZXkgPSBvcHRpb25zLmFsbG93RG90cyA/IGdpdmVuS2V5LnJlcGxhY2UoL1xcLihbXi5bXSspL2csICdbJDFdJykgOiBnaXZlbktleTtcblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBicmFja2V0cyA9IC8oXFxbW15bXFxdXSpdKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXltcXF1dKl0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBvcHRpb25zLmRlcHRoID4gMCAmJiBicmFja2V0cy5leGVjKGtleSk7XG4gICAgdmFyIHBhcmVudCA9IHNlZ21lbnQgPyBrZXkuc2xpY2UoMCwgc2VnbWVudC5pbmRleCkgOiBrZXk7XG5cbiAgICAvLyBTdGFzaCB0aGUgcGFyZW50IGlmIGl0IGV4aXN0c1xuXG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBwbGFpbiBvYmplY3RzLCBvcHRpb25hbGx5IHByZWZpeCBrZXlzIHRoYXQgd291bGQgb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLnB1c2gocGFyZW50KTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAob3B0aW9ucy5kZXB0aCA+IDAgJiYgKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzZWdtZW50WzFdLnNsaWNlKDEsIC0xKSkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCk7XG59O1xuXG52YXIgbm9ybWFsaXplUGFyc2VPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplUGFyc2VPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmRlY29kZXIgIT09IG51bGwgJiYgb3B0cy5kZWNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgdmFyIGNoYXJzZXQgPSB0eXBlb2Ygb3B0cy5jaGFyc2V0ID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmNoYXJzZXQgOiBvcHRzLmNoYXJzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd0RvdHM6IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzLFxuICAgICAgICBhbGxvd1Byb3RvdHlwZXM6IHR5cGVvZiBvcHRzLmFsbG93UHJvdG90eXBlcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hbGxvd1Byb3RvdHlwZXMgOiBkZWZhdWx0cy5hbGxvd1Byb3RvdHlwZXMsXG4gICAgICAgIGFycmF5TGltaXQ6IHR5cGVvZiBvcHRzLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0cy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYTogdHlwZW9mIG9wdHMuY29tbWEgPT09ICdib29sZWFuJyA/IG9wdHMuY29tbWEgOiBkZWZhdWx0cy5jb21tYSxcbiAgICAgICAgZGVjb2RlcjogdHlwZW9mIG9wdHMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXIsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRzLmRlbGltaXRlcikgPyBvcHRzLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcixcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uLCBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgZGVwdGg6ICh0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ251bWJlcicgfHwgb3B0cy5kZXB0aCA9PT0gZmFsc2UpID8gK29wdHMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aCxcbiAgICAgICAgaWdub3JlUXVlcnlQcmVmaXg6IG9wdHMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWUsXG4gICAgICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogdHlwZW9mIG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID09PSAnYm9vbGVhbicgPyBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA6IGRlZmF1bHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyxcbiAgICAgICAgcGFyYW1ldGVyTGltaXQ6IHR5cGVvZiBvcHRzLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdCxcbiAgICAgICAgcGFyc2VBcnJheXM6IG9wdHMucGFyc2VBcnJheXMgIT09IGZhbHNlLFxuICAgICAgICBwbGFpbk9iamVjdHM6IHR5cGVvZiBvcHRzLnBsYWluT2JqZWN0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5wbGFpbk9iamVjdHMgOiBkZWZhdWx0cy5wbGFpbk9iamVjdHMsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKTtcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMsIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBhcnJheVByZWZpeEdlbmVyYXRvcnMgPSB7XG4gICAgYnJhY2tldHM6IGZ1bmN0aW9uIGJyYWNrZXRzKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1tdJztcbiAgICB9LFxuICAgIGNvbW1hOiAnY29tbWEnLFxuICAgIGluZGljZXM6IGZ1bmN0aW9uIGluZGljZXMocHJlZml4LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcbiAgICB9LFxuICAgIHJlcGVhdDogZnVuY3Rpb24gcmVwZWF0KHByZWZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG52YXIgcHVzaFRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB2YWx1ZU9yQXJyYXkpIHtcbiAgICBwdXNoLmFwcGx5KGFyciwgaXNBcnJheSh2YWx1ZU9yQXJyYXkpID8gdmFsdWVPckFycmF5IDogW3ZhbHVlT3JBcnJheV0pO1xufTtcblxudmFyIHRvSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBkZWZhdWx0Rm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xudmFyIGRlZmF1bHRzID0ge1xuICAgIGFkZFF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBlbmNvZGU6IHRydWUsXG4gICAgZW5jb2RlcjogdXRpbHMuZW5jb2RlLFxuICAgIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgICBmb3JtYXR0ZXI6IGZvcm1hdHMuZm9ybWF0dGVyc1tkZWZhdWx0Rm9ybWF0XSxcbiAgICAvLyBkZXByZWNhdGVkXG4gICAgaW5kaWNlczogZmFsc2UsXG4gICAgc2VyaWFsaXplRGF0ZTogZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKGRhdGUpO1xuICAgIH0sXG4gICAgc2tpcE51bGxzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaXNOb25OdWxsaXNoUHJpbWl0aXZlID0gZnVuY3Rpb24gaXNOb25OdWxsaXNoUHJpbWl0aXZlKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnc3ltYm9sJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCc7XG59O1xuXG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KFxuICAgIG9iamVjdCxcbiAgICBwcmVmaXgsXG4gICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgc2tpcE51bGxzLFxuICAgIGVuY29kZXIsXG4gICAgZmlsdGVyLFxuICAgIHNvcnQsXG4gICAgYWxsb3dEb3RzLFxuICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgZm9ybWF0LFxuICAgIGZvcm1hdHRlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgIGNoYXJzZXRcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqID0gdXRpbHMubWF5YmVNYXAob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCkgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAoaXNOb25OdWxsaXNoUHJpbWl0aXZlKG9iaikgfHwgdXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gZW5jb2RlVmFsdWVzT25seSA/IHByZWZpeCA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KTtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJywgZm9ybWF0KSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBqb2luIGVsZW1lbnRzIGluXG4gICAgICAgIG9iaktleXMgPSBbeyB2YWx1ZTogb2JqLmxlbmd0aCA+IDAgPyBvYmouam9pbignLCcpIHx8IG51bGwgOiB1bmRlZmluZWQgfV07XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIG9iaktleXMgPSBzb3J0ID8ga2V5cy5zb3J0KHNvcnQpIDoga2V5cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleS52YWx1ZSAhPT0gdW5kZWZpbmVkID8ga2V5LnZhbHVlIDogb2JqW2tleV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5UHJlZml4ID0gaXNBcnJheShvYmopXG4gICAgICAgICAgICA/IHR5cGVvZiBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnZnVuY3Rpb24nID8gZ2VuZXJhdGVBcnJheVByZWZpeChwcmVmaXgsIGtleSkgOiBwcmVmaXhcbiAgICAgICAgICAgIDogcHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGtleSA6ICdbJyArIGtleSArICddJyk7XG5cbiAgICAgICAgcHVzaFRvQXJyYXkodmFsdWVzLCBzdHJpbmdpZnkoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGtleVByZWZpeCxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICBlbmNvZGVyLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgY2hhcnNldFxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxudmFyIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmVuY29kZXIgIT09IG51bGwgJiYgb3B0cy5lbmNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMuZW5jb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBjaGFyc2V0ID0gb3B0cy5jaGFyc2V0IHx8IGRlZmF1bHRzLmNoYXJzZXQ7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFoYXMuY2FsbChmb3JtYXRzLmZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBmb3JtYXQgb3B0aW9uIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IG9wdHMuZm9ybWF0O1xuICAgIH1cbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICB2YXIgZmlsdGVyID0gZGVmYXVsdHMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgaXNBcnJheShvcHRzLmZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0cy5maWx0ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkUXVlcnlQcmVmaXg6IHR5cGVvZiBvcHRzLmFkZFF1ZXJ5UHJlZml4ID09PSAnYm9vbGVhbicgPyBvcHRzLmFkZFF1ZXJ5UHJlZml4IDogZGVmYXVsdHMuYWRkUXVlcnlQcmVmaXgsXG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICAgICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZGVsaW1pdGVyIDogb3B0cy5kZWxpbWl0ZXIsXG4gICAgICAgIGVuY29kZTogdHlwZW9mIG9wdHMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZSxcbiAgICAgICAgZW5jb2RlcjogdHlwZW9mIG9wdHMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXIsXG4gICAgICAgIGVuY29kZVZhbHVlc09ubHk6IHR5cGVvZiBvcHRzLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gICAgICAgIHNlcmlhbGl6ZURhdGU6IHR5cGVvZiBvcHRzLnNlcmlhbGl6ZURhdGUgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNlcmlhbGl6ZURhdGUgOiBkZWZhdWx0cy5zZXJpYWxpemVEYXRlLFxuICAgICAgICBza2lwTnVsbHM6IHR5cGVvZiBvcHRzLnNraXBOdWxscyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5za2lwTnVsbHMgOiBkZWZhdWx0cy5za2lwTnVsbHMsXG4gICAgICAgIHNvcnQ6IHR5cGVvZiBvcHRzLnNvcnQgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNvcnQgOiBudWxsLFxuICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmdcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRzKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMob3B0cyk7XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICB2YXIgZmlsdGVyO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqID0gZmlsdGVyKCcnLCBvYmopO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvcHRpb25zLmZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBhcnJheUZvcm1hdDtcbiAgICBpZiAob3B0cyAmJiBvcHRzLmFycmF5Rm9ybWF0IGluIGFycmF5UHJlZml4R2VuZXJhdG9ycykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdHMuYXJyYXlGb3JtYXQ7XG4gICAgfSBlbHNlIGlmIChvcHRzICYmICdpbmRpY2VzJyBpbiBvcHRzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSAnaW5kaWNlcyc7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlQXJyYXlQcmVmaXggPSBhcnJheVByZWZpeEdlbmVyYXRvcnNbYXJyYXlGb3JtYXRdO1xuXG4gICAgaWYgKCFvYmpLZXlzKSB7XG4gICAgICAgIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICAgICAgb2JqS2V5cy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaFRvQXJyYXkoa2V5cywgc3RyaW5naWZ5KFxuICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBvcHRpb25zLnNraXBOdWxscyxcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlID8gb3B0aW9ucy5lbmNvZGVyIDogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5zb3J0LFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0RvdHMsXG4gICAgICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBvcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgb3B0aW9ucy5jaGFyc2V0XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBrZXlzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgICBpZiAob3B0aW9ucy5jaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JyksIHRoZSBcIm51bWVyaWMgZW50aXR5XCIgcmVwcmVzZW50YXRpb24gb2YgYSBjaGVja21hcmtcbiAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lMjYlMjMxMDAwMyUzQiYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSVFMiU5QyU5MyYnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGpvaW5lZC5sZW5ndGggPiAwID8gcHJlZml4ICsgam9pbmVkIDogJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufSgpKTtcblxudmFyIGNvbXBhY3RRdWV1ZSA9IGZ1bmN0aW9uIGNvbXBhY3RRdWV1ZShxdWV1ZSkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Qoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IDAgKi9cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKChvcHRpb25zICYmIChvcHRpb25zLnBsYWluT2JqZWN0cyB8fCBvcHRpb25zLmFsbG93UHJvdG90eXBlcykpIHx8ICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiAhaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0ID0gYXJyYXlUb09iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwodGFyZ2V0LCBpKSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJdGVtID0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtICYmIHR5cGVvZiB0YXJnZXRJdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBtZXJnZSh0YXJnZXRJdGVtLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBtZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG1lcmdlVGFyZ2V0KTtcbn07XG5cbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn07XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3RyLCBkZWNvZGVyLCBjaGFyc2V0KSB7XG4gICAgdmFyIHN0cldpdGhvdXRQbHVzID0gc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgLy8gdW5lc2NhcGUgbmV2ZXIgdGhyb3dzLCBubyB0cnkuLi5jYXRjaCBuZWVkZWQ6XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cy5yZXBsYWNlKC8lWzAtOWEtZl17Mn0vZ2ksIHVuZXNjYXBlKTtcbiAgICB9XG4gICAgLy8gdXRmLThcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cldpdGhvdXRQbHVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cztcbiAgICB9XG59O1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0ciwgZGVmYXVsdEVuY29kZXIsIGNoYXJzZXQsIGtpbmQsIGZvcm1hdCkge1xuICAgIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIChtc2NkZXgpIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxuICAgIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gc3RyO1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3ltYm9sJykge1xuICAgICAgICBzdHJpbmcgPSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0cmluZyA9IFN0cmluZyhzdHIpO1xuICAgIH1cblxuICAgIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZShzdHJpbmcpLnJlcGxhY2UoLyV1WzAtOWEtZl17NH0vZ2ksIGZ1bmN0aW9uICgkMCkge1xuICAgICAgICAgICAgcmV0dXJuICclMjYlMjMnICsgcGFyc2VJbnQoJDAuc2xpY2UoMiksIDE2KSArICclM0InO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjID09PSAweDJEIC8vIC1cbiAgICAgICAgICAgIHx8IGMgPT09IDB4MkUgLy8gLlxuICAgICAgICAgICAgfHwgYyA9PT0gMHg1RiAvLyBfXG4gICAgICAgICAgICB8fCBjID09PSAweDdFIC8vIH5cbiAgICAgICAgICAgIHx8IChjID49IDB4MzAgJiYgYyA8PSAweDM5KSAvLyAwLTlcbiAgICAgICAgICAgIHx8IChjID49IDB4NDEgJiYgYyA8PSAweDVBKSAvLyBhLXpcbiAgICAgICAgICAgIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDdBKSAvLyBBLVpcbiAgICAgICAgICAgIHx8IChmb3JtYXQgPT09IGZvcm1hdHMuUkZDMTczOCAmJiAoYyA9PT0gMHgyOCB8fCBjID09PSAweDI5KSkgLy8gKCApXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3V0ICs9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgaGV4VGFibGVbY107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEMwIHwgKGMgPj4gNildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+PSAweEUwMDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEUwIHwgKGMgPj4gMTIpXSArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgJiAweDNGRikpO1xuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gc3BlY2lhbCB0aGFua3MgdG8gaHR0cHM6Ly9ibG9nLm5hYWxuLmNvbS8yMDE2LzA3L2hleG8td2l0aC1hbGdvbGlhL1xuaW1wb3J0IGFsZ29saWFzZWFyY2ggZnJvbSAnYWxnb2xpYXNlYXJjaC9saXRlJ1xuaW1wb3J0IGluc3RhbnRzZWFyY2ggZnJvbSAnaW5zdGFudHNlYXJjaC5qcydcbmltcG9ydCB7XG4gIGNvbmZpZ3VyZSxcbiAgc2VhcmNoQm94LFxuICBoaXRzLFxuICBzdGF0cyxcbiAgcGFnaW5hdGlvbixcbn0gZnJvbSAnaW5zdGFudHNlYXJjaC5qcy9lcy93aWRnZXRzJ1xuaW1wb3J0IGFyY2hlclV0aWwgZnJvbSAnLi91dGlsJ1xuXG5jb25zdCBpbml0QWxnb2xpYSA9ICgpID0+IHtcbiAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFsZ29saWFTZXR0aW5ncyA9IGFsZ29saWFcbiAgICBjb25zdCBpc0FsZ29saWFTZXR0aW5nc1ZhbGlkID1cbiAgICAgIGFsZ29saWFTZXR0aW5ncy5hcHBsaWNhdGlvbklEICYmXG4gICAgICBhbGdvbGlhU2V0dGluZ3MuYXBpS2V5ICYmXG4gICAgICBhbGdvbGlhU2V0dGluZ3MuaW5kZXhOYW1lXG5cbiAgICBpZiAoIWlzQWxnb2xpYVNldHRpbmdzVmFsaWQpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKFxuICAgICAgICAnQWxnb2xpYSBTZXR0aW5ncyBhcmUgaW52YWxpZC4gQ2hlY2sgZG9jczogaHR0cHM6Ly9naXRodWIuY29tL2ZpM2V3b3JrL2hleG8tdGhlbWUtYXJjaGVyL3dpa2kvJUU1JTkwJUFGJUU3JTk0JUE4LUFsZ29saWEtJUU2JTkwJTlDJUU3JUI0JUEyIyVFOCU4RSVCNyVFNSU4RiU5Ni1rZXlzJ1xuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc2VhcmNoQ2xpZW50ID0gYWxnb2xpYXNlYXJjaChcbiAgICAgIGFsZ29saWFTZXR0aW5ncy5hcHBsaWNhdGlvbklELFxuICAgICAgYWxnb2xpYVNldHRpbmdzLmFwaUtleVxuICAgIClcblxuICAgIGNvbnN0IHNlYXJjaCA9IGluc3RhbnRzZWFyY2goe1xuICAgICAgaW5kZXhOYW1lOiBhbGdvbGlhU2V0dGluZ3MuaW5kZXhOYW1lLFxuICAgICAgc2VhcmNoQ2xpZW50LFxuICAgICAgc2VhcmNoRnVuY3Rpb246IGZ1bmN0aW9uIChoZWxwZXIpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoSW5wdXQgPSAkKCcjYWxnb2xpYS1zZWFyY2gtaW5wdXQnKS5maW5kKCdpbnB1dCcpXG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFsZ29saWEtcmVzdWx0cycpXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gaGVscGVyLnN0YXRlLnF1ZXJ5ID09PSAnJyA/ICdub25lJyA6ICcnXG5cbiAgICAgICAgaWYgKHNlYXJjaElucHV0LnZhbCgpKSB7XG4gICAgICAgICAgaGVscGVyLnNlYXJjaCgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdGFsbGVkU2VhcmNoRGVsYXk6IDUwMCxcbiAgICB9KVxuXG4gICAgLy8gUmVnaXN0ZXJpbmcgV2lkZ2V0c1xuICAgIHNlYXJjaC5hZGRXaWRnZXRzKFtcbiAgICAgIGNvbmZpZ3VyZSh7XG4gICAgICAgIGhpdHNQZXJQYWdlOiBhbGdvbGlhU2V0dGluZ3MuaGl0cy5wZXJfcGFnZSB8fCAxMCxcbiAgICAgIH0pLFxuICAgICAgc2VhcmNoQm94KHtcbiAgICAgICAgY29udGFpbmVyOiAnI2FsZ29saWEtc2VhcmNoLWlucHV0JyxcbiAgICAgICAgcGxhY2Vob2xkZXI6IGFsZ29saWFTZXR0aW5ncy5sYWJlbHMuaW5wdXRfcGxhY2Vob2xkZXIsXG4gICAgICAgIHNob3dTdWJtaXQ6IGZhbHNlLFxuICAgICAgICBzaG93UmVzZXQ6IGZhbHNlLFxuICAgICAgICBzaG93TG9hZGluZ0luZGljYXRvcjogZmFsc2UsXG4gICAgICB9KSxcbiAgICAgIGhpdHMoe1xuICAgICAgICBjb250YWluZXI6ICcjYWxnb2xpYS1oaXRzJyxcbiAgICAgICAgdGVtcGxhdGVzOiB7XG4gICAgICAgICAgaXRlbTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBkYXRhLnBlcm1hbGlua1xuICAgICAgICAgICAgICA/IGRhdGEucGVybWFsaW5rXG4gICAgICAgICAgICAgIDogc2l0ZU1ldGEucm9vdCArIGRhdGEucGF0aFxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgJzxhIGhyZWY9XCInICtcbiAgICAgICAgICAgICAgbGluayArXG4gICAgICAgICAgICAgICdcIiBjbGFzcz1cImFsZ29saWEtaGl0LWl0ZW0tbGlua1wiPicgK1xuICAgICAgICAgICAgICBpbnN0YW50c2VhcmNoLmhpZ2hsaWdodCh7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiAndGl0bGUnLFxuICAgICAgICAgICAgICAgIGhpdDogZGF0YSxcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlZFRhZ05hbWU6ICdlbScsXG4gICAgICAgICAgICAgIH0pICtcbiAgICAgICAgICAgICAgJzwvYT4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbXB0eTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhcyBmYS1kcmFmdGluZy1jb21wYXNzIGZhLTEweFwiPjwvaT4nICtcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGdvbGlhLWhpdC1lbXB0eS1sYWJlbFwiPicgK1xuICAgICAgICAgICAgICBhbGdvbGlhU2V0dGluZ3MubGFiZWxzLmhpdHNfZW1wdHkucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvXFwkXFx7cXVlcnlcXH0vLFxuICAgICAgICAgICAgICAgIGRhdGEucXVlcnlcbiAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3NzQ2xhc3Nlczoge1xuICAgICAgICAgIGl0ZW06ICdhbGdvbGlhLWhpdC1pdGVtJyxcbiAgICAgICAgICBsaXN0OiAnYWxnb2xpYS1oaXQtbGlzdCcsXG4gICAgICAgICAgcm9vdDogJ2FsZ29saWEtaGl0JyxcbiAgICAgICAgICBlbXB0eVJvb3Q6ICdhbGdvbGlhLWhpdC1lbXB0eScsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICAgIHN0YXRzKHtcbiAgICAgICAgY29udGFpbmVyOiAnI2FsZ29saWEtc3RhdHMnLFxuICAgICAgICB0ZW1wbGF0ZXM6IHtcbiAgICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgbGV0IHN0YXRzID0gYWxnb2xpYVNldHRpbmdzLmxhYmVscy5oaXRzX3N0YXRzXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCRcXHtoaXRzXFx9LywgZGF0YS5uYkhpdHMpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCRcXHt0aW1lXFx9LywgZGF0YS5wcm9jZXNzaW5nVGltZU1TKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgc3RhdHMgK1xuICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJhbGdvbGlhLXBvd2VyZWRcIj4nICtcbiAgICAgICAgICAgICAgJyAgPGltZyBzcmM9XCInICtcbiAgICAgICAgICAgICAgc2l0ZU1ldGEucm9vdCArXG4gICAgICAgICAgICAgICdhc3NldHMvYWxnb2xpYV9sb2dvLnN2Z1wiIGFsdD1cIkFsZ29saWFcIiAvPicgK1xuICAgICAgICAgICAgICAnPC9zcGFuPicgK1xuICAgICAgICAgICAgICAnPGhyIC8+J1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNzc0NsYXNzZXM6IHtcbiAgICAgICAgICByb290OiAnYWxnb2xpYS1zdGF0LXJvb3QnLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgICBwYWdpbmF0aW9uKHtcbiAgICAgICAgY29udGFpbmVyOiAnI2FsZ29saWEtcGFnaW5hdGlvbicsXG4gICAgICAgIHNjcm9sbFRvOiBmYWxzZSxcbiAgICAgICAgdGVtcGxhdGVzOiB7XG4gICAgICAgICAgZmlyc3Q6ICc8aSBjbGFzcz1cImZhIGZhLWFuZ2xlLWRvdWJsZS1sZWZ0XCI+PC9pPicsXG4gICAgICAgICAgbGFzdDogJzxpIGNsYXNzPVwiZmEgZmEtYW5nbGUtZG91YmxlLXJpZ2h0XCI+PC9pPicsXG4gICAgICAgICAgcHJldmlvdXM6ICc8aSBjbGFzcz1cImZhIGZhLWFuZ2xlLWxlZnRcIj48L2k+JyxcbiAgICAgICAgICBuZXh0OiAnPGkgY2xhc3M9XCJmYSBmYS1hbmdsZS1yaWdodFwiPjwvaT4nLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXSlcblxuICAgIHNlYXJjaC5zdGFydCgpXG5cbiAgICAkKCcucG9wdXAtdHJpZ2dlcicpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAkKCdib2R5JylcbiAgICAgICAgLnByZXBlbmQoJzxkaXYgY2xhc3M9XCJzZWFyY2gtcG9wdXAtb3ZlcmxheSBhbGdvbGlhLXBvcC1vdmVybGF5XCI+PC9kaXY+JylcbiAgICAgICAgLmNzcygnb3ZlcmZsb3cnLCAnaGlkZGVuJylcbiAgICAgICQoJy5wb3B1cCcpLnRvZ2dsZSgpXG4gICAgICAkKCcjYWxnb2xpYS1zZWFyY2gtaW5wdXQnKS5maW5kKCdpbnB1dCcpLmZvY3VzKClcbiAgICAgIGFyY2hlclV0aWwuc3RvcEJvZHlTY3JvbGwodHJ1ZSlcbiAgICB9KVxuXG4gICAgY29uc3QgaGlkZVBvcHVwID0gKCkgPT4ge1xuICAgICAgJCgnLmFpcy1TZWFyY2hCb3gtZm9ybScpLnRyaWdnZXIoJ3Jlc2V0JylcbiAgICAgICQoJy5wb3B1cCcpLmhpZGUoKVxuICAgICAgJCgnLmFsZ29saWEtcG9wLW92ZXJsYXknKS5yZW1vdmUoKVxuICAgICAgJCgnYm9keScpLmNzcygnb3ZlcmZsb3cnLCAnJylcbiAgICAgIGFyY2hlclV0aWwuc3RvcEJvZHlTY3JvbGwoZmFsc2UpXG4gICAgfVxuXG4gICAgJCgnLnBvcHVwLWJ0bi1jbG9zZScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpZGVQb3B1cCgpXG4gICAgfSlcblxuICAgICQoZG9jdW1lbnQpLm9uKCdrZXlkb3duJywgJy5haXMtU2VhcmNoQm94LWZvcm0nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIGhpZGVQb3B1cCgpXG4gICAgICB9XG4gICAgfSlcblxuICAgICQoJy5zaXRlLXNlYXJjaCcpLnJlbW92ZUNsYXNzKCdzaXRlLXNlYXJjaC1sb2FkaW5nJylcbiAgfSlcbn1cblxuaW5pdEFsZ29saWEoKVxuIl0sIm5hbWVzIjpbImJvZHlFbCIsImRvY3VtZW50IiwiYm9keSIsIndpbmRvd1RvcCIsImJvZHlFbFBvc2l0aW9uIiwic3R5bGUiLCJwb3NpdGlvbiIsImFyY2hlclV0aWwiLCJiYWNrVG9wIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsIndpbmRvdyIsInNjcm9sbFRvIiwidG9wIiwiYmVoYXZpb3IiLCJnZXRBYnNQb3NpdGlvbiIsImUiLCJ4Iiwib2Zmc2V0TGVmdCIsInkiLCJvZmZzZXRUb3AiLCJjdXJyZW50Iiwib2Zmc2V0UGFyZW50IiwiZGF0ZUZvcm1hdGVyIiwiZGF0ZSIsImZtdCIsIm8iLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiTWF0aCIsImZsb29yIiwiUyIsImdldE1pbGxpc2Vjb25kcyIsInRlc3QiLCJyZXBsYWNlIiwiUmVnRXhwIiwiJDEiLCJTdHJpbmciLCJnZXRGdWxsWWVhciIsInN1YnN0ciIsImxlbmd0aCIsImsiLCJyZW0iLCJwYXJzZUludCIsIiQiLCJjc3MiLCJzZXRXaW5kb3dIYXNoIiwiaGFzaCIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJnZXRXaW5kb3dIYXNoIiwibG9jYXRpb24iLCJyYWZUaWNrIiwidGlja2luZyIsInVwZGF0ZUZ1bmMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdG9wQm9keVNjcm9sbCIsImlzRml4ZWQiLCJzY3JvbGxZIiwid2lkdGgiLCJ0aHJvdHRsZSIsImZ1bmMiLCJ3YWl0IiwiaW1tZWRpYXRlIiwidGltZXIiLCJhcmdzIiwiYXJndW1lbnRzIiwic2V0VGltZW91dCIsInVuZGVmaW5lZCIsImFwcGx5IiwiZGVib3VuY2UiLCJjbGVhclRpbWVvdXQiLCJhbGdvbGlhc2VhcmNoIiwiaW5zdGFudHNlYXJjaCIsImNvbmZpZ3VyZSIsInNlYXJjaEJveCIsImhpdHMiLCJzdGF0cyIsInBhZ2luYXRpb24iLCJpbml0QWxnb2xpYSIsInJlYWR5IiwiYWxnb2xpYVNldHRpbmdzIiwiYWxnb2xpYSIsImlzQWxnb2xpYVNldHRpbmdzVmFsaWQiLCJhcHBsaWNhdGlvbklEIiwiYXBpS2V5IiwiaW5kZXhOYW1lIiwiY29uc29sZSIsImVycm9yIiwic2VhcmNoQ2xpZW50Iiwic2VhcmNoIiwic2VhcmNoRnVuY3Rpb24iLCJoZWxwZXIiLCJzZWFyY2hJbnB1dCIsImZpbmQiLCJjb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwiZGlzcGxheSIsInN0YXRlIiwicXVlcnkiLCJ2YWwiLCJzdGFsbGVkU2VhcmNoRGVsYXkiLCJhZGRXaWRnZXRzIiwiaGl0c1BlclBhZ2UiLCJwZXJfcGFnZSIsInBsYWNlaG9sZGVyIiwibGFiZWxzIiwiaW5wdXRfcGxhY2Vob2xkZXIiLCJzaG93U3VibWl0Iiwic2hvd1Jlc2V0Iiwic2hvd0xvYWRpbmdJbmRpY2F0b3IiLCJ0ZW1wbGF0ZXMiLCJpdGVtIiwiZGF0YSIsImxpbmsiLCJwZXJtYWxpbmsiLCJzaXRlTWV0YSIsInJvb3QiLCJwYXRoIiwiaGlnaGxpZ2h0IiwiYXR0cmlidXRlIiwiaGl0IiwiaGlnaGxpZ2h0ZWRUYWdOYW1lIiwiZW1wdHkiLCJoaXRzX2VtcHR5IiwiY3NzQ2xhc3NlcyIsImxpc3QiLCJlbXB0eVJvb3QiLCJ0ZXh0IiwiaGl0c19zdGF0cyIsIm5iSGl0cyIsInByb2Nlc3NpbmdUaW1lTVMiLCJmaXJzdCIsImxhc3QiLCJwcmV2aW91cyIsIm5leHQiLCJzdGFydCIsIm9uIiwic3RvcFByb3BhZ2F0aW9uIiwicHJlcGVuZCIsInRvZ2dsZSIsImZvY3VzIiwiaGlkZVBvcHVwIiwidHJpZ2dlciIsImhpZGUiLCJyZW1vdmUiLCJjbGljayIsImtleSIsInJlbW92ZUNsYXNzIl0sInNvdXJjZVJvb3QiOiIifQ==